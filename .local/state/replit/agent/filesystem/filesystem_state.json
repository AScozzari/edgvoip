{"file_contents":{"packages/backend/src/routes/superadmin.routes.ts":{"content":"// @ts-nocheck\r\nimport express from 'express';\r\nimport bcrypt from 'bcrypt';\r\nimport { getClient } from '@w3-voip/database';\r\nimport { authenticateJWT, requireSuperAdmin, AuthenticatedRequest } from '../middleware/auth.middleware';\r\n\r\nconst router = express.Router();\r\n\r\n/**\r\n * Get all tenants (super admin only)\r\n * GET /superadmin/tenants\r\n */\r\nrouter.get('/tenants', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  try {\r\n    const client = await getClient();\r\n    const result = await client.query(`\r\n      SELECT \r\n        t.*,\r\n        COUNT(DISTINCT u.id) as user_count,\r\n        COUNT(DISTINCT e.id) as extension_count,\r\n        COUNT(DISTINCT s.id) as store_count\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      LEFT JOIN stores s ON t.id = s.tenant_id\r\n      GROUP BY t.id\r\n      ORDER BY t.created_at DESC\r\n    `);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result.rows\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching tenants:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Create new tenant (super admin only)\r\n * POST /superadmin/tenants\r\n */\r\nrouter.post('/tenants', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  const { name, domain, sip_domain, companies, adminUser } = req.body;\r\n\r\n  if (!name || !domain || !sip_domain || !companies || !adminUser) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Missing required fields: name, domain, sip_domain, companies, adminUser'\r\n    });\r\n  }\r\n\r\n  try {\r\n    const client = await getClient();\r\n    \r\n    // Start transaction\r\n    await client.query('BEGIN');\r\n\r\n    // Create tenant\r\n    const tenantResult = await client.query(`\r\n      INSERT INTO tenants (name, domain, sip_domain, companies, status, slug)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n      RETURNING *\r\n    `, [name, domain, sip_domain, JSON.stringify(companies), 'active', domain.replace(/[^a-zA-Z0-9-]/g, '-')]);\r\n\r\n    const tenant = tenantResult.rows[0];\r\n\r\n    // Create admin user for the tenant\r\n    const hashedPassword = await bcrypt.hash(adminUser.password, 10);\r\n    const userResult = await client.query(`\r\n      INSERT INTO users (tenant_id, email, password_hash, first_name, last_name, role, status)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n      RETURNING *\r\n    `, [tenant.id, adminUser.email, hashedPassword, adminUser.firstName, adminUser.lastName, 'admin', 'active']);\r\n\r\n    const user = userResult.rows[0];\r\n\r\n    // Commit transaction\r\n    await client.query('COMMIT');\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        tenant,\r\n        adminUser: {\r\n          id: user.id,\r\n          email: user.email,\r\n          firstName: user.first_name,\r\n          lastName: user.last_name,\r\n          role: user.role\r\n        }\r\n      },\r\n      message: 'Tenant created successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating tenant:', error);\r\n    await client.query('ROLLBACK');\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Update tenant (super admin only)\r\n * PUT /superadmin/tenants/:id\r\n */\r\nrouter.put('/tenants/:id', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  const { id } = req.params;\r\n  const { name, domain, sip_domain, companies, status } = req.body;\r\n\r\n  try {\r\n    const client = await getClient();\r\n    const result = await client.query(`\r\n      UPDATE tenants \r\n      SET name = $1, domain = $2, sip_domain = $3, companies = $4, status = $5, updated_at = NOW()\r\n      WHERE id = $6\r\n      RETURNING *\r\n    `, [name, domain, sip_domain, JSON.stringify(companies), status, id]);\r\n\r\n    if (result.rows.length === 0) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Tenant not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result.rows[0],\r\n      message: 'Tenant updated successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error updating tenant:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Delete tenant (super admin only)\r\n * DELETE /superadmin/tenants/:id\r\n */\r\nrouter.delete('/tenants/:id', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  const { id } = req.params;\r\n\r\n  try {\r\n    const client = await getClient();\r\n    \r\n    // Start transaction\r\n    await client.query('BEGIN');\r\n\r\n    // Delete related data\r\n    await client.query('DELETE FROM users WHERE tenant_id = $1', [id]);\r\n    await client.query('DELETE FROM extensions WHERE tenant_id = $1', [id]);\r\n    await client.query('DELETE FROM stores WHERE tenant_id = $1', [id]);\r\n    \r\n    // Delete tenant\r\n    const result = await client.query('DELETE FROM tenants WHERE id = $1 RETURNING *', [id]);\r\n\r\n    if (result.rows.length === 0) {\r\n      await client.query('ROLLBACK');\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Tenant not found'\r\n      });\r\n    }\r\n\r\n    // Commit transaction\r\n    await client.query('COMMIT');\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Tenant deleted successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error deleting tenant:', error);\r\n    await client.query('ROLLBACK');\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Get tenant users (super admin only)\r\n * GET /superadmin/tenants/:id/users\r\n */\r\nrouter.get('/tenants/:id/users', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  const { id } = req.params;\r\n\r\n  try {\r\n    const client = await getClient();\r\n    const result = await client.query(`\r\n      SELECT id, email, first_name, last_name, role, status, created_at, updated_at\r\n      FROM users \r\n      WHERE tenant_id = $1\r\n      ORDER BY created_at DESC\r\n    `, [id]);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result.rows\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error fetching tenant users:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Create user for tenant (super admin only)\r\n * POST /superadmin/tenants/:id/users\r\n */\r\nrouter.post('/tenants/:id/users', authenticateJWT, requireSuperAdmin, async (req: AuthenticatedRequest, res) => {\r\n  const { id } = req.params;\r\n  const { email, password, firstName, lastName, role } = req.body;\r\n\r\n  if (!email || !password || !firstName || !lastName || !role) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Missing required fields: email, password, firstName, lastName, role'\r\n    });\r\n  }\r\n\r\n  try {\r\n    const client = await getClient();\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n    \r\n    const result = await client.query(`\r\n      INSERT INTO users (tenant_id, email, password_hash, first_name, last_name, role, status)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n      RETURNING id, email, first_name, last_name, role, status, created_at\r\n    `, [id, email, hashedPassword, firstName, lastName, role, 'active']);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: result.rows[0],\r\n      message: 'User created successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error creating user:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;","size_bytes":7706},"packages/frontend/src/App.tsx":{"content":"import { BrowserRouter as Router, Routes, Route, Navigate, useParams } from 'react-router-dom';\nimport { AuthProvider, useAuth } from '@/contexts/AuthContext';\nimport { Toaster } from '@/components/ui/toaster';\nimport Layout from '@/components/layout/Layout';\nimport ImpersonationBanner from '@/components/ImpersonationBanner';\nimport Login from '@/pages/Login';\nimport SuperAdminLogin from '@/pages/SuperAdminLogin';\nimport SuperAdminDashboard from '@/pages/SuperAdminDashboard';\nimport SuperAdminTenants from '@/pages/SuperAdminTenants';\nimport SuperAdminUsers from '@/pages/SuperAdminUsers';\nimport SuperAdminAnalytics from '@/pages/SuperAdminAnalytics';\nimport CreateTenant from '@/pages/CreateTenant';\nimport TenantNotFound from '@/pages/TenantNotFound';\nimport Dashboard from '@/pages/Dashboard';\nimport Tenants from '@/pages/Tenants';\nimport Stores from '@/pages/Stores';\nimport Extensions from '@/pages/Extensions';\nimport CDRViewer from '@/pages/CDRViewer';\nimport LiveCalls from '@/pages/LiveCalls';\nimport TrunkRegistration from '@/pages/TrunkRegistration';\nimport CallRouting from '@/pages/CallRouting';\nimport SipTrunks from '@/pages/SipTrunks';\nimport Destinations from '@/pages/Destinations';\nimport W3SuiteApiDocs from '@/pages/W3SuiteApiDocs';\nimport Logs from '@/pages/Logs';\nimport RingGroups from '@/pages/RingGroups';\nimport Queues from '@/pages/Queues';\nimport IvrMenus from '@/pages/IvrMenus';\nimport ConferenceRooms from '@/pages/ConferenceRooms';\nimport Voicemail from '@/pages/Voicemail';\nimport TimeConditions from '@/pages/TimeConditions';\nimport { useTenantValidation } from '@/hooks/useTenantValidation';\n\nfunction TenantRoutes() {\n  const { tenantSlug } = useParams();\n  const { isAuthenticated, isLoading: authLoading, user } = useAuth();\n  const { isValid: tenantValid, isLoading: tenantLoading } = useTenantValidation(tenantSlug);\n\n  if (authLoading || tenantLoading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  if (tenantValid === false) {\n    return <TenantNotFound />;\n  }\n\n  return (\n    <Routes>\n      <Route path=\"login\" element={<Login tenantSlug={tenantSlug!} />} />\n      {isAuthenticated ? (\n        <Route path=\"/*\" element={\n          <Layout>\n            <Routes>\n              <Route path=\"dashboard\" element={<Dashboard />} />\n              <Route path=\"tenants\" element={<Tenants />} />\n              <Route path=\"stores\" element={<Stores />} />\n              <Route path=\"extensions\" element={<Extensions />} />\n              <Route path=\"cdr\" element={<CDRViewer />} />\n              <Route path=\"live-calls\" element={<LiveCalls />} />\n              <Route path=\"trunk-registration\" element={<TrunkRegistration />} />\n              <Route path=\"call-routing\" element={<CallRouting />} />\n              <Route path=\"sip-trunks\" element={<SipTrunks />} />\n              <Route path=\"destinations\" element={<Destinations />} />\n              <Route path=\"logs\" element={<Logs />} />\n              <Route path=\"w3-api-docs\" element={<W3SuiteApiDocs />} />\n              <Route path=\"ring-groups\" element={<RingGroups />} />\n              <Route path=\"queues\" element={<Queues />} />\n              <Route path=\"ivr-menus\" element={<IvrMenus />} />\n              <Route path=\"conference-rooms\" element={<ConferenceRooms />} />\n              <Route path=\"voicemail\" element={<Voicemail />} />\n              <Route path=\"time-conditions\" element={<TimeConditions />} />\n              <Route path=\"\" element={<Navigate to={`/${tenantSlug}/dashboard`} replace />} />\n              <Route path=\"*\" element={<Navigate to={`/${tenantSlug}/dashboard`} replace />} />\n            </Routes>\n          </Layout>\n        } />\n      ) : (\n        <Route path=\"*\" element={<Navigate to={`/${tenantSlug}/login`} replace />} />\n      )}\n    </Routes>\n  );\n}\n\nfunction SuperAdminRoutes() {\n  const { isAuthenticated, isLoading } = useAuth();\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  if (!isAuthenticated) {\n    return <Navigate to=\"/edgvoip/login\" replace />;\n  }\n\n  return (\n    <Layout variant=\"superadmin\">\n      <Routes>\n        <Route path=\"dashboard\" element={<SuperAdminDashboard />} />\n        <Route path=\"tenants\" element={<SuperAdminTenants />} />\n        <Route path=\"tenants/create\" element={<CreateTenant />} />\n        <Route path=\"tenants/:tenantId\" element={<SuperAdminTenants />} />\n        <Route path=\"tenants/:tenantId/users\" element={<SuperAdminUsers />} />\n        <Route path=\"users\" element={<SuperAdminUsers />} />\n        <Route path=\"analytics\" element={<SuperAdminAnalytics />} />\n        <Route path=\"system-settings\" element={<div>System Settings - Coming Soon</div>} />\n        <Route path=\"logs\" element={<div>System Logs - Coming Soon</div>} />\n        <Route path=\"*\" element={<Navigate to=\"dashboard\" replace />} />\n      </Routes>\n    </Layout>\n  );\n}\n\nfunction App() {\n  return (\n    <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>\n      <AuthProvider>\n        <div className=\"min-h-screen bg-background\">\n          <ImpersonationBanner />\n          <Routes>\n            {/* Root redirect to demo tenant */}\n            <Route path=\"/\" element={<Navigate to=\"/demo/login\" replace />} />\n            \n            {/* Super admin routes */}\n            <Route path=\"/edgvoip/login\" element={<SuperAdminLogin />} />\n            <Route path=\"/edgvoip/*\" element={<SuperAdminRoutes />} />\n            \n            {/* Tenant routes (monotenant) */}\n            <Route path=\"/:tenantSlug/*\" element={<TenantRoutes />} />\n            \n            {/* 404 for invalid tenant */}\n            <Route path=\"*\" element={<TenantNotFound />} />\n          </Routes>\n          <Toaster />\n        </div>\n      </AuthProvider>\n    </Router>\n  );\n}\n\nexport default App;","size_bytes":6088},"packages/frontend/src/components/ui/select.tsx":{"content":"import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}","size_bytes":5614},"packages/frontend/src/components/ui/alert.tsx":{"content":"import * as React from 'react';\r\n\r\ntype AlertVariant = 'default' | 'destructive' | 'success' | 'warning' | 'info';\r\n\r\nexport interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  variant?: AlertVariant;\r\n}\r\n\r\nconst variantToClasses: Record<AlertVariant, string> = {\r\n  default:\r\n    'border border-gray-200 bg-white text-gray-900 dark:border-gray-800 dark:bg-gray-900 dark:text-gray-100',\r\n  destructive:\r\n    'border border-red-200 bg-red-50 text-red-800 dark:border-red-900/50 dark:bg-red-950 dark:text-red-300',\r\n  success:\r\n    'border border-emerald-200 bg-emerald-50 text-emerald-800 dark:border-emerald-900/50 dark:bg-emerald-950 dark:text-emerald-300',\r\n  warning:\r\n    'border border-amber-200 bg-amber-50 text-amber-900 dark:border-amber-900/50 dark:bg-amber-950 dark:text-amber-300',\r\n  info:\r\n    'border border-sky-200 bg-sky-50 text-sky-900 dark:border-sky-900/50 dark:bg-sky-950 dark:text-sky-300',\r\n};\r\n\r\nexport const Alert = React.forwardRef<HTMLDivElement, AlertProps>(\r\n  ({ className = '', variant = 'default', children, ...props }, ref) => {\r\n    const classes = `w-full rounded-md px-4 py-3 text-sm ${variantToClasses[variant]} ${className}`.trim();\r\n    return (\r\n      <div ref={ref} role=\"alert\" className={classes} {...props}>\r\n        {children}\r\n      </div>\r\n    );\r\n  }\r\n);\r\nAlert.displayName = 'Alert';\r\n\r\nexport interface AlertDescriptionProps extends React.HTMLAttributes<HTMLParagraphElement> {}\r\n\r\nexport const AlertDescription = React.forwardRef<HTMLParagraphElement, AlertDescriptionProps>(\r\n  ({ className = '', children, ...props }, ref) => {\r\n    const classes = `mt-1 leading-relaxed ${className}`.trim();\r\n    return (\r\n      <p ref={ref} className={classes} {...props}>\r\n        {children}\r\n      </p>\r\n    );\r\n  }\r\n);\r\nAlertDescription.displayName = 'AlertDescription';\r\n\r\n\r\n","size_bytes":1836},"packages/frontend/src/components/ImpersonationBanner.tsx":{"content":"import React, { useState, useEffect } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Alert, AlertDescription } from '@/components/ui/alert';\r\nimport { Button } from '@/components/ui/button';\r\nimport { X, Shield, User } from 'lucide-react';\r\nimport apiClient from '@/lib/api';\r\n\r\ninterface ImpersonationInfo {\r\n  originalUser: {\r\n    first_name: string;\r\n    last_name: string;\r\n    email: string;\r\n    role: string;\r\n  };\r\n  impersonatedAt: string;\r\n}\r\n\r\nexport default function ImpersonationBanner() {\r\n  const [impersonationInfo, setImpersonationInfo] = useState<ImpersonationInfo | null>(null);\r\n  const [isImpersonating, setIsImpersonating] = useState(false);\r\n  const navigate = useNavigate();\r\n\r\n  useEffect(() => {\r\n    // Check if we're impersonating\r\n    const isCurrentlyImpersonating = apiClient.isImpersonating();\r\n    setIsImpersonating(isCurrentlyImpersonating);\r\n\r\n    if (isCurrentlyImpersonating) {\r\n      // Load impersonation info\r\n      const info = localStorage.getItem('impersonation_info');\r\n      if (info) {\r\n        try {\r\n          setImpersonationInfo(JSON.parse(info));\r\n        } catch (error) {\r\n          console.error('Failed to parse impersonation info:', error);\r\n        }\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  const handleExitImpersonation = () => {\r\n    // Exit impersonation\r\n    apiClient.exitImpersonation();\r\n    \r\n    // Clear impersonation info\r\n    localStorage.removeItem('impersonation_info');\r\n    \r\n    // Reset state\r\n    setIsImpersonating(false);\r\n    setImpersonationInfo(null);\r\n    \r\n    // Redirect to super admin dashboard\r\n    navigate('/edgvoip/dashboard');\r\n  };\r\n\r\n  if (!isImpersonating || !impersonationInfo) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div className=\"fixed top-0 left-0 right-0 z-50\">\r\n      <Alert className=\"border-orange-200 bg-orange-50 text-orange-800 rounded-none\">\r\n        <Shield className=\"h-4 w-4\" />\r\n        <AlertDescription className=\"flex items-center justify-between w-full\">\r\n          <div className=\"flex items-center space-x-4\">\r\n            <div className=\"flex items-center space-x-2\">\r\n              <User className=\"h-4 w-4\" />\r\n              <span className=\"font-medium\">\r\n                Impersonating: {impersonationInfo.originalUser.first_name} {impersonationInfo.originalUser.last_name}\r\n              </span>\r\n              <span className=\"text-sm text-orange-600\">\r\n                ({impersonationInfo.originalUser.email})\r\n              </span>\r\n            </div>\r\n            <div className=\"text-sm text-orange-600\">\r\n              Started: {new Date(impersonationInfo.impersonatedAt).toLocaleTimeString()}\r\n            </div>\r\n          </div>\r\n          <Button\r\n            size=\"sm\"\r\n            variant=\"outline\"\r\n            onClick={handleExitImpersonation}\r\n            className=\"border-orange-300 text-orange-800 hover:bg-orange-100\"\r\n          >\r\n            <X className=\"h-4 w-4 mr-2\" />\r\n            Exit Impersonation\r\n          </Button>\r\n        </AlertDescription>\r\n      </Alert>\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":3060},"packages/backend/src/types/express.d.ts":{"content":"import { Request } from 'express';\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      id?: string;\r\n      user?: {\r\n        id: string;\r\n        email: string;\r\n        role: string;\r\n        tenant_id?: string;\r\n        tenant_slug?: string;\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n","size_bytes":295},"packages/backend/src/services/freeswitch.service.ts":{"content":"import { EventEmitter } from 'events';\r\nimport { Socket } from 'net';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { logFreeSWITCHEvent } from '../utils/logger';\r\n\r\nexport interface FreeSWITCHEvent {\r\n  eventName: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n}\r\n\r\nexport interface CallInfo {\r\n  uuid: string;\r\n  direction: 'inbound' | 'outbound' | 'internal';\r\n  caller_id_number: string;\r\n  caller_id_name: string;\r\n  callee_id_number: string;\r\n  callee_id_name: string;\r\n  domain: string;\r\n  context: string;\r\n  start_time: Date;\r\n  answer_time?: Date;\r\n  end_time?: Date;\r\n  duration?: number;\r\n  hangup_cause?: string;\r\n  recording_path?: string;\r\n}\r\n\r\nexport class FreeSWITCHService extends EventEmitter {\r\n  private socket: Socket | null = null;\r\n  private connected: boolean = false;\r\n  private host: string;\r\n  private port: number;\r\n  private password: string;\r\n  private reconnectAttempts: number = 0;\r\n  private maxReconnectAttempts: number = 5;\r\n  private reconnectInterval: number = 5000;\r\n  private eventBuffer: string = '';\r\n  private eventListeners: Map<string, (event: FreeSWITCHEvent) => void> = new Map();\r\n\r\n  constructor() {\r\n    super();\r\n    this.host = process.env.FREESWITCH_HOST || '192.168.172.234';\r\n    this.port = parseInt(process.env.FREESWITCH_PORT || '8021');\r\n    this.password = process.env.FREESWITCH_PASSWORD || 'ClueCon';\r\n  }\r\n\r\n  // Connect to FreeSWITCH Event Socket\r\n  async connect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        this.socket = new Socket();\r\n        \r\n        this.socket.on('connect', () => {\r\n          this.connected = true;\r\n          this.reconnectAttempts = 0;\r\n          logFreeSWITCHEvent('connection', { status: 'connected', host: this.host, port: this.port });\r\n          this.emit('connected');\r\n        });\r\n\r\n        this.socket.on('data', (data) => {\r\n          this.handleData(data.toString());\r\n        });\r\n\r\n        this.socket.on('error', (error) => {\r\n          logFreeSWITCHEvent('connection_error', { error: error.message });\r\n          this.emit('error', error);\r\n          this.handleReconnect();\r\n        });\r\n\r\n        this.socket.on('close', () => {\r\n          this.connected = false;\r\n          logFreeSWITCHEvent('connection', { status: 'disconnected' });\r\n          this.emit('disconnected');\r\n          this.handleReconnect();\r\n        });\r\n\r\n        this.socket.connect(this.port, this.host, () => {\r\n          // Send authentication\r\n          this.sendCommand('auth', this.password);\r\n        });\r\n\r\n        // Set up authentication response handler\r\n        this.once('auth_success', () => {\r\n          this.subscribeToEvents();\r\n          resolve();\r\n        });\r\n\r\n        this.once('auth_failure', (error) => {\r\n          reject(new Error(`FreeSWITCH authentication failed: ${error}`));\r\n        });\r\n\r\n        // Timeout for connection\r\n        setTimeout(() => {\r\n          if (!this.connected) {\r\n            reject(new Error('FreeSWITCH connection timeout'));\r\n          }\r\n        }, 10000);\r\n\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Handle incoming data from FreeSWITCH\r\n  private handleData(data: string): void {\r\n    this.eventBuffer += data;\r\n    \r\n    // Process complete events\r\n    while (this.eventBuffer.includes('\\n\\n')) {\r\n      const eventEnd = this.eventBuffer.indexOf('\\n\\n');\r\n      const eventData = this.eventBuffer.substring(0, eventEnd);\r\n      this.eventBuffer = this.eventBuffer.substring(eventEnd + 2);\r\n      \r\n      this.processEvent(eventData);\r\n    }\r\n  }\r\n\r\n  // Process a complete event\r\n  private processEvent(eventData: string): void {\r\n    const lines = eventData.split('\\n');\r\n    const event: FreeSWITCHEvent = {\r\n      eventName: '',\r\n      headers: {},\r\n      body: ''\r\n    };\r\n\r\n    let inBody = false;\r\n    let bodyLines: string[] = [];\r\n\r\n    for (const line of lines) {\r\n      if (line.trim() === '') {\r\n        inBody = true;\r\n        continue;\r\n      }\r\n\r\n      if (inBody) {\r\n        bodyLines.push(line);\r\n      } else {\r\n        const colonIndex = line.indexOf(':');\r\n        if (colonIndex > 0) {\r\n          const key = line.substring(0, colonIndex).trim();\r\n          const value = line.substring(colonIndex + 1).trim();\r\n          \r\n          if (key === 'Event-Name') {\r\n            event.eventName = value;\r\n          } else {\r\n            event.headers[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bodyLines.length > 0) {\r\n      event.body = bodyLines.join('\\n');\r\n    }\r\n\r\n    this.handleEvent(event);\r\n  }\r\n\r\n  // Handle specific events\r\n  private handleEvent(event: FreeSWITCHEvent): void {\r\n    logFreeSWITCHEvent('event_received', { \r\n      eventName: event.eventName, \r\n      uuid: event.headers['Unique-ID'] \r\n    });\r\n\r\n    // Handle authentication response\r\n    if (event.eventName === 'auth/request') {\r\n      this.emit('auth_success');\r\n      return;\r\n    }\r\n\r\n    if (event.eventName === 'auth/request') {\r\n      this.emit('auth_failure', 'Authentication failed');\r\n      return;\r\n    }\r\n\r\n    // Handle call events\r\n    switch (event.eventName) {\r\n      case 'CHANNEL_CREATE':\r\n        this.handleChannelCreate(event);\r\n        break;\r\n      case 'CHANNEL_ANSWER':\r\n        this.handleChannelAnswer(event);\r\n        break;\r\n      case 'CHANNEL_HANGUP':\r\n        this.handleChannelHangup(event);\r\n        break;\r\n      case 'CHANNEL_BRIDGE':\r\n        this.handleChannelBridge(event);\r\n        break;\r\n      case 'RECORD_START':\r\n        this.handleRecordStart(event);\r\n        break;\r\n      case 'RECORD_STOP':\r\n        this.handleRecordStop(event);\r\n        break;\r\n      default:\r\n        // Emit generic event\r\n        this.emit('event', event);\r\n    }\r\n\r\n    // Call specific event listeners\r\n    const listener = this.eventListeners.get(event.eventName);\r\n    if (listener) {\r\n      listener(event);\r\n    }\r\n  }\r\n\r\n  // Handle channel creation\r\n  private handleChannelCreate(event: FreeSWITCHEvent): void {\r\n    const callInfo: CallInfo = {\r\n      uuid: event.headers['Unique-ID'],\r\n      direction: this.getCallDirection(event),\r\n      caller_id_number: event.headers['Caller-Caller-ID-Number'] || '',\r\n      caller_id_name: event.headers['Caller-Caller-ID-Name'] || '',\r\n      callee_id_number: event.headers['Caller-Destination-Number'] || '',\r\n      callee_id_name: event.headers['Caller-Destination-Name'] || '',\r\n      domain: event.headers['Caller-Domain'] || '',\r\n      context: event.headers['Caller-Context'] || '',\r\n      start_time: new Date()\r\n    };\r\n\r\n    this.emit('call_started', callInfo);\r\n  }\r\n\r\n  // Handle channel answer\r\n  private handleChannelAnswer(event: FreeSWITCHEvent): void {\r\n    const callInfo: Partial<CallInfo> = {\r\n      uuid: event.headers['Unique-ID'],\r\n      answer_time: new Date()\r\n    };\r\n\r\n    this.emit('call_answered', callInfo);\r\n  }\r\n\r\n  // Handle channel hangup\r\n  private handleChannelHangup(event: FreeSWITCHEvent): void {\r\n    const callInfo: Partial<CallInfo> = {\r\n      uuid: event.headers['Unique-ID'],\r\n      end_time: new Date(),\r\n      duration: parseInt(event.headers['variable_duration'] || '0'),\r\n      hangup_cause: event.headers['Hangup-Cause']\r\n    };\r\n\r\n    this.emit('call_ended', callInfo);\r\n  }\r\n\r\n  // Handle channel bridge\r\n  private handleChannelBridge(event: FreeSWITCHEvent): void {\r\n    const callInfo: Partial<CallInfo> = {\r\n      uuid: event.headers['Unique-ID']\r\n    };\r\n\r\n    this.emit('call_bridged', callInfo);\r\n  }\r\n\r\n  // Handle recording start\r\n  private handleRecordStart(event: FreeSWITCHEvent): void {\r\n    const callInfo: Partial<CallInfo> = {\r\n      uuid: event.headers['Unique-ID'],\r\n      recording_path: event.headers['variable_record_sample_rate']\r\n    };\r\n\r\n    this.emit('recording_started', callInfo);\r\n  }\r\n\r\n  // Handle recording stop\r\n  private handleRecordStop(event: FreeSWITCHEvent): void {\r\n    const callInfo: Partial<CallInfo> = {\r\n      uuid: event.headers['Unique-ID']\r\n    };\r\n\r\n    this.emit('recording_stopped', callInfo);\r\n  }\r\n\r\n  // Determine call direction\r\n  private getCallDirection(event: FreeSWITCHEvent): 'inbound' | 'outbound' | 'internal' {\r\n    const context = event.headers['Caller-Context'];\r\n    const direction = event.headers['Call-Direction'];\r\n\r\n    if (direction === 'inbound') return 'inbound';\r\n    if (direction === 'outbound') return 'outbound';\r\n    if (context === 'internal') return 'internal';\r\n    \r\n    // Fallback logic\r\n    const callerNumber = event.headers['Caller-Caller-ID-Number'];\r\n    const calleeNumber = event.headers['Caller-Destination-Number'];\r\n    \r\n    if (callerNumber && callerNumber.startsWith('+')) return 'outbound';\r\n    if (calleeNumber && calleeNumber.startsWith('+')) return 'inbound';\r\n    \r\n    return 'internal';\r\n  }\r\n\r\n  // Subscribe to events\r\n  private subscribeToEvents(): void {\r\n    const events = [\r\n      'CHANNEL_CREATE',\r\n      'CHANNEL_ANSWER', \r\n      'CHANNEL_HANGUP',\r\n      'CHANNEL_BRIDGE',\r\n      'RECORD_START',\r\n      'RECORD_STOP',\r\n      'CUSTOM',\r\n      'BACKGROUND_JOB'\r\n    ];\r\n\r\n    this.sendCommand('event', `plain ${events.join(' ')}`);\r\n  }\r\n\r\n  // Send command to FreeSWITCH\r\n  sendCommand(command: string, args?: string): void {\r\n    if (!this.connected || !this.socket) {\r\n      throw new Error('FreeSWITCH not connected');\r\n    }\r\n\r\n    const fullCommand = args ? `${command} ${args}` : command;\r\n    const message = `${fullCommand}\\n\\n`;\r\n    \r\n    this.socket.write(message);\r\n    logFreeSWITCHEvent('command_sent', { command, args });\r\n  }\r\n\r\n  // Originate a call\r\n  async originateCall(\r\n    callerExtension: string,\r\n    calleeNumber: string,\r\n    domain: string,\r\n    options: {\r\n      timeout?: number;\r\n      callerId?: string;\r\n      context?: string;\r\n      recording?: boolean;\r\n    } = {}\r\n  ): Promise<string> {\r\n    const callUuid = uuidv4();\r\n    const timeout = options.timeout || 30;\r\n    const callerId = options.callerId || callerExtension;\r\n    const context = options.context || 'default';\r\n    const recording = options.recording ? 'true' : 'false';\r\n\r\n    const originateString = `{origination_uuid=${callUuid},origination_caller_id_number=${callerId},origination_caller_id_name=${callerId},record=${recording}}${callerExtension}@${domain} &bridge({origination_uuid=${callUuid}}${calleeNumber})`;\r\n\r\n    this.sendCommand('originate', originateString);\r\n\r\n    return callUuid;\r\n  }\r\n\r\n  // Transfer a call\r\n  async transferCall(\r\n    callUuid: string,\r\n    destination: string,\r\n    type: 'attended' | 'blind' = 'blind'\r\n  ): Promise<void> {\r\n    if (type === 'attended') {\r\n      this.sendCommand('uuid_transfer', `${callUuid} ${destination} XML default`);\r\n    } else {\r\n      this.sendCommand('uuid_bridge', `${callUuid} ${destination}`);\r\n    }\r\n  }\r\n\r\n  // Hangup a call\r\n  async hangupCall(callUuid: string, cause: string = 'NORMAL_CLEARING'): Promise<void> {\r\n    this.sendCommand('uuid_kill', `${callUuid} ${cause}`);\r\n  }\r\n\r\n  // Hold/Unhold a call\r\n  async holdCall(callUuid: string, hold: boolean = true): Promise<void> {\r\n    const action = hold ? 'hold' : 'unhold';\r\n    this.sendCommand('uuid_hold', `${callUuid} ${action}`);\r\n  }\r\n\r\n  // Mute/Unmute a call\r\n  async muteCall(callUuid: string, mute: boolean = true): Promise<void> {\r\n    const action = mute ? 'mute' : 'unmute';\r\n    this.sendCommand('uuid_audio', `${callUuid} ${action}`);\r\n  }\r\n\r\n  // Start/Stop recording\r\n  async recordCall(callUuid: string, record: boolean = true, path?: string): Promise<void> {\r\n    if (record) {\r\n      const recordPath = path || `/var/recordings/${callUuid}.wav`;\r\n      this.sendCommand('uuid_record', `${callUuid} start ${recordPath}`);\r\n    } else {\r\n      this.sendCommand('uuid_record', `${callUuid} stop`);\r\n    }\r\n  }\r\n\r\n  // Get call information\r\n  async getCallInfo(callUuid: string): Promise<Record<string, string>> {\r\n    return new Promise((resolve, reject) => {\r\n      const jobUuid = uuidv4();\r\n      \r\n      const listener = (event: FreeSWITCHEvent) => {\r\n        if (event.eventName === 'BACKGROUND_JOB' && event.headers['Job-UUID'] === jobUuid) {\r\n          this.eventListeners.delete('BACKGROUND_JOB');\r\n          \r\n          if (event.headers['Job-Command-Arg']?.includes('uuid_dump')) {\r\n            const info: Record<string, string> = {};\r\n            const lines = event.body?.split('\\n') || [];\r\n            \r\n            for (const line of lines) {\r\n              const colonIndex = line.indexOf(':');\r\n              if (colonIndex > 0) {\r\n                const key = line.substring(0, colonIndex).trim();\r\n                const value = line.substring(colonIndex + 1).trim();\r\n                info[key] = value;\r\n              }\r\n            }\r\n            \r\n            resolve(info);\r\n          } else {\r\n            reject(new Error('Failed to get call info'));\r\n          }\r\n        }\r\n      };\r\n\r\n      this.eventListeners.set('BACKGROUND_JOB', listener);\r\n      this.sendCommand('bgapi', `uuid_dump ${callUuid}`);\r\n      \r\n      // Timeout after 5 seconds\r\n      setTimeout(() => {\r\n        this.eventListeners.delete('BACKGROUND_JOB');\r\n        reject(new Error('Timeout getting call info'));\r\n      }, 5000);\r\n    });\r\n  }\r\n\r\n  // Add event listener\r\n  addEventListener(eventName: string, listener: (event: FreeSWITCHEvent) => void): void {\r\n    this.eventListeners.set(eventName, listener);\r\n  }\r\n\r\n  // Remove event listener\r\n  removeEventListener(eventName: string): void {\r\n    this.eventListeners.delete(eventName);\r\n  }\r\n\r\n  // Handle reconnection\r\n  private handleReconnect(): void {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      logFreeSWITCHEvent('reconnect_failed', { \r\n        attempts: this.reconnectAttempts,\r\n        maxAttempts: this.maxReconnectAttempts \r\n      });\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    logFreeSWITCHEvent('reconnect_attempt', { \r\n      attempt: this.reconnectAttempts,\r\n      maxAttempts: this.maxReconnectAttempts \r\n    });\r\n\r\n    setTimeout(() => {\r\n      this.connect().catch((error) => {\r\n        logFreeSWITCHEvent('reconnect_error', { error: error.message });\r\n      });\r\n    }, this.reconnectInterval);\r\n  }\r\n\r\n  // Disconnect from FreeSWITCH\r\n  disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.end();\r\n      this.socket = null;\r\n    }\r\n    this.connected = false;\r\n    this.eventListeners.clear();\r\n  }\r\n\r\n  // Check if connected\r\n  isConnected(): boolean {\r\n    return this.connected;\r\n  }\r\n\r\n  // Get connection status\r\n  getStatus(): { connected: boolean; host: string; port: number; reconnectAttempts: number } {\r\n    return {\r\n      connected: this.connected,\r\n      host: this.host,\r\n      port: this.port,\r\n      reconnectAttempts: this.reconnectAttempts\r\n    };\r\n  }\r\n}\r\n\r\n","size_bytes":14736},"packages/frontend/src/pages/CallRouting.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Plus, \n  Search, \n  Edit, \n  Trash2, \n  ArrowRight, \n  ArrowLeft,\n  Save,\n  X,\n  RefreshCw,\n  Eye,\n  Mic\n} from 'lucide-react';\nimport { \n  InboundRoute, \n  OutboundRoute \n} from '@voip/shared';\nimport { apiClient } from '@/lib/api';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useVoipEntityOptions } from '@/hooks/use-voip-entities';\n\nexport default function CallRouting() {\n  const { user } = useAuth();\n  const [activeTab, setActiveTab] = useState('inbound');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [showModal, setShowModal] = useState(false);\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\n  const [loading, setLoading] = useState(false);\n  \n  // Data states\n  const [inboundRoutes, setInboundRoutes] = useState<InboundRoute[]>([]);\n  const [outboundRoutes, setOutboundRoutes] = useState<OutboundRoute[]>([]);\n\n  // Form states\n  const [formData, setFormData] = useState<any>({});\n  const [editingItem, setEditingItem] = useState<any>(null);\n\n  // VoIP Entity Options for dropdowns\n  const { options: extensionOptions } = useVoipEntityOptions('extensions');\n  const { options: ringGroupOptions } = useVoipEntityOptions('ring-groups');\n  const { options: queueOptions } = useVoipEntityOptions('queues');\n  const { options: conferenceOptions } = useVoipEntityOptions('conference-rooms');\n  const { options: voicemailOptions } = useVoipEntityOptions('voicemail-boxes');\n  const { options: ivrOptions } = useVoipEntityOptions('ivr-menus');\n  const { options: timeConditionOptions } = useVoipEntityOptions('time-conditions');\n  const { options: trunkOptions } = useVoipEntityOptions('extensions');\n\n  // Load data on component mount\n  useEffect(() => {\n    loadAllData();\n  }, []);\n\n  const loadAllData = async () => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const [inboundRes, outboundRes] = await Promise.all([\n        apiClient.get(`/voip/inbound-routes?tenant_id=${user.tenant_id}`),\n        apiClient.get(`/voip/outbound-routes?tenant_id=${user.tenant_id}`)\n      ]);\n\n      setInboundRoutes((inboundRes.data as InboundRoute[]) || []);\n      setOutboundRoutes((outboundRes.data as OutboundRoute[]) || []);\n    } catch (error) {\n      console.error('Error loading data:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCreate = async (type: string, data: any) => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const response = await apiClient.post(`/voip/${type}`, {\n        ...data,\n        tenant_id: user.tenant_id\n      });\n      \n      // Update local state\n      if (type === 'inbound-routes') {\n        setInboundRoutes(prev => [...prev, response.data]);\n      } else {\n        setOutboundRoutes(prev => [...prev, response.data]);\n      }\n      \n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error creating route:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleUpdate = async (type: string, id: string, data: any) => {\n    setLoading(true);\n    try {\n      const response = await apiClient.put(`/voip/${type}/${id}`, data);\n      \n      // Update local state\n      if (type === 'inbound-routes') {\n        setInboundRoutes(prev => prev.map(item => item.id === id ? response.data : item));\n      } else {\n        setOutboundRoutes(prev => prev.map(item => item.id === id ? response.data : item));\n      }\n      \n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error updating route:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDelete = async (type: string, id: string) => {\n    if (!confirm('Are you sure you want to delete this route?')) return;\n    \n    setLoading(true);\n    try {\n      await apiClient.delete(`/voip/${type}/${id}`);\n      \n      // Update local state\n      if (type === 'inbound-routes') {\n        setInboundRoutes(prev => prev.filter(item => item.id !== id));\n      } else {\n        setOutboundRoutes(prev => prev.filter(item => item.id !== id));\n      }\n    } catch (error) {\n      console.error('Error deleting route:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const openModal = (type: 'create' | 'edit' | 'view', item?: any) => {\n    setModalType(type);\n    if (item) {\n      setEditingItem(item);\n      setFormData(item);\n    } else {\n      setEditingItem(null);\n      setFormData({});\n    }\n    setShowModal(true);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setEditingItem(null);\n    setFormData({});\n  };\n\n  const getDestinationTypeLabel = (type: string) => {\n    const labels: Record<string, string> = {\n      extension: 'Extension',\n      ring_group: 'Ring Group',\n      queue: 'Queue',\n      voicemail: 'Voicemail',\n      ivr: 'IVR Menu',\n      conference: 'Conference',\n      external: 'External Number',\n    };\n    return labels[type] || type;\n  };\n\n  const renderDataTable = (data: any[], type: string, columns: any[]) => (\n    <div className=\"w-full\">\n      <div className=\"overflow-x-auto\">\n        <table className=\"w-full border-collapse\">\n          <thead>\n            <tr className=\"border-b bg-gray-50\">\n              {columns.map((col, index) => (\n                <th key={index} className=\"text-left p-3 font-medium text-gray-700\">\n                  {col.header}\n                </th>\n              ))}\n              <th className=\"text-right p-3 font-medium text-gray-700\">Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {data.map((item, index) => (\n              <tr key={item.id || index} className=\"border-b hover:bg-gray-50\">\n                {columns.map((col, colIndex) => (\n                  <td key={colIndex} className=\"p-3\">\n                    {col.render ? col.render(item) : item[col.key]}\n                  </td>\n                ))}\n                <td className=\"p-3\">\n                  <div className=\"flex items-center justify-end space-x-1\">\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('view', item)}\n                      title=\"View Details\"\n                    >\n                      <Eye className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('edit', item)}\n                      title=\"Edit\"\n                    >\n                      <Edit className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => handleDelete(type, item.id)}\n                      title=\"Delete\"\n                      className=\"text-red-600 hover:text-red-700\"\n                    >\n                      <Trash2 className=\"h-4 w-4\" />\n                    </Button>\n                  </div>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n\n  const renderInboundRoutes = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'DID Number', key: 'did_number' },\n      { \n        header: 'Destination', \n        key: 'destination',\n        render: (item: any) => `${getDestinationTypeLabel(item.destination_type)}: ${item.destination_value}`\n      },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_calls && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      },\n      { header: 'Description', key: 'description' }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <ArrowRight className=\"h-5 w-5 mr-2\" />\n            Inbound Routes ({inboundRoutes.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Inbound Route\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(inboundRoutes, 'inbound-routes', columns)}\n      </div>\n    );\n  };\n\n  const renderOutboundRoutes = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Dial Pattern', key: 'dial_pattern' },\n      { header: 'Trunk', key: 'trunk_id' },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_calls && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      },\n      { header: 'Description', key: 'description' }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <ArrowLeft className=\"h-5 w-5 mr-2\" />\n            Outbound Routes ({outboundRoutes.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Outbound Route\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(outboundRoutes, 'outbound-routes', columns)}\n      </div>\n    );\n  };\n\n  const renderModal = () => {\n    if (!showModal) return null;\n\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className=\"bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-xl font-semibold\">\n              {modalType === 'create' ? 'Create New' : modalType === 'edit' ? 'Edit' : 'View'} {activeTab} Route\n            </h2>\n            <Button variant=\"ghost\" size=\"sm\" onClick={closeModal}>\n              <X className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          \n          <Tabs defaultValue=\"basic\" className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-4\">\n              <TabsTrigger value=\"basic\">Basic</TabsTrigger>\n              <TabsTrigger value=\"routing\">Routing</TabsTrigger>\n              <TabsTrigger value=\"advanced\">Advanced</TabsTrigger>\n              <TabsTrigger value=\"recording\">Recording</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"basic\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Route Name</label>\n                  <Input \n                    placeholder=\"Route name\" \n                    value={formData.name || ''}\n                    onChange={(e) => setFormData({...formData, name: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Description</label>\n                  <Input \n                    placeholder=\"Route description\" \n                    value={formData.description || ''}\n                    onChange={(e) => setFormData({...formData, description: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n              {activeTab === 'inbound' && (\n                <div>\n                  <label className=\"text-sm font-medium\">DID Number</label>\n                  <Input \n                    placeholder=\"+1234567890\" \n                    value={formData.did_number || ''}\n                    onChange={(e) => setFormData({...formData, did_number: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              )}\n              {activeTab === 'outbound' && (\n                <div>\n                  <label className=\"text-sm font-medium\">Dial Pattern</label>\n                  <Input \n                    placeholder=\"^\\+1([0-9]{10})$\" \n                    value={formData.dial_pattern || ''}\n                    onChange={(e) => setFormData({...formData, dial_pattern: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              )}\n              <div className=\"flex items-center space-x-2\">\n                <Switch \n                  id=\"enabled\" \n                  checked={formData.enabled || false}\n                  onCheckedChange={(checked) => setFormData({...formData, enabled: checked})}\n                  disabled={modalType === 'view'}\n                />\n                <label htmlFor=\"enabled\" className=\"text-sm font-medium\">Enabled</label>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"routing\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Destination Type</label>\n                  <Select \n                    value={formData.destination_type || ''}\n                    onValueChange={(value) => setFormData({...formData, destination_type: value})}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select destination\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"extension\">Extension</SelectItem>\n                      <SelectItem value=\"ring_group\">Ring Group</SelectItem>\n                      <SelectItem value=\"queue\">Queue</SelectItem>\n                      <SelectItem value=\"voicemail\">Voicemail</SelectItem>\n                      <SelectItem value=\"ivr\">IVR Menu</SelectItem>\n                      <SelectItem value=\"conference\">Conference</SelectItem>\n                      <SelectItem value=\"external\">External Number</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Destination Value</label>\n                  {formData.destination_type === 'extension' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select extension\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {extensionOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {formData.destination_type === 'ring_group' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select ring group\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {ringGroupOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {formData.destination_type === 'queue' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select queue\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {queueOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {formData.destination_type === 'conference' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select conference room\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {conferenceOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {formData.destination_type === 'voicemail' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select voicemail box\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {voicemailOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {formData.destination_type === 'ivr' && (\n                    <Select \n                      value={formData.destination_value || ''}\n                      onValueChange={(value) => setFormData({...formData, destination_value: value})}\n                      disabled={modalType === 'view'}\n                    >\n                      <SelectTrigger>\n                        <SelectValue placeholder=\"Select IVR menu\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        {ivrOptions.map((option) => (\n                          <SelectItem key={option.value} value={option.value}>\n                            {option.label}\n                          </SelectItem>\n                        ))}\n                      </SelectContent>\n                    </Select>\n                  )}\n                  {(formData.destination_type === 'external' || !formData.destination_type) && (\n                    <Input \n                      placeholder=\"External number or ID\"\n                      value={formData.destination_value || ''}\n                      onChange={(e) => setFormData({...formData, destination_value: e.target.value})}\n                      disabled={modalType === 'view'}\n                    />\n                  )}\n                </div>\n              </div>\n              \n              {/* Time Condition */}\n              <div>\n                <label className=\"text-sm font-medium\">Time Condition (Optional)</label>\n                <Select \n                  value={formData.time_condition_id || ''}\n                  onValueChange={(value) => setFormData({...formData, time_condition_id: value})}\n                  disabled={modalType === 'view'}\n                >\n                  <SelectTrigger>\n                    <SelectValue placeholder=\"Select time condition\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"\">No time condition</SelectItem>\n                    {timeConditionOptions.map((option) => (\n                      <SelectItem key={option.value} value={option.value}>\n                        {option.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              </div>\n              \n              {activeTab === 'outbound' && (\n                <div>\n                  <label className=\"text-sm font-medium\">SIP Trunk</label>\n                  <Select \n                    value={formData.trunk_id || ''}\n                    onValueChange={(value) => setFormData({...formData, trunk_id: value})}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select SIP trunk\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {trunkOptions.map((option) => (\n                        <SelectItem key={option.value} value={option.value}>\n                          {option.label}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                </div>\n              )}\n            </TabsContent>\n            \n            <TabsContent value=\"advanced\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Priority</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"100\" \n                    value={formData.priority || ''}\n                    onChange={(e) => setFormData({...formData, priority: parseInt(e.target.value)})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Timeout (seconds)</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"30\" \n                    value={formData.timeout || ''}\n                    onChange={(e) => setFormData({...formData, timeout: parseInt(e.target.value)})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"caller-id-override\" \n                    checked={formData.caller_id_override || false}\n                    onCheckedChange={(checked) => setFormData({...formData, caller_id_override: checked})}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"caller-id-override\" className=\"text-sm font-medium\">Caller ID Override</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"failover-enabled\" \n                    checked={formData.failover_enabled || false}\n                    onCheckedChange={(checked) => setFormData({...formData, failover_enabled: checked})}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"failover-enabled\" className=\"text-sm font-medium\">Failover Enabled</label>\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"recording\" className=\"space-y-4\">\n              <div className=\"flex items-center space-x-2\">\n                <Switch \n                  id=\"record-calls\" \n                  checked={formData.record_calls || false}\n                  onCheckedChange={(checked) => setFormData({...formData, record_calls: checked})}\n                  disabled={modalType === 'view'}\n                />\n                <label htmlFor=\"record-calls\" className=\"text-sm font-medium\">Record Calls</label>\n              </div>\n              <div>\n                <label className=\"text-sm font-medium\">Recording Path</label>\n                <Input \n                  placeholder=\"/var/recordings/\" \n                  value={formData.recording_path || ''}\n                  onChange={(e) => setFormData({...formData, recording_path: e.target.value})}\n                  disabled={modalType === 'view'}\n                />\n              </div>\n            </TabsContent>\n          </Tabs>\n          \n          {modalType !== 'view' && (\n            <div className=\"flex justify-end space-x-2 mt-6\">\n              <Button \n                variant=\"outline\"\n                onClick={closeModal}\n              >\n                <X className=\"h-4 w-4 mr-2\" />\n                Cancel\n              </Button>\n              <Button \n                onClick={() => {\n                  if (editingItem) {\n                    handleUpdate(`${activeTab}-routes`, editingItem.id, formData);\n                  } else {\n                    handleCreate(`${activeTab}-routes`, formData);\n                  }\n                }}\n                disabled={loading}\n                className=\"bg-blue-600 hover:bg-blue-700\"\n              >\n                <Save className=\"h-4 w-4 mr-2\" />\n                {loading ? 'Saving...' : 'Save Route'}\n              </Button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Call Routing</h1>\n          <p className=\"text-muted-foreground\">\n            Configure inbound and outbound call routing rules\n          </p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search routes...\"\n              className=\"pl-8 w-64\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"space-y-8\">\n        <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"inbound\">Inbound Routes</TabsTrigger>\n            <TabsTrigger value=\"outbound\">Outbound Routes</TabsTrigger>\n          </TabsList>\n          \n          <TabsContent value=\"inbound\" className=\"mt-6\">\n            {renderInboundRoutes()}\n          </TabsContent>\n          \n          <TabsContent value=\"outbound\" className=\"mt-6\">\n            {renderOutboundRoutes()}\n          </TabsContent>\n        </Tabs>\n      </div>\n\n      {/* Modal */}\n      {renderModal()}\n    </div>\n  );\n}","size_bytes":29200},"packages/frontend/src/pages/Queues.tsx":{"content":"import { useState, useEffect } from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { \r\n  Plus, \r\n  Search, \r\n  Edit, \r\n  Trash2, \r\n  Phone, \r\n  Users,\r\n  Clock,\r\n  Activity,\r\n  MoreHorizontal,\r\n  UserMinus,\r\n  RefreshCw,\r\n  Eye\r\n} from 'lucide-react';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\nimport { useAuthenticatedApi } from '@/hooks/useAuthenticatedApi';\r\n\r\ninterface CallQueue {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  strategy: 'ring-all' | 'longest-idle' | 'round-robin' | 'top-down' | 'agent-with-least-talk-time';\r\n  max_wait_time: number;\r\n  agents: Array<{\r\n    id: string;\r\n    extension_id: string;\r\n    agent_name: string;\r\n    agent_type: 'callback' | 'uuid-standby' | 'uuid-bridge';\r\n    contact: string;\r\n    status: 'Available' | 'On Break' | 'Logged Out';\r\n    state: 'Waiting' | 'Receiving' | 'In a queue call';\r\n    tier_level: number;\r\n    tier_position: number;\r\n    calls_answered: number;\r\n    talk_time: number;\r\n    enabled: boolean;\r\n  }>;\r\n  queue_timeout: number;\r\n  queue_timeout_action: 'hangup' | 'voicemail' | 'forward';\r\n  enabled: boolean;\r\n  current_calls: number;\r\n  max_concurrent_calls: number;\r\n}\r\n\r\ninterface Extension {\r\n  id: string;\r\n  extension: string;\r\n  display_name: string;\r\n}\r\n\r\nexport default function Queues() {\r\n  const { user } = useAuth();\r\n  const { apiCall } = useAuthenticatedApi();\r\n  const [queues, setQueues] = useState<CallQueue[]>([]);\r\n  const [extensions, setExtensions] = useState<Extension[]>([]);\r\n  const [showModal, setShowModal] = useState(false);\r\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\r\n  const [loading, setLoading] = useState(false);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [formData, setFormData] = useState<Partial<CallQueue>>({});\r\n  const [editingItem, setEditingItem] = useState<CallQueue | null>(null);\r\n\r\n\r\n  // Load queues on component mount\r\n  useEffect(() => {\r\n    if (user) {\r\n      loadQueues();\r\n      loadExtensions();\r\n    }\r\n  }, [user]);\r\n\r\n  const loadQueues = async () => {\r\n    if (!user) {\r\n      console.warn('⚠️ User not authenticated, skipping queue load');\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await apiCall(`${API_BASE_URL}/queues`);\r\n      const data = await response.json();\r\n      \r\n      if (data?.success && Array.isArray(data?.data)) {\r\n        setQueues(data.data);\r\n      } else {\r\n        console.warn('⚠️ Invalid API response format');\r\n        setQueues([]);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error loading queues:', error);\r\n      setQueues([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const loadExtensions = async () => {\r\n    if (!user) {\r\n      console.warn('⚠️ User not authenticated, skipping extensions load');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await apiCall(`${API_BASE_URL}/extensions`);\r\n      const data = await response.json();\r\n      \r\n      if (data?.success && Array.isArray(data?.extensions)) {\r\n        setExtensions(data.extensions.map((ext: any) => ({\r\n          id: ext.id,\r\n          extension: ext.extension,\r\n          display_name: ext.display_name\r\n        })));\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error loading extensions:', error);\r\n    }\r\n  };\r\n\r\n  const handleCreate = async () => {\r\n    if (!user?.tenant_id) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/queues`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          ...formData,\r\n          tenant_id: user.tenant_id\r\n        })\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadQueues();\r\n        setShowModal(false);\r\n        setFormData({});\r\n      } else {\r\n        console.error('❌ Error creating queue:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error creating queue:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleEdit = async () => {\r\n    if (!editingItem) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/queues/${editingItem.id}`, {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(formData)\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadQueues();\r\n        setShowModal(false);\r\n        setFormData({});\r\n        setEditingItem(null);\r\n      } else {\r\n        console.error('❌ Error updating queue:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error updating queue:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (queue: CallQueue) => {\r\n    if (!confirm(`Are you sure you want to delete queue \"${queue.name}\"?`)) {\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/queues/${queue.id}`, {\r\n        method: 'DELETE'\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadQueues();\r\n      } else {\r\n        console.error('❌ Error deleting queue:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error deleting queue:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleAddAgent = async (queueId: string, extensionId: string) => {\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/queues/${queueId}/agents`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ extension_id: extensionId })\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadQueues();\r\n      } else {\r\n        console.error('❌ Error adding agent:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error adding agent:', error);\r\n    }\r\n  };\r\n\r\n  const handleRemoveAgent = async (queueId: string, extensionId: string) => {\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/queues/${queueId}/agents/${extensionId}`, {\r\n        method: 'DELETE'\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadQueues();\r\n      } else {\r\n        console.error('❌ Error removing agent:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error removing agent:', error);\r\n    }\r\n  };\r\n\r\n  const filteredQueues = queues.filter(queue =>\r\n    queue.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n    queue.extension.includes(searchTerm) ||\r\n    queue.description?.toLowerCase().includes(searchTerm.toLowerCase())\r\n  );\r\n\r\n  const getStrategyLabel = (strategy: string) => {\r\n    switch (strategy) {\r\n      case 'ring-all': return 'Ring All';\r\n      case 'longest-idle': return 'Longest Idle';\r\n      case 'round-robin': return 'Round Robin';\r\n      case 'top-down': return 'Top Down';\r\n      case 'agent-with-least-talk-time': return 'Least Talk Time';\r\n      default: return strategy;\r\n    }\r\n  };\r\n\r\n  const getStrategyColor = (strategy: string) => {\r\n    switch (strategy) {\r\n      case 'ring-all': return 'bg-blue-100 text-blue-800';\r\n      case 'longest-idle': return 'bg-green-100 text-green-800';\r\n      case 'round-robin': return 'bg-purple-100 text-purple-800';\r\n      case 'top-down': return 'bg-orange-100 text-orange-800';\r\n      case 'agent-with-least-talk-time': return 'bg-pink-100 text-pink-800';\r\n      default: return 'bg-gray-100 text-gray-800';\r\n    }\r\n  };\r\n\r\n  const getAgentStatusColor = (status: string) => {\r\n    switch (status) {\r\n      case 'Available': return 'bg-green-100 text-green-800';\r\n      case 'On Break': return 'bg-yellow-100 text-yellow-800';\r\n      case 'Logged Out': return 'bg-red-100 text-red-800';\r\n      default: return 'bg-gray-100 text-gray-800';\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Call Queues</h1>\r\n          <p className=\"text-gray-600\">Manage call queues for distributing calls to agents</p>\r\n        </div>\r\n        <Button onClick={() => {\r\n          setModalType('create');\r\n          setFormData({});\r\n          setShowModal(true);\r\n        }}>\r\n          <Plus className=\"h-4 w-4 mr-2\" />\r\n          Add Queue\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Search and Stats */}\r\n      <div className=\"flex items-center space-x-4\">\r\n        <div className=\"relative flex-1 max-w-md\">\r\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\r\n          <Input\r\n            placeholder=\"Search queues...\"\r\n            value={searchTerm}\r\n            onChange={(e) => setSearchTerm(e.target.value)}\r\n            className=\"pl-10\"\r\n          />\r\n        </div>\r\n        <Button variant=\"outline\" onClick={loadQueues} disabled={loading}>\r\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\r\n          Refresh\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Queues Grid */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n        {filteredQueues.map((queue) => (\r\n          <Card key={queue.id} className=\"relative\">\r\n            <CardHeader className=\"pb-3\">\r\n              <div className=\"flex items-start justify-between\">\r\n                <div className=\"flex-1\">\r\n                  <CardTitle className=\"text-lg\">{queue.name}</CardTitle>\r\n                  <CardDescription>{queue.description}</CardDescription>\r\n                </div>\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Badge variant={queue.enabled ? 'default' : 'secondary'}>\r\n                    {queue.enabled ? 'Active' : 'Inactive'}\r\n                  </Badge>\r\n                  <Button variant=\"ghost\" size=\"sm\">\r\n                    <MoreHorizontal className=\"h-4 w-4\" />\r\n                  </Button>\r\n                </div>\r\n              </div>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              {/* Extension and Strategy */}\r\n              <div className=\"flex items-center justify-between\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Phone className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"font-medium\">{queue.extension}</span>\r\n                </div>\r\n                <Badge className={getStrategyColor(queue.strategy)}>\r\n                  {getStrategyLabel(queue.strategy)}\r\n                </Badge>\r\n              </div>\r\n\r\n              {/* Agents */}\r\n              <div className=\"space-y-2\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Users className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"text-sm text-gray-600\">\r\n                    {queue.agents.length} agent{queue.agents.length !== 1 ? 's' : ''}\r\n                  </span>\r\n                </div>\r\n                \r\n                {/* Agent Status */}\r\n                <div className=\"space-y-1\">\r\n                  {queue.agents.slice(0, 3).map((agent) => (\r\n                    <div key={agent.id} className=\"flex items-center justify-between text-xs\">\r\n                      <span className=\"text-gray-600\">{agent.agent_name}</span>\r\n                      <Badge className={`${getAgentStatusColor(agent.status)} text-xs`}>\r\n                        {agent.status}\r\n                      </Badge>\r\n                    </div>\r\n                  ))}\r\n                  {queue.agents.length > 3 && (\r\n                    <div className=\"text-xs text-gray-500\">\r\n                      +{queue.agents.length - 3} more agents\r\n                    </div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              {/* Wait Time */}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Clock className=\"h-4 w-4 text-gray-500\" />\r\n                <span className=\"text-sm text-gray-600\">\r\n                  {Math.floor(queue.max_wait_time / 60)}m max wait\r\n                </span>\r\n              </div>\r\n\r\n              {/* Current Activity */}\r\n              <div className=\"flex items-center justify-between\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Activity className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"text-sm text-gray-600\">\r\n                    {queue.current_calls}/{queue.max_concurrent_calls} calls\r\n                  </span>\r\n                </div>\r\n                <div className=\"flex items-center space-x-1\">\r\n                  {queue.current_calls > 0 ? (\r\n                    <div className=\"w-2 h-2 bg-green-500 rounded-full animate-pulse\"></div>\r\n                  ) : (\r\n                    <div className=\"w-2 h-2 bg-gray-300 rounded-full\"></div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('edit');\r\n                    setFormData(queue);\r\n                    setEditingItem(queue);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Edit className=\"h-4 w-4 mr-1\" />\r\n                  Edit\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('view');\r\n                    setFormData(queue);\r\n                    setEditingItem(queue);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Eye className=\"h-4 w-4 mr-1\" />\r\n                  View\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => handleDelete(queue)}\r\n                  className=\"text-red-600 hover:text-red-700\"\r\n                >\r\n                  <Trash2 className=\"h-4 w-4\" />\r\n                </Button>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Empty State */}\r\n      {filteredQueues.length === 0 && !loading && (\r\n        <Card>\r\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n            <Users className=\"h-12 w-12 text-gray-400 mb-4\" />\r\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No Queues Found</h3>\r\n            <p className=\"text-gray-500 text-center mb-4\">\r\n              {searchTerm ? 'No queues match your search criteria.' : 'Create your first call queue to get started.'}\r\n            </p>\r\n            {!searchTerm && (\r\n              <Button onClick={() => {\r\n                setModalType('create');\r\n                setFormData({});\r\n                setShowModal(true);\r\n              }}>\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Create Queue\r\n              </Button>\r\n            )}\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Create/Edit Modal */}\r\n      {showModal && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <Card className=\"w-full max-w-2xl max-h-[90vh] overflow-y-auto\">\r\n            <CardHeader>\r\n              <CardTitle>\r\n                {modalType === 'create' ? 'Create Call Queue' : \r\n                 modalType === 'edit' ? 'Edit Call Queue' : 'View Call Queue'}\r\n              </CardTitle>\r\n              <CardDescription>\r\n                {modalType === 'create' ? 'Create a new call queue for your agents' :\r\n                 modalType === 'edit' ? 'Update queue settings' :\r\n                 'View queue details and agents'}\r\n              </CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Name</label>\r\n                  <Input\r\n                    value={formData.name || ''}\r\n                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"Support Queue\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Extension</label>\r\n                  <Input\r\n                    value={formData.extension || ''}\r\n                    onChange={(e) => setFormData({ ...formData, extension: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"3000\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div>\r\n                <label className=\"text-sm font-medium\">Description</label>\r\n                <Textarea\r\n                  value={formData.description || ''}\r\n                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}\r\n                  disabled={modalType === 'view'}\r\n                  placeholder=\"Call queue for customer support\"\r\n                />\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Strategy</label>\r\n                  <Select\r\n                    value={formData.strategy || 'ring-all'}\r\n                    onValueChange={(value) => setFormData({ ...formData, strategy: value as any })}\r\n                    disabled={modalType === 'view'}\r\n                  >\r\n                    <SelectTrigger>\r\n                      <SelectValue />\r\n                    </SelectTrigger>\r\n                    <SelectContent>\r\n                      <SelectItem value=\"ring-all\">Ring All</SelectItem>\r\n                      <SelectItem value=\"longest-idle\">Longest Idle</SelectItem>\r\n                      <SelectItem value=\"round-robin\">Round Robin</SelectItem>\r\n                      <SelectItem value=\"top-down\">Top Down</SelectItem>\r\n                      <SelectItem value=\"agent-with-least-talk-time\">Least Talk Time</SelectItem>\r\n                    </SelectContent>\r\n                  </Select>\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Max Wait Time (seconds)</label>\r\n                  <Input\r\n                    type=\"number\"\r\n                    value={formData.max_wait_time || 300}\r\n                    onChange={(e) => setFormData({ ...formData, max_wait_time: parseInt(e.target.value) })}\r\n                    disabled={modalType === 'view'}\r\n                    min=\"1\"\r\n                    max=\"3600\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Queue Timeout (seconds)</label>\r\n                  <Input\r\n                    type=\"number\"\r\n                    value={formData.queue_timeout || 60}\r\n                    onChange={(e) => setFormData({ ...formData, queue_timeout: parseInt(e.target.value) })}\r\n                    disabled={modalType === 'view'}\r\n                    min=\"1\"\r\n                    max=\"300\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Max Concurrent Calls</label>\r\n                  <Input\r\n                    type=\"number\"\r\n                    value={formData.max_concurrent_calls || 10}\r\n                    onChange={(e) => setFormData({ ...formData, max_concurrent_calls: parseInt(e.target.value) })}\r\n                    disabled={modalType === 'view'}\r\n                    min=\"1\"\r\n                    max=\"100\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              {/* Timeout Action */}\r\n              <div>\r\n                <label className=\"text-sm font-medium\">Timeout Action</label>\r\n                <Select\r\n                  value={formData.queue_timeout_action || 'hangup'}\r\n                  onValueChange={(value) => setFormData({ ...formData, queue_timeout_action: value as any })}\r\n                  disabled={modalType === 'view'}\r\n                >\r\n                  <SelectTrigger>\r\n                    <SelectValue />\r\n                  </SelectTrigger>\r\n                  <SelectContent>\r\n                    <SelectItem value=\"hangup\">Hangup</SelectItem>\r\n                    <SelectItem value=\"voicemail\">Voicemail</SelectItem>\r\n                    <SelectItem value=\"forward\">Forward</SelectItem>\r\n                  </SelectContent>\r\n                </Select>\r\n              </div>\r\n\r\n              {/* Agents Section */}\r\n              {(modalType === 'edit' || modalType === 'view') && editingItem && (\r\n                <div className=\"border-t pt-4\">\r\n                  <h4 className=\"font-medium mb-3\">Agents</h4>\r\n                  <div className=\"space-y-2\">\r\n                    {editingItem.agents.map((agent) => (\r\n                      <div key={agent.id} className=\"flex items-center justify-between p-2 border rounded\">\r\n                        <div className=\"flex items-center space-x-2\">\r\n                          <Phone className=\"h-4 w-4 text-gray-500\" />\r\n                          <span className=\"font-medium\">{agent.agent_name}</span>\r\n                          <Badge className={`${getAgentStatusColor(agent.status)} text-xs`}>\r\n                            {agent.status}\r\n                          </Badge>\r\n                        </div>\r\n                        <div className=\"flex items-center space-x-2\">\r\n                          <span className=\"text-sm text-gray-500\">\r\n                            T{agent.tier_level}.{agent.tier_position}\r\n                          </span>\r\n                          {modalType === 'edit' && (\r\n                            <Button\r\n                              variant=\"outline\"\r\n                              size=\"sm\"\r\n                              onClick={() => handleRemoveAgent(editingItem.id, agent.extension_id)}\r\n                              className=\"text-red-600 hover:text-red-700\"\r\n                            >\r\n                              <UserMinus className=\"h-4 w-4\" />\r\n                            </Button>\r\n                          )}\r\n                        </div>\r\n                      </div>\r\n                    ))}\r\n                    \r\n                    {modalType === 'edit' && (\r\n                      <div className=\"pt-2\">\r\n                        <Select onValueChange={(value) => {\r\n                          if (value) {\r\n                            handleAddAgent(editingItem.id, value);\r\n                          }\r\n                        }}>\r\n                          <SelectTrigger>\r\n                            <SelectValue placeholder=\"Add agent...\" />\r\n                          </SelectTrigger>\r\n                          <SelectContent>\r\n                            {extensions\r\n                              .filter(ext => !editingItem.agents.some(agent => agent.extension_id === ext.id))\r\n                              .map((ext) => (\r\n                                <SelectItem key={ext.id} value={ext.id}>\r\n                                  {ext.extension} - {ext.display_name}\r\n                                </SelectItem>\r\n                              ))}\r\n                          </SelectContent>\r\n                        </Select>\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n              )}\r\n\r\n              {/* Modal Actions */}\r\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  onClick={() => {\r\n                    setShowModal(false);\r\n                    setFormData({});\r\n                    setEditingItem(null);\r\n                  }}\r\n                >\r\n                  Cancel\r\n                </Button>\r\n                {modalType !== 'view' && (\r\n                  <Button\r\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\r\n                    disabled={loading}\r\n                  >\r\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\r\n                  </Button>\r\n                )}\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":25889},"packages/backend/entrypoint.sh":{"content":"#!/bin/sh\n\n# =============================================================================\n# Backend Entrypoint Script\n# =============================================================================\n\nset -e\n\necho \"🚀 Starting EDG VoIP Backend...\"\n\n# Wait for database to be ready\necho \"⏳ Waiting for database...\"\nuntil nc -z database 5432; do\n  echo \"Database is unavailable - sleeping\"\n  sleep 2\ndone\necho \"✅ Database is ready\"\n\n# Wait for Redis to be ready\necho \"⏳ Waiting for Redis...\"\nuntil nc -z redis 6379; do\n  echo \"Redis is unavailable - sleeping\"\n  sleep 2\ndone\necho \"✅ Redis is ready\"\n\n# Wait for FreeSWITCH to be ready\necho \"⏳ Waiting for FreeSWITCH...\"\nuntil nc -z freeswitch 8021; do\n  echo \"FreeSWITCH is unavailable - sleeping\"\n  sleep 2\ndone\necho \"✅ FreeSWITCH is ready\"\n\n# Run database migrations if needed\necho \"📊 Running database migrations...\"\nif [ -f \"dist/migrate.js\" ]; then\n    node dist/migrate.js\nfi\n\n# Start the application\necho \"🎯 Starting backend server...\"\nexec \"$@\"\n","size_bytes":1018},"packages/backend/src/middleware/tenant.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { getClient } from '@w3-voip/database';\nimport { AuthRequest } from './auth';\n\n// Tenant Context Middleware\nexport const setTenantContext = async (req: AuthRequest, res: Response, next: NextFunction) => {\n  try {\n    if (!req.tenantId) {\n      return res.status(400).json({\n        success: false,\n        error: {\n          code: 'TENANT_ID_REQUIRED',\n          message: 'Tenant ID is required'\n        }\n      });\n    }\n\n    // Verify tenant exists and is active\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT id, name, status FROM tenants WHERE id = $1',\n        [req.tenantId]\n      );\n\n      if (result.rows.length === 0) {\n        return res.status(404).json({\n          success: false,\n          error: {\n            code: 'TENANT_NOT_FOUND',\n            message: 'Tenant not found'\n          }\n        });\n      }\n\n      const tenant = result.rows[0];\n      \n      if (tenant.status !== 'active') {\n        return res.status(403).json({\n          success: false,\n          error: {\n            code: 'TENANT_INACTIVE',\n            message: `Tenant is ${tenant.status}`\n          }\n        });\n      }\n\n      // Set tenant context in request\n      req.tenantId = tenant.id;\n      \n      // Add tenant info to response headers for debugging\n      res.set('X-Tenant-ID', tenant.id);\n      res.set('X-Tenant-Name', tenant.name);\n      \n    } finally {\n      await client.release();\n    }\n\n    next();\n  } catch (error) {\n    console.error('Tenant context error:', error);\n    return res.status(500).json({\n      success: false,\n      error: {\n        code: 'TENANT_CONTEXT_ERROR',\n        message: 'Failed to set tenant context'\n      }\n    });\n  }\n};\n\n// Store Context Middleware\nexport const setStoreContext = async (req: AuthRequest, res: Response, next: NextFunction) => {\n  try {\n    const storeId = req.params.storeId || req.body.storeId || req.query.storeId;\n    \n    if (!storeId) {\n      return next(); // Store is optional\n    }\n\n    if (!req.tenantId) {\n      return res.status(400).json({\n        success: false,\n        error: {\n          code: 'TENANT_CONTEXT_REQUIRED',\n          message: 'Tenant context required for store access'\n        }\n      });\n    }\n\n    // Verify store exists and belongs to tenant\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT id, name, status FROM stores WHERE id = $1 AND tenant_id = $2',\n        [storeId, req.tenantId]\n      );\n\n      if (result.rows.length === 0) {\n        return res.status(404).json({\n          success: false,\n          error: {\n            code: 'STORE_NOT_FOUND',\n            message: 'Store not found or access denied'\n          }\n        });\n      }\n\n      const store = result.rows[0];\n      \n      if (store.status !== 'active') {\n        return res.status(403).json({\n          success: false,\n          error: {\n            code: 'STORE_INACTIVE',\n            message: `Store is ${store.status}`\n          }\n        });\n      }\n\n      // Set store context in request\n      req.storeId = store.id;\n      \n      // Add store info to response headers for debugging\n      res.set('X-Store-ID', store.id);\n      res.set('X-Store-Name', store.name);\n      \n    } finally {\n      await client.release();\n    }\n\n    next();\n  } catch (error) {\n    console.error('Store context error:', error);\n    return res.status(500).json({\n      success: false,\n      error: {\n        code: 'STORE_CONTEXT_ERROR',\n        message: 'Failed to set store context'\n      }\n    });\n  }\n};\n\n// Tenant Rate Limiting Middleware\nexport const tenantRateLimit = (maxRequests: number = 100, windowMs: number = 900000) => {\n  const requests = new Map<string, { count: number; resetTime: number }>();\n\n  return (req: AuthRequest, res: Response, next: NextFunction) => {\n    if (!req.tenantId) {\n      return next();\n    }\n\n    const now = Date.now();\n    const key = `tenant:${req.tenantId}`;\n    const tenantRequests = requests.get(key);\n\n    if (!tenantRequests || now > tenantRequests.resetTime) {\n      // Reset or initialize\n      requests.set(key, {\n        count: 1,\n        resetTime: now + windowMs\n      });\n      return next();\n    }\n\n    if (tenantRequests.count >= maxRequests) {\n      return res.status(429).json({\n        success: false,\n        error: {\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: `Rate limit exceeded for tenant. Max ${maxRequests} requests per ${windowMs / 1000} seconds`\n        }\n      });\n    }\n\n    tenantRequests.count++;\n    next();\n  };\n};\n\n// Tenant Resource Validation Middleware - FIXED SQL INJECTION VULNERABILITY\nexport const validateTenantResource = (resourceType: string) => {\n  return async (req: AuthRequest, res: Response, next: NextFunction) => {\n    try {\n      const resourceId = req.params.id || req.params[`${resourceType}Id`];\n      \n      if (!resourceId) {\n        return next();\n      }\n\n      if (!req.tenantId) {\n        return res.status(400).json({\n          success: false,\n          error: {\n            code: 'TENANT_CONTEXT_REQUIRED',\n            message: 'Tenant context required for resource validation'\n          }\n        });\n      }\n\n      // Validate resource belongs to tenant\n      const client = await getClient();\n      \n      try {\n        // Whitelist of allowed table names to prevent SQL injection\n        const tableNameMap: Record<string, string> = {\n          'extension': 'extensions',\n          'trunk': 'sip_trunks',\n          'store': 'stores',\n          'queue': 'call_queues',\n          'ivr': 'ivr_menus',\n          'conference': 'conference_rooms',\n          'voicemail': 'voicemail_boxes',\n          'ring_group': 'ring_groups',\n          'time_condition': 'time_conditions'\n        };\n        \n        const tableName = tableNameMap[resourceType];\n        \n        if (!tableName) {\n          return res.status(400).json({\n            success: false,\n            error: {\n              code: 'INVALID_RESOURCE_TYPE',\n              message: `Invalid resource type: ${resourceType}`\n            }\n          });\n        }\n        \n        const result = await client.query(\n          `SELECT id FROM ${tableName} WHERE id = $1 AND tenant_id = $2`,\n          [resourceId, req.tenantId]\n        );\n\n        if (result.rows.length === 0) {\n          return res.status(404).json({\n            success: false,\n            error: {\n              code: 'RESOURCE_NOT_FOUND',\n              message: `${resourceType} not found or access denied`\n            }\n          });\n        }\n        \n      } finally {\n        await client.release();\n      }\n\n      next();\n    } catch (error) {\n      console.error('Resource validation error:', error);\n      return res.status(500).json({\n        success: false,\n        error: {\n          code: 'RESOURCE_VALIDATION_ERROR',\n          message: 'Failed to validate resource access'\n        }\n      });\n    }\n  };\n};\n","size_bytes":6993},"packages/backend/src/services/extension.service.ts":{"content":"// @ts-nocheck\nimport { getClient, withTransaction } from '@w3-voip/database';\n// import { Extension, ExtensionSchema } from '@w3-voip/shared';\nimport { v4 as uuidv4 } from 'uuid';\nimport bcrypt from 'bcryptjs';\n\n// Define Extension type locally\nexport interface Extension {\n  id: string;\n  tenant_id: string;\n  store_id?: string;\n  extension: string;\n  password: string;\n  display_name: string;\n  status: 'active' | 'inactive';\n  type: 'user' | 'queue' | 'conference';\n  settings: {\n    voicemail_enabled: boolean;\n    call_forwarding: {\n      enabled: boolean;\n      destination?: string;\n    };\n    recording: {\n      enabled: boolean;\n      mode: 'always' | 'on_demand';\n    };\n  };\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class ExtensionService {\n  // Create a new extension\n  async createExtension(extensionData: Omit<Extension, 'id' | 'created_at' | 'updated_at'>): Promise<Extension> {\n    return withTransaction(async (client) => {\n      // Verify tenant exists\n      const tenantResult = await client.query(\n        'SELECT id FROM tenants WHERE id = $1 AND status = $2',\n        [extensionData.tenant_id, 'active']\n      );\n\n      if (tenantResult.rows.length === 0) {\n        throw new Error('Tenant not found or inactive');\n      }\n\n      // Verify store exists if provided\n      if (extensionData.store_id) {\n        const storeResult = await client.query(\n          'SELECT id FROM stores WHERE id = $1 AND tenant_id = $2 AND status = $3',\n          [extensionData.store_id, extensionData.tenant_id, 'active']\n        );\n\n        if (storeResult.rows.length === 0) {\n          throw new Error('Store not found or inactive');\n        }\n      }\n\n      // Check if extension already exists for this tenant\n      const existingExtension = await client.query(\n        'SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2',\n        [extensionData.tenant_id, extensionData.extension]\n      );\n\n      if (existingExtension.rows.length > 0) {\n        throw new Error('Extension already exists for this tenant');\n      }\n\n      // Hash password\n      const hashedPassword = await bcrypt.hash(extensionData.password, 12);\n\n      // Create extension\n      const result = await client.query(\n        `INSERT INTO extensions (id, tenant_id, store_id, extension, password, display_name, status, type, settings)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n         RETURNING *`,\n        [\n          uuidv4(),\n          extensionData.tenant_id,\n          extensionData.store_id || null,\n          extensionData.extension,\n          hashedPassword,\n          extensionData.display_name,\n          extensionData.status || 'active',\n          extensionData.type || 'user',\n          JSON.stringify(extensionData.settings)\n        ]\n      );\n\n      const extension = result.rows[0];\n      return {\n        ...extension,\n        password: extensionData.password, // Return original password for response\n        settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n      };\n    });\n  }\n\n  // Get extension by ID\n  async getExtensionById(extensionId: string, tenantId?: string): Promise<Extension | null> {\n    const client = await getClient();\n    \n    try {\n      let query = 'SELECT * FROM extensions WHERE id = $1';\n      let params: any[] = [extensionId];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const extension = result.rows[0];\n      return {\n        ...extension,\n        settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get extension by extension number and tenant\n  async getExtensionByNumber(extension: string, tenantId: string): Promise<Extension | null> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT * FROM extensions WHERE extension = $1 AND tenant_id = $2',\n        [extension, tenantId]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const ext = result.rows[0];\n      return {\n        ...ext,\n        settings: typeof ext.settings === 'string' ? JSON.parse(ext.settings) : ext.settings\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Update extension\n  async updateExtension(extensionId: string, updates: Partial<Omit<Extension, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>, tenantId?: string): Promise<Extension> {\n    return withTransaction(async (client) => {\n      // Check if extension conflicts with other extensions in the same tenant\n      if (updates.extension) {\n        const existingExtension = await client.query(\n          'SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2 AND id != $3',\n          [tenantId, updates.extension, extensionId]\n        );\n\n        if (existingExtension.rows.length > 0) {\n          throw new Error('Extension already exists for this tenant');\n        }\n      }\n\n      // Build update query\n      const updateFields: string[] = [];\n      const values: any[] = [];\n      let paramCount = 1;\n\n      if (updates.extension !== undefined) {\n        updateFields.push(`extension = $${paramCount++}`);\n        values.push(updates.extension);\n      }\n      if (updates.password !== undefined) {\n        const hashedPassword = await bcrypt.hash(updates.password, 12);\n        updateFields.push(`password = $${paramCount++}`);\n        values.push(hashedPassword);\n      }\n      if (updates.display_name !== undefined) {\n        updateFields.push(`display_name = $${paramCount++}`);\n        values.push(updates.display_name);\n      }\n      if (updates.status !== undefined) {\n        updateFields.push(`status = $${paramCount++}`);\n        values.push(updates.status);\n      }\n      if (updates.type !== undefined) {\n        updateFields.push(`type = $${paramCount++}`);\n        values.push(updates.type);\n      }\n      if (updates.store_id !== undefined) {\n        updateFields.push(`store_id = $${paramCount++}`);\n        values.push(updates.store_id || null);\n      }\n      if (updates.settings !== undefined) {\n        updateFields.push(`settings = $${paramCount++}`);\n        values.push(JSON.stringify(updates.settings));\n      }\n\n      if (updateFields.length === 0) {\n        throw new Error('No fields to update');\n      }\n\n      values.push(extensionId);\n      \n      let query = `UPDATE extensions SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $${paramCount}`;\n      \n      if (tenantId) {\n        query += ` AND tenant_id = $${paramCount + 1}`;\n        values.push(tenantId);\n      }\n      \n      query += ' RETURNING *';\n\n      const result = await client.query(query, values);\n\n      if (result.rows.length === 0) {\n        throw new Error('Extension not found');\n      }\n\n      const extension = result.rows[0];\n      return {\n        ...extension,\n        password: updates.password || '[HIDDEN]', // Return updated password or hidden\n        settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n      };\n    });\n  }\n\n  // Delete extension\n  async deleteExtension(extensionId: string, tenantId?: string): Promise<void> {\n    return withTransaction(async (client) => {\n      let query = 'DELETE FROM extensions WHERE id = $1';\n      let params: any[] = [extensionId];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rowCount === 0) {\n        throw new Error('Extension not found');\n      }\n    });\n  }\n\n  // List extensions for a tenant\n  async listExtensions(tenantId: string, storeId?: string, page: number = 1, limit: number = 50, search?: string): Promise<{\n    extensions: Extension[];\n    total: number;\n    totalPages: number;\n  }> {\n    const client = await getClient();\n    \n    try {\n      const offset = (page - 1) * limit;\n      \n      let whereClause = 'WHERE tenant_id = $1';\n      let queryParams: any[] = [tenantId];\n      \n      if (storeId) {\n        whereClause += ' AND store_id = $2';\n        queryParams.push(storeId);\n      }\n      \n      if (search) {\n        const searchParam = storeId ? 3 : 2;\n        whereClause += ` AND (extension ILIKE $${searchParam} OR display_name ILIKE $${searchParam})`;\n        queryParams.push(`%${search}%`);\n      }\n\n      // Get total count\n      const countResult = await client.query(\n        `SELECT COUNT(*) FROM extensions ${whereClause}`,\n        queryParams\n      );\n      const total = parseInt(countResult.rows[0].count);\n\n      // Get extensions\n      const result = await client.query(\n        `SELECT * FROM extensions ${whereClause}\n         ORDER BY extension ASC\n         LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`,\n        [...queryParams, limit, offset]\n      );\n\n      const extensions = result.rows.map(row => ({\n        ...row,\n        password: '[HIDDEN]', // Hide passwords in list\n        settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings\n      }));\n\n      return {\n        extensions,\n        total,\n        totalPages: Math.ceil(total / limit)\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Verify extension password\n  async verifyExtensionPassword(extension: string, password: string, tenantId: string): Promise<Extension | null> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT * FROM extensions WHERE extension = $1 AND tenant_id = $2 AND status = $3',\n        [extension, tenantId, 'active']\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const ext = result.rows[0];\n      const isValidPassword = await bcrypt.compare(password, ext.password);\n\n      if (!isValidPassword) {\n        return null;\n      }\n\n      return {\n        ...ext,\n        password: '[HIDDEN]',\n        settings: typeof ext.settings === 'string' ? JSON.parse(ext.settings) : ext.settings\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Activate extension\n  async activateExtension(extensionId: string, tenantId?: string): Promise<Extension> {\n    return this.updateExtension(extensionId, { status: 'active' }, tenantId);\n  }\n\n  // Deactivate extension\n  async deactivateExtension(extensionId: string, tenantId?: string): Promise<Extension> {\n    return this.updateExtension(extensionId, { status: 'inactive' }, tenantId);\n  }\n\n  // Lock extension\n  async lockExtension(extensionId: string, tenantId?: string): Promise<Extension> {\n    return this.updateExtension(extensionId, { status: 'inactive' }, tenantId);\n  }\n\n  // Validate extension number uniqueness within tenant\n  async validateExtensionUniqueness(extension: string, tenantId: string, excludeExtensionId?: string): Promise<boolean> {\n    const client = await getClient();\n    \n    try {\n      let query = 'SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2';\n      let params: any[] = [tenantId, extension];\n      \n      if (excludeExtensionId) {\n        query += ' AND id != $3';\n        params.push(excludeExtensionId);\n      }\n\n      const result = await client.query(query, params);\n      return result.rows.length === 0;\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get extension statistics\n  async getExtensionStats(extensionId: string, tenantId?: string): Promise<{\n    total_calls: number;\n    answered_calls: number;\n    missed_calls: number;\n    total_duration: number;\n    last_call_time: Date | null;\n  }> {\n    const client = await getClient();\n    \n    try {\n      let whereClause = 'WHERE e.id = $1';\n      let params: any[] = [extensionId];\n      \n      if (tenantId) {\n        whereClause += ' AND e.tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(\n        `SELECT \n           COUNT(DISTINCT c.id) as total_calls,\n           COUNT(DISTINCT CASE WHEN c.hangup_disposition = 'answered' THEN c.id END) as answered_calls,\n           COUNT(DISTINCT CASE WHEN c.hangup_disposition IN ('no_answer', 'busy') THEN c.id END) as missed_calls,\n           COALESCE(SUM(c.duration), 0) as total_duration,\n           MAX(c.start_time) as last_call_time\n         FROM extensions e\n         LEFT JOIN cdr c ON e.id = c.extension_id\n         ${whereClause}\n         GROUP BY e.id`,\n        params\n      );\n\n      if (result.rows.length === 0) {\n        throw new Error('Extension not found');\n      }\n\n      return result.rows[0];\n    } finally {\n      await client.release();\n    }\n  }\n}\n\n","size_bytes":12807},"packages/shared/src/types/user.ts":{"content":"import { z } from 'zod';\r\n\r\n// User roles hierarchy\r\nexport const UserRoleSchema = z.enum([\r\n  'super_admin',    // System administrator - can manage all tenants\r\n  'tenant_admin',   // Tenant administrator - can manage everything within their tenant\r\n  'tenant_user'     // Regular user - limited access within tenant\r\n]);\r\n\r\nexport type UserRole = z.infer<typeof UserRoleSchema>;\r\n\r\n// User permissions based on role\r\nexport const UserPermissionsSchema = z.object({\r\n  // Super Admin permissions\r\n  can_create_tenants: z.boolean().default(false),\r\n  can_delete_tenants: z.boolean().default(false),\r\n  can_manage_system_settings: z.boolean().default(false),\r\n  can_view_all_tenants: z.boolean().default(false),\r\n  \r\n  // Tenant Admin permissions\r\n  can_manage_tenant_settings: z.boolean().default(false),\r\n  can_create_stores: z.boolean().default(false),\r\n  can_manage_stores: z.boolean().default(false),\r\n  can_create_trunks: z.boolean().default(false),\r\n  can_manage_trunks: z.boolean().default(false),\r\n  can_create_extensions: z.boolean().default(false),\r\n  can_manage_extensions: z.boolean().default(false),\r\n  can_view_cdr: z.boolean().default(false),\r\n  can_manage_users: z.boolean().default(false),\r\n  \r\n  // Tenant User permissions\r\n  can_view_own_extensions: z.boolean().default(false),\r\n  can_make_calls: z.boolean().default(false),\r\n  can_view_own_cdr: z.boolean().default(false),\r\n  can_manage_own_settings: z.boolean().default(false)\r\n});\r\n\r\nexport type UserPermissions = z.infer<typeof UserPermissionsSchema>;\r\n\r\n// User schema\r\nexport const UserSchema = z.object({\r\n  id: z.string().uuid(),\r\n  email: z.string().email(),\r\n  name: z.string().min(1).max(100),\r\n  role: UserRoleSchema,\r\n  tenant_id: z.string().uuid().optional(), // null for super_admin\r\n  status: z.enum(['active', 'inactive', 'suspended']),\r\n  created_at: z.date(),\r\n  updated_at: z.date(),\r\n  last_login: z.date().optional(),\r\n  permissions: UserPermissionsSchema\r\n});\r\n\r\nexport type User = z.infer<typeof UserSchema>;\r\n\r\n// Helper function to get permissions based on role\r\nexport function getPermissionsForRole(role: UserRole): UserPermissions {\r\n  switch (role) {\r\n    case 'super_admin':\r\n      return {\r\n        can_create_tenants: true,\r\n        can_delete_tenants: true,\r\n        can_manage_system_settings: true,\r\n        can_view_all_tenants: true,\r\n        can_manage_tenant_settings: false,\r\n        can_create_stores: false,\r\n        can_manage_stores: false,\r\n        can_create_trunks: false,\r\n        can_manage_trunks: false,\r\n        can_create_extensions: false,\r\n        can_manage_extensions: false,\r\n        can_view_cdr: false,\r\n        can_manage_users: false,\r\n        can_view_own_extensions: false,\r\n        can_make_calls: false,\r\n        can_view_own_cdr: false,\r\n        can_manage_own_settings: false\r\n      };\r\n    \r\n    case 'tenant_admin':\r\n      return {\r\n        can_create_tenants: false,\r\n        can_delete_tenants: false,\r\n        can_manage_system_settings: false,\r\n        can_view_all_tenants: false,\r\n        can_manage_tenant_settings: true,\r\n        can_create_stores: true,\r\n        can_manage_stores: true,\r\n        can_create_trunks: true,\r\n        can_manage_trunks: true,\r\n        can_create_extensions: true,\r\n        can_manage_extensions: true,\r\n        can_view_cdr: true,\r\n        can_manage_users: true,\r\n        can_view_own_extensions: true,\r\n        can_make_calls: true,\r\n        can_view_own_cdr: true,\r\n        can_manage_own_settings: true\r\n      };\r\n    \r\n    case 'tenant_user':\r\n      return {\r\n        can_create_tenants: false,\r\n        can_delete_tenants: false,\r\n        can_manage_system_settings: false,\r\n        can_view_all_tenants: false,\r\n        can_manage_tenant_settings: false,\r\n        can_create_stores: false,\r\n        can_manage_stores: false,\r\n        can_create_trunks: false,\r\n        can_manage_trunks: false,\r\n        can_create_extensions: false,\r\n        can_manage_extensions: false,\r\n        can_view_cdr: false,\r\n        can_manage_users: false,\r\n        can_view_own_extensions: true,\r\n        can_make_calls: true,\r\n        can_view_own_cdr: true,\r\n        can_manage_own_settings: true\r\n      };\r\n    \r\n    default:\r\n      return {\r\n        can_create_tenants: false,\r\n        can_delete_tenants: false,\r\n        can_manage_system_settings: false,\r\n        can_view_all_tenants: false,\r\n        can_manage_tenant_settings: false,\r\n        can_create_stores: false,\r\n        can_manage_stores: false,\r\n        can_create_trunks: false,\r\n        can_manage_trunks: false,\r\n        can_create_extensions: false,\r\n        can_manage_extensions: false,\r\n        can_view_cdr: false,\r\n        can_manage_users: false,\r\n        can_view_own_extensions: false,\r\n        can_make_calls: false,\r\n        can_view_own_cdr: false,\r\n        can_manage_own_settings: false\r\n      };\r\n  }\r\n}\r\n\r\n","size_bytes":4861},"packages/frontend/postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}","size_bytes":79},"packages/frontend/src/pages/SuperAdminDashboard.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Building2, \n  Users, \n  Phone, \n  Activity, \n  Plus, \n  Eye, \n  BarChart3,\n  Settings,\n  LogOut,\n  TrendingUp,\n  AlertCircle\n} from 'lucide-react';\nimport apiClient from '@/lib/api';\n\ninterface CrossTenantStats {\n  total_tenants: number;\n  total_users: number;\n  total_extensions: number;\n  total_calls_24h: number;\n  active_tenants: number;\n  inactive_tenants: number;\n}\n\ninterface TenantStats {\n  tenant_id: string;\n  tenant_name: string;\n  tenant_slug: string;\n  users_count: number;\n  extensions_count: number;\n  calls_24h: number;\n  companies_count: number;\n  contacts_count: number;\n  status: string;\n}\n\nexport default function SuperAdminDashboard() {\n  const [stats, setStats] = useState<CrossTenantStats | null>(null);\n  const [tenantStats, setTenantStats] = useState<TenantStats[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    loadDashboardData();\n  }, []);\n\n  const loadDashboardData = async () => {\n    try {\n      setLoading(true);\n      const [statsResponse, tenantStatsResponse] = await Promise.all([\n        apiClient.getCrossTenantStats(),\n        apiClient.getTenantStatsList()\n      ]);\n\n      if (statsResponse.success) {\n        setStats(statsResponse.data);\n      }\n\n      if (tenantStatsResponse.success) {\n        setTenantStats(tenantStatsResponse.data);\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to load dashboard data');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogout = () => {\n    localStorage.removeItem('token');\n    apiClient.clearToken();\n    navigate('/edgvoip/login');\n  };\n\n  const getStatusBadge = (status: string) => {\n    switch (status) {\n      case 'active':\n        return <Badge variant=\"default\" className=\"bg-green-100 text-green-800\">Active</Badge>;\n      case 'suspended':\n        return <Badge variant=\"destructive\">Suspended</Badge>;\n      case 'pending':\n        return <Badge variant=\"secondary\">Pending</Badge>;\n      default:\n        return <Badge variant=\"outline\">{status}</Badge>;\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"></div>\n          <p className=\"text-gray-600\">Loading dashboard...</p>\n        </div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <Card className=\"w-full max-w-md\">\n          <CardContent className=\"pt-6\">\n            <div className=\"text-center\">\n              <AlertCircle className=\"h-12 w-12 text-red-500 mx-auto mb-4\" />\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">Error</h3>\n              <p className=\"text-gray-600 mb-4\">{error}</p>\n              <Button onClick={loadDashboardData} variant=\"outline\">\n                Retry\n              </Button>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"mb-8\">\n          <h1 className=\"text-2xl font-bold text-gray-900\">Cross-tenant Management Dashboard</h1>\n          <p className=\"text-gray-600\">Overview of all tenants and system statistics</p>\n        </div>\n        {/* Stats Cards */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8\">\n          <Card>\n            <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n              <CardTitle className=\"text-sm font-medium\">Total Tenants</CardTitle>\n              <Building2 className=\"h-4 w-4 text-muted-foreground\" />\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-2xl font-bold\">{stats?.total_tenants || 0}</div>\n              <p className=\"text-xs text-muted-foreground\">\n                {stats?.active_tenants || 0} active, {stats?.inactive_tenants || 0} inactive\n              </p>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n              <CardTitle className=\"text-sm font-medium\">Total Users</CardTitle>\n              <Users className=\"h-4 w-4 text-muted-foreground\" />\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-2xl font-bold\">{stats?.total_users || 0}</div>\n              <p className=\"text-xs text-muted-foreground\">\n                Across all tenants\n              </p>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n              <CardTitle className=\"text-sm font-medium\">Total Extensions</CardTitle>\n              <Phone className=\"h-4 w-4 text-muted-foreground\" />\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-2xl font-bold\">{stats?.total_extensions || 0}</div>\n              <p className=\"text-xs text-muted-foreground\">\n                VoIP extensions configured\n              </p>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n              <CardTitle className=\"text-sm font-medium\">Calls (24h)</CardTitle>\n              <Activity className=\"h-4 w-4 text-muted-foreground\" />\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-2xl font-bold\">{stats?.total_calls_24h || 0}</div>\n              <p className=\"text-xs text-muted-foreground\">\n                <TrendingUp className=\"h-3 w-3 inline mr-1\" />\n                Last 24 hours\n              </p>\n            </CardContent>\n          </Card>\n        </div>\n\n        {/* Quick Actions */}\n        <div className=\"mb-8\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Quick Actions</CardTitle>\n              <CardDescription>Common administrative tasks</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                <Button \n                  className=\"h-20 flex flex-col items-center justify-center\"\n                  onClick={() => navigate('/edgvoip/tenants?action=create')}\n                >\n                  <Plus className=\"h-6 w-6 mb-2\" />\n                  <span>Create New Tenant</span>\n                </Button>\n                <Button \n                  variant=\"outline\"\n                  className=\"h-20 flex flex-col items-center justify-center\"\n                  onClick={() => navigate('/edgvoip/tenants')}\n                >\n                  <Eye className=\"h-6 w-6 mb-2\" />\n                  <span>View All Tenants</span>\n                </Button>\n                <Button \n                  variant=\"outline\"\n                  className=\"h-20 flex flex-col items-center justify-center\"\n                  onClick={() => navigate('/edgvoip/analytics')}\n                >\n                  <BarChart3 className=\"h-6 w-6 mb-2\" />\n                  <span>View Analytics</span>\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n\n        {/* Tenant Overview */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Tenant Overview</CardTitle>\n            <CardDescription>Summary of all tenants in the system</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4\">Tenant</th>\n                    <th className=\"text-left py-3 px-4\">Status</th>\n                    <th className=\"text-left py-3 px-4\">Users</th>\n                    <th className=\"text-left py-3 px-4\">Extensions</th>\n                    <th className=\"text-left py-3 px-4\">Companies</th>\n                    <th className=\"text-left py-3 px-4\">Calls (24h)</th>\n                    <th className=\"text-left py-3 px-4\">Actions</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {tenantStats.map((tenant) => (\n                    <tr key={tenant.tenant_id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{tenant.tenant_name}</div>\n                          <div className=\"text-sm text-gray-500\">{tenant.tenant_slug}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        {getStatusBadge(tenant.status)}\n                      </td>\n                      <td className=\"py-3 px-4\">{tenant.users_count}</td>\n                      <td className=\"py-3 px-4\">{tenant.extensions_count}</td>\n                      <td className=\"py-3 px-4\">{tenant.companies_count}</td>\n                      <td className=\"py-3 px-4\">{tenant.calls_24h}</td>\n                      <td className=\"py-3 px-4\">\n                        <div className=\"flex space-x-2\">\n                          <Button \n                            size=\"sm\" \n                            variant=\"outline\"\n                            onClick={() => navigate(`/edgvoip/tenants/${tenant.tenant_id}`)}\n                          >\n                            <Eye className=\"h-3 w-3 mr-1\" />\n                            View\n                          </Button>\n                          <Button \n                            size=\"sm\" \n                            variant=\"outline\"\n                            onClick={() => navigate(`/edgvoip/tenants/${tenant.tenant_id}/users`)}\n                          >\n                            <Users className=\"h-3 w-3 mr-1\" />\n                            Users\n                          </Button>\n                        </div>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n}","size_bytes":10649},"packages/frontend/public/chrome-extension-blocker.js":{"content":"// Advanced Chrome Extension Blocker\n(function() {\n  'use strict';\n  \n  console.log('🛡️ Advanced extension blocker loading...');\n  \n  // List of problematic extension IDs and patterns\n  const blockedExtensions = [\n    'pejdijmoenmkgeppbflobdenhhabjlaj',\n    'chrome-extension://',\n    'completion_list.html',\n    'utils.js',\n    'extensionState.js',\n    'heuristicsRedefinitions.js'\n  ];\n  \n  // Function to check if a message/URL should be blocked\n  function shouldBlock(text) {\n    if (!text) return false;\n    const str = text.toString().toLowerCase();\n    return blockedExtensions.some(pattern => str.includes(pattern.toLowerCase()));\n  }\n  \n  // Override console methods more aggressively\n  const originalConsole = {\n    error: console.error,\n    warn: console.warn,\n    log: console.log,\n    info: console.info,\n    debug: console.debug,\n    trace: console.trace\n  };\n  \n  Object.keys(originalConsole).forEach(method => {\n    console[method] = function(...args) {\n      const message = args.join(' ');\n      if (!shouldBlock(message)) {\n        originalConsole[method].apply(console, args);\n      }\n    };\n  });\n  \n  // Block all network requests to extensions\n  if (window.fetch) {\n    const originalFetch = window.fetch;\n    window.fetch = function(...args) {\n      const url = args[0]?.toString() || '';\n      if (shouldBlock(url)) {\n        console.log('🚫 Blocked fetch request to extension:', url);\n        return Promise.reject(new Error('Extension request blocked'));\n      }\n      return originalFetch.apply(this, args);\n    };\n  }\n  \n  // Block XMLHttpRequest to extensions\n  if (window.XMLHttpRequest) {\n    const originalXHROpen = XMLHttpRequest.prototype.open;\n    XMLHttpRequest.prototype.open = function(method, url, ...args) {\n      if (shouldBlock(url)) {\n        console.log('🚫 Blocked XHR request to extension:', url);\n        throw new Error('Extension request blocked');\n      }\n      return originalXHROpen.call(this, method, url, ...args);\n    };\n  }\n  \n  // Block all error events from extensions\n  window.addEventListener('error', function(event) {\n    const message = event.message || '';\n    const filename = event.filename || '';\n    const source = event.source || '';\n    \n    if (shouldBlock(message) || shouldBlock(filename) || shouldBlock(source)) {\n      event.preventDefault();\n      event.stopPropagation();\n      return false;\n    }\n  }, true);\n  \n  // Block unhandled promise rejections from extensions\n  window.addEventListener('unhandledrejection', function(event) {\n    const reason = event.reason?.toString() || '';\n    if (shouldBlock(reason)) {\n      event.preventDefault();\n      return false;\n    }\n  });\n  \n  // Block resource loading errors\n  window.addEventListener('error', function(event) {\n    const target = event.target;\n    if (target && (target.src || target.href)) {\n      const url = (target.src || target.href).toString();\n      if (shouldBlock(url)) {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n      }\n    }\n  }, true);\n  \n  // Block CSP violations from extensions\n  document.addEventListener('securitypolicyviolation', function(event) {\n    if (shouldBlock(event.violatedDirective) || shouldBlock(event.blockedURI)) {\n      event.preventDefault();\n      return false;\n    }\n  });\n  \n  console.log('🛡️ Advanced extension blocker loaded successfully');\n  \n})();","size_bytes":3385},"packages/frontend/src/pages/IvrMenus.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Plus, \n  Search, \n  Edit, \n  Trash2, \n  Phone, \n  Clock,\n  Settings,\n  Eye,\n  MoreHorizontal,\n  RefreshCw,\n  Hash,\n  PhoneCall,\n  Users,\n  MessageSquare,\n  Mic,\n  ArrowRight\n} from 'lucide-react';\nimport { useAuth } from '@/contexts/AuthContext';\n\ninterface IvrMenu {\n  id: string;\n  name: string;\n  description?: string;\n  extension: string;\n  greeting_sound?: string;\n  invalid_sound?: string;\n  exit_sound?: string;\n  timeout: number;\n  max_failures: number;\n  timeout_action: {\n    type: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'repeat';\n    destination: string;\n  };\n  invalid_action: {\n    type: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'repeat';\n    destination: string;\n  };\n  options: { [key: string]: {\n    action: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'submenu' | 'conference';\n    destination: string;\n    description?: string;\n  }};\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport default function IvrMenus() {\n  const { user } = useAuth();\n  const [ivrMenus, setIvrMenus] = useState<IvrMenu[]>([]);\n  const [showModal, setShowModal] = useState(false);\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\n  const [loading, setLoading] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [formData, setFormData] = useState<Partial<IvrMenu>>({});\n  const [editingItem, setEditingItem] = useState<IvrMenu | null>(null);\n\n  // Load IVR menus on component mount\n  useEffect(() => {\n    loadIvrMenus();\n  }, []);\n\n  const loadIvrMenus = async () => {\n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ivr-menus`);\n      const data = await response.json();\n      \n      if (data?.success && Array.isArray(data?.data)) {\n        setIvrMenus(data.data);\n      } else {\n        console.warn('⚠️ Invalid API response format');\n        setIvrMenus([]);\n      }\n    } catch (error) {\n      console.error('❌ Error loading IVR menus:', error);\n      setIvrMenus([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCreate = async () => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ivr-menus`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          ...formData,\n          tenant_id: user.tenant_id\n        })\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadIvrMenus();\n        setShowModal(false);\n        setFormData({});\n      } else {\n        console.error('❌ Error creating IVR menu:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error creating IVR menu:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleEdit = async () => {\n    if (!editingItem) return;\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ivr-menus/${editingItem.id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(formData)\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadIvrMenus();\n        setShowModal(false);\n        setFormData({});\n        setEditingItem(null);\n      } else {\n        console.error('❌ Error updating IVR menu:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error updating IVR menu:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDelete = async (ivrMenu: IvrMenu) => {\n    if (!confirm(`Are you sure you want to delete IVR menu \"${ivrMenu.name}\"?`)) {\n      return;\n    }\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ivr-menus/${ivrMenu.id}`, {\n        method: 'DELETE'\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadIvrMenus();\n      } else {\n        console.error('❌ Error deleting IVR menu:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error deleting IVR menu:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const filteredIvrMenus = ivrMenus.filter(menu =>\n    menu.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    menu.extension.includes(searchTerm) ||\n    menu.description?.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  const getActionIcon = (action: string) => {\n    switch (action) {\n      case 'extension': return <Phone className=\"h-4 w-4\" />;\n      case 'queue': return <Users className=\"h-4 w-4\" />;\n      case 'conference': return <MessageSquare className=\"h-4 w-4\" />;\n      case 'voicemail': return <Mic className=\"h-4 w-4\" />;\n      case 'submenu': return <ArrowRight className=\"h-4 w-4\" />;\n      case 'hangup': return <PhoneCall className=\"h-4 w-4\" />;\n      default: return <Settings className=\"h-4 w-4\" />;\n    }\n  };\n\n  const getActionLabel = (action: string) => {\n    switch (action) {\n      case 'extension': return 'Extension';\n      case 'queue': return 'Queue';\n      case 'conference': return 'Conference';\n      case 'voicemail': return 'Voicemail';\n      case 'submenu': return 'Submenu';\n      case 'hangup': return 'Hangup';\n      default: return action;\n    }\n  };\n\n  const getActionColor = (action: string) => {\n    switch (action) {\n      case 'extension': return 'bg-blue-100 text-blue-800';\n      case 'queue': return 'bg-green-100 text-green-800';\n      case 'conference': return 'bg-purple-100 text-purple-800';\n      case 'voicemail': return 'bg-orange-100 text-orange-800';\n      case 'submenu': return 'bg-pink-100 text-pink-800';\n      case 'hangup': return 'bg-red-100 text-red-800';\n      default: return 'bg-gray-100 text-gray-800';\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold\">IVR Menus</h1>\n          <p className=\"text-gray-600\">Create and manage Interactive Voice Response menus</p>\n        </div>\n        <Button onClick={() => {\n          setModalType('create');\n          setFormData({\n            timeout: 10,\n            max_failures: 3,\n            timeout_action: { type: 'hangup', destination: '' },\n            invalid_action: { type: 'hangup', destination: '' },\n            options: {}\n          });\n          setShowModal(true);\n        }}>\n          <Plus className=\"h-4 w-4 mr-2\" />\n          Add IVR Menu\n        </Button>\n      </div>\n\n      {/* Search and Stats */}\n      <div className=\"flex items-center space-x-4\">\n        <div className=\"relative flex-1 max-w-md\">\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\n          <Input\n            placeholder=\"Search IVR menus...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n            className=\"pl-10\"\n          />\n        </div>\n        <Button variant=\"outline\" onClick={loadIvrMenus} disabled={loading}>\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\n          Refresh\n        </Button>\n      </div>\n\n      {/* IVR Menus Grid */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        {filteredIvrMenus.map((menu) => (\n          <Card key={menu.id} className=\"relative\">\n            <CardHeader className=\"pb-3\">\n              <div className=\"flex items-start justify-between\">\n                <div className=\"flex-1\">\n                  <CardTitle className=\"text-lg\">{menu.name}</CardTitle>\n                  <CardDescription>{menu.description}</CardDescription>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Badge variant={menu.enabled ? 'default' : 'secondary'}>\n                    {menu.enabled ? 'Active' : 'Inactive'}\n                  </Badge>\n                  <Button variant=\"ghost\" size=\"sm\">\n                    <MoreHorizontal className=\"h-4 w-4\" />\n                  </Button>\n                </div>\n              </div>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {/* Extension */}\n              <div className=\"flex items-center space-x-2\">\n                <Phone className=\"h-4 w-4 text-gray-500\" />\n                <span className=\"font-medium\">{menu.extension}</span>\n              </div>\n\n              {/* Timeout Settings */}\n              <div className=\"grid grid-cols-2 gap-2 text-sm\">\n                <div className=\"flex items-center space-x-2\">\n                  <Clock className=\"h-4 w-4 text-gray-500\" />\n                  <span>{menu.timeout}s timeout</span>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Hash className=\"h-4 w-4 text-gray-500\" />\n                  <span>{menu.max_failures} max tries</span>\n                </div>\n              </div>\n\n              {/* Options */}\n              <div className=\"space-y-2\">\n                <div className=\"flex items-center space-x-2\">\n                  <Settings className=\"h-4 w-4 text-gray-500\" />\n                  <span className=\"text-sm text-gray-600\">\n                    {Object.keys(menu.options).length} option{Object.keys(menu.options).length !== 1 ? 's' : ''}\n                  </span>\n                </div>\n                \n                {/* DTMF Options Preview */}\n                <div className=\"space-y-1\">\n                  {Object.entries(menu.options).slice(0, 3).map(([dtmf, option]) => (\n                    <div key={dtmf} className=\"flex items-center justify-between text-xs\">\n                      <div className=\"flex items-center space-x-2\">\n                        <span className=\"font-mono bg-gray-100 px-1 rounded\">{dtmf}</span>\n                        <span className=\"text-gray-600\">{option.description || option.destination}</span>\n                      </div>\n                      <Badge className={`${getActionColor(option.action)} text-xs flex items-center space-x-1`}>\n                        {getActionIcon(option.action)}\n                        <span>{getActionLabel(option.action)}</span>\n                      </Badge>\n                    </div>\n                  ))}\n                  {Object.keys(menu.options).length > 3 && (\n                    <div className=\"text-xs text-gray-500\">\n                      +{Object.keys(menu.options).length - 3} more options\n                    </div>\n                  )}\n                </div>\n              </div>\n\n              {/* Actions */}\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setModalType('edit');\n                    setFormData(menu);\n                    setEditingItem(menu);\n                    setShowModal(true);\n                  }}\n                >\n                  <Edit className=\"h-4 w-4 mr-1\" />\n                  Edit\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setModalType('view');\n                    setFormData(menu);\n                    setEditingItem(menu);\n                    setShowModal(true);\n                  }}\n                >\n                  <Eye className=\"h-4 w-4 mr-1\" />\n                  View\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => handleDelete(menu)}\n                  className=\"text-red-600 hover:text-red-700\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {/* Empty State */}\n      {filteredIvrMenus.length === 0 && !loading && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <Phone className=\"h-12 w-12 text-gray-400 mb-4\" />\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No IVR Menus Found</h3>\n            <p className=\"text-gray-500 text-center mb-4\">\n              {searchTerm ? 'No IVR menus match your search criteria.' : 'Create your first IVR menu to get started.'}\n            </p>\n            {!searchTerm && (\n              <Button onClick={() => {\n                setModalType('create');\n                setFormData({\n                  timeout: 10,\n                  max_failures: 3,\n                  timeout_action: { type: 'hangup', destination: '' },\n                  invalid_action: { type: 'hangup', destination: '' },\n                  options: {}\n                });\n                setShowModal(true);\n              }}>\n                <Plus className=\"h-4 w-4 mr-2\" />\n                Create IVR Menu\n              </Button>\n            )}\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Create/Edit Modal */}\n      {showModal && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n          <Card className=\"w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\n            <CardHeader>\n              <CardTitle>\n                {modalType === 'create' ? 'Create IVR Menu' : \n                 modalType === 'edit' ? 'Edit IVR Menu' : 'View IVR Menu'}\n              </CardTitle>\n              <CardDescription>\n                {modalType === 'create' ? 'Create a new Interactive Voice Response menu' :\n                 modalType === 'edit' ? 'Update IVR menu settings' :\n                 'View IVR menu details and options'}\n              </CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-6\">\n              {/* Basic Information */}\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Name</label>\n                  <Input\n                    value={formData.name || ''}\n                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}\n                    disabled={modalType === 'view'}\n                    placeholder=\"Main Menu\"\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Extension</label>\n                  <Input\n                    value={formData.extension || ''}\n                    onChange={(e) => setFormData({ ...formData, extension: e.target.value })}\n                    disabled={modalType === 'view'}\n                    placeholder=\"1000\"\n                  />\n                </div>\n              </div>\n\n              <div>\n                <label className=\"text-sm font-medium\">Description</label>\n                <Textarea\n                  value={formData.description || ''}\n                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}\n                  disabled={modalType === 'view'}\n                  placeholder=\"Main customer service menu\"\n                />\n              </div>\n\n              {/* Settings */}\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Timeout (seconds)</label>\n                  <Input\n                    type=\"number\"\n                    value={formData.timeout || 10}\n                    onChange={(e) => setFormData({ ...formData, timeout: parseInt(e.target.value) })}\n                    disabled={modalType === 'view'}\n                    min=\"1\"\n                    max=\"60\"\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Max Failures</label>\n                  <Input\n                    type=\"number\"\n                    value={formData.max_failures || 3}\n                    onChange={(e) => setFormData({ ...formData, max_failures: parseInt(e.target.value) })}\n                    disabled={modalType === 'view'}\n                    min=\"1\"\n                    max=\"10\"\n                  />\n                </div>\n              </div>\n\n              {/* DTMF Options */}\n              <div className=\"border-t pt-4\">\n                <h4 className=\"font-medium mb-3\">DTMF Options</h4>\n                <div className=\"space-y-3\">\n                  {Object.entries(formData.options || {}).map(([dtmf, option], index) => (\n                    <div key={dtmf} className=\"flex items-center space-x-3 p-3 border rounded\">\n                      <div className=\"w-16\">\n                        <Input\n                          value={dtmf}\n                          onChange={(e) => {\n                            const newOptions = { ...formData.options };\n                            delete newOptions[dtmf];\n                            newOptions[e.target.value] = option;\n                            setFormData({ ...formData, options: newOptions });\n                          }}\n                          disabled={modalType === 'view'}\n                          placeholder=\"1\"\n                          className=\"text-center font-mono\"\n                        />\n                      </div>\n                      <div className=\"flex-1\">\n                        <Input\n                          value={option.description || ''}\n                          onChange={(e) => {\n                            const newOptions = { ...formData.options };\n                            newOptions[dtmf] = { ...option, description: e.target.value };\n                            setFormData({ ...formData, options: newOptions });\n                          }}\n                          disabled={modalType === 'view'}\n                          placeholder=\"Option description\"\n                        />\n                      </div>\n                      <div className=\"w-32\">\n                        <Select\n                          value={option.action}\n                          onValueChange={(value) => {\n                            const newOptions = { ...formData.options };\n                            newOptions[dtmf] = { ...option, action: value as any };\n                            setFormData({ ...formData, options: newOptions });\n                          }}\n                          disabled={modalType === 'view'}\n                        >\n                          <SelectTrigger>\n                            <SelectValue />\n                          </SelectTrigger>\n                          <SelectContent>\n                            <SelectItem value=\"extension\">Extension</SelectItem>\n                            <SelectItem value=\"queue\">Queue</SelectItem>\n                            <SelectItem value=\"conference\">Conference</SelectItem>\n                            <SelectItem value=\"voicemail\">Voicemail</SelectItem>\n                            <SelectItem value=\"submenu\">Submenu</SelectItem>\n                            <SelectItem value=\"hangup\">Hangup</SelectItem>\n                          </SelectContent>\n                        </Select>\n                      </div>\n                      <div className=\"w-32\">\n                        <Input\n                          value={option.destination}\n                          onChange={(e) => {\n                            const newOptions = { ...formData.options };\n                            newOptions[dtmf] = { ...option, destination: e.target.value };\n                            setFormData({ ...formData, options: newOptions });\n                          }}\n                          disabled={modalType === 'view'}\n                          placeholder=\"Destination\"\n                        />\n                      </div>\n                      {modalType !== 'view' && (\n                        <Button\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => {\n                            const newOptions = { ...formData.options };\n                            delete newOptions[dtmf];\n                            setFormData({ ...formData, options: newOptions });\n                          }}\n                          className=\"text-red-600 hover:text-red-700\"\n                        >\n                          <Trash2 className=\"h-4 w-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  ))}\n                  \n                  {modalType !== 'view' && (\n                    <Button\n                      variant=\"outline\"\n                      onClick={() => {\n                        const newOptions = { ...formData.options || {} };\n                        const nextKey = Object.keys(newOptions).length.toString();\n                        newOptions[nextKey] = {\n                          action: 'hangup',\n                          destination: '',\n                          description: ''\n                        };\n                        setFormData({ ...formData, options: newOptions });\n                      }}\n                    >\n                      <Plus className=\"h-4 w-4 mr-2\" />\n                      Add Option\n                    </Button>\n                  )}\n                </div>\n              </div>\n\n              {/* Modal Actions */}\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\n                <Button\n                  variant=\"outline\"\n                  onClick={() => {\n                    setShowModal(false);\n                    setFormData({});\n                    setEditingItem(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                {modalType !== 'view' && (\n                  <Button\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\n                    disabled={loading}\n                  >\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      )}\n    </div>\n  );\n}\n","size_bytes":23167},"packages/frontend/src/components/ui/LoadingSpinner.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\ninterface LoadingSpinnerProps {\n  className?: string\n  size?: \"sm\" | \"md\" | \"lg\"\n}\n\nexport function LoadingSpinner({ className, size = \"md\" }: LoadingSpinnerProps) {\n  const sizeClasses = {\n    sm: \"h-4 w-4\",\n    md: \"h-6 w-6\",\n    lg: \"h-8 w-8\"\n  }\n\n  return (\n    <div\n      className={cn(\n        \"animate-spin rounded-full border-2 border-current border-t-transparent\",\n        sizeClasses[size],\n        className\n      )}\n      role=\"status\"\n      aria-label=\"Loading\"\n    >\n      <span className=\"sr-only\">Loading...</span>\n    </div>\n  )\n}","size_bytes":581},"packages/frontend/src/components/ui/toaster.tsx":{"content":"import {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\nimport { useToast } from \"@/hooks/use-toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }: any) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}","size_bytes":776},"scripts/start-dev.sh":{"content":"#!/bin/bash\n\n# W3 VoIP Development Startup Script\n# This script starts all necessary services for development\n\nset -e\n\necho \"🚀 Starting W3 VoIP Development Environment...\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"❌ Node.js is not installed. Please install Node.js 18+ first.\"\n    exit 1\nfi\n\n# Check if PostgreSQL is running\nif ! pg_isready -q; then\n    echo \"❌ PostgreSQL is not running. Please start PostgreSQL first.\"\n    echo \"   On Ubuntu/Debian: sudo systemctl start postgresql\"\n    echo \"   On macOS: brew services start postgresql\"\n    exit 1\nfi\n\n# Check if FreeSWITCH is running (optional for development)\nif ! systemctl is-active --quiet freeswitch 2>/dev/null; then\n    echo \"⚠️  FreeSWITCH is not running. VoIP functionality will be limited.\"\n    echo \"   To start FreeSWITCH: sudo systemctl start freeswitch\"\nfi\n\n# Install dependencies if node_modules doesn't exist\nif [ ! -d \"node_modules\" ]; then\n    echo \"📦 Installing dependencies...\"\n    npm install\nfi\n\n# Build shared package\necho \"🔨 Building shared package...\"\ncd packages/shared\nnpm run build\ncd ../..\n\n# Build database package\necho \"🗄️  Building database package...\"\ncd packages/database\nnpm run build\ncd ../..\n\n# Check if .env exists\nif [ ! -f \".env\" ]; then\n    echo \"⚙️  Creating .env file from template...\"\n    cp env.example .env\n    echo \"📝 Please edit .env file with your configuration before continuing.\"\n    echo \"   Required: DATABASE_URL, JWT_SECRET\"\n    exit 1\nfi\n\n# Run database migrations\necho \"🗄️  Running database migrations...\"\ncd packages/database\nnpm run migrate\ncd ../..\n\n# Build backend\necho \"🔨 Building backend...\"\ncd packages/backend\nnpm run build\ncd ../..\n\n# Build frontend\necho \"🔨 Building frontend...\"\ncd packages/frontend\nnpm run build\ncd ../..\n\necho \"✅ All packages built successfully!\"\necho \"\"\necho \"🎯 To start the development servers:\"\necho \"   Terminal 1: npm run dev:backend\"\necho \"   Terminal 2: npm run dev:frontend\"\necho \"\"\necho \"🌐 Access points:\"\necho \"   Frontend: http://localhost:5173\"\necho \"   Backend API: http://localhost:3000/api\"\necho \"   API Health: http://localhost:3000/api/health\"\necho \"\"\necho \"📚 Documentation:\"\necho \"   README.md - Project overview\"\necho \"   INSTALLATION.md - Detailed setup guide\"\necho \"\"\necho \"🔧 Troubleshooting:\"\necho \"   - Check logs: npm run logs\"\necho \"   - Restart services: npm run restart\"\necho \"   - Clean build: npm run clean && npm run build\"\necho \"\"\necho \"Happy coding! 🎉\"\n\n","size_bytes":2524},"packages/backend/src/middleware/index.ts":{"content":"// Export all middleware\r\nexport * from './auth';\r\nexport * from './tenant';\r\nexport * from './security';\r\nexport * from './validation';\r\n\r\n","size_bytes":140},"packages/backend/src/index.ts":{"content":"import express from 'express';\nimport cors from 'cors';\nimport compression from 'compression';\nimport morgan from 'morgan';\nimport dotenv from 'dotenv';\nimport jwt from 'jsonwebtoken';\nimport { createServer } from 'http';\nimport { Server as SocketIOServer } from 'socket.io';\n\n// Load environment variables\ndotenv.config();\n\n// Validate required environment variables\nfunction validateEnvironment() {\n  const required = ['DATABASE_URL', 'JWT_SECRET'];\n  const missing = required.filter(key => !process.env[key]);\n  \n  if (missing.length > 0) {\n    console.error('❌ Missing required environment variables:', missing.join(', '));\n    console.error('💡 Please set these in your .env file');\n    process.exit(1);\n  }\n\n  if (process.env.JWT_SECRET && process.env.JWT_SECRET.length < 32) {\n    console.error('❌ JWT_SECRET must be at least 32 characters long');\n    process.exit(1);\n  }\n\n  console.log('✅ Environment variables validated');\n}\n\n// Validate environment on startup\nvalidateEnvironment();\n\n// Import middleware\nimport {\n  securityHeaders,\n  requestId,\n  apiRateLimit,\n  sanitizeInput,\n  validateContentType,\n  requestSizeLimit,\n  securityEventLogger\n} from './middleware/security';\nimport { requestLogger } from './utils/logger';\nimport { errorHandler } from './utils/response';\n\n// Import routes\nimport apiRoutes from './routes';\n\n// Import database\nimport { \n  healthCheck as dbHealthCheck, \n  getClient, \n  startPeriodicHealthCheck,\n  getPoolStats \n} from '@w3-voip/database';\nimport { validateTenantSlug } from './middleware/tenant.middleware';\n\nconst app = express();\nconst server = createServer(app);\n\n// Get CORS origin from environment or use restrictive default\nconst corsOrigin = process.env.CORS_ORIGIN?.split(',').map(origin => origin.trim()) || ['http://localhost:3000'];\n\nconst io = new SocketIOServer(server, {\n  cors: {\n    origin: corsOrigin,\n    methods: ['GET', 'POST'],\n    credentials: true\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\nconst JWT_SECRET = process.env.JWT_SECRET!; // Validated above\n\n// Security middleware\napp.use(securityHeaders);\napp.use(requestId);\napp.use(securityEventLogger);\n\n// CORS configuration - Secure, only allowed origins\napp.use(cors({\n  origin: (origin, callback) => {\n    // Allow requests with no origin (mobile apps, Postman, curl)\n    if (!origin) return callback(null, true);\n    \n    // Check if origin is in allowed list\n    if (corsOrigin.includes(origin) || corsOrigin.includes('*')) {\n      callback(null, true);\n    } else {\n      console.warn(`🚫 CORS blocked request from origin: ${origin}`);\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID']\n}));\n\n// Compression\napp.use(compression());\n\n// Request logging\napp.use(morgan('combined'));\napp.use(requestLogger);\n\n// Debug middleware for login requests\napp.use((req, res, next) => {\n  if (req.path.includes('/login')) {\n    console.log('🔍 Login Request Debug:');\n    console.log('  Path:', req.path);\n    console.log('  Method:', req.method);\n    console.log('  Content-Type:', req.headers['content-type']);\n    console.log('  Headers:', JSON.stringify(req.headers, null, 2));\n  }\n  next();\n});\n\n// Body parsing middleware\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Input sanitization\napp.use(sanitizeInput);\n\n// Request size limiting\napp.use(requestSizeLimit('10mb'));\n\n// Rate limiting\napp.use('/api', apiRateLimit);\n\n// API routes\napp.use('/api', apiRoutes);\n\n// Root endpoint\napp.get('/', (req, res) => {\n  res.json({\n    success: true,\n    data: {\n      message: 'W3 VoIP System API',\n      version: process.env.npm_package_version || '1.0.0',\n      timestamp: new Date().toISOString(),\n      endpoints: {\n        health: '/api/health',\n        tenants: '/api/tenants',\n        stores: '/api/stores',\n        extensions: '/api/extensions'\n      }\n    }\n  });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({\n    success: false,\n    error: {\n      code: 'NOT_FOUND',\n      message: 'Endpoint not found'\n    }\n  });\n});\n\n// Body parser error handler\napp.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  if (err instanceof SyntaxError && 'body' in err) {\n    console.error('❌ Body parser error:', err.message);\n    console.error('❌ Request path:', req.path);\n    console.error('❌ Content-Type:', req.headers['content-type']);\n    return res.status(400).json({\n      success: false,\n      error: {\n        code: 'INVALID_JSON',\n        message: 'Invalid JSON in request body'\n      }\n    });\n  }\n  next(err);\n});\n\n// Error handling middleware\napp.use(errorHandler);\n\n// Socket.IO connection handling\nio.on('connection', (socket) => {\n  console.log('Client connected:', socket.id);\n  \n  // Join tenant room for real-time updates\n  socket.on('join-tenant', (tenantId: string) => {\n    socket.join(`tenant:${tenantId}`);\n    console.log(`Client ${socket.id} joined tenant: ${tenantId}`);\n  });\n  \n  // Leave tenant room\n  socket.on('leave-tenant', (tenantId: string) => {\n    socket.leave(`tenant:${tenantId}`);\n    console.log(`Client ${socket.id} left tenant: ${tenantId}`);\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('Client disconnected:', socket.id);\n  });\n});\n\n// Make io available to other modules\napp.set('io', io);\n\n// Database health check\nasync function checkDatabaseHealth() {\n  try {\n    const isHealthy = await dbHealthCheck();\n    if (!isHealthy) {\n      console.warn('⚠️ Database health check returned false, but continuing anyway');\n    } else {\n      console.log('✅ Database health check passed');\n    }\n  } catch (error) {\n    console.error('⚠️ Database connection failed:', error);\n    console.warn('⚠️ Continuing despite health check failure (database may recover)');\n  }\n}\n\n// Start server\nasync function startServer() {\n  try {\n    // Check database health\n    await checkDatabaseHealth();\n    \n    // Start periodic health check (every 30 seconds)\n    startPeriodicHealthCheck(30000);\n    \n    // Start HTTP server\n    server.listen(Number(PORT), '0.0.0.0', () => {\n      console.log(`🚀 W3 VoIP System API running on port ${PORT}`);\n      console.log(`📊 Environment: ${process.env.NODE_ENV || 'development'}`);\n      console.log(`🔗 CORS Origins: ${corsOrigin.join(', ')}`);\n      console.log(`📡 Socket.IO enabled for real-time updates`);\n      \n      // Log initial pool stats\n      const stats = getPoolStats();\n      console.log(`🔌 Database pool: ${stats.totalCount} total, ${stats.idleCount} idle, ${stats.waitingCount} waiting`);\n    });\n  } catch (error) {\n    console.error('❌ Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('🛑 SIGTERM received, shutting down gracefully');\n  server.close(() => {\n    console.log('✅ Server closed');\n    process.exit(0);\n  });\n});\n\nprocess.on('SIGINT', () => {\n  console.log('🛑 SIGINT received, shutting down gracefully');\n  server.close(() => {\n    console.log('✅ Server closed');\n    process.exit(0);\n  });\n});\n\n// Handle uncaught exceptions (but don't crash on database connection errors)\nprocess.on('uncaughtException', (error: any) => {\n  // Database connection errors - log but don't crash (pool will handle reconnection)\n  const dbErrorCodes = ['57P01', '57P02', '57P03', '08003', '08006', '08P01', 'ECONNREFUSED', 'ECONNRESET'];\n  const isDbError = dbErrorCodes.includes(error?.code) || \n                    error?.message?.includes('terminating connection') ||\n                    error?.message?.includes('Connection terminated') ||\n                    error?.message?.includes('server closed the connection');\n  \n  if (isDbError) {\n    console.error('⚠️ Database connection error (non-fatal):', error.message);\n    console.error('⚠️ Error code:', error.code);\n    console.error('⚠️ Connection pool will handle recovery automatically');\n    return;\n  }\n  \n  // For other critical errors, log and exit\n  console.error('❌ Uncaught Exception:', error);\n  console.error('Stack trace:', error.stack);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason: any, promise) => {\n  // Database connection errors - log but don't crash\n  const dbErrorCodes = ['57P01', '57P02', '57P03', '08003', '08006', '08P01', 'ECONNREFUSED', 'ECONNRESET'];\n  const isDbError = dbErrorCodes.includes(reason?.code) || \n                    reason?.message?.includes('terminating connection') ||\n                    reason?.message?.includes('Connection terminated') ||\n                    reason?.message?.includes('server closed the connection');\n  \n  if (isDbError) {\n    console.error('⚠️ Database connection promise rejection (non-fatal):', reason.message);\n    console.error('⚠️ Error code:', reason.code);\n    console.error('⚠️ Connection pool will handle recovery automatically');\n    return;\n  }\n  \n  // For other critical rejections, log and exit\n  console.error('❌ Unhandled Rejection at:', promise);\n  console.error('Reason:', reason);\n  if (reason?.stack) {\n    console.error('Stack trace:', reason.stack);\n  }\n  process.exit(1);\n});\n\n// Start the server\nstartServer();\n\nexport { app, server, io, JWT_SECRET };\n","size_bytes":9378},"packages/backend/src/routes/voip-routes.ts":{"content":"// @ts-nocheck\r\nimport { Router } from 'express';\r\nimport { VoipService } from '../services/voip-service';\r\nimport { tenantContextMiddleware } from '../middleware/tenant-context';\r\n// import { \r\n//   InboundRoute, \r\n//   OutboundRoute, \r\n//   TimeCondition, \r\n//   IvrMenu, \r\n//   RingGroup, \r\n//   Queue, \r\n//   ConferenceRoom, \r\n//   VoicemailBox,\r\n//   SipExtensionConfig,\r\n//   SipTrunkConfig,\r\n//   OpenSipsRoute\r\n// } from '@w3-voip/shared';\r\n\r\nconst router = Router();\r\n\r\n// Apply tenant context middleware to all VoIP routes\r\nrouter.use(tenantContextMiddleware);\r\n\r\n// Initialize VoIP Service with configuration\r\nconst voipService = new VoipService(\r\n  {\r\n    host: process.env.FREESWITCH_HOST || '192.168.172.234',\r\n    port: parseInt(process.env.FREESWITCH_PORT || '8021'),\r\n    password: process.env.FREESWITCH_PASSWORD || 'ClueCon',\r\n    context: process.env.FREESWITCH_CONTEXT || 'default'\r\n  },\r\n  {\r\n    host: process.env.OPENSIPS_HOST || '192.168.172.234',\r\n    port: parseInt(process.env.OPENSIPS_PORT || '5060'),\r\n    database: {\r\n      host: process.env.OPENSIPS_DB_HOST || '192.168.172.234',\r\n      port: parseInt(process.env.OPENSIPS_DB_PORT || '5432'),\r\n      name: process.env.OPENSIPS_DB_NAME || 'opensips',\r\n      user: process.env.OPENSIPS_DB_USER || 'opensips',\r\n      password: process.env.OPENSIPS_DB_PASSWORD || 'opensips'\r\n    }\r\n  },\r\n  {\r\n    host: process.env.FUSIONPBX_HOST || '192.168.172.234',\r\n    port: parseInt(process.env.FUSIONPBX_PORT || '80'),\r\n    database: {\r\n      host: process.env.FUSIONPBX_DB_HOST || '192.168.172.234',\r\n      port: parseInt(process.env.FUSIONPBX_DB_PORT || '5432'),\r\n      name: process.env.FUSIONPBX_DB_NAME || 'fusionpbx',\r\n      user: process.env.FUSIONPBX_DB_USER || 'fusionpbx',\r\n      password: process.env.FUSIONPBX_DB_PASSWORD || 'fusionpbx'\r\n    }\r\n  }\r\n);\r\n\r\n// ===== INBOUND ROUTES =====\r\nrouter.post('/inbound-routes', async (req, res) => {\r\n  try {\r\n    const route = req.body;\r\n    const createdRoute = await voipService.createInboundRoute(req.tenantContext!, route);\r\n    res.status(201).json(createdRoute);\r\n  } catch (error) {\r\n    console.error('Error creating inbound route:', error);\r\n    res.status(500).json({ error: 'Failed to create inbound route' });\r\n  }\r\n});\r\n\r\nrouter.get('/inbound-routes', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const routes = await voipService.getInboundRoutes(tenantId);\r\n    res.json(routes);\r\n  } catch (error) {\r\n    console.error('Error fetching inbound routes:', error);\r\n    res.status(500).json({ error: 'Failed to fetch inbound routes' });\r\n  }\r\n});\r\n\r\nrouter.get('/inbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    // TODO: Implement get inbound route by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching inbound route:', error);\r\n    res.status(500).json({ error: 'Failed to fetch inbound route' });\r\n  }\r\n});\r\n\r\nrouter.put('/inbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const route: Partial<InboundRoute> = req.body;\r\n    const updatedRoute = await voipService.updateInboundRoute(routeId, route);\r\n    res.json(updatedRoute);\r\n  } catch (error) {\r\n    console.error('Error updating inbound route:', error);\r\n    res.status(500).json({ error: 'Failed to update inbound route' });\r\n  }\r\n});\r\n\r\nrouter.delete('/inbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    await voipService.deleteInboundRoute(routeId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting inbound route:', error);\r\n    res.status(500).json({ error: 'Failed to delete inbound route' });\r\n  }\r\n});\r\n\r\n// ===== OUTBOUND ROUTES =====\r\nrouter.post('/outbound-routes', async (req, res) => {\r\n  try {\r\n    const route = req.body;\r\n    const createdRoute = await voipService.createOutboundRoute(req.tenantContext!, route);\r\n    res.status(201).json(createdRoute);\r\n  } catch (error) {\r\n    console.error('Error creating outbound route:', error);\r\n    res.status(500).json({ error: 'Failed to create outbound route' });\r\n  }\r\n});\r\n\r\nrouter.get('/outbound-routes', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const routes = await voipService.getOutboundRoutes(tenantId);\r\n    res.json(routes);\r\n  } catch (error) {\r\n    console.error('Error fetching outbound routes:', error);\r\n    res.status(500).json({ error: 'Failed to fetch outbound routes' });\r\n  }\r\n});\r\n\r\nrouter.get('/outbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    // TODO: Implement get outbound route by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching outbound route:', error);\r\n    res.status(500).json({ error: 'Failed to fetch outbound route' });\r\n  }\r\n});\r\n\r\nrouter.put('/outbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const route: Partial<OutboundRoute> = req.body;\r\n    const updatedRoute = await voipService.updateOutboundRoute(routeId, route);\r\n    res.json(updatedRoute);\r\n  } catch (error) {\r\n    console.error('Error updating outbound route:', error);\r\n    res.status(500).json({ error: 'Failed to update outbound route' });\r\n  }\r\n});\r\n\r\nrouter.delete('/outbound-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    await voipService.deleteOutboundRoute(routeId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting outbound route:', error);\r\n    res.status(500).json({ error: 'Failed to delete outbound route' });\r\n  }\r\n});\r\n\r\n// ===== TIME CONDITIONS =====\r\nrouter.post('/time-conditions', async (req, res) => {\r\n  try {\r\n    const condition = req.body;\r\n    const createdCondition = await voipService.createTimeCondition(req.tenantContext!, condition);\r\n    res.status(201).json(createdCondition);\r\n  } catch (error) {\r\n    console.error('Error creating time condition:', error);\r\n    res.status(500).json({ error: 'Failed to create time condition' });\r\n  }\r\n});\r\n\r\nrouter.get('/time-conditions', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const conditions = await voipService.getTimeConditions(tenantId);\r\n    res.json(conditions);\r\n  } catch (error) {\r\n    console.error('Error fetching time conditions:', error);\r\n    res.status(500).json({ error: 'Failed to fetch time conditions' });\r\n  }\r\n});\r\n\r\nrouter.get('/time-conditions/:id', async (req, res) => {\r\n  try {\r\n    const conditionId = req.params.id;\r\n    // TODO: Implement get time condition by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching time condition:', error);\r\n    res.status(500).json({ error: 'Failed to fetch time condition' });\r\n  }\r\n});\r\n\r\nrouter.put('/time-conditions/:id', async (req, res) => {\r\n  try {\r\n    const conditionId = req.params.id;\r\n    const condition: Partial<TimeCondition> = req.body;\r\n    const updatedCondition = await voipService.updateTimeCondition(conditionId, condition);\r\n    res.json(updatedCondition);\r\n  } catch (error) {\r\n    console.error('Error updating time condition:', error);\r\n    res.status(500).json({ error: 'Failed to update time condition' });\r\n  }\r\n});\r\n\r\nrouter.delete('/time-conditions/:id', async (req, res) => {\r\n  try {\r\n    const conditionId = req.params.id;\r\n    await voipService.deleteTimeCondition(conditionId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting time condition:', error);\r\n    res.status(500).json({ error: 'Failed to delete time condition' });\r\n  }\r\n});\r\n\r\n// ===== IVR MENUS =====\r\nrouter.post('/ivr-menus', async (req, res) => {\r\n  try {\r\n    const menu = req.body;\r\n    const createdMenu = await voipService.createIvrMenu(req.tenantContext!, menu);\r\n    res.status(201).json(createdMenu);\r\n  } catch (error) {\r\n    console.error('Error creating IVR menu:', error);\r\n    res.status(500).json({ error: 'Failed to create IVR menu' });\r\n  }\r\n});\r\n\r\nrouter.get('/ivr-menus', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const menus = await voipService.getIvrMenus(tenantId);\r\n    res.json(menus);\r\n  } catch (error) {\r\n    console.error('Error fetching IVR menus:', error);\r\n    res.status(500).json({ error: 'Failed to fetch IVR menus' });\r\n  }\r\n});\r\n\r\nrouter.get('/ivr-menus/:id', async (req, res) => {\r\n  try {\r\n    const menuId = req.params.id;\r\n    // TODO: Implement get IVR menu by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching IVR menu:', error);\r\n    res.status(500).json({ error: 'Failed to fetch IVR menu' });\r\n  }\r\n});\r\n\r\nrouter.put('/ivr-menus/:id', async (req, res) => {\r\n  try {\r\n    const menuId = req.params.id;\r\n    const menu: Partial<IvrMenu> = req.body;\r\n    const updatedMenu = await voipService.updateIvrMenu(menuId, menu);\r\n    res.json(updatedMenu);\r\n  } catch (error) {\r\n    console.error('Error updating IVR menu:', error);\r\n    res.status(500).json({ error: 'Failed to update IVR menu' });\r\n  }\r\n});\r\n\r\nrouter.delete('/ivr-menus/:id', async (req, res) => {\r\n  try {\r\n    const menuId = req.params.id;\r\n    await voipService.deleteIvrMenu(menuId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting IVR menu:', error);\r\n    res.status(500).json({ error: 'Failed to delete IVR menu' });\r\n  }\r\n});\r\n\r\n// ===== RING GROUPS =====\r\nrouter.post('/ring-groups', async (req, res) => {\r\n  try {\r\n    const group = req.body;\r\n    const createdGroup = await voipService.createRingGroup(req.tenantContext!, group);\r\n    res.status(201).json(createdGroup);\r\n  } catch (error) {\r\n    console.error('Error creating ring group:', error);\r\n    res.status(500).json({ error: 'Failed to create ring group' });\r\n  }\r\n});\r\n\r\nrouter.get('/ring-groups', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const groups = await voipService.getRingGroups(tenantId);\r\n    res.json(groups);\r\n  } catch (error) {\r\n    console.error('Error fetching ring groups:', error);\r\n    res.status(500).json({ error: 'Failed to fetch ring groups' });\r\n  }\r\n});\r\n\r\nrouter.get('/ring-groups/:id', async (req, res) => {\r\n  try {\r\n    const groupId = req.params.id;\r\n    // TODO: Implement get ring group by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching ring group:', error);\r\n    res.status(500).json({ error: 'Failed to fetch ring group' });\r\n  }\r\n});\r\n\r\nrouter.put('/ring-groups/:id', async (req, res) => {\r\n  try {\r\n    const groupId = req.params.id;\r\n    const group: Partial<RingGroup> = req.body;\r\n    const updatedGroup = await voipService.updateRingGroup(groupId, group);\r\n    res.json(updatedGroup);\r\n  } catch (error) {\r\n    console.error('Error updating ring group:', error);\r\n    res.status(500).json({ error: 'Failed to update ring group' });\r\n  }\r\n});\r\n\r\nrouter.delete('/ring-groups/:id', async (req, res) => {\r\n  try {\r\n    const groupId = req.params.id;\r\n    await voipService.deleteRingGroup(groupId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting ring group:', error);\r\n    res.status(500).json({ error: 'Failed to delete ring group' });\r\n  }\r\n});\r\n\r\n// ===== QUEUES =====\r\nrouter.post('/queues', async (req, res) => {\r\n  try {\r\n    const queue = req.body;\r\n    const createdQueue = await voipService.createQueue(req.tenantContext!, queue);\r\n    res.status(201).json(createdQueue);\r\n  } catch (error) {\r\n    console.error('Error creating queue:', error);\r\n    res.status(500).json({ error: 'Failed to create queue' });\r\n  }\r\n});\r\n\r\nrouter.get('/queues', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const queues = await voipService.getQueues(tenantId);\r\n    res.json(queues);\r\n  } catch (error) {\r\n    console.error('Error fetching queues:', error);\r\n    res.status(500).json({ error: 'Failed to fetch queues' });\r\n  }\r\n});\r\n\r\nrouter.get('/queues/:id', async (req, res) => {\r\n  try {\r\n    const queueId = req.params.id;\r\n    // TODO: Implement get queue by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching queue:', error);\r\n    res.status(500).json({ error: 'Failed to fetch queue' });\r\n  }\r\n});\r\n\r\nrouter.put('/queues/:id', async (req, res) => {\r\n  try {\r\n    const queueId = req.params.id;\r\n    const queue: Partial<Queue> = req.body;\r\n    const updatedQueue = await voipService.updateQueue(queueId, queue);\r\n    res.json(updatedQueue);\r\n  } catch (error) {\r\n    console.error('Error updating queue:', error);\r\n    res.status(500).json({ error: 'Failed to update queue' });\r\n  }\r\n});\r\n\r\nrouter.delete('/queues/:id', async (req, res) => {\r\n  try {\r\n    const queueId = req.params.id;\r\n    await voipService.deleteQueue(queueId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting queue:', error);\r\n    res.status(500).json({ error: 'Failed to delete queue' });\r\n  }\r\n});\r\n\r\n// ===== CONFERENCE ROOMS =====\r\nrouter.post('/conference-rooms', async (req, res) => {\r\n  try {\r\n    const room = req.body;\r\n    const createdRoom = await voipService.createConferenceRoom(req.tenantContext!, room);\r\n    res.status(201).json(createdRoom);\r\n  } catch (error) {\r\n    console.error('Error creating conference room:', error);\r\n    res.status(500).json({ error: 'Failed to create conference room' });\r\n  }\r\n});\r\n\r\nrouter.get('/conference-rooms', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const rooms = await voipService.getConferenceRooms(tenantId);\r\n    res.json(rooms);\r\n  } catch (error) {\r\n    console.error('Error fetching conference rooms:', error);\r\n    res.status(500).json({ error: 'Failed to fetch conference rooms' });\r\n  }\r\n});\r\n\r\nrouter.get('/conference-rooms/:id', async (req, res) => {\r\n  try {\r\n    const roomId = req.params.id;\r\n    // TODO: Implement get conference room by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching conference room:', error);\r\n    res.status(500).json({ error: 'Failed to fetch conference room' });\r\n  }\r\n});\r\n\r\nrouter.put('/conference-rooms/:id', async (req, res) => {\r\n  try {\r\n    const roomId = req.params.id;\r\n    const room: Partial<ConferenceRoom> = req.body;\r\n    const updatedRoom = await voipService.updateConferenceRoom(roomId, room);\r\n    res.json(updatedRoom);\r\n  } catch (error) {\r\n    console.error('Error updating conference room:', error);\r\n    res.status(500).json({ error: 'Failed to update conference room' });\r\n  }\r\n});\r\n\r\nrouter.delete('/conference-rooms/:id', async (req, res) => {\r\n  try {\r\n    const roomId = req.params.id;\r\n    await voipService.deleteConferenceRoom(roomId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting conference room:', error);\r\n    res.status(500).json({ error: 'Failed to delete conference room' });\r\n  }\r\n});\r\n\r\n// ===== VOICEMAIL BOXES =====\r\nrouter.post('/voicemail-boxes', async (req, res) => {\r\n  try {\r\n    const box = req.body;\r\n    const createdBox = await voipService.createVoicemailBox(req.tenantContext!, box);\r\n    res.status(201).json(createdBox);\r\n  } catch (error) {\r\n    console.error('Error creating voicemail box:', error);\r\n    res.status(500).json({ error: 'Failed to create voicemail box' });\r\n  }\r\n});\r\n\r\nrouter.get('/voicemail-boxes', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const boxes = await voipService.getVoicemailBoxes(tenantId);\r\n    res.json(boxes);\r\n  } catch (error) {\r\n    console.error('Error fetching voicemail boxes:', error);\r\n    res.status(500).json({ error: 'Failed to fetch voicemail boxes' });\r\n  }\r\n});\r\n\r\nrouter.get('/voicemail-boxes/:id', async (req, res) => {\r\n  try {\r\n    const boxId = req.params.id;\r\n    // TODO: Implement get voicemail box by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching voicemail box:', error);\r\n    res.status(500).json({ error: 'Failed to fetch voicemail box' });\r\n  }\r\n});\r\n\r\nrouter.put('/voicemail-boxes/:id', async (req, res) => {\r\n  try {\r\n    const boxId = req.params.id;\r\n    const box: Partial<VoicemailBox> = req.body;\r\n    const updatedBox = await voipService.updateVoicemailBox(boxId, box);\r\n    res.json(updatedBox);\r\n  } catch (error) {\r\n    console.error('Error updating voicemail box:', error);\r\n    res.status(500).json({ error: 'Failed to update voicemail box' });\r\n  }\r\n});\r\n\r\nrouter.delete('/voicemail-boxes/:id', async (req, res) => {\r\n  try {\r\n    const boxId = req.params.id;\r\n    await voipService.deleteVoicemailBox(boxId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting voicemail box:', error);\r\n    res.status(500).json({ error: 'Failed to delete voicemail box' });\r\n  }\r\n});\r\n\r\n// ===== SIP EXTENSIONS =====\r\nrouter.post('/sip-extensions', async (req, res) => {\r\n  try {\r\n    const extension = req.body;\r\n    const createdExtension = await voipService.createSipExtension(req.tenantContext!, extension);\r\n    res.status(201).json(createdExtension);\r\n  } catch (error) {\r\n    console.error('Error creating SIP extension:', error);\r\n    res.status(500).json({ error: 'Failed to create SIP extension' });\r\n  }\r\n});\r\n\r\nrouter.get('/sip-extensions', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const extensions = await voipService.getSipExtensions(tenantId);\r\n    res.json(extensions);\r\n  } catch (error) {\r\n    console.error('Error fetching SIP extensions:', error);\r\n    res.status(500).json({ error: 'Failed to fetch SIP extensions' });\r\n  }\r\n});\r\n\r\nrouter.get('/sip-extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    // TODO: Implement get SIP extension by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching SIP extension:', error);\r\n    res.status(500).json({ error: 'Failed to fetch SIP extension' });\r\n  }\r\n});\r\n\r\nrouter.put('/sip-extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    const extension: Partial<SipExtensionConfig> = req.body;\r\n    const updatedExtension = await voipService.updateSipExtension(extensionId, extension);\r\n    res.json(updatedExtension);\r\n  } catch (error) {\r\n    console.error('Error updating SIP extension:', error);\r\n    res.status(500).json({ error: 'Failed to update SIP extension' });\r\n  }\r\n});\r\n\r\nrouter.delete('/sip-extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    await voipService.deleteSipExtension(extensionId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting SIP extension:', error);\r\n    res.status(500).json({ error: 'Failed to delete SIP extension' });\r\n  }\r\n});\r\n\r\n// ===== SIP TRUNKS =====\r\nrouter.post('/sip-trunks', async (req, res) => {\r\n  try {\r\n    const trunk = req.body;\r\n    const createdTrunk = await voipService.createSipTrunk(req.tenantContext!, trunk);\r\n    res.status(201).json(createdTrunk);\r\n  } catch (error) {\r\n    console.error('Error creating SIP trunk:', error);\r\n    res.status(500).json({ error: 'Failed to create SIP trunk' });\r\n  }\r\n});\r\n\r\nrouter.get('/sip-trunks', async (req, res) => {\r\n  try {\r\n    // tenant_id is automatically available from tenantContext\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const trunks = await voipService.getSipTrunks(tenantId);\r\n    res.json({\r\n      success: true,\r\n      data: trunks,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching SIP trunks:', error);\r\n    res.status(500).json({ \r\n      success: false,\r\n      error: 'Failed to fetch SIP trunks',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/sip-trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    // TODO: Implement get SIP trunk by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching SIP trunk:', error);\r\n    res.status(500).json({ error: 'Failed to fetch SIP trunk' });\r\n  }\r\n});\r\n\r\nrouter.put('/sip-trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    const trunk: Partial<SipTrunkConfig> = req.body;\r\n    const updatedTrunk = await voipService.updateSipTrunk(trunkId, trunk);\r\n    res.json(updatedTrunk);\r\n  } catch (error) {\r\n    console.error('Error updating SIP trunk:', error);\r\n    res.status(500).json({ error: 'Failed to update SIP trunk' });\r\n  }\r\n});\r\n\r\nrouter.delete('/sip-trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    await voipService.deleteSipTrunk(trunkId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting SIP trunk:', error);\r\n    res.status(500).json({ error: 'Failed to delete SIP trunk' });\r\n  }\r\n});\r\n\r\n// ===== OPENSIPS ROUTES =====\r\nrouter.post('/opensips-routes', async (req, res) => {\r\n  try {\r\n    const route: OpenSipsRoute = req.body;\r\n    const createdRoute = await voipService.createOpenSipsRoute(route);\r\n    res.status(201).json(createdRoute);\r\n  } catch (error) {\r\n    console.error('Error creating OpenSIPS route:', error);\r\n    res.status(500).json({ error: 'Failed to create OpenSIPS route' });\r\n  }\r\n});\r\n\r\nrouter.get('/opensips-routes', async (req, res) => {\r\n  try {\r\n    const tenantId = req.query.tenant_id as string;\r\n    // TODO: Implement get OpenSIPS routes from database\r\n    res.json([]);\r\n  } catch (error) {\r\n    console.error('Error fetching OpenSIPS routes:', error);\r\n    res.status(500).json({ error: 'Failed to fetch OpenSIPS routes' });\r\n  }\r\n});\r\n\r\nrouter.get('/opensips-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    // TODO: Implement get OpenSIPS route by ID from database\r\n    res.json({});\r\n  } catch (error) {\r\n    console.error('Error fetching OpenSIPS route:', error);\r\n    res.status(500).json({ error: 'Failed to fetch OpenSIPS route' });\r\n  }\r\n});\r\n\r\nrouter.put('/opensips-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const route: Partial<OpenSipsRoute> = req.body;\r\n    const updatedRoute = await voipService.updateOpenSipsRoute(routeId, route);\r\n    res.json(updatedRoute);\r\n  } catch (error) {\r\n    console.error('Error updating OpenSIPS route:', error);\r\n    res.status(500).json({ error: 'Failed to update OpenSIPS route' });\r\n  }\r\n});\r\n\r\nrouter.delete('/opensips-routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    await voipService.deleteOpenSipsRoute(routeId);\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting OpenSIPS route:', error);\r\n    res.status(500).json({ error: 'Failed to delete OpenSIPS route' });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":23475},"packages/backend/src/middleware/tenant-context.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { Pool } from 'pg';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\n\nexport interface TenantContext {\n  tenant_id: string;\n  sip_domain: string;\n  store_id?: string;\n}\n\n// Extend Express Request interface\ndeclare global {\n  namespace Express {\n    interface Request {\n      tenantContext?: TenantContext;\n    }\n  }\n}\n\n// PostgreSQL connection pool\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL\n});\n\nexport async function tenantContextMiddleware(req: Request, res: Response, next: NextFunction) {\n  try {\n    // Extract token from Authorization header\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'No valid authorization header' });\n    }\n\n    const token = authHeader.split(' ')[1];\n    const JWT_SECRET = process.env.JWT_SECRET || 'edg-voip-secret-key-2024';\n\n    // Verify and decode JWT\n    const payload = jwt.verify(token, JWT_SECRET) as any;\n    \n    if (!payload.tenant_id) {\n      return res.status(401).json({ error: 'No tenant_id in JWT payload' });\n    }\n\n    // Fetch tenant from database\n    const result = await pool.query(\n      'SELECT id, name, sip_domain FROM tenants WHERE id = $1 AND status = $2',\n      [payload.tenant_id, 'active']\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Tenant not found' });\n    }\n\n    const tenant = result.rows[0];\n\n    // Extract store_id from request body or query params (optional)\n    const store_id = req.body?.store_id || req.query?.store_id;\n\n    // Add tenant context to request\n    req.tenantContext = {\n      tenant_id: payload.tenant_id,\n      sip_domain: tenant.sip_domain,\n      store_id: store_id as string | undefined\n    };\n\n    next();\n  } catch (error) {\n    console.error('Tenant context middleware error:', error);\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Helper function to generate SIP domain from tenant name\nexport function generateSipDomain(tenantName: string): string {\n  return `${tenantName\n    .toLowerCase()\n    .trim()\n    .replace(/\\s+/g, '-')\n    .replace(/[^a-z0-9-]/g, '')}.edgvoip.it`;\n}\n\n// Helper function to validate SIP domain format\nexport function validateSipDomain(sipDomain: string): boolean {\n  const regex = /^[a-z0-9-]+\\.edgvoip\\.it$/;\n  return regex.test(sipDomain) && sipDomain.length <= 253;\n}\n","size_bytes":2523},"packages/backend/src/utils/logger.ts":{"content":"import winston from 'winston';\r\nimport DailyRotateFile from 'winston-daily-rotate-file';\r\nimport path from 'path';\r\n\r\n// Create logs directory if it doesn't exist\r\nconst logsDir = path.join(process.cwd(), 'logs');\r\n\r\n// Define log levels\r\nconst levels = {\r\n  error: 0,\r\n  warn: 1,\r\n  info: 2,\r\n  http: 3,\r\n  debug: 4,\r\n};\r\n\r\n// Define colors for each level\r\nconst colors = {\r\n  error: 'red',\r\n  warn: 'yellow',\r\n  info: 'green',\r\n  http: 'magenta',\r\n  debug: 'white',\r\n};\r\n\r\n// Tell winston that you want to link the colors\r\nwinston.addColors(colors);\r\n\r\n// Define which level to use based on environment\r\nconst level = () => {\r\n  const env = process.env.NODE_ENV || 'development';\r\n  const isDevelopment = env === 'development';\r\n  return isDevelopment ? 'debug' : 'warn';\r\n};\r\n\r\n// Define format for console output\r\nconst consoleFormat = winston.format.combine(\r\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\r\n  winston.format.colorize({ all: true }),\r\n  winston.format.printf(\r\n    (info) => `${info.timestamp} ${info.level}: ${info.message}`\r\n  )\r\n);\r\n\r\n// Define format for file output\r\nconst fileFormat = winston.format.combine(\r\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),\r\n  winston.format.errors({ stack: true }),\r\n  winston.format.json()\r\n);\r\n\r\n// Define transports\r\nconst transports = [\r\n  // Console transport\r\n  new winston.transports.Console({\r\n    format: consoleFormat,\r\n  }),\r\n  \r\n  // Error log file\r\n  new DailyRotateFile({\r\n    filename: path.join(logsDir, 'error-%DATE%.log'),\r\n    datePattern: 'YYYY-MM-DD',\r\n    level: 'error',\r\n    format: fileFormat,\r\n    maxSize: '20m',\r\n    maxFiles: '14d',\r\n  }),\r\n  \r\n  // Combined log file\r\n  new DailyRotateFile({\r\n    filename: path.join(logsDir, 'combined-%DATE%.log'),\r\n    datePattern: 'YYYY-MM-DD',\r\n    format: fileFormat,\r\n    maxSize: '20m',\r\n    maxFiles: '14d',\r\n  }),\r\n  \r\n  // Security events log file\r\n  new DailyRotateFile({\r\n    filename: path.join(logsDir, 'security-%DATE%.log'),\r\n    datePattern: 'YYYY-MM-DD',\r\n    level: 'warn',\r\n    format: fileFormat,\r\n    maxSize: '20m',\r\n    maxFiles: '30d', // Keep security logs longer\r\n  }),\r\n  \r\n  // API access log file\r\n  new DailyRotateFile({\r\n    filename: path.join(logsDir, 'api-%DATE%.log'),\r\n    datePattern: 'YYYY-MM-DD',\r\n    level: 'http',\r\n    format: fileFormat,\r\n    maxSize: '20m',\r\n    maxFiles: '7d',\r\n  }),\r\n];\r\n\r\n// Create the logger\r\nconst logger = winston.createLogger({\r\n  level: level(),\r\n  levels,\r\n  transports,\r\n  exitOnError: false,\r\n});\r\n\r\n// Create specialized loggers for different components\r\nexport const securityLogger = winston.createLogger({\r\n  level: 'info',\r\n  levels,\r\n  transports: [\r\n    new winston.transports.Console({\r\n      format: winston.format.combine(\r\n        winston.format.colorize({ all: true }),\r\n        winston.format.label({ label: 'SECURITY' }),\r\n        winston.format.printf(\r\n          (info) => `${info.timestamp} [${info.label}] ${info.level}: ${info.message}`\r\n        )\r\n      ),\r\n    }),\r\n    new DailyRotateFile({\r\n      filename: path.join(logsDir, 'security-%DATE%.log'),\r\n      datePattern: 'YYYY-MM-DD',\r\n      format: fileFormat,\r\n      maxSize: '20m',\r\n      maxFiles: '30d',\r\n    }),\r\n  ],\r\n});\r\n\r\nexport const apiLogger = winston.createLogger({\r\n  level: 'http',\r\n  levels,\r\n  transports: [\r\n    new DailyRotateFile({\r\n      filename: path.join(logsDir, 'api-%DATE%.log'),\r\n      datePattern: 'YYYY-MM-DD',\r\n      format: fileFormat,\r\n      maxSize: '20m',\r\n      maxFiles: '7d',\r\n    }),\r\n  ],\r\n});\r\n\r\nexport const cdrLogger = winston.createLogger({\r\n  level: 'info',\r\n  levels,\r\n  transports: [\r\n    new DailyRotateFile({\r\n      filename: path.join(logsDir, 'cdr-%DATE%.log'),\r\n      datePattern: 'YYYY-MM-DD',\r\n      format: fileFormat,\r\n      maxSize: '50m',\r\n      maxFiles: '90d', // Keep CDR logs for 3 months\r\n    }),\r\n  ],\r\n});\r\n\r\nexport const freeswitchLogger = winston.createLogger({\r\n  level: 'info',\r\n  levels,\r\n  transports: [\r\n    new winston.transports.Console({\r\n      format: winston.format.combine(\r\n        winston.format.colorize({ all: true }),\r\n        winston.format.label({ label: 'FREESWITCH' }),\r\n        winston.format.printf(\r\n          (info) => `${info.timestamp} [${info.label}] ${info.level}: ${info.message}`\r\n        )\r\n      ),\r\n    }),\r\n    new DailyRotateFile({\r\n      filename: path.join(logsDir, 'freeswitch-%DATE%.log'),\r\n      datePattern: 'YYYY-MM-DD',\r\n      format: fileFormat,\r\n      maxSize: '20m',\r\n      maxFiles: '14d',\r\n    }),\r\n  ],\r\n});\r\n\r\n// Logging middleware for Express\r\nexport const requestLogger = (req: any, res: any, next: any) => {\r\n  const start = Date.now();\r\n  \r\n  res.on('finish', () => {\r\n    const duration = Date.now() - start;\r\n    const logData = {\r\n      method: req.method,\r\n      url: req.url,\r\n      status: res.statusCode,\r\n      duration: `${duration}ms`,\r\n      ip: req.ip,\r\n      userAgent: req.headers['user-agent'],\r\n      tenantId: req.tenantId,\r\n      userId: req.user?.sub,\r\n      requestId: req.id,\r\n    };\r\n    \r\n    if (res.statusCode >= 400) {\r\n      apiLogger.warn('API Request', logData);\r\n    } else {\r\n      apiLogger.http('API Request', logData);\r\n    }\r\n  });\r\n  \r\n  next();\r\n};\r\n\r\n// Security event logger\r\nexport const logSecurityEvent = (event: string, details: any, req?: any) => {\r\n  const logData = {\r\n    event,\r\n    details,\r\n    timestamp: new Date().toISOString(),\r\n    ip: req?.ip,\r\n    userAgent: req?.headers['user-agent'],\r\n    tenantId: req?.tenantId,\r\n    userId: req?.user?.sub,\r\n    requestId: req?.id,\r\n  };\r\n  \r\n  securityLogger.warn('Security Event', logData);\r\n};\r\n\r\n// CDR event logger\r\nexport const logCDREvent = (event: string, cdrData: any) => {\r\n  const logData = {\r\n    event,\r\n    cdr: cdrData,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n  \r\n  cdrLogger.info('CDR Event', logData);\r\n};\r\n\r\n// FreeSWITCH event logger\r\nexport const logFreeSWITCHEvent = (event: string, data: any) => {\r\n  const logData = {\r\n    event,\r\n    data,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n  \r\n  freeswitchLogger.info('FreeSWITCH Event', logData);\r\n};\r\n\r\nexport default logger;\r\n\r\n","size_bytes":6139},"packages/frontend/src/pages/SipTrunks.tsx":{"content":"import { useState, useEffect, useRef } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Phone, Plus, RefreshCw, Search, Eye, Trash2, X, Save, \n  CheckCircle, XCircle, AlertCircle, Network, Server, Activity\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api';\n\nexport default function SipTrunks() {\n  const [trunks, setTrunks] = useState<any[]>([]);\n  const [showModal, setShowModal] = useState(false);\r\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\r\n  const [loading, setLoading] = useState(false);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [formData, setFormData] = useState<any>({});\r\n  const [showPassword, setShowPassword] = useState(false);\r\n  const [editingItem, setEditingItem] = useState<any>(null);\r\n  const [activeView, setActiveView] = useState<'status' | 'trunks'>('status');\r\n  const [sipStatusTab, setSipStatusTab] = useState<'trunks' | 'extensions'>('trunks');\r\n  const [extensions, setExtensions] = useState<any[]>([]);\r\n  const [extensionsLoading, setExtensionsLoading] = useState(false);\r\n\r\n  // Load trunks on component mount\r\n  useEffect(() => {\r\n    loadTrunks();\r\n    loadExtensions();\r\n  }, []);\r\n  const loadTrunks = async () => {\r\n    setLoading(true);\r\n    try {\r\n      // Load trunks from API\r\n      const response = await apiClient.get('/sip-trunks');\r\n      console.log('📡 API Response:', response.data);\r\n      \r\n      // Handle both formats: {success: true, data: [...]} and [...]\r\n      if ((response.data as any)?.success) {\r\n        setTrunks((response.data as any).data);\r\n        console.log('✅ SIP Trunks loaded successfully:', (response.data as any).data.length);\r\n      } else if (Array.isArray(response.data)) {\r\n        // Direct array response\r\n        setTrunks(response.data);\r\n        console.log('✅ SIP Trunks loaded successfully (direct array):', response.data.length);\r\n      } else {\r\n        // Fallback to hardcoded Messagenet trunk if API fails\r\n        console.warn('⚠️ API response not successful, using hardcoded Messagenet trunk');\r\n        console.log('Response data:', response.data);\r\n      }\r\n    } catch (error: any) {\r\n      console.error('❌ Error loading trunks:', error.message || error);\r\n      console.error('Backend URL:', error.config?.url);\r\n      console.error('Status:', error.response?.status);\r\n      console.error('Response data:', error.response?.data);\r\n      // Keep hardcoded Messagenet trunk as fallback\r\n      console.log('Using hardcoded Messagenet trunk as fallback');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const loadExtensions = async () => {\r\n    setExtensionsLoading(true);\r\n    try {\r\n      // Load extensions from API using apiClient\r\n      const data = await apiClient.getExtensions({ limit: 100 });\r\n      \r\n      console.log('📡 Extensions API Response:', data);\r\n      \r\n      if (data?.success && data?.data?.items && Array.isArray(data.data.items)) {\r\n        setExtensions(data.data.items);\r\n        console.log('✅ Extensions loaded from database:', data.data.items.length);\r\n      } else {\r\n        console.warn('⚠️ Invalid API response format');\r\n        setExtensions([]);\r\n      }\r\n    } catch (error: any) {\r\n      console.error('❌ Error loading extensions:', error);\r\n      setExtensions([]);\r\n    } finally {\r\n      setExtensionsLoading(false);\r\n    }\r\n  };\r\n\r\n\r\n  const getStatusIcon = (status: string) => {\r\n    switch (status) {\r\n      case 'registered': return <CheckCircle className=\"h-4 w-4 text-green-500\" />;\r\n      case 'unregistered': return <XCircle className=\"h-4 w-4 text-red-500\" />;\r\n      case 'failed': return <AlertCircle className=\"h-4 w-4 text-yellow-500\" />;\r\n      case 'busy': return <Phone className=\"h-4 w-4 text-orange-500\" />;\r\n      default: return <AlertCircle className=\"h-4 w-4 text-gray-500\" />;\r\n    }\r\n  };\r\n\r\n  const getStatusColor = (status: string) => {\r\n    switch (status) {\r\n      case 'registered': return 'default';\r\n      case 'unregistered': return 'secondary';\r\n      case 'failed': return 'destructive';\r\n      case 'busy': return 'outline';\r\n      default: return 'secondary';\r\n    }\r\n  };\r\n\r\n  const getStatusLabel = (status: string) => {\r\n    switch (status) {\r\n      case 'registered': return 'Registered';\r\n      case 'unregistered': return 'Unregistered';\r\n      case 'failed': return 'Failed';\r\n      case 'busy': return 'Busy';\r\n      default: return 'Unknown';\r\n    }\r\n  };\r\n\r\n  const renderSipStatusCard = () => (\r\n    <Card \r\n      className={`cursor-pointer transition-all duration-200 ${\r\n        activeView === 'status' \r\n          ? 'ring-2 ring-blue-500 shadow-lg' \r\n          : 'hover:shadow-md'\r\n      }`} \r\n      onClick={() => setActiveView('status')}\r\n    >\r\n      <CardContent className=\"p-6\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <div className=\"flex items-center space-x-4\">\r\n            <div className=\"p-3 bg-blue-100 rounded-lg\">\r\n              <Activity className=\"h-6 w-6 text-blue-600\" />\r\n            </div>\r\n            <div>\r\n              <h3 className=\"text-lg font-semibold\">SIP Status</h3>\r\n              <p className=\"text-sm text-gray-600\">Monitor SIP trunk and extension registration status</p>\r\n            </div>\r\n          </div>\r\n          <div className=\"text-right\">\r\n            <div className=\"text-2xl font-bold text-blue-600\">\r\n              {trunks.filter(t => t.registration?.status === 'registered').length}\r\n            </div>\r\n            <div className=\"text-sm text-blue-600\">Active</div>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n\r\n  const renderSipTrunksCard = () => (\r\n    <Card \r\n      className={`cursor-pointer transition-all duration-200 ${\r\n        activeView === 'trunks' \r\n          ? 'ring-2 ring-blue-500 shadow-lg' \r\n          : 'hover:shadow-md'\r\n      }`} \r\n      onClick={() => setActiveView('trunks')}\r\n    >\r\n      <CardContent className=\"p-6\">\r\n        <div className=\"flex items-center justify-between\">\r\n          <div className=\"flex items-center space-x-4\">\r\n            <div className=\"p-3 bg-green-100 rounded-lg\">\r\n              <Network className=\"h-6 w-6 text-green-600\" />\r\n            </div>\r\n            <div>\r\n              <h3 className=\"text-lg font-semibold\">SIP Trunks</h3>\r\n              <p className=\"text-sm text-gray-600\">Manage SIP trunk configurations and gateway settings</p>\r\n            </div>\r\n          </div>\r\n          <div className=\"text-right\">\r\n            <div className=\"text-2xl font-bold text-green-600\">{trunks.length}</div>\r\n            <div className=\"text-sm text-green-600\">Total</div>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n\r\n  const renderSipStatusView = () => (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <h3 className=\"text-lg font-semibold\">SIP Status Overview</h3>\r\n        <div className=\"flex space-x-2\">\r\n          <Button onClick={loadTrunks} variant=\"outline\" size=\"sm\">\r\n            <RefreshCw className=\"h-4 w-4 mr-2\" />\r\n            Refresh Trunks\r\n          </Button>\r\n          <Button onClick={loadExtensions} variant=\"outline\" size=\"sm\" disabled={extensionsLoading}>\r\n            <RefreshCw className={`h-4 w-4 mr-2 ${extensionsLoading ? 'animate-spin' : ''}`} />\r\n            {extensionsLoading ? 'Loading...' : 'Refresh Extensions'}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* SIP Status Submenu */}\r\n      <div className=\"w-full\">\r\n        <div className=\"flex w-full border-b border-gray-200 mb-4\">\r\n          <button\r\n            onClick={() => setSipStatusTab('trunks')}\r\n            className={`flex-1 px-4 py-2 text-sm font-medium transition-colors ${\r\n              sipStatusTab === 'trunks'\r\n                ? 'border-b-2 border-blue-600 text-blue-600'\r\n                : 'text-gray-500 hover:text-gray-700'\r\n            }`}\r\n          >\r\n            SIP Status Trunks\r\n          </button>\r\n          <button\r\n            onClick={() => setSipStatusTab('extensions')}\r\n            className={`flex-1 px-4 py-2 text-sm font-medium transition-colors ${\r\n              sipStatusTab === 'extensions'\r\n                ? 'border-b-2 border-blue-600 text-blue-600'\r\n                : 'text-gray-500 hover:text-gray-700'\r\n            }`}\r\n          >\r\n            SIP Status Extensions\r\n          </button>\r\n        </div>\r\n        \r\n        <div className=\"mt-4 space-y-6\">\r\n          {sipStatusTab === 'trunks' && renderSipStatusTrunks()}\r\n          {sipStatusTab === 'extensions' && renderSipStatusExtensions()}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n\r\n  const renderSipStatusTrunks = () => (\r\n    <>\r\n      {/* Status Summary */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\r\n        <Card>\r\n          <CardContent className=\"p-4\">\r\n            <div className=\"flex items-center space-x-2\">\r\n              <CheckCircle className=\"h-8 w-8 text-green-500\" />\r\n              <div>\r\n                <div className=\"text-2xl font-bold text-green-600\">\r\n                  {trunks.filter(t => t.registration?.status === 'registered').length}\r\n                </div>\r\n                <div className=\"text-sm text-green-600\">Registered Trunks</div>\r\n              </div>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n        <Card>\r\n          <CardContent className=\"p-4\">\r\n            <div className=\"flex items-center space-x-2\">\r\n              <XCircle className=\"h-8 w-8 text-red-500\" />\r\n              <div>\r\n                <div className=\"text-2xl font-bold text-red-600\">\r\n                  {trunks.filter(t => t.registration?.status === 'unregistered').length}\r\n                </div>\r\n                <div className=\"text-sm text-red-600\">Unregistered Trunks</div>\r\n              </div>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n        <Card>\r\n          <CardContent className=\"p-4\">\r\n            <div className=\"flex items-center space-x-2\">\r\n              <AlertCircle className=\"h-8 w-8 text-yellow-500\" />\r\n              <div>\r\n                <div className=\"text-2xl font-bold text-yellow-600\">\r\n                  {trunks.filter(t => t.registration?.status === 'failed').length}\r\n                </div>\r\n                <div className=\"text-sm text-yellow-600\">Failed Registrations</div>\r\n              </div>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      </div>\r\n\r\n      {/* Detailed Status Table */}\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle>Trunk Registration Status</CardTitle>\r\n        </CardHeader>\r\n        <CardContent>\r\n          <div className=\"overflow-x-auto\">\r\n            <table className=\"w-full border-collapse\">\r\n              <thead>\r\n                <tr className=\"border-b bg-gray-50\">\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Trunk Name</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Host</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Status</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Last Update</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Actions</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {trunks.map((trunk, index) => (\r\n                  <tr key={index} className=\"border-b hover:bg-gray-50\">\r\n                    <td className=\"p-3\">{trunk.name}</td>\r\n                    <td className=\"p-3\">{trunk.sip_config?.host}:{trunk.sip_config?.port}</td>\r\n                    <td className=\"p-3\">\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        {getStatusIcon(trunk.status || 'UNKNOWN')}\r\n                        <Badge variant={getStatusColor(trunk.status || 'UNKNOWN')}>\r\n                          {getStatusLabel(trunk.status || 'UNKNOWN')}\r\n                        </Badge>\r\n                      </div>\r\n                    </td>\r\n                    <td className=\"p-3\">\r\n                      <div className=\"flex items-center text-sm text-gray-500\">\r\n                        <Clock className=\"h-4 w-4 mr-1\" />\r\n                        {new Date().toLocaleTimeString()}\r\n                      </div>\r\n                    </td>\r\n                    <td className=\"p-3\">\r\n                      <div className=\"flex items-center space-x-1\">\r\n                        <Button\r\n                          variant=\"ghost\"\r\n                          size=\"sm\"\r\n                          title=\"View Details\"\r\n                          onClick={() => handleViewTrunk(trunk)}\r\n                        >\r\n                          <Eye className=\"h-4 w-4\" />\r\n                        </Button>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                ))}\r\n              </tbody>\r\n            </table>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    </>\r\n  );\r\n\r\n  const renderSipStatusExtensions = () => {\r\n    // Calculate extension statistics\r\n    const onlineCount = extensions.filter(ext => ext.status === 'registered').length;\r\n    const offlineCount = extensions.filter(ext => ext.status === 'unregistered').length;\r\n    const busyCount = extensions.filter(ext => ext.status === 'busy').length;\r\n\r\n    return (\r\n      <>\r\n        {/* Extensions Status Summary */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\r\n          <Card>\r\n            <CardContent className=\"p-4\">\r\n              <div className=\"flex items-center space-x-2\">\r\n                <CheckCircle className=\"h-8 w-8 text-green-500\" />\r\n                <div>\r\n                  <div className=\"text-2xl font-bold text-green-600\">{onlineCount}</div>\r\n                  <div className=\"text-sm text-green-600\">Online Extensions</div>\r\n                </div>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n          <Card>\r\n            <CardContent className=\"p-4\">\r\n              <div className=\"flex items-center space-x-2\">\r\n                <XCircle className=\"h-8 w-8 text-red-500\" />\r\n                <div>\r\n                  <div className=\"text-2xl font-bold text-red-600\">{offlineCount}</div>\r\n                  <div className=\"text-sm text-red-600\">Offline Extensions</div>\r\n                </div>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n          <Card>\r\n            <CardContent className=\"p-4\">\r\n              <div className=\"flex items-center space-x-2\">\r\n                <AlertCircle className=\"h-8 w-8 text-yellow-500\" />\r\n                <div>\r\n                  <div className=\"text-2xl font-bold text-yellow-600\">{busyCount}</div>\r\n                  <div className=\"text-sm text-yellow-600\">Busy Extensions</div>\r\n                </div>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n\r\n        {/* Extensions Status Table */}\r\n        <Card>\r\n          <CardHeader>\r\n            <CardTitle>Extension Registration Status</CardTitle>\r\n          </CardHeader>\r\n          <CardContent>\r\n            <div className=\"overflow-x-auto\">\r\n              <table className=\"w-full border-collapse\">\r\n                <thead>\r\n                  <tr className=\"border-b bg-gray-50\">\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Extension</th>\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Display Name</th>\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Status</th>\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Last Seen</th>\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Contact</th>\r\n                      <th className=\"text-left p-3 font-medium text-gray-700\">Actions</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {extensionsLoading ? (\r\n                    <tr>\r\n                      <td colSpan={6} className=\"p-6 text-center text-gray-500\">\r\n                        Loading extensions...\r\n                      </td>\r\n                    </tr>\r\n                  ) : extensions.length === 0 ? (\r\n                    <tr>\r\n                      <td colSpan={6} className=\"p-6 text-center text-gray-500\">\r\n                        No extensions found\r\n                      </td>\r\n                    </tr>\r\n                  ) : (\r\n                    extensions.map((ext, index) => (\r\n                      <tr key={index} className=\"border-b hover:bg-gray-50\">\r\n                        <td className=\"p-3\">{ext.extension}</td>\r\n                        <td className=\"p-3\">{ext.display_name}</td>\r\n                        <td className=\"p-3\">\r\n                          <div className=\"flex items-center space-x-2\">\r\n                            {getStatusIcon(ext.status)}\r\n                            <Badge variant={getStatusColor(ext.status)}>\r\n                              {getStatusLabel(ext.status)}\r\n                            </Badge>\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"p-3\">\r\n                          <div className=\"flex items-center text-sm text-gray-500\">\r\n                            <Clock className=\"h-4 w-4 mr-1\" />\r\n                            {ext.lastSeen ? new Date(ext.lastSeen).toLocaleTimeString() : 'Never'}\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"p-3\">\r\n                          <div className=\"text-sm text-gray-600 max-w-xs truncate\" title={ext.contact || 'N/A'}>\r\n                            {ext.contact || 'N/A'}\r\n                          </div>\r\n                        </td>\r\n                        <td className=\"p-3\">\r\n                          <div className=\"flex items-center space-x-1\">\r\n                            <Button\r\n                              variant=\"ghost\"\r\n                              size=\"sm\"\r\n                              title=\"View Details\"\r\n                              onClick={() => console.log('View extension:', ext)}\r\n                            >\r\n                              <Eye className=\"h-4 w-4\" />\r\n                            </Button>\r\n                          </div>\r\n                        </td>\r\n                      </tr>\r\n                    ))\r\n                  )}\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n          </CardContent>\r\n        </Card>\r\n      </>\r\n    );\r\n  };\r\n\r\n  const handleCreateTrunk = () => {\r\n    setModalType('create');\r\n    setFormData({});\r\n    setEditingItem(null);\r\n    setShowModal(true);\r\n  };\r\n\r\n\r\n  const handleViewTrunk = (trunk: any) => {\r\n    setModalType('view');\r\n    setFormData(trunk);\r\n    setEditingItem(trunk);\r\n    setShowModal(true);\r\n  };\r\n\r\n\r\n  const handleSaveTrunk = async () => {\r\n    setLoading(true);\r\n    try {\r\n      // Prepare the data according to the API schema\r\n      const trunkData = {\r\n        name: formData.name,\r\n        provider: formData.provider,\r\n        status: modalType === 'create' ? 'testing' : formData.status || 'active',\r\n        sip_config: {\r\n          host: formData.sip_config?.host || formData.proxy,\r\n          port: formData.sip_config?.port || formData.port || 5060,\r\n          transport: formData.sip_config?.transport || formData.transport || 'udp',\r\n          username: formData.sip_config?.username || formData.auth_username,\r\n          password: formData.sip_config?.password || formData.auth_password,\r\n          realm: formData.sip_config?.realm || formData.realm,\r\n          register: true,\r\n          retry_seconds: 60,\r\n          caller_id_in_from: false,\r\n          ping: true,\r\n          ping_time: 60\r\n        },\r\n        did_config: {\r\n          number: formData.did_config?.number || formData.number,\r\n          country_code: formData.did_config?.country_code || formData.country_code,\r\n          local_number: formData.did_config?.local_number || formData.local_number,\r\n          area_code: formData.did_config?.area_code,\r\n          provider_did: formData.did_config?.provider_did,\r\n          inbound_route: formData.did_config?.inbound_route\r\n        },\r\n        security: {\r\n          encryption: formData.security?.encryption || formData.encryption || 'tls',\r\n          authentication: formData.security?.authentication || formData.authentication || 'digest',\r\n          acl: [],\r\n          rate_limit: {\r\n            enabled: true,\r\n            calls_per_minute: 60,\r\n            calls_per_hour: 1000\r\n          }\r\n        },\r\n        gdpr: {\r\n          data_retention_days: formData.gdpr?.data_retention_days || formData.data_retention_days || 365,\r\n          recording_consent_required: formData.gdpr?.recording_consent_required || formData.recording_consent_required || true,\r\n          data_processing_purpose: 'Business communications',\r\n          lawful_basis: 'legitimate_interest',\r\n          data_controller: formData.gdpr?.data_controller || formData.data_controller,\r\n          dpo_contact: formData.gdpr?.dpo_contact || formData.dpo_contact\r\n        }\r\n      };\r\n\r\n      if (modalType === 'create') {\r\n        // Create new trunk via API\r\n        const response = await apiClient.post('/sip-trunks', trunkData);\r\n        if ((response.data as any)?.success) {\r\n          setTrunks(prev => [(response.data as any).data, ...prev]);\r\n          alert('SIP Trunk created successfully!');\r\n        }\r\n      } else if (modalType === 'edit') {\r\n        // Update existing trunk via API\r\n        const response = await apiClient.put(`/sip-trunks/${editingItem.id}`, trunkData);\r\n        if ((response.data as any)?.success) {\r\n          setTrunks(prev => prev.map(trunk => \r\n            trunk.id === editingItem.id \r\n              ? (response.data as any).data\r\n              : trunk\r\n          ));\r\n          alert('SIP Trunk updated successfully!');\r\n        }\r\n      }\r\n      \r\n      setShowModal(false);\r\n    } catch (error) {\r\n      console.error('Error saving trunk:', error);\r\n      alert('Error saving SIP trunk. Please check the console for details.');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const renderSipTrunksView = () => (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <h3 className=\"text-lg font-semibold\">SIP Trunks Management</h3>\r\n        <div className=\"flex items-center space-x-2\">\r\n          <Button onClick={loadTrunks} variant=\"outline\" size=\"sm\">\r\n            <RefreshCw className=\"h-4 w-4 mr-2\" />\r\n            Refresh\r\n          </Button>\r\n          <Button onClick={handleCreateTrunk}>\r\n            <Plus className=\"h-4 w-4 mr-2\" />\r\n            Create New SIP Trunk\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Search */}\r\n      <div className=\"flex items-center space-x-2\">\r\n        <Search className=\"h-4 w-4 text-gray-500\" />\r\n        <Input\r\n          placeholder=\"Search trunks...\"\r\n          value={searchTerm}\r\n          onChange={(e) => setSearchTerm(e.target.value)}\r\n        />\r\n      </div>\r\n\r\n      {/* Data Table */}\r\n      <Card>\r\n        <CardContent className=\"p-0\">\r\n          <div className=\"overflow-x-auto\">\r\n            <table className=\"w-full border-collapse\">\r\n              <thead>\r\n                <tr className=\"border-b bg-gray-50\">\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Name</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Provider</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Host</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Status</th>\r\n                  <th className=\"text-left p-3 font-medium text-gray-700\">Actions</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {trunks.map((trunk, index) => (\r\n                  <tr key={index} className=\"border-b hover:bg-gray-50\">\r\n                    <td className=\"p-3\">{trunk.name}</td>\r\n                    <td className=\"p-3\">{trunk.provider}</td>\r\n                    <td className=\"p-3\">{trunk.sip_config?.host}:{trunk.sip_config?.port}</td>\r\n                    <td className=\"p-3\">\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        {getStatusIcon(trunk.status || 'UNKNOWN')}\r\n                        <Badge variant={getStatusColor(trunk.status || 'UNKNOWN')}>\r\n                          {getStatusLabel(trunk.status || 'UNKNOWN')}\r\n                        </Badge>\r\n                      </div>\r\n                    </td>\r\n                    <td className=\"p-3\">\r\n                      <div className=\"flex items-center space-x-1\">\r\n                        <Button\r\n                          variant=\"ghost\"\r\n                          size=\"sm\"\r\n                          title=\"View Details\"\r\n                          onClick={() => handleViewTrunk(trunk)}\r\n                        >\r\n                          <Eye className=\"h-4 w-4\" />\r\n                        </Button>\r\n                        <Button\r\n                          variant=\"ghost\"\r\n                          size=\"sm\"\r\n                          title=\"Delete\"\r\n                        >\r\n                          <Trash2 className=\"h-4 w-4\" />\r\n                        </Button>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                ))}\r\n              </tbody>\r\n            </table>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n\r\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold\">SIP Management</h1>\n          <p className=\"text-gray-600\">Monitor SIP status and manage SIP trunk configurations</p>\n        </div>\n        <Button onClick={loadTrunks} variant=\"outline\">\n          <RefreshCw className=\"h-4 w-4 mr-2\" />\n          Refresh All\n        </Button>\n      </div>\n\n      {/* Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n        {renderSipStatusCard()}\n        {renderSipTrunksCard()}\n      </div>\n\n      {/* Embedded Content Below Cards */}\n      <div className=\"mt-6\">\n        {activeView === 'status' ? renderSipStatusView() : renderSipTrunksView()}\n      </div>\n\n      {/* Modal */}\r\n      {showModal && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <div className=\"bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\r\n            <div className=\"flex items-center justify-between mb-4\">\r\n              <h2 className=\"text-xl font-semibold\">\r\n                {modalType === 'create' ? 'Create New' : modalType === 'edit' ? 'Edit' : 'View'} SIP Trunk\r\n              </h2>\r\n              <Button variant=\"ghost\" size=\"sm\" onClick={() => setShowModal(false)}>\r\n                <X className=\"h-4 w-4\" />\r\n              </Button>\r\n            </div>\r\n            \r\n            <div className=\"space-y-6\">\r\n              {/* Basic Information */}\r\n              <div>\r\n                <h3 className=\"text-lg font-medium mb-4\">Basic Information</h3>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Trunk Name *</label>\r\n                    <Input \r\n                      value={formData.name || ''}\r\n                      onChange={(e) => setFormData({...formData, name: e.target.value})}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"Messagenet SIP Trunk\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Provider *</label>\r\n                    <Input \r\n                      value={formData.provider || ''}\r\n                      onChange={(e) => setFormData({...formData, provider: e.target.value})}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"Messagenet\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* SIP Configuration */}\r\n              <div>\r\n                <h3 className=\"text-lg font-medium mb-4\">SIP Configuration</h3>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Host/Proxy *</label>\r\n                    <Input \r\n                      value={formData.sip_config?.host || formData.proxy || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        sip_config: {...formData.sip_config, host: e.target.value},\r\n                        proxy: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"sip.messagenet.it\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Port *</label>\r\n                    <Input \r\n                      type=\"number\"\r\n                      value={formData.sip_config?.port || formData.port || 5060}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        sip_config: {...formData.sip_config, port: parseInt(e.target.value)},\r\n                        port: parseInt(e.target.value)\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"5060\"\r\n                      min=\"1\"\r\n                      max=\"65535\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Transport *</label>\r\n                    <Select \r\n                      value={formData.sip_config?.transport || formData.transport || 'udp'}\r\n                      onValueChange={(value) => setFormData({\r\n                        ...formData, \r\n                        sip_config: {...formData.sip_config, transport: value},\r\n                        transport: value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    >\r\n                      <SelectTrigger>\r\n                        <SelectValue />\r\n                      </SelectTrigger>\r\n                      <SelectContent>\r\n                        <SelectItem value=\"udp\">UDP</SelectItem>\r\n                        <SelectItem value=\"tcp\">TCP</SelectItem>\r\n                        <SelectItem value=\"tls\">TLS</SelectItem>\r\n                      </SelectContent>\r\n                    </Select>\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Username *</label>\r\n                    <Input \r\n                      value={formData.sip_config?.username || formData.auth_username || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        sip_config: {...formData.sip_config, username: e.target.value},\r\n                        auth_username: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"messagenet_user\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Password *</label>\r\n                    <div className=\"relative\">\r\n                      <Input \r\n                        type={showPassword ? \"text\" : \"password\"}\r\n                        value={formData.sip_config?.password || formData.auth_password || ''}\r\n                        onChange={(e) => setFormData({\r\n                          ...formData, \r\n                          sip_config: {...formData.sip_config, password: e.target.value},\r\n                          auth_password: e.target.value\r\n                        })}\r\n                        disabled={modalType === 'view'}\r\n                        placeholder=\"messagenet_password\"\r\n                        required\r\n                      />\r\n                      <Button\r\n                        type=\"button\"\r\n                        variant=\"ghost\"\r\n                        size=\"sm\"\r\n                        className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n                        onClick={() => setShowPassword(!showPassword)}\r\n                        disabled={modalType === 'view'}\r\n                      >\r\n                        {showPassword ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\r\n                      </Button>\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Realm</label>\r\n                    <Input \r\n                      value={formData.sip_config?.realm || formData.realm || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        sip_config: {...formData.sip_config, realm: e.target.value},\r\n                        realm: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"messagenet.it\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* DID Configuration */}\r\n              <div>\r\n                <h3 className=\"text-lg font-medium mb-4\">DID Configuration</h3>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">DID Number *</label>\r\n                    <Input \r\n                      value={formData.did_config?.number || formData.number || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        did_config: {...formData.did_config, number: e.target.value},\r\n                        number: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"+393331234567\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Country Code *</label>\r\n                    <Input \r\n                      value={formData.did_config?.country_code || formData.country_code || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        did_config: {...formData.did_config, country_code: e.target.value},\r\n                        country_code: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"IT\"\r\n                      maxLength={2}\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Local Number *</label>\r\n                    <Input \r\n                      value={formData.did_config?.local_number || formData.local_number || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        did_config: {...formData.did_config, local_number: e.target.value},\r\n                        local_number: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"1234567\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Area Code</label>\r\n                    <Input \r\n                      value={formData.did_config?.area_code || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        did_config: {...formData.did_config, area_code: e.target.value}\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"333\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Security Configuration */}\r\n              <div>\r\n                <h3 className=\"text-lg font-medium mb-4\">Security Configuration</h3>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Encryption</label>\r\n                    <Select \r\n                      value={formData.security?.encryption || formData.encryption || 'tls'}\r\n                      onValueChange={(value) => setFormData({\r\n                        ...formData, \r\n                        security: {...formData.security, encryption: value},\r\n                        encryption: value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    >\r\n                      <SelectTrigger>\r\n                        <SelectValue />\r\n                      </SelectTrigger>\r\n                      <SelectContent>\r\n                        <SelectItem value=\"none\">None</SelectItem>\r\n                        <SelectItem value=\"tls\">TLS</SelectItem>\r\n                        <SelectItem value=\"srtp\">SRTP</SelectItem>\r\n                      </SelectContent>\r\n                    </Select>\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Authentication</label>\r\n                    <Select \r\n                      value={formData.security?.authentication || formData.authentication || 'digest'}\r\n                      onValueChange={(value) => setFormData({\r\n                        ...formData, \r\n                        security: {...formData.security, authentication: value},\r\n                        authentication: value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    >\r\n                      <SelectTrigger>\r\n                        <SelectValue />\r\n                      </SelectTrigger>\r\n                      <SelectContent>\r\n                        <SelectItem value=\"none\">None</SelectItem>\r\n                        <SelectItem value=\"digest\">Digest</SelectItem>\r\n                        <SelectItem value=\"tls\">TLS</SelectItem>\r\n                      </SelectContent>\r\n                    </Select>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* GDPR Configuration */}\r\n              <div>\r\n                <h3 className=\"text-lg font-medium mb-4\">GDPR Configuration</h3>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Data Retention (days)</label>\r\n                    <Input \r\n                      type=\"number\"\r\n                      value={formData.gdpr?.data_retention_days || formData.data_retention_days || 365}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        gdpr: {...formData.gdpr, data_retention_days: parseInt(e.target.value)},\r\n                        data_retention_days: parseInt(e.target.value)\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      min=\"30\"\r\n                      max=\"2555\"\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">Data Controller *</label>\r\n                    <Input \r\n                      value={formData.gdpr?.data_controller || formData.data_controller || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        gdpr: {...formData.gdpr, data_controller: e.target.value},\r\n                        data_controller: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"Company Name SRL\"\r\n                      required\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <label className=\"text-sm font-medium\">DPO Contact</label>\r\n                    <Input \r\n                      type=\"email\"\r\n                      value={formData.gdpr?.dpo_contact || formData.dpo_contact || ''}\r\n                      onChange={(e) => setFormData({\r\n                        ...formData, \r\n                        gdpr: {...formData.gdpr, dpo_contact: e.target.value},\r\n                        dpo_contact: e.target.value\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"dpo@company.com\"\r\n                    />\r\n                  </div>\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Switch \r\n                      checked={formData.gdpr?.recording_consent_required || formData.recording_consent_required || true}\r\n                      onCheckedChange={(checked) => setFormData({\r\n                        ...formData, \r\n                        gdpr: {...formData.gdpr, recording_consent_required: checked},\r\n                        recording_consent_required: checked\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    />\r\n                    <span className=\"text-sm font-medium\">Recording Consent Required</span>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n              \r\n              {formData.last_error && (\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Last Error</label>\r\n                  <div className=\"p-3 bg-red-50 border border-red-200 rounded-md\">\r\n                    <p className=\"text-sm text-red-600\">{formData.last_error}</p>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n            \r\n            {modalType !== 'view' && (\r\n              <div className=\"flex justify-end space-x-2 mt-6\">\r\n                <Button variant=\"outline\" onClick={() => setShowModal(false)}>\r\n                  <X className=\"h-4 w-4 mr-2\" />\r\n                  Cancel\r\n                </Button>\r\n                <Button onClick={handleSaveTrunk} disabled={loading} className=\"bg-blue-600 hover:bg-blue-700\">\r\n                  <Save className=\"h-4 w-4 mr-2\" />\r\n                  {loading ? 'Saving...' : 'Save Trunk'}\r\n                </Button>\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":43232},"scripts/deploy.sh":{"content":"#!/bin/bash\n\n# Production Deployment Script for EDG VoIP System\n\nset -e\n\necho \"🚀 EDG VoIP System - Production Deployment\"\necho \"==========================================\"\n\n# Load environment variables\nif [ -f \"env.production\" ]; then\n    export $(cat env.production | grep -v '^#' | xargs)\n    echo \"✅ Loaded production environment variables\"\nelse\n    echo \"❌ env.production file not found!\"\n    exit 1\nfi\n\n# Check required tools\necho \"\"\necho \"📋 Checking prerequisites...\"\ncommand -v docker >/dev/null 2>&1 || { echo \"❌ Docker is required\"; exit 1; }\ncommand -v docker-compose >/dev/null 2>&1 || { echo \"❌ Docker Compose is required\"; exit 1; }\necho \"✅ All prerequisites met\"\n\n# Build Docker images\necho \"\"\necho \"🔨 Building Docker images...\"\ndocker-compose -f docker-compose.prod.yml build --no-cache\n\n# Stop existing containers\necho \"\"\necho \"🛑 Stopping existing containers...\"\ndocker-compose -f docker-compose.prod.yml down\n\n# Run database migrations\necho \"\"\necho \"📊 Running database migrations...\"\ndocker-compose -f docker-compose.prod.yml run --rm backend npm run migrate\n\n# Seed database with initial data\necho \"\"\necho \"🌱 Seeding database...\"\ndocker-compose -f docker-compose.prod.yml run --rm backend npm run seed\n\n# Start services\necho \"\"\necho \"🎯 Starting services...\"\ndocker-compose -f docker-compose.prod.yml up -d\n\n# Wait for services to be healthy\necho \"\"\necho \"⏳ Waiting for services to become healthy...\"\nsleep 10\n\n# Check health\necho \"\"\necho \"🏥 Checking service health...\"\ndocker-compose -f docker-compose.prod.yml ps\n\n# Test API endpoint\necho \"\"\necho \"🧪 Testing API endpoints...\"\nsleep 5\ncurl -f http://localhost/api/health || echo \"⚠️  Health check failed\"\n\necho \"\"\necho \"✅ Deployment completed successfully!\"\necho \"\"\necho \"📝 Next steps:\"\necho \"  1. Configure your domain in env.production\"\necho \"  2. Set up SSL certificates in ./ssl/\"\necho \"  3. Update nginx-prod.conf with your domain\"\necho \"  4. Run: docker-compose -f docker-compose.prod.yml restart nginx\"\necho \"\"\necho \"🔗 Access points:\"\necho \"  - Frontend: https://your-domain.com\"\necho \"  - API: https://your-domain.com/api\"\necho \"  - Super Admin: https://your-domain.com/edgvoip/login\"\necho \"\"\n\n","size_bytes":2221},"packages/frontend/src/pages/SuperAdminLogin.tsx":{"content":"import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Loader2, Shield, Building2 } from 'lucide-react';\nimport apiClient from '@/lib/api';\n\nexport default function SuperAdminLogin() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const navigate = useNavigate();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setLoading(true);\n    setError('');\n\n    try {\n      const response = await apiClient.post(`/edgvoip/login`, {\n        email,\n        password,\n      });\n\n      if (response.success && response.data?.token) {\n        // Store token\n        localStorage.setItem('token', response.data.token);\n        apiClient.setToken(response.data.token);\n\n        // Verify user is super admin\n        if (response.data.user?.role !== 'super_admin') {\n          throw new Error('Access denied. Super admin privileges required.');\n        }\n\n        // Redirect to super admin dashboard\n        navigate('/edgvoip/dashboard');\n      } else {\n        throw new Error(response.error || 'Login failed');\n      }\n    } catch (err: any) {\n      setError(err.message || 'Login failed');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center \n                bg-gradient-to-br from-purple-600 via-purple-500 to-indigo-600\n                bg-[length:400%_400%] animate-gradient p-4\">\n      <Card variant=\"glass\" className=\"w-full max-w-md p-8\">\n        <CardHeader className=\"text-center\">\n          <div className=\"flex justify-center mb-4\">\n            <div className=\"p-4 bg-white/20 backdrop-blur-sm rounded-full border border-white/30 shadow-glass\">\n              <Shield className=\"h-10 w-10 text-white\" />\n            </div>\n          </div>\n          <CardTitle className=\"text-2xl font-bold text-white\">\n            Super Admin Login\n          </CardTitle>\n          <CardDescription className=\"text-white/80\">\n            Access the EDG VoIP Master Dashboard\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <form onSubmit={handleSubmit} className=\"space-y-6\">\n            {error && (\n              <Alert variant=\"destructive\" className=\"glass-light\">\n                <AlertDescription>{error}</AlertDescription>\n              </Alert>\n            )}\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"email\" className=\"text-sm font-medium text-white\">Email</Label>\n              <Input\n                id=\"email\"\n                type=\"email\"\n                placeholder=\"admin@edgvoip.it\"\n                value={email}\n                onChange={(e) => setEmail(e.target.value)}\n                required\n                disabled={loading}\n                className=\"glass-input focus:ring-2 focus:ring-purple-500/50 \n                          transition-all duration-200\"\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"password\" className=\"text-sm font-medium text-white\">Password</Label>\n              <Input\n                id=\"password\"\n                type=\"password\"\n                placeholder=\"Enter your password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                required\n                disabled={loading}\n                className=\"glass-input focus:ring-2 focus:ring-purple-500/50 \n                          transition-all duration-200\"\n              />\n            </div>\n\n            <Button\n              type=\"submit\"\n              variant=\"gradient\"\n              className=\"w-full hover:scale-[1.02] transition-all duration-200\"\n              disabled={loading}\n            >\n              {loading ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Signing in...\n                </>\n              ) : (\n                <>\n                  <Shield className=\"mr-2 h-4 w-4\" />\n                  Access Master Dashboard\n                </>\n              )}\n            </Button>\n          </form>\n\n          <div className=\"mt-6 pt-6 border-t border-white/20\">\n            <div className=\"text-center text-sm text-white/80\">\n              <div className=\"flex items-center justify-center mb-2\">\n                <Building2 className=\"h-4 w-4 mr-2\" />\n                <span>EDG VoIP Master Tenant</span>\n              </div>\n              <p>Cross-tenant management and analytics</p>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}","size_bytes":5019},"packages/frontend/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}","size_bytes":4838},"packages/frontend/src/pages/TimeConditions.tsx":{"content":"import { useState, useEffect } from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { \r\n  Plus, \r\n  Search, \r\n  Edit, \r\n  Trash2, \r\n  Clock,\r\n  Settings,\r\n  Eye,\r\n  MoreHorizontal,\r\n  RefreshCw,\r\n  Calendar,\r\n  Phone,\r\n  Users,\r\n  Menu,\r\n  Mic,\r\n  PhoneCall\r\n} from 'lucide-react';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\ninterface TimeCondition {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  timezone: string;\r\n  conditions: Array<{\r\n    day_of_week: number; // 0-6 (Sunday-Saturday)\r\n    start_time: string; // HH:MM format\r\n    end_time: string; // HH:MM format\r\n    is_active: boolean;\r\n  }>;\r\n  action_true: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'ivr' | 'hangup';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  action_false: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'ivr' | 'hangup';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport default function TimeConditions() {\r\n  const { user } = useAuth();\r\n  const [timeConditions, setTimeConditions] = useState<TimeCondition[]>([]);\r\n  const [showModal, setShowModal] = useState(false);\r\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\r\n  const [loading, setLoading] = useState(false);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [formData, setFormData] = useState<Partial<TimeCondition>>({});\r\n  const [editingItem, setEditingItem] = useState<TimeCondition | null>(null);\r\n\r\n  // Load time conditions on component mount\r\n  useEffect(() => {\r\n    loadTimeConditions();\r\n  }, []);\r\n\r\n  const loadTimeConditions = async () => {\r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/time-conditions`);\r\n      const data = await response.json();\r\n      \r\n      if (data?.success && Array.isArray(data?.data)) {\r\n        setTimeConditions(data.data);\r\n      } else {\r\n        console.warn('⚠️ Invalid API response format');\r\n        setTimeConditions([]);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error loading time conditions:', error);\r\n      setTimeConditions([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleCreate = async () => {\r\n    if (!user?.tenant_id) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/time-conditions`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          ...formData,\r\n          tenant_id: user.tenant_id\r\n        })\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadTimeConditions();\r\n        setShowModal(false);\r\n        setFormData({});\r\n      } else {\r\n        console.error('❌ Error creating time condition:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error creating time condition:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleEdit = async () => {\r\n    if (!editingItem) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/time-conditions/${editingItem.id}`, {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(formData)\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadTimeConditions();\r\n        setShowModal(false);\r\n        setFormData({});\r\n        setEditingItem(null);\r\n      } else {\r\n        console.error('❌ Error updating time condition:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error updating time condition:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (condition: TimeCondition) => {\r\n    if (!confirm(`Are you sure you want to delete time condition \"${condition.name}\"?`)) {\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/time-conditions/${condition.id}`, {\r\n        method: 'DELETE'\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadTimeConditions();\r\n      } else {\r\n        console.error('❌ Error deleting time condition:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error deleting time condition:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const filteredConditions = timeConditions.filter(condition =>\r\n    condition.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n    condition.description?.toLowerCase().includes(searchTerm.toLowerCase())\r\n  );\r\n\r\n  const getDayName = (dayOfWeek: number) => {\r\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n    return days[dayOfWeek];\r\n  };\r\n\r\n  const getActionIcon = (action: string) => {\r\n    switch (action) {\r\n      case 'extension': return <Phone className=\"h-4 w-4\" />;\r\n      case 'queue': return <Users className=\"h-4 w-4\" />;\r\n      case 'ivr': return <Menu className=\"h-4 w-4\" />;\r\n      case 'voicemail': return <Mic className=\"h-4 w-4\" />;\r\n      case 'hangup': return <PhoneCall className=\"h-4 w-4\" />;\r\n      default: return <Settings className=\"h-4 w-4\" />;\r\n    }\r\n  };\r\n\r\n  const getActionLabel = (action: string) => {\r\n    switch (action) {\r\n      case 'extension': return 'Extension';\r\n      case 'queue': return 'Queue';\r\n      case 'ivr': return 'IVR';\r\n      case 'voicemail': return 'Voicemail';\r\n      case 'hangup': return 'Hangup';\r\n      default: return action;\r\n    }\r\n  };\r\n\r\n  const getActionColor = (action: string) => {\r\n    switch (action) {\r\n      case 'extension': return 'bg-blue-100 text-blue-800';\r\n      case 'queue': return 'bg-green-100 text-green-800';\r\n      case 'ivr': return 'bg-purple-100 text-purple-800';\r\n      case 'voicemail': return 'bg-orange-100 text-orange-800';\r\n      case 'hangup': return 'bg-red-100 text-red-800';\r\n      default: return 'bg-gray-100 text-gray-800';\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Time Conditions</h1>\r\n          <p className=\"text-gray-600\">Create time-based call routing rules</p>\r\n        </div>\r\n        <Button onClick={() => {\r\n          setModalType('create');\r\n          setFormData({\r\n            timezone: 'UTC',\r\n            conditions: [],\r\n            action_true: { type: 'extension', destination: '' },\r\n            action_false: { type: 'hangup', destination: '' }\r\n          });\r\n          setShowModal(true);\r\n        }}>\r\n          <Plus className=\"h-4 w-4 mr-2\" />\r\n          Add Time Condition\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Search and Stats */}\r\n      <div className=\"flex items-center space-x-4\">\r\n        <div className=\"relative flex-1 max-w-md\">\r\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\r\n          <Input\r\n            placeholder=\"Search time conditions...\"\r\n            value={searchTerm}\r\n            onChange={(e) => setSearchTerm(e.target.value)}\r\n            className=\"pl-10\"\r\n          />\r\n        </div>\r\n        <Button variant=\"outline\" onClick={loadTimeConditions} disabled={loading}>\r\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\r\n          Refresh\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Time Conditions Grid */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n        {filteredConditions.map((condition) => (\r\n          <Card key={condition.id} className=\"relative\">\r\n            <CardHeader className=\"pb-3\">\r\n              <div className=\"flex items-start justify-between\">\r\n                <div className=\"flex-1\">\r\n                  <CardTitle className=\"text-lg\">{condition.name}</CardTitle>\r\n                  <CardDescription>{condition.description}</CardDescription>\r\n                </div>\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Badge variant={condition.enabled ? 'default' : 'secondary'}>\r\n                    {condition.enabled ? 'Active' : 'Inactive'}\r\n                  </Badge>\r\n                  <Button variant=\"ghost\" size=\"sm\">\r\n                    <MoreHorizontal className=\"h-4 w-4\" />\r\n                  </Button>\r\n                </div>\r\n              </div>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              {/* Timezone */}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Clock className=\"h-4 w-4 text-gray-500\" />\r\n                <span className=\"text-sm text-gray-600\">{condition.timezone}</span>\r\n              </div>\r\n\r\n              {/* Conditions */}\r\n              <div className=\"space-y-2\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Calendar className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"text-sm text-gray-600\">\r\n                    {condition.conditions.length} condition{condition.conditions.length !== 1 ? 's' : ''}\r\n                  </span>\r\n                </div>\r\n                \r\n                {/* Time Conditions Preview */}\r\n                <div className=\"space-y-1\">\r\n                  {condition.conditions.slice(0, 2).map((timeCondition, index) => (\r\n                    <div key={index} className=\"flex items-center justify-between text-xs\">\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        <span className=\"text-gray-600\">{getDayName(timeCondition.day_of_week)}</span>\r\n                        <span className=\"text-gray-500\">\r\n                          {timeCondition.start_time} - {timeCondition.end_time}\r\n                        </span>\r\n                      </div>\r\n                      <Badge className={`${timeCondition.is_active ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'} text-xs`}>\r\n                        {timeCondition.is_active ? 'Active' : 'Inactive'}\r\n                      </Badge>\r\n                    </div>\r\n                  ))}\r\n                  {condition.conditions.length > 2 && (\r\n                    <div className=\"text-xs text-gray-500\">\r\n                      +{condition.conditions.length - 2} more conditions\r\n                    </div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"space-y-2\">\r\n                <div className=\"flex items-center justify-between text-xs\">\r\n                  <span className=\"text-gray-600\">True Action:</span>\r\n                  <Badge className={`${getActionColor(condition.action_true.type)} text-xs flex items-center space-x-1`}>\r\n                    {getActionIcon(condition.action_true.type)}\r\n                    <span>{getActionLabel(condition.action_true.type)}</span>\r\n                  </Badge>\r\n                </div>\r\n                <div className=\"flex items-center justify-between text-xs\">\r\n                  <span className=\"text-gray-600\">False Action:</span>\r\n                  <Badge className={`${getActionColor(condition.action_false.type)} text-xs flex items-center space-x-1`}>\r\n                    {getActionIcon(condition.action_false.type)}\r\n                    <span>{getActionLabel(condition.action_false.type)}</span>\r\n                  </Badge>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('edit');\r\n                    setFormData(condition);\r\n                    setEditingItem(condition);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Edit className=\"h-4 w-4 mr-1\" />\r\n                  Edit\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('view');\r\n                    setFormData(condition);\r\n                    setEditingItem(condition);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Eye className=\"h-4 w-4 mr-1\" />\r\n                  View\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => handleDelete(condition)}\r\n                  className=\"text-red-600 hover:text-red-700\"\r\n                >\r\n                  <Trash2 className=\"h-4 w-4\" />\r\n                </Button>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Empty State */}\r\n      {filteredConditions.length === 0 && !loading && (\r\n        <Card>\r\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n            <Clock className=\"h-12 w-12 text-gray-400 mb-4\" />\r\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No Time Conditions Found</h3>\r\n            <p className=\"text-gray-500 text-center mb-4\">\r\n              {searchTerm ? 'No time conditions match your search criteria.' : 'Create your first time condition to get started.'}\r\n            </p>\r\n            {!searchTerm && (\r\n              <Button onClick={() => {\r\n                setModalType('create');\r\n                setFormData({\r\n                  timezone: 'UTC',\r\n                  conditions: [],\r\n                  action_true: { type: 'extension', destination: '' },\r\n                  action_false: { type: 'hangup', destination: '' }\r\n                });\r\n                setShowModal(true);\r\n              }}>\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Create Time Condition\r\n              </Button>\r\n            )}\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Create/Edit Modal */}\r\n      {showModal && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <Card className=\"w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\r\n            <CardHeader>\r\n              <CardTitle>\r\n                {modalType === 'create' ? 'Create Time Condition' : \r\n                 modalType === 'edit' ? 'Edit Time Condition' : 'View Time Condition'}\r\n              </CardTitle>\r\n              <CardDescription>\r\n                {modalType === 'create' ? 'Create a new time-based routing rule' :\r\n                 modalType === 'edit' ? 'Update time condition settings' :\r\n                 'View time condition details'}\r\n              </CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-6\">\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Name</label>\r\n                  <Input\r\n                    value={formData.name || ''}\r\n                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"Business Hours\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Timezone</label>\r\n                  <Select\r\n                    value={formData.timezone || 'UTC'}\r\n                    onValueChange={(value) => setFormData({ ...formData, timezone: value })}\r\n                    disabled={modalType === 'view'}\r\n                  >\r\n                    <SelectTrigger>\r\n                      <SelectValue />\r\n                    </SelectTrigger>\r\n                    <SelectContent>\r\n                      <SelectItem value=\"UTC\">UTC</SelectItem>\r\n                      <SelectItem value=\"Europe/Rome\">Europe/Rome</SelectItem>\r\n                      <SelectItem value=\"America/New_York\">America/New_York</SelectItem>\r\n                      <SelectItem value=\"Asia/Tokyo\">Asia/Tokyo</SelectItem>\r\n                    </SelectContent>\r\n                  </Select>\r\n                </div>\r\n              </div>\r\n\r\n              <div>\r\n                <label className=\"text-sm font-medium\">Description</label>\r\n                <Textarea\r\n                  value={formData.description || ''}\r\n                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}\r\n                  disabled={modalType === 'view'}\r\n                  placeholder=\"Route calls during business hours\"\r\n                />\r\n              </div>\r\n\r\n              {/* Time Conditions */}\r\n              <div className=\"border-t pt-4\">\r\n                <h4 className=\"font-medium mb-3\">Time Conditions</h4>\r\n                <div className=\"space-y-3\">\r\n                  {(formData.conditions || []).map((condition, index) => (\r\n                    <div key={index} className=\"flex items-center space-x-3 p-3 border rounded\">\r\n                      <div className=\"w-32\">\r\n                        <Select\r\n                          value={condition.day_of_week.toString()}\r\n                          onValueChange={(value) => {\r\n                            const newConditions = [...(formData.conditions || [])];\r\n                            newConditions[index].day_of_week = parseInt(value);\r\n                            setFormData({ ...formData, conditions: newConditions });\r\n                          }}\r\n                          disabled={modalType === 'view'}\r\n                        >\r\n                          <SelectTrigger>\r\n                            <SelectValue />\r\n                          </SelectTrigger>\r\n                          <SelectContent>\r\n                            <SelectItem value=\"0\">Sunday</SelectItem>\r\n                            <SelectItem value=\"1\">Monday</SelectItem>\r\n                            <SelectItem value=\"2\">Tuesday</SelectItem>\r\n                            <SelectItem value=\"3\">Wednesday</SelectItem>\r\n                            <SelectItem value=\"4\">Thursday</SelectItem>\r\n                            <SelectItem value=\"5\">Friday</SelectItem>\r\n                            <SelectItem value=\"6\">Saturday</SelectItem>\r\n                          </SelectContent>\r\n                        </Select>\r\n                      </div>\r\n                      <div className=\"w-24\">\r\n                        <Input\r\n                          type=\"time\"\r\n                          value={condition.start_time}\r\n                          onChange={(e) => {\r\n                            const newConditions = [...(formData.conditions || [])];\r\n                            newConditions[index].start_time = e.target.value;\r\n                            setFormData({ ...formData, conditions: newConditions });\r\n                          }}\r\n                          disabled={modalType === 'view'}\r\n                        />\r\n                      </div>\r\n                      <div className=\"w-24\">\r\n                        <Input\r\n                          type=\"time\"\r\n                          value={condition.end_time}\r\n                          onChange={(e) => {\r\n                            const newConditions = [...(formData.conditions || [])];\r\n                            newConditions[index].end_time = e.target.value;\r\n                            setFormData({ ...formData, conditions: newConditions });\r\n                          }}\r\n                          disabled={modalType === 'view'}\r\n                        />\r\n                      </div>\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        <Switch\r\n                          checked={condition.is_active}\r\n                          onCheckedChange={(checked) => {\r\n                            const newConditions = [...(formData.conditions || [])];\r\n                            newConditions[index].is_active = checked;\r\n                            setFormData({ ...formData, conditions: newConditions });\r\n                          }}\r\n                          disabled={modalType === 'view'}\r\n                        />\r\n                        <label className=\"text-sm\">Active</label>\r\n                      </div>\r\n                      {modalType !== 'view' && (\r\n                        <Button\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                          onClick={() => {\r\n                            const newConditions = [...(formData.conditions || [])];\r\n                            newConditions.splice(index, 1);\r\n                            setFormData({ ...formData, conditions: newConditions });\r\n                          }}\r\n                          className=\"text-red-600 hover:text-red-700\"\r\n                        >\r\n                          <Trash2 className=\"h-4 w-4\" />\r\n                        </Button>\r\n                      )}\r\n                    </div>\r\n                  ))}\r\n                  \r\n                  {modalType !== 'view' && (\r\n                    <Button\r\n                      variant=\"outline\"\r\n                      onClick={() => {\r\n                        const newConditions = [...(formData.conditions || [])];\r\n                        newConditions.push({\r\n                          day_of_week: 1,\r\n                          start_time: '09:00',\r\n                          end_time: '17:00',\r\n                          is_active: true\r\n                        });\r\n                        setFormData({ ...formData, conditions: newConditions });\r\n                      }}\r\n                    >\r\n                      <Plus className=\"h-4 w-4 mr-2\" />\r\n                      Add Condition\r\n                    </Button>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">True Action</label>\r\n                  <div className=\"space-y-2\">\r\n                    <Select\r\n                      value={formData.action_true?.type || 'extension'}\r\n                      onValueChange={(value) => setFormData({ \r\n                        ...formData, \r\n                        action_true: { ...formData.action_true!, type: value as any }\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    >\r\n                      <SelectTrigger>\r\n                        <SelectValue />\r\n                      </SelectTrigger>\r\n                      <SelectContent>\r\n                        <SelectItem value=\"extension\">Extension</SelectItem>\r\n                        <SelectItem value=\"queue\">Queue</SelectItem>\r\n                        <SelectItem value=\"ivr\">IVR</SelectItem>\r\n                        <SelectItem value=\"voicemail\">Voicemail</SelectItem>\r\n                        <SelectItem value=\"hangup\">Hangup</SelectItem>\r\n                      </SelectContent>\r\n                    </Select>\r\n                    <Input\r\n                      value={formData.action_true?.destination || ''}\r\n                      onChange={(e) => setFormData({ \r\n                        ...formData, \r\n                        action_true: { ...formData.action_true!, destination: e.target.value }\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"Destination\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">False Action</label>\r\n                  <div className=\"space-y-2\">\r\n                    <Select\r\n                      value={formData.action_false?.type || 'hangup'}\r\n                      onValueChange={(value) => setFormData({ \r\n                        ...formData, \r\n                        action_false: { ...formData.action_false!, type: value as any }\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                    >\r\n                      <SelectTrigger>\r\n                        <SelectValue />\r\n                      </SelectTrigger>\r\n                      <SelectContent>\r\n                        <SelectItem value=\"extension\">Extension</SelectItem>\r\n                        <SelectItem value=\"queue\">Queue</SelectItem>\r\n                        <SelectItem value=\"ivr\">IVR</SelectItem>\r\n                        <SelectItem value=\"voicemail\">Voicemail</SelectItem>\r\n                        <SelectItem value=\"hangup\">Hangup</SelectItem>\r\n                      </SelectContent>\r\n                    </Select>\r\n                    <Input\r\n                      value={formData.action_false?.destination || ''}\r\n                      onChange={(e) => setFormData({ \r\n                        ...formData, \r\n                        action_false: { ...formData.action_false!, destination: e.target.value }\r\n                      })}\r\n                      disabled={modalType === 'view'}\r\n                      placeholder=\"Destination\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Modal Actions */}\r\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  onClick={() => {\r\n                    setShowModal(false);\r\n                    setFormData({});\r\n                    setEditingItem(null);\r\n                  }}\r\n                >\r\n                  Cancel\r\n                </Button>\r\n                {modalType !== 'view' && (\r\n                  <Button\r\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\r\n                    disabled={loading}\r\n                  >\r\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\r\n                  </Button>\r\n                )}\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":27061},"packages/frontend/public/CHROME_EXTENSION_FIX.md":{"content":"# 🛡️ Chrome Extension Error Fix\n\n## Problema\nGli errori delle estensioni Chrome stanno interferendo con lo sviluppo dell'applicazione EDG VoIP.\n\n## Soluzioni Implementate\n\n### 1. ✅ Extension Blocker Immediato\n- Script caricato nel `<head>` che blocca immediatamente tutti gli errori\n- Intercetta console.error, console.warn, console.log\n- Blocca fetch() e XMLHttpRequest alle estensioni\n\n### 2. ✅ Service Worker\n- Intercetta le richieste a livello di rete\n- Blocca tutte le richieste a `chrome-extension://`\n- File: `/sw.js`\n\n### 3. ✅ Content Security Policy\n- CSP che limita le risorse esterne\n- Blocca l'esecuzione di script delle estensioni\n\n## Soluzioni Manuali\n\n### Metodo 1: Modalità Incognito (Raccomandato)\n```bash\n# Apri Chrome in modalità incognito\nCtrl+Shift+N (Windows/Linux)\nCmd+Shift+N (Mac)\n```\n\n### Metodo 2: Disabilita Estensioni Specifiche\n1. Vai su `chrome://extensions/`\n2. Disabilita le estensioni che causano errori:\n   - Password managers\n   - Ad blockers\n   - Autocomplete extensions\n   - Developer tools extensions\n\n### Metodo 3: Chrome con Estensioni Disabilitate\n```bash\n# Avvia Chrome senza estensioni\nchrome.exe --disable-extensions --disable-plugins\n```\n\n### Metodo 4: Profilo Chrome Pulito\n1. Crea un nuovo profilo Chrome\n2. Non installare estensioni\n3. Usa questo profilo per lo sviluppo\n\n## Verifica della Soluzione\n\n### Controlla Console\n1. Apri DevTools (F12)\n2. Vai alla tab Console\n3. Dovresti vedere: `🛡️ Extension blocker loaded immediately`\n4. Non dovrebbero esserci errori delle estensioni\n\n### Controlla Network\n1. Vai alla tab Network\n2. Ricarica la pagina\n3. Non dovrebbero esserci richieste a `chrome-extension://`\n\n## File Coinvolti\n\n- `index.html` - Script di blocco immediato\n- `sw.js` - Service Worker per blocco rete\n- `chrome-extension-blocker.js` - Script di blocco avanzato\n- `error-handler.ts` - Handler TypeScript per errori\n\n## Note\n\n- Gli errori delle estensioni NON influenzano il funzionamento dell'app\n- L'app funziona perfettamente anche con gli errori\n- Questi errori sono solo \"rumore\" nella console\n- Il sistema di blocco è proattivo e previene gli errori\n\n## Test\n\n1. Apri http://localhost:5173/\n2. Login con: admin@edgvoip.local / admin123\n3. Verifica che non ci siano errori in console\n4. Tutte le funzionalità dovrebbero funzionare normalmente\n","size_bytes":2332},"packages/shared/src/types/w3-voip.ts":{"content":"import { z } from 'zod';\r\n\r\n// ===== VOIP TRUNKS =====\r\nexport const VoipTrunkSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  sip_domain: z.string(), // es. tenantA.pbx.w3suite.it\r\n  provider: z.string(), // nome carrier (es. Messagenet)\r\n  proxy: z.string(), // host/realm del registrar (es. sip.messagenet.it)\r\n  port: z.number().min(1).max(65535).default(5060),\r\n  transport: z.enum(['udp', 'tcp', 'tls']).default('udp'),\r\n  auth_username: z.string(), // user/URI del trunk\r\n  secret_ref: z.string(), // riferimento a segreto (vault/KMS)\r\n  register: z.boolean().default(true), // registrato o IP auth\r\n  expiry_seconds: z.number().min(60).max(3600).default(300),\r\n  codec_set: z.string().default('G729,PCMA,PCMU'), // priorità codec verso carrier\r\n  status: z.enum(['REG_OK', 'FAIL', 'UNKNOWN']).default('UNKNOWN'),\r\n  note: z.string().optional()\r\n});\r\n\r\nexport type VoipTrunk = z.infer<typeof VoipTrunkSchema>;\r\n\r\n// ===== VOIP DIDS =====\r\nexport const VoipDidSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  trunk_id: z.string().uuid(), // riferimento al trunk d'ingresso\r\n  e164: z.string().regex(/^\\+[1-9]\\d{1,14}$/), // numero in formato E.164\r\n  sip_domain: z.string().optional(), // dominio PBX (utile per lookup)\r\n  route_target_type: z.enum(['ext', 'ivr', 'queue', 'ai']), // destinazione\r\n  route_target_ref: z.string(), // riferimento concreto (es. 1001 o ivr_main)\r\n  label: z.string(), // alias descrittivo (es. \"Main Line Roma\")\r\n  active: z.boolean().default(true)\r\n});\r\n\r\nexport type VoipDid = z.infer<typeof VoipDidSchema>;\r\n\r\n// ===== VOIP EXTENSIONS =====\r\nexport const VoipExtensionSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  sip_domain: z.string(), // dominio PBX del tenant\r\n  ext_number: z.string().regex(/^[0-9]{3,6}$/), // numero interno (unico nel dominio)\r\n  display_name: z.string(), // nome mostrato (caller name)\r\n  enabled: z.boolean().default(true), // registrabile e chiamabile\r\n  voicemail_enabled: z.boolean().default(false), // se abilita VM\r\n  forward_rules: z.record(z.string()).optional(), // JSON semplice (busy/no-answer/off-hours → target)\r\n  class_of_service: z.enum(['agent', 'supervisor', 'admin']).default('agent'), // profilo chiamate consentite\r\n  note: z.string().optional() // testo libero (info/HR)\r\n});\r\n\r\nexport type VoipExtension = z.infer<typeof VoipExtensionSchema>;\r\n\r\n// ===== VOIP ROUTES =====\r\nexport const VoipRouteSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  name: z.string(), // nome rotta (es. \"Uscita nazionale\")\r\n  pattern: z.string(), // regex/pattern (es. ^9(\\d+)$)\r\n  strip_digits: z.number().min(0).default(0), // numeri da rimuovere (es. 1 per togliere il 9)\r\n  prepend: z.string().optional(), // prefisso da aggiungere (es. 0)\r\n  trunk_id: z.string().uuid(), // trunk da usare per l'uscita\r\n  priority: z.number().min(1).default(1), // ordine di valutazione\r\n  active: z.boolean().default(true)\r\n});\r\n\r\nexport type VoipRoute = z.infer<typeof VoipRouteSchema>;\r\n\r\n// ===== CONTACT POLICIES =====\r\nexport const ContactPolicySchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  scope_type: z.enum(['tenant', 'store', 'did', 'ext']), // ambito applicazione\r\n  scope_ref: z.string(), // id di riferimento (es. store_id o e164 o ext)\r\n  rules_json: z.record(z.any()), // JSON con orari apertura/chiusura, fallback (VM/AI/queue), annunci\r\n  active: z.boolean().default(true),\r\n  label: z.string() // alias descrittivo (es. \"Orari Roma\")\r\n});\r\n\r\nexport type ContactPolicy = z.infer<typeof ContactPolicySchema>;\r\n\r\n// ===== VOIP ACTIVITY LOG =====\r\nexport const VoipActivityLogSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  actor: z.string(), // user:<id> o system:w3-provisioner\r\n  action: z.enum(['create', 'update', 'delete', 'provision', 'sync']),\r\n  target_type: z.enum(['trunk', 'did', 'ext', 'route', 'policy']),\r\n  target_id: z.string().uuid(),\r\n  status: z.enum(['ok', 'fail']),\r\n  details_json: z.record(z.any()).optional(), // payload/diff/esito chiamate API verso PBX\r\n  ts: z.string().datetime() // timestamp evento (UTC)\r\n});\r\n\r\nexport type VoipActivityLog = z.infer<typeof VoipActivityLogSchema>;\r\n\r\n// ===== VOIP CDR =====\r\nexport const VoipCdrSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  sip_domain: z.string(), // dominio PBX (per correlazione multi-tenant)\r\n  call_id: z.string(), // ID chiamata PBX\r\n  direction: z.enum(['in', 'out']),\r\n  from_uri: z.string(), // sorgente (E.164 o ext)\r\n  to_uri: z.string(), // destinazione (E.164 o ext)\r\n  did_e164: z.string().optional(), // DID coinvolto (se inbound)\r\n  ext_number: z.string().optional(), // interno coinvolto (se presente)\r\n  start_ts: z.string().datetime(),\r\n  answer_ts: z.string().datetime().optional(),\r\n  end_ts: z.string().datetime(),\r\n  billsec: z.number().min(0).default(0), // secondi fatturati\r\n  disposition: z.enum(['ANSWERED', 'NO_ANSWER', 'BUSY', 'FAILED']),\r\n  recording_url: z.string().url().optional(), // link alla registrazione (se disponibile)\r\n  meta_json: z.record(z.any()).optional() // extra (codec, mos, cause codes)\r\n});\r\n\r\nexport type VoipCdr = z.infer<typeof VoipCdrSchema>;\r\n\r\n// ===== API REQUEST/RESPONSE TYPES =====\r\n\r\n// Create Trunk Request\r\nexport const CreateTrunkRequestSchema = z.object({\r\n  provider: z.string(),\r\n  proxy: z.string(),\r\n  port: z.number().min(1).max(65535).default(5060),\r\n  transport: z.enum(['udp', 'tcp', 'tls']).default('udp'),\r\n  auth_username: z.string(),\r\n  secret_ref: z.string(),\r\n  register: z.boolean().default(true),\r\n  expiry_seconds: z.number().min(60).max(3600).default(300),\r\n  codec_set: z.string().default('G729,PCMA,PCMU'),\r\n  note: z.string().optional(),\r\n  store_id: z.string().uuid().optional()\r\n});\r\n\r\nexport type CreateTrunkRequest = z.infer<typeof CreateTrunkRequestSchema>;\r\n\r\n// Create DID Request\r\nexport const CreateDidRequestSchema = z.object({\r\n  trunk_id: z.string().uuid(),\r\n  e164: z.string().regex(/^\\+[1-9]\\d{1,14}$/),\r\n  route_target_type: z.enum(['ext', 'ivr', 'queue', 'ai']),\r\n  route_target_ref: z.string(),\r\n  label: z.string(),\r\n  active: z.boolean().default(true),\r\n  store_id: z.string().uuid().optional()\r\n});\r\n\r\nexport type CreateDidRequest = z.infer<typeof CreateDidRequestSchema>;\r\n\r\n// Create Extension Request\r\nexport const CreateExtensionRequestSchema = z.object({\r\n  ext_number: z.string().regex(/^[0-9]{3,6}$/),\r\n  display_name: z.string(),\r\n  enabled: z.boolean().default(true),\r\n  voicemail_enabled: z.boolean().default(false),\r\n  forward_rules: z.record(z.string()).optional(),\r\n  class_of_service: z.enum(['agent', 'supervisor', 'admin']).default('agent'),\r\n  note: z.string().optional(),\r\n  store_id: z.string().uuid().optional()\r\n});\r\n\r\nexport type CreateExtensionRequest = z.infer<typeof CreateExtensionRequestSchema>;\r\n\r\n// Create Route Request\r\nexport const CreateRouteRequestSchema = z.object({\r\n  name: z.string(),\r\n  pattern: z.string(),\r\n  strip_digits: z.number().min(0).default(0),\r\n  prepend: z.string().optional(),\r\n  trunk_id: z.string().uuid(),\r\n  priority: z.number().min(1).default(1),\r\n  active: z.boolean().default(true)\r\n});\r\n\r\nexport type CreateRouteRequest = z.infer<typeof CreateRouteRequestSchema>;\r\n\r\n// Create Contact Policy Request\r\nexport const CreateContactPolicyRequestSchema = z.object({\r\n  scope_type: z.enum(['tenant', 'store', 'did', 'ext']),\r\n  scope_ref: z.string(),\r\n  rules_json: z.record(z.any()),\r\n  label: z.string(),\r\n  active: z.boolean().default(true)\r\n});\r\n\r\nexport type CreateContactPolicyRequest = z.infer<typeof CreateContactPolicyRequestSchema>;\r\n","size_bytes":7870},"packages/shared/src/types/cdr.ts":{"content":"import { z } from 'zod';\r\n\r\n// Call Detail Record schema\r\nexport const CDRSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  extension_id: z.string().uuid().optional(),\r\n  trunk_id: z.string().uuid().optional(),\r\n  \r\n  // Call identification\r\n  call_uuid: z.string().uuid(),\r\n  call_direction: z.enum(['inbound', 'outbound', 'internal']),\r\n  call_type: z.enum(['voice', 'video', 'fax']),\r\n  \r\n  // Caller information\r\n  caller_id_number: z.string().optional(),\r\n  caller_id_name: z.string().optional(),\r\n  caller_extension: z.string().optional(),\r\n  \r\n  // Callee information\r\n  callee_id_number: z.string().optional(),\r\n  callee_id_name: z.string().optional(),\r\n  callee_extension: z.string().optional(),\r\n  \r\n  // Call details\r\n  start_time: z.date(),\r\n  answer_time: z.date().optional(),\r\n  end_time: z.date(),\r\n  duration: z.number().min(0), // seconds\r\n  bill_seconds: z.number().min(0), // billable seconds\r\n  hangup_cause: z.string(),\r\n  hangup_disposition: z.enum(['answered', 'busy', 'no_answer', 'congestion', 'fail', 'timeout']),\r\n  \r\n  // Media information\r\n  audio_codec: z.string().optional(),\r\n  video_codec: z.string().optional(),\r\n  rtp_audio_in_mos: z.number().min(1).max(5).optional(), // Mean Opinion Score\r\n  rtp_audio_out_mos: z.number().min(1).max(5).optional(),\r\n  \r\n  // Recording\r\n  recording_enabled: z.boolean().default(false),\r\n  recording_path: z.string().optional(),\r\n  recording_duration: z.number().min(0).optional(),\r\n  recording_consent: z.boolean().optional(),\r\n  \r\n  // Network information\r\n  local_ip: z.string().optional(),\r\n  remote_ip: z.string().optional(),\r\n  local_port: z.number().optional(),\r\n  remote_port: z.number().optional(),\r\n  \r\n  // FreeSWITCH specific\r\n  fs_uuid: z.string().uuid(),\r\n  fs_domain: z.string(),\r\n  fs_context: z.string().optional(),\r\n  fs_profile: z.string().optional(),\r\n  \r\n  // Metadata\r\n  metadata: z.record(z.string()).optional(),\r\n  tags: z.array(z.string()).default([]),\r\n  \r\n  // Timestamps\r\n  created_at: z.date(),\r\n  updated_at: z.date()\r\n});\r\n\r\nexport type CDR = z.infer<typeof CDRSchema>;\r\n\r\n// CDR filter schema for queries\r\nexport const CDRFilterSchema = z.object({\r\n  tenant_id: z.string().uuid().optional(),\r\n  store_id: z.string().uuid().optional(),\r\n  extension_id: z.string().uuid().optional(),\r\n  trunk_id: z.string().uuid().optional(),\r\n  \r\n  // Date range\r\n  start_date: z.date().optional(),\r\n  end_date: z.date().optional(),\r\n  \r\n  // Call filters\r\n  call_direction: z.enum(['inbound', 'outbound', 'internal']).optional(),\r\n  call_type: z.enum(['voice', 'video', 'fax']).optional(),\r\n  hangup_disposition: z.enum(['answered', 'busy', 'no_answer', 'congestion', 'fail', 'timeout']).optional(),\r\n  \r\n  // Number filters\r\n  caller_number: z.string().optional(),\r\n  callee_number: z.string().optional(),\r\n  \r\n  // Duration filters\r\n  min_duration: z.number().min(0).optional(),\r\n  max_duration: z.number().min(0).optional(),\r\n  \r\n  // Recording filters\r\n  recording_enabled: z.boolean().optional(),\r\n  recording_consent: z.boolean().optional(),\r\n  \r\n  // Quality filters\r\n  min_mos: z.number().min(1).max(5).optional(),\r\n  \r\n  // Pagination\r\n  page: z.number().min(1).default(1),\r\n  limit: z.number().min(1).max(1000).default(50),\r\n  \r\n  // Sorting\r\n  sort_by: z.enum(['start_time', 'duration', 'caller_number', 'callee_number']).default('start_time'),\r\n  sort_order: z.enum(['asc', 'desc']).default('desc')\r\n});\r\n\r\nexport type CDRFilter = z.infer<typeof CDRFilterSchema>;\r\n\r\n// CDR statistics schema\r\nexport const CDRStatsSchema = z.object({\r\n  total_calls: z.number().min(0),\r\n  answered_calls: z.number().min(0),\r\n  missed_calls: z.number().min(0),\r\n  total_duration: z.number().min(0), // seconds\r\n  average_duration: z.number().min(0), // seconds\r\n  total_cost: z.number().min(0).optional(), // if billing enabled\r\n  \r\n  // By direction\r\n  inbound_calls: z.number().min(0),\r\n  outbound_calls: z.number().min(0),\r\n  internal_calls: z.number().min(0),\r\n  \r\n  // By disposition\r\n  disposition_stats: z.record(z.number().min(0)),\r\n  \r\n  // Quality metrics\r\n  average_mos: z.number().min(1).max(5).optional(),\r\n  \r\n  // Time period\r\n  period_start: z.date(),\r\n  period_end: z.date(),\r\n  \r\n  // Tenant isolation\r\n  tenant_id: z.string().uuid()\r\n});\r\n\r\nexport type CDRStats = z.infer<typeof CDRStatsSchema>;\r\n\r\n","size_bytes":4371},"packages/frontend/src/pages/Stores.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { Plus, Search, Edit, Trash2, Eye, Phone } from 'lucide-react';\nimport apiClient from '@/lib/api';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface Store {\n  id: string;\n  tenant_id: string;\n  name: string;\n  store_id: string;\n  sip_trunk_settings: any;\n  created_at: string;\n  updated_at: string;\n}\n\nexport default function Stores() {\n  const [stores, setStores] = useState<Store[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [searchTerm, setSearchTerm] = useState('');\n  const { toast } = useToast();\n\n  useEffect(() => {\n    loadStores();\n  }, []);\n\n  const loadStores = async () => {\n    try {\n      setIsLoading(true);\n      const response = await apiClient.getStores();\n      setStores((response.data as any)?.stores || []);\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load stores\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const filteredStores = stores.filter(store =>\n    store.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    store.store_id.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Stores</h1>\n          <p className=\"text-muted-foreground\">\n            Manage store locations and SIP trunk configurations\n          </p>\n        </div>\n        <Button>\n          <Plus className=\"h-4 w-4 mr-2\" />\n          Add Store\n        </Button>\n      </div>\n\n      {/* Search */}\n      <div className=\"flex items-center space-x-2\">\n        <div className=\"relative flex-1 max-w-sm\">\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n          <Input\n            placeholder=\"Search stores...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n            className=\"pl-10\"\n          />\n        </div>\n      </div>\n\n      {/* Stores Grid */}\n      <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n        {filteredStores.map((store) => (\n          <Card key={store.id}>\n            <CardHeader>\n              <div className=\"flex items-center justify-between\">\n                <CardTitle className=\"text-lg\">{store.name}</CardTitle>\n                <Badge variant=\"secondary\">Active</Badge>\n              </div>\n              <CardDescription>Store ID: {store.store_id}</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-2\">\n                <div className=\"text-sm\">\n                  <span className=\"font-medium\">SIP Trunk:</span>\n                  <span className=\"ml-2 text-muted-foreground\">\n                    {store.sip_trunk_settings?.provider || 'Not configured'}\n                  </span>\n                </div>\n                <div className=\"text-sm\">\n                  <span className=\"font-medium\">Created:</span>\n                  <span className=\"ml-2 text-muted-foreground\">\n                    {new Date(store.created_at).toLocaleDateString()}\n                  </span>\n                </div>\n              </div>\n              \n              <div className=\"flex space-x-2 mt-4\">\n                <Button variant=\"outline\" size=\"sm\">\n                  <Eye className=\"h-4 w-4 mr-1\" />\n                  View\n                </Button>\n                <Button variant=\"outline\" size=\"sm\">\n                  <Edit className=\"h-4 w-4 mr-1\" />\n                  Edit\n                </Button>\n                <Button variant=\"outline\" size=\"sm\">\n                  <Phone className=\"h-4 w-4 mr-1\" />\n                  SIP Config\n                </Button>\n                <Button variant=\"outline\" size=\"sm\">\n                  <Trash2 className=\"h-4 w-4 mr-1\" />\n                  Delete\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {filteredStores.length === 0 && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <div className=\"text-center\">\n              <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                No stores found\n              </h3>\n              <p className=\"text-gray-500 mb-4\">\n                {searchTerm ? 'Try adjusting your search terms.' : 'Get started by creating your first store.'}\n              </p>\n              <Button>\n                <Plus className=\"h-4 w-4 mr-2\" />\n                Add Store\n              </Button>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}","size_bytes":5214},"packages/frontend/vite.config.ts":{"content":"import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport path from 'path'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n      \"@voip/shared\": path.resolve(__dirname, \"../shared/src\"),\n    },\n  },\n  define: {\n    'import.meta.env': 'import.meta.env',\n    __API_BASE__: JSON.stringify(process.env.VITE_API_BASE_URL || 'http://localhost:3001/api')\n  },\n  server: {\n    port: 5000,\n    host: '0.0.0.0',\n    strictPort: true,\n    allowedHosts: true,\n    hmr: {\n      clientPort: 443,\n      protocol: 'wss'\n    },\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3001',\n        changeOrigin: true,\n        secure: false\n      }\n    }\n  },\n  build: {\n    outDir: 'dist',\n    sourcemap: true\n  }\n})\n","size_bytes":840},"packages/backend/src/routes/auth.routes.ts":{"content":"import express from 'express';\r\nimport bcrypt from 'bcrypt';\r\nimport jwt from 'jsonwebtoken';\r\nimport { getClient } from '@w3-voip/database';\r\nimport { validateTenantSlug, TenantRequest } from '../middleware/tenant.middleware';\r\n\r\nconst router = express.Router();\r\n\r\n/**\r\n * Super admin login: POST /superadmin/login\r\n * Authenticates super admin users (no tenant validation)\r\n */\r\nrouter.post('/superadmin/login', async (req, res) => {\r\n  console.log('🚀 SUPER ADMIN LOGIN ROUTE REACHED!');\r\n  console.log('Super admin login request body:', JSON.stringify(req.body));\r\n  const { email, password } = req.body;\r\n\r\n  if (!email || !password) {\r\n    console.log('❌ Missing email or password');\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Email and password are required'\r\n    });\r\n  }\r\n\r\n  try {\r\n    console.log(`🔍 Looking for super admin user: email=${email}, role=super_admin, status=active`);\r\n    const client = await getClient();\r\n    const result = await client.query(\r\n      'SELECT * FROM users WHERE email = $1 AND role = $2 AND status = $3',\r\n      [email, 'super_admin', 'active']\r\n    );\r\n\r\n    console.log(`📊 Query result: ${result.rows.length} users found`);\r\n    if (result.rows.length === 0) {\r\n      console.log('❌ No super admin user found');\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid credentials' \r\n      });\r\n    }\r\n\r\n    const user = result.rows[0];\r\n    console.log(`👤 User found: ${user.email}, role: ${user.role}`);\r\n    console.log(`🔐 Password hash: ${user.password_hash.substring(0, 20)}...`);\r\n    \r\n    const passwordValid = await bcrypt.compare(password, user.password_hash);\r\n    console.log(`🔑 Password validation result: ${passwordValid}`);\r\n\r\n    if (!passwordValid) {\r\n      console.log('❌ Password validation failed');\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid credentials' \r\n      });\r\n    }\r\n\r\n    // Create JWT token for super admin with 15 minutes session timeout\r\n    const token = jwt.sign(\r\n      {\r\n        id: user.id,\r\n        email: user.email,\r\n        role: user.role,\r\n        iat: Math.floor(Date.now() / 1000),\r\n        exp: Math.floor(Date.now() / 1000) + (15 * 60) // 15 minutes session timeout\r\n      },\r\n      process.env.JWT_SECRET || 'fallback-secret'\r\n    );\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        token,\r\n        user: {\r\n          id: user.id,\r\n          email: user.email,\r\n          firstName: user.first_name,\r\n          lastName: user.last_name,\r\n          role: user.role\r\n        }\r\n      },\r\n      message: 'Super admin login successful'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Super admin login error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n\n/**\n * Validate tenant exists: GET /:tenantSlug/validate\n * Public endpoint to check if a tenant exists (no authentication required)\n */\nrouter.get('/:tenantSlug/validate', validateTenantSlug, (req: TenantRequest, res) => {\n  return res.status(200).json({\n    success: true,\n    data: {\n      slug: req.tenant?.slug,\n      name: req.tenant?.name,\n      domain: req.tenant?.domain\n    }\n  });\n});\n\n/**\r\n * Tenant-scoped login: POST /:tenantSlug/login\r\n * Validates tenant slug and authenticates user within that tenant\r\n * Excludes 'superadmin' slug to avoid conflicts\r\n */\r\nrouter.post('/:tenantSlug/login', (req, res, next) => {\r\n  console.log('🔍 Checking tenantSlug:', req.params.tenantSlug);\r\n  if (req.params.tenantSlug === 'superadmin') {\r\n    console.log('❌ Blocking superadmin slug');\r\n    return res.status(404).json({\r\n      success: false,\r\n      error: 'Use /superadmin/login for super admin authentication'\r\n    });\r\n  }\r\n  console.log('✅ Allowing tenantSlug:', req.params.tenantSlug);\r\n  next();\r\n}, validateTenantSlug, async (req: TenantRequest, res) => {\r\n  console.log('🚀 LOGIN ROUTE REACHED!');\r\n  console.log('Login request body:', JSON.stringify(req.body));\r\n  console.log('Login request headers:', req.headers);\r\n  const { email, password } = req.body;\r\n  const tenant = req.tenant!;\r\n\r\n  if (!email || !password) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Email and password are required'\r\n    });\r\n  }\r\n\r\n  try {\r\n    const client = await getClient();\r\n    console.log(`Looking for user: email=${email}, tenant_id=${tenant.id}, status=active`);\r\n    const result = await client.query(\r\n      'SELECT * FROM users WHERE email = $1 AND tenant_id = $2 AND status = $3',\r\n      [email, tenant.id, 'active']\r\n    );\r\n    console.log(`Query result: ${result.rows.length} users found`);\r\n\r\n    if (result.rows.length === 0) {\r\n      console.log('No user found with these credentials');\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid credentials' \r\n      });\r\n    }\r\n\r\n    const user = result.rows[0];\r\n    console.log(`User found: ${user.email}, role: ${user.role}`);\r\n    const passwordValid = await bcrypt.compare(password, user.password_hash);\r\n    console.log(`Password validation result: ${passwordValid}`);\r\n\r\n    if (!passwordValid) {\r\n      console.log('Password validation failed');\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid credentials' \r\n      });\r\n    }\r\n\r\n    console.log('Login successful, creating JWT token');\r\n    // Create JWT token with 15 minutes session timeout\r\n    const token = jwt.sign(\r\n      {\r\n        id: user.id,\r\n        email: user.email,\r\n        tenant_id: user.tenant_id,\r\n        tenant_slug: tenant.slug,\r\n        role: user.role,\r\n        iat: Math.floor(Date.now() / 1000),\r\n        exp: Math.floor(Date.now() / 1000) + (15 * 60) // 15 minutes session timeout\r\n      },\r\n      process.env.JWT_SECRET || 'fallback-secret'\r\n    );\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        token,\r\n        user: {\r\n          id: user.id,\r\n          email: user.email,\r\n          firstName: user.first_name,\r\n          lastName: user.last_name,\r\n          role: user.role,\r\n          tenantId: user.tenant_id,\r\n          tenantSlug: tenant.slug\r\n        }\r\n      },\r\n      message: 'Login successful'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Login error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      error: 'Internal server error'\r\n    });\r\n  }\r\n});\r\n\r\n/**\r\n * Verify token endpoint\r\n */\r\nrouter.post('/verify-token', async (req, res) => {\r\n  const { token } = req.body;\r\n\r\n  if (!token) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Token is required'\r\n    });\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        valid: true,\r\n        user: {\r\n          id: decoded.id,\r\n          email: decoded.email,\r\n          role: decoded.role,\r\n          tenant_id: decoded.tenant_id,\r\n          tenant_slug: decoded.tenant_slug\r\n        }\r\n      }\r\n    });\r\n  } catch (error) {\r\n    res.status(401).json({\r\n      success: false,\r\n      error: 'Invalid or expired token'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;","size_bytes":7253},"packages/frontend/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }","size_bytes":1127},"packages/frontend/tailwind.config.js":{"content":"/** @type {import('tailwindcss').Config} */\nexport default {\n  darkMode: [\"class\"],\n  content: [\n    './pages/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './app/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n  ],\n  prefix: \"\",\n  theme: {\n    container: {\n      center: true,\n      padding: \"2rem\",\n      screens: {\n        \"2xl\": \"1400px\",\n      },\n    },\n    extend: {\n      colors: {\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n      },\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      backdropBlur: {\n        xs: '2px',\n        sm: '4px',\n        md: '8px',\n        lg: '12px',\n        xl: '16px',\n        '2xl': '24px',\n        '3xl': '40px',\n      },\n      boxShadow: {\n        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.37)',\n        'glass-lg': '0 12px 40px 0 rgba(31, 38, 135, 0.5)',\n        'glass-xl': '0 20px 60px 0 rgba(31, 38, 135, 0.6)',\n        'inner-glass': 'inset 0 1px 0 0 rgba(255, 255, 255, 0.2)',\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: \"0\" },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: \"0\" },\n        },\n        \"slideIn\": {\n          \"0%\": { transform: \"translateX(-100%)\", opacity: \"0\" },\n          \"100%\": { transform: \"translateX(0)\", opacity: \"1\" },\n        },\n        \"fadeIn\": {\n          \"0%\": { opacity: \"0\", transform: \"translateY(10px)\" },\n          \"100%\": { opacity: \"1\", transform: \"translateY(0)\" },\n        },\n        \"shimmer\": {\n          \"0%\": { transform: \"translateX(-100%)\" },\n          \"100%\": { transform: \"translateX(100%)\" },\n        },\n        \"float\": {\n          \"0%, 100%\": { transform: \"translateY(0px)\" },\n          \"50%\": { transform: \"translateY(-10px)\" },\n        },\n        \"gradient\": {\n          \"0%, 100%\": { backgroundPosition: \"0% 50%\" },\n          \"50%\": { backgroundPosition: \"100% 50%\" },\n        },\n        \"bounce-smooth\": {\n          \"0%, 100%\": { transform: \"translateY(-5%)\", animationTimingFunction: \"cubic-bezier(0.8, 0, 1, 1)\" },\n          \"50%\": { transform: \"translateY(0)\", animationTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\" },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n        \"slideIn\": \"slideIn 0.3s ease-out\",\n        \"fadeIn\": \"fadeIn 0.2s ease-out\",\n        \"shimmer\": \"shimmer 2s infinite\",\n        \"float\": \"float 3s ease-in-out infinite\",\n        \"gradient\": \"gradient 15s ease infinite\",\n        \"bounce-smooth\": \"bounce-smooth 1s infinite\",\n      },\n      transitionTimingFunction: {\n        'bounce': 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',\n        'smooth': 'cubic-bezier(0.4, 0, 0.2, 1)',\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\")],\n}","size_bytes":4015},"packages/frontend/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-all duration-200 ease-smooth focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 hover:scale-[1.02] active:scale-[0.98]\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90 hover:scale-[1.02] active:scale-[0.98]\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground hover:scale-[1.02] active:scale-[0.98]\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80 hover:scale-[1.02] active:scale-[0.98]\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground hover:scale-105 active:scale-95\",\n        link: \"text-primary underline-offset-4 hover:underline hover:scale-105\",\n        glass: \"glass-light hover:bg-white/70 hover:scale-105 hover:shadow-lg transition-all duration-200 active:scale-95\",\n        gradient: \"bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 hover:scale-[1.02] active:scale-[0.98] text-white shadow-lg hover:shadow-xl\",\n        glassDark: \"backdrop-blur-sm bg-slate-900/60 dark:bg-slate-800/60 border-white/10 hover:bg-slate-800/80 hover:scale-105 hover:shadow-glass-lg transition-all duration-200 active:scale-95\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }","size_bytes":2562},"packages/shared/src/types/sip.ts":{"content":"import { z } from 'zod';\n\n// SIP Registration Status\nexport const SipRegistrationStatusSchema = z.enum([\n  'registered',\n  'unregistered', \n  'failed',\n  'expired',\n  'unknown'\n]);\n\nexport type SipRegistrationStatus = z.infer<typeof SipRegistrationStatusSchema>;\n\n// SIP Extension Configuration\nexport const SipExtensionConfigSchema = z.object({\n  // Basic Settings\n  extension: z.string().regex(/^[0-9]{3,6}$/),\n  password: z.string().min(8).max(32),\n  display_name: z.string().min(1).max(100),\n  \n  // Tenant Context (auto-populated)\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  realm: z.string(), // Auto-populated: tenant.sip_domain\n  \n  // SIP Settings\n  sip_settings: z.object({\n    auth_username: z.string().optional(),\n    auth_password: z.string().optional(),\n    caller_id_name: z.string().optional(),\n    caller_id_number: z.string().optional(),\n    context: z.string().default('default'),\n    host: z.string().default('dynamic'),\n    type: z.enum(['friend', 'user', 'peer']).default('friend'),\n    nat: z.enum(['force_rport', 'comedia', 'auto_force_rport', 'auto_comedia']).default('force_rport'),\n    qualify: z.boolean().default(true),\n    qualify_freq: z.number().min(30).max(300).default(60),\n    canreinvite: z.boolean().default(false),\n    dtmfmode: z.enum(['rfc2833', 'inband', 'info']).default('rfc2833'),\n    disallow: z.array(z.string()).default(['all']),\n    allow: z.array(z.string()).default(['ulaw', 'alaw', 'g729', 'g722']),\n    directmedia: z.boolean().default(false),\n    trustrpid: z.boolean().default(false),\n    sendrpid: z.boolean().default(false),\n    callgroup: z.string().optional(),\n    pickupgroup: z.string().optional(),\n    musicclass: z.string().default('default'),\n    mohsuggest: z.string().default('default'),\n    parkinglot: z.string().optional(),\n    hasvoicemail: z.boolean().default(true),\n    mailbox: z.string().optional(),\n    attach: z.string().optional(),\n    cid_masquerade: z.string().optional(),\n    callingpres: z.enum(['allowed_not_screened', 'allowed_passed_screen', 'allowed_failed_screen', 'allowed', 'prohib_not_screened', 'prohib_passed_screen', 'prohib_failed_screen', 'prohib']).default('allowed_not_screened'),\n    restrictcid: z.boolean().default(false),\n    outboundcid: z.string().optional(),\n    language: z.string().default('en'),\n    accountcode: z.string().optional(),\n    amaflags: z.enum(['default', 'omit', 'billing', 'documentation']).default('default'),\n    callcounter: z.boolean().default(false),\n    busylevel: z.number().min(1).max(100).default(1),\n    ringinuse: z.boolean().default(false),\n    setvar: z.array(z.string()).default([]),\n    useragent: z.string().optional(),\n    lastms: z.number().optional(),\n    regserver: z.string().optional(),\n    regseconds: z.number().optional(),\n    fullcontact: z.string().optional(),\n    ipaddr: z.string().optional(),\n    port: z.number().optional(),\n    username: z.string().optional(),\n    defaultip: z.string().optional(),\n    defaultuser: z.string().optional(),\n    secret: z.string().optional(),\n    regexten: z.string().optional(),\n    vmexten: z.string().optional(),\n    callbackextension: z.string().optional(),\n    namedcallgroup: z.string().optional(),\n    namedpickupgroup: z.string().optional(),\n    namedcontext: z.string().optional(),\n    subscribecontext: z.string().optional(),\n    musiconhold: z.string().optional(),\n    permit: z.string().optional(),\n    deny: z.string().optional(),\n    calllimit: z.number().optional(),\n    rtpkeepalive: z.number().default(0),\n    rtp_timeout: z.number().default(60),\n    rtp_hold_timeout: z.number().default(300),\n    rfc2833compensate: z.boolean().default(false),\n    session_timers: z.boolean().default(false),\n    session_expires: z.number().default(1800),\n    session_minse: z.number().default(90),\n    session_refresher: z.enum(['uac', 'uas']).default('uas'),\n    t38pt_udptl: z.boolean().default(false),\n    t38pt_rtp: z.boolean().default(false),\n    t38pt_tcp: z.boolean().default(false),\n    t38pt_usertpsource: z.string().optional(),\n    t38pt_rtp_udptl: z.boolean().default(false),\n    faxdetect_audio: z.boolean().default(false),\n    faxdetect_modem: z.boolean().default(false),\n    faxdetect_ced: z.boolean().default(false),\n    faxdetect_cng: z.boolean().default(false),\n    faxdetect_audio_silence_threshold: z.number().default(128),\n    faxdetect_audio_silence_duration: z.number().default(2000),\n    faxdetect_audio_energy_threshold: z.number().default(128),\n    faxdetect_audio_energy_duration: z.number().default(2000),\n    faxdetect_modem_silence_threshold: z.number().default(128),\n    faxdetect_modem_silence_duration: z.number().default(2000),\n    faxdetect_modem_energy_threshold: z.number().default(128),\n    faxdetect_modem_energy_duration: z.number().default(2000),\n    faxdetect_ced_silence_threshold: z.number().default(128),\n    faxdetect_ced_silence_duration: z.number().default(2000),\n    faxdetect_ced_energy_threshold: z.number().default(128),\n    faxdetect_ced_energy_duration: z.number().default(2000),\n    faxdetect_cng_silence_threshold: z.number().default(128),\n    faxdetect_cng_silence_duration: z.number().default(2000),\n    faxdetect_cng_energy_threshold: z.number().default(128),\n    faxdetect_cng_energy_duration: z.number().default(2000)\n  }),\n  \n  // Call Features\n  call_features: z.object({\n    call_forwarding: z.object({\n      enabled: z.boolean().default(false),\n      destination: z.string().optional(),\n      no_answer_timeout: z.number().min(5).max(60).default(20),\n      busy_destination: z.string().optional(),\n      unavailable_destination: z.string().optional()\n    }),\n    call_waiting: z.object({\n      enabled: z.boolean().default(true),\n      tone_frequency: z.number().default(440),\n      tone_duration: z.number().default(200)\n    }),\n    do_not_disturb: z.object({\n      enabled: z.boolean().default(false),\n      message: z.string().default('User is not available')\n    }),\n    voicemail: z.object({\n      enabled: z.boolean().default(true),\n      password: z.string().optional(),\n      email_notification: z.boolean().default(false),\n      email_address: z.string().email().optional(),\n      delete_after_email: z.boolean().default(false),\n      attach_audio: z.boolean().default(true),\n      max_messages: z.number().min(1).max(1000).default(100),\n      max_message_length: z.number().min(30).max(600).default(300)\n    }),\n    recording: z.object({\n      enabled: z.boolean().default(false),\n      auto_record: z.boolean().default(false),\n      record_internal: z.boolean().default(false),\n      record_external: z.boolean().default(true),\n      consent_required: z.boolean().default(true)\n    })\n  }),\n  \n  // Security Settings\n  security: z.object({\n    ip_whitelist: z.array(z.string()).default([]),\n    ip_blacklist: z.array(z.string()).default([]),\n    max_concurrent_calls: z.number().min(1).max(10).default(3),\n    password_expiry_days: z.number().min(30).max(365).default(90),\n    require_secure_rtp: z.boolean().default(false),\n    encryption_method: z.enum(['none', 'srtp', 'zrtp']).default('none')\n  }),\n  \n  // Advanced Settings\n  advanced: z.object({\n    custom_headers: z.array(z.object({\n      name: z.string(),\n      value: z.string()\n    })).default([]),\n    custom_variables: z.array(z.object({\n      name: z.string(),\n      value: z.string()\n    })).default([]),\n    dialplan_context: z.string().default('default'),\n    outbound_proxy: z.string().optional(),\n    transport: z.enum(['udp', 'tcp', 'tls', 'ws', 'wss']).default('udp'),\n    local_net: z.string().default('192.168.0.0/16'),\n    externip: z.string().optional(),\n    externhost: z.string().optional(),\n    externrefresh: z.number().default(10)\n  })\n});\n\nexport type SipExtensionConfig = z.infer<typeof SipExtensionConfigSchema>;\n\n// SIP Trunk Configuration\nexport const SipTrunkConfigSchema = z.object({\n  // Basic Settings\n  name: z.string().min(1).max(100),\n  host: z.string(),\n  port: z.number().min(1).max(65535).default(5060),\n  username: z.string().optional(),\n  password: z.string().optional(),\n  from_user: z.string().optional(),\n  from_domain: z.string(), // Auto-populated: tenant.sip_domain\n  \n  // Tenant Context (auto-populated)\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  \n  // SIP Settings\n  sip_settings: z.object({\n    type: z.enum(['friend', 'user', 'peer']).default('peer'),\n    context: z.string().default('from-trunk'),\n    host: z.string(),\n    port: z.number().default(5060),\n    username: z.string().optional(),\n    secret: z.string().optional(),\n    fromuser: z.string().optional(),\n    fromdomain: z.string().optional(),\n    callerid: z.string().optional(),\n    calleridname: z.string().optional(),\n    calleridpres: z.enum(['allowed_not_screened', 'allowed_passed_screen', 'allowed_failed_screen', 'allowed', 'prohib_not_screened', 'prohib_passed_screen', 'prohib_failed_screen', 'prohib']).default('allowed_not_screened'),\n    nat: z.enum(['force_rport', 'comedia', 'auto_force_rport', 'auto_comedia']).default('force_rport'),\n    qualify: z.boolean().default(true),\n    qualifyfreq: z.number().min(30).max(300).default(60),\n    canreinvite: z.boolean().default(false),\n    dtmfmode: z.enum(['rfc2833', 'inband', 'info']).default('rfc2833'),\n    disallow: z.array(z.string()).default(['all']),\n    allow: z.array(z.string()).default(['ulaw', 'alaw', 'g729', 'g722']),\n    directmedia: z.boolean().default(false),\n    trustrpid: z.boolean().default(false),\n    sendrpid: z.boolean().default(false),\n    callgroup: z.string().optional(),\n    pickupgroup: z.string().optional(),\n    musicclass: z.string().default('default'),\n    mohsuggest: z.string().default('default'),\n    parkinglot: z.string().optional(),\n    hasvoicemail: z.boolean().default(false),\n    mailbox: z.string().optional(),\n    attach: z.string().optional(),\n    cid_masquerade: z.string().optional(),\n    callingpres: z.enum(['allowed_not_screened', 'allowed_passed_screen', 'allowed_failed_screen', 'allowed', 'prohib_not_screened', 'prohib_passed_screen', 'prohib_failed_screen', 'prohib']).default('allowed_not_screened'),\n    restrictcid: z.boolean().default(false),\n    outboundcid: z.string().optional(),\n    language: z.string().default('en'),\n    accountcode: z.string().optional(),\n    amaflags: z.enum(['default', 'omit', 'billing', 'documentation']).default('default'),\n    callcounter: z.boolean().default(false),\n    busylevel: z.number().min(1).max(100).default(1),\n    ringinuse: z.boolean().default(false),\n    setvar: z.array(z.string()).default([]),\n    useragent: z.string().optional(),\n    lastms: z.number().optional(),\n    regserver: z.string().optional(),\n    regseconds: z.number().optional(),\n    fullcontact: z.string().optional(),\n    ipaddr: z.string().optional(),\n    defaultip: z.string().optional(),\n    defaultuser: z.string().optional(),\n    regexten: z.string().optional(),\n    vmexten: z.string().optional(),\n    callbackextension: z.string().optional(),\n    namedcallgroup: z.string().optional(),\n    namedpickupgroup: z.string().optional(),\n    namedcontext: z.string().optional(),\n    subscribecontext: z.string().optional(),\n    musiconhold: z.string().optional(),\n    permit: z.string().optional(),\n    deny: z.string().optional(),\n    calllimit: z.number().optional(),\n    rtpkeepalive: z.number().default(0),\n    rtp_timeout: z.number().default(60),\n    rtp_hold_timeout: z.number().default(300),\n    rfc2833compensate: z.boolean().default(false),\n    session_timers: z.boolean().default(false),\n    session_expires: z.number().default(1800),\n    session_minse: z.number().default(90),\n    session_refresher: z.enum(['uac', 'uas']).default('uas'),\n    t38pt_udptl: z.boolean().default(false),\n    t38pt_rtp: z.boolean().default(false),\n    t38pt_tcp: z.boolean().default(false),\n    t38pt_usertpsource: z.string().optional(),\n    t38pt_rtp_udptl: z.boolean().default(false)\n  }),\n  \n  // Registration Settings\n  registration: z.object({\n    enabled: z.boolean().default(false),\n    auth_username: z.string().optional(),\n    auth_password: z.string().optional(),\n    auth_realm: z.string().optional(),\n    refresh_interval: z.number().min(30).max(3600).default(300),\n    retry_interval: z.number().min(10).max(300).default(60),\n    max_retries: z.number().min(1).max(10).default(3),\n    expire: z.number().min(60).max(3600).default(3600)\n  }),\n  \n  // Security Settings\n  security: z.object({\n    ip_whitelist: z.array(z.string()).default([]),\n    ip_blacklist: z.array(z.string()).default([]),\n    max_concurrent_calls: z.number().min(1).max(100).default(10),\n    require_secure_rtp: z.boolean().default(false),\n    encryption_method: z.enum(['none', 'srtp', 'zrtp']).default('none'),\n    authentication: z.enum(['none', 'md5', 'sha1']).default('md5')\n  }),\n  \n  // Advanced Settings\n  advanced: z.object({\n    custom_headers: z.array(z.object({\n      name: z.string(),\n      value: z.string()\n    })).default([]),\n    custom_variables: z.array(z.object({\n      name: z.string(),\n      value: z.string()\n    })).default([]),\n    dialplan_context: z.string().default('from-trunk'),\n    outbound_proxy: z.string().optional(),\n    transport: z.enum(['udp', 'tcp', 'tls', 'ws', 'wss']).default('udp'),\n    local_net: z.string().default('192.168.0.0/16'),\n    externip: z.string().optional(),\n    externhost: z.string().optional(),\n    externrefresh: z.number().default(10)\n  })\n});\n\nexport type SipTrunkConfig = z.infer<typeof SipTrunkConfigSchema>;\n\n// Call Routing Rules\nexport const CallRoutingRuleSchema = z.object({\n  id: z.string().uuid(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  priority: z.number().min(1).max(1000).default(100),\n  enabled: z.boolean().default(true),\n  \n  // Matching Conditions\n  conditions: z.object({\n    caller_id: z.object({\n      number: z.string().optional(),\n      name: z.string().optional(),\n      pattern: z.string().optional()\n    }).optional(),\n    called_number: z.object({\n      number: z.string().optional(),\n      pattern: z.string().optional()\n    }).optional(),\n    time_conditions: z.object({\n      enabled: z.boolean().default(false),\n      timezone: z.string().default('Europe/Rome'),\n      schedule: z.record(z.object({\n        enabled: z.boolean().default(true),\n        start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n        end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)\n      }))\n    }).optional(),\n    day_conditions: z.object({\n      enabled: z.boolean().default(false),\n      days: z.array(z.enum(['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'])).default(['monday', 'tuesday', 'wednesday', 'thursday', 'friday'])\n    }).optional(),\n    source: z.object({\n      trunk_id: z.string().uuid().optional(),\n      extension_id: z.string().uuid().optional(),\n      ip_address: z.string().optional()\n    }).optional(),\n    destination: z.object({\n      trunk_id: z.string().uuid().optional(),\n      extension_id: z.string().uuid().optional(),\n      external_number: z.string().optional()\n    }).optional()\n  }),\n  \n  // Actions\n  actions: z.object({\n    route_to: z.object({\n      type: z.enum(['extension', 'trunk', 'external', 'voicemail', 'hangup', 'busy', 'congestion']),\n      target: z.string(), // extension number, trunk name, external number, etc.\n      timeout: z.number().min(5).max(300).default(30)\n    }),\n    call_forwarding: z.object({\n      enabled: z.boolean().default(false),\n      destination: z.string().optional(),\n      timeout: z.number().min(5).max(60).default(20)\n    }).optional(),\n    recording: z.object({\n      enabled: z.boolean().default(false),\n      consent_required: z.boolean().default(true)\n    }).optional(),\n    cdr_tag: z.string().optional(),\n    custom_variables: z.array(z.object({\n      name: z.string(),\n      value: z.string()\n    })).default([])\n  }),\n  \n  // Metadata\n  created_at: z.date(),\n  updated_at: z.date(),\n  created_by: z.string().uuid(),\n  tenant_id: z.string().uuid()\n});\n\nexport type CallRoutingRule = z.infer<typeof CallRoutingRuleSchema>;\n\n// SIP Registration Status\nexport const SipRegistrationStatusInfoSchema = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n  type: z.enum(['extension', 'trunk']),\n  status: SipRegistrationStatusSchema,\n  last_registration: z.date().optional(),\n  last_unregistration: z.date().optional(),\n  registration_attempts: z.number().default(0),\n  last_error: z.string().optional(),\n  ip_address: z.string().optional(),\n  port: z.number().optional(),\n  user_agent: z.string().optional(),\n  expires: z.number().optional(),\n  contact: z.string().optional(),\n  tenant_id: z.string().uuid()\n});\n\nexport type SipRegistrationStatusInfo = z.infer<typeof SipRegistrationStatusInfoSchema>;\n\n// Inbound Route\nexport const InboundRouteSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  did_number: z.string().min(1).max(20), // Direct Inward Dialing number\n  caller_id_name: z.string().optional(),\n  caller_id_number: z.string().optional(),\n  destination_type: z.enum(['extension', 'ring_group', 'queue', 'voicemail', 'ivr', 'conference', 'external']),\n  destination_value: z.string(), // Extension number, ring group ID, etc.\n  time_condition_id: z.string().uuid().optional(), // Reference to time condition\n  enabled: z.boolean().default(true),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Recording\n  record_calls: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  // Failover\n  failover_enabled: z.boolean().default(false),\n  failover_destination_type: z.enum(['extension', 'voicemail', 'external']).optional(),\n  failover_destination_value: z.string().optional(),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type InboundRoute = z.infer<typeof InboundRouteSchema>;\n\n// Outbound Route\nexport const OutboundRouteSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  dial_pattern: z.string().min(1).max(50), // Regex pattern for matching numbers\n  caller_id_name: z.string().optional(),\n  caller_id_number: z.string().optional(),\n  trunk_id: z.string().uuid(), // Reference to SIP trunk\n  prefix: z.string().optional(), // Prefix to add to dialed number\n  strip_digits: z.number().int().min(0).default(0), // Digits to strip from beginning\n  add_digits: z.string().optional(), // Digits to add to beginning\n  enabled: z.boolean().default(true),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Recording\n  record_calls: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  // Failover\n  failover_trunk_id: z.string().uuid().optional(),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type OutboundRoute = z.infer<typeof OutboundRouteSchema>;\n\n// Time Condition\nexport const TimeConditionSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  timezone: z.string().default('UTC'),\n  // Business hours\n  business_hours: z.object({\n    monday: z.object({\n      enabled: z.boolean().default(true),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/), // HH:MM format\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    tuesday: z.object({\n      enabled: z.boolean().default(true),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    wednesday: z.object({\n      enabled: z.boolean().default(true),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    thursday: z.object({\n      enabled: z.boolean().default(true),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    friday: z.object({\n      enabled: z.boolean().default(true),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    saturday: z.object({\n      enabled: z.boolean().default(false),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n    sunday: z.object({\n      enabled: z.boolean().default(false),\n      start_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n      end_time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\n    }).optional(),\n  }),\n  // Holidays\n  holidays: z.array(z.object({\n    name: z.string(),\n    date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/), // YYYY-MM-DD format\n    enabled: z.boolean().default(true),\n  })).default([]),\n  // Actions\n  business_hours_action: z.enum(['continue', 'voicemail', 'external', 'hangup']).default('continue'),\n  business_hours_destination: z.string().optional(),\n  after_hours_action: z.enum(['voicemail', 'external', 'hangup']).default('voicemail'),\n  after_hours_destination: z.string().optional(),\n  holiday_action: z.enum(['voicemail', 'external', 'hangup']).default('voicemail'),\n  holiday_destination: z.string().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type TimeCondition = z.infer<typeof TimeConditionSchema>;\n\n// IVR Menu\nexport const IvrMenuSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  greeting_message: z.string().optional(), // Text-to-speech or audio file\n  invalid_message: z.string().optional(),\n  timeout_message: z.string().optional(),\n  timeout_seconds: z.number().int().min(1).max(60).default(10),\n  max_failures: z.number().int().min(1).max(10).default(3),\n  // Menu options (0-9, *, #)\n  options: z.array(z.object({\n    digit: z.string().length(1), // 0-9, *, #\n    action: z.enum(['extension', 'ring_group', 'queue', 'voicemail', 'ivr', 'conference', 'external', 'hangup']),\n    destination: z.string(), // Extension number, ring group ID, etc.\n    description: z.string().optional(),\n  })).max(12), // Maximum 12 options (0-9, *, #)\n  // Default action when no digit is pressed\n  default_action: z.enum(['extension', 'ring_group', 'queue', 'voicemail', 'ivr', 'conference', 'external', 'hangup']).default('hangup'),\n  default_destination: z.string().optional(),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Recording\n  record_calls: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type IvrMenu = z.infer<typeof IvrMenuSchema>;\n\n// Ring Group\nexport const RingGroupSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  extension_number: z.string().min(3).max(10), // e.g., \"2001\"\n  strategy: z.enum(['simultaneous', 'sequential', 'round_robin', 'random', 'longest_idle']).default('simultaneous'),\n  timeout: z.number().int().min(5).max(300).default(30), // seconds\n  max_calls: z.number().int().min(1).max(100).default(10),\n  // Members\n  members: z.array(z.object({\n    extension_id: z.string().uuid(),\n    extension_number: z.string(),\n    display_name: z.string(),\n    priority: z.number().int().min(1).max(100).default(1),\n    enabled: z.boolean().default(true),\n    delay: z.number().int().min(0).max(60).default(0), // seconds delay for sequential\n  })),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Recording\n  record_calls: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  // Failover\n  failover_enabled: z.boolean().default(false),\n  failover_destination_type: z.enum(['extension', 'voicemail', 'external']).optional(),\n  failover_destination_value: z.string().optional(),\n  // Time conditions\n  time_condition_id: z.string().uuid().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type RingGroup = z.infer<typeof RingGroupSchema>;\n\n// Queue (Call Center Queue)\nexport const QueueSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  extension_number: z.string().min(3).max(10), // e.g., \"3001\"\n  strategy: z.enum(['ring_all', 'longest_idle', 'round_robin', 'top_down', 'agent_with_least_calls', 'agent_with_fewest_calls', 'sequentially_by_agent_order', 'random']).default('longest_idle'),\n  timeout: z.number().int().min(5).max(300).default(30), // seconds\n  max_calls: z.number().int().min(1).max(1000).default(100),\n  // Queue settings\n  hold_music: z.string().optional(), // Music on hold class\n  announce_frequency: z.number().int().min(0).max(300).default(0), // seconds, 0 = no announcements\n  announce_position: z.boolean().default(false),\n  announce_hold_time: z.boolean().default(false),\n  // Agents\n  agents: z.array(z.object({\n    extension_id: z.string().uuid(),\n    extension_number: z.string(),\n    display_name: z.string(),\n    penalty: z.number().int().min(0).max(100).default(0), // lower = higher priority\n    enabled: z.boolean().default(true),\n    max_calls: z.number().int().min(1).max(10).default(1),\n  })),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Recording\n  record_calls: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  // Failover\n  failover_enabled: z.boolean().default(false),\n  failover_destination_type: z.enum(['extension', 'voicemail', 'external']).optional(),\n  failover_destination_value: z.string().optional(),\n  // Time conditions\n  time_condition_id: z.string().uuid().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type Queue = z.infer<typeof QueueSchema>;\n\n// Conference Room\nexport const ConferenceRoomSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  extension_number: z.string().min(3).max(10), // e.g., \"4001\"\n  pin: z.string().optional(), // PIN for joining\n  moderator_pin: z.string().optional(), // PIN for moderator\n  max_members: z.number().int().min(2).max(1000).default(10),\n  // Conference settings\n  record_conference: z.boolean().default(false),\n  recording_path: z.string().optional(),\n  mute_on_join: z.boolean().default(false),\n  announce_join_leave: z.boolean().default(true),\n  hold_music: z.string().optional(),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  // Time conditions\n  time_condition_id: z.string().uuid().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type ConferenceRoom = z.infer<typeof ConferenceRoomSchema>;\n\n// Voicemail Box\nexport const VoicemailBoxSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  store_id: z.string().uuid().optional(),\n  extension_number: z.string().min(3).max(10),\n  password: z.string().min(4).max(20),\n  display_name: z.string().min(1).max(100),\n  email_address: z.string().email().optional(),\n  // Voicemail settings\n  max_messages: z.number().int().min(1).max(1000).default(100),\n  max_message_length: z.number().int().min(30).max(600).default(300), // seconds\n  delete_after_email: z.boolean().default(false),\n  attach_audio: z.boolean().default(true),\n  email_notification: z.boolean().default(true),\n  // Greeting\n  greeting_type: z.enum(['default', 'custom', 'none']).default('default'),\n  custom_greeting_path: z.string().optional(),\n  // Advanced options\n  caller_id_override: z.boolean().default(false),\n  caller_id_name_override: z.string().optional(),\n  caller_id_number_override: z.string().optional(),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type VoicemailBox = z.infer<typeof VoicemailBoxSchema>;\n\n// FreeSWITCH Dialplan Context\nexport const DialplanContextSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  name: z.string().min(1).max(50), // e.g., \"default\", \"from-trunk\", \"from-internal\"\n  description: z.string().optional(),\n  // Context settings\n  continue_on_fail: z.boolean().default(false),\n  break_on_fail: z.boolean().default(false),\n  // Extensions in this context\n  extensions: z.array(z.object({\n    id: z.string().uuid(),\n    name: z.string(),\n    condition: z.string(), // FreeSWITCH condition\n    action: z.string(), // FreeSWITCH action\n    anti_action: z.string().optional(),\n    enabled: z.boolean().default(true),\n  })),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type DialplanContext = z.infer<typeof DialplanContextSchema>;\n\n// OpenSIPS Route\nexport const OpenSipsRouteSchema = z.object({\n  id: z.string().uuid().optional(),\n  tenant_id: z.string().uuid(),\n  name: z.string().min(1).max(100),\n  description: z.string().optional(),\n  priority: z.number().int().min(1).max(1000).default(100),\n  // Route conditions\n  conditions: z.array(z.object({\n    type: z.enum(['method', 'uri', 'from_uri', 'to_uri', 'src_ip', 'dst_ip', 'port', 'user_agent', 'custom_header']),\n    operator: z.enum(['equals', 'contains', 'regex', 'starts_with', 'ends_with']),\n    value: z.string(),\n    enabled: z.boolean().default(true),\n  })),\n  // Route actions\n  actions: z.array(z.object({\n    type: z.enum(['forward', 'redirect', 'reject', 'drop', 'log', 'set_header', 'remove_header', 'set_variable']),\n    value: z.string(),\n    enabled: z.boolean().default(true),\n  })),\n  enabled: z.boolean().default(true),\n  created_at: z.date().optional(),\n  updated_at: z.date().optional(),\n});\n\nexport type OpenSipsRoute = z.infer<typeof OpenSipsRouteSchema>;\n","size_bytes":31374},"packages/backend/src/services/dialplan-generator.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Interfaces for dialplan components\r\nexport interface InboundRoute {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  did_number?: string;\r\n  caller_id_pattern?: string;\r\n  destination_type: 'extension' | 'ring_group' | 'queue' | 'ivr' | 'conference' | 'voicemail';\r\n  destination_id?: string;\r\n  destination_data?: any;\r\n  time_condition_id?: string;\r\n  priority: number;\r\n  enabled: boolean;\r\n  failover_destination_type?: string;\r\n  failover_destination_id?: string;\r\n  failover_destination_data?: any;\r\n  settings?: any;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface OutboundRoute {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  pattern: string;\r\n  caller_id_prefix?: string;\r\n  caller_id_number?: string;\r\n  trunk_priority: string[];\r\n  least_cost_routing: boolean;\r\n  time_condition_id?: string;\r\n  priority: number;\r\n  enabled: boolean;\r\n  settings?: any;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface TimeCondition {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  time_groups: Array<{\r\n    days: number[];\r\n    start_time: string;\r\n    end_time: string;\r\n    timezone: string;\r\n  }>;\r\n  holidays: Array<{\r\n    date: string;\r\n    name: string;\r\n    type: 'holiday' | 'special_day';\r\n  }>;\r\n  timezone: string;\r\n  match_destination_type: string;\r\n  match_destination_id?: string;\r\n  match_destination_data?: any;\r\n  nomatch_destination_type: string;\r\n  nomatch_destination_id?: string;\r\n  nomatch_destination_data?: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface DialplanContext {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  context_type: 'internal' | 'external' | 'public' | 'private';\r\n  variables: any;\r\n  conditions: Array<{\r\n    condition: string;\r\n    expression: string;\r\n    actions: Array<{\r\n      application: string;\r\n      data: string;\r\n    }>;\r\n  }>;\r\n  enabled: boolean;\r\n  priority: number;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class DialplanGeneratorService {\r\n  private configPath: string;\r\n\r\n  constructor() {\r\n    this.configPath = process.env.FREESWITCH_CONFIG_PATH || './docker/freeswitch/conf';\r\n    console.log(`🔧 Dialplan Generator Service initialized with path: ${this.configPath}`);\r\n  }\r\n\r\n  // Generate complete dialplan XML\r\n  async generateCompleteDialplan(tenantId: string): Promise<string> {\r\n    try {\r\n      console.log(`🔄 Generating complete dialplan for tenant: ${tenantId}`);\r\n\r\n      // Get all dialplan components\r\n      const [inboundRoutes, outboundRoutes, timeConditions, dialplanContexts] = await Promise.all([\r\n        this.getInboundRoutes(tenantId),\r\n        this.getOutboundRoutes(tenantId),\r\n        this.getTimeConditions(tenantId),\r\n        this.getDialplanContexts(tenantId)\r\n      ]);\r\n\r\n      let xml = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<include>\r\n  <!-- Internal extensions routing -->\r\n  <extension name=\"internal_calls\">\r\n    <condition field=\"destination_number\" expression=\"^(1\\\\d{3})$\">\r\n      <action application=\"set\" data=\"domain_name=\\${domain_name}\"/>\r\n      <action application=\"set\" data=\"domain_uuid=\\${domain_uuid}\"/>\r\n      <action application=\"set\" data=\"call_direction=inbound\"/>\r\n      <action application=\"set\" data=\"sip_h_X-accountcode=\\${accountcode}\"/>\r\n      <action application=\"set\" data=\"sip_h_X-tenant-id=${tenantId}\"/>\r\n      <action application=\"bridge\" data=\"user/\\\\\\${destination_number}@\\\\\\${domain_name}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n    </condition>\r\n  </extension>`;\r\n\r\n      // Generate inbound routes\r\n      for (const route of inboundRoutes.filter(r => r.enabled)) {\r\n        xml += this.generateInboundRouteXML(route, timeConditions);\r\n      }\r\n\r\n      // Generate outbound routes\r\n      for (const route of outboundRoutes.filter(r => r.enabled)) {\r\n        xml += this.generateOutboundRouteXML(route, timeConditions);\r\n      }\r\n\r\n      // Generate dialplan contexts\r\n      for (const context of dialplanContexts.filter(c => c.enabled)) {\r\n        xml += this.generateDialplanContextXML(context);\r\n      }\r\n\r\n      // Add default external routing\r\n      xml += `\r\n  <!-- Default external routing -->\r\n  <extension name=\"external_calls\">\r\n    <condition field=\"destination_number\" expression=\"^([0-9]+)$\">\r\n      <action application=\"set\" data=\"domain_name=\\${domain_name}\"/>\r\n      <action application=\"set\" data=\"domain_uuid=\\${domain_uuid}\"/>\r\n      <action application=\"set\" data=\"call_direction=outbound\"/>\r\n      <action application=\"set\" data=\"sip_h_X-accountcode=\\${accountcode}\"/>\r\n      <action application=\"set\" data=\"sip_h_X-tenant-id=${tenantId}\"/>\r\n      <action application=\"bridge\" data=\"sofia/gateway/default/\\\\\\${destination_number}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n    </condition>\r\n  </extension>\r\n</include>`;\r\n\r\n      console.log(`✅ Generated dialplan XML for tenant: ${tenantId}`);\r\n      return xml;\r\n    } catch (error) {\r\n      console.error('❌ Error generating complete dialplan:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Generate inbound route XML\r\n  private generateInboundRouteXML(route: InboundRoute, timeConditions: TimeCondition[]): string {\r\n    const timeCondition = route.time_condition_id ? \r\n      timeConditions.find(tc => tc.id === route.time_condition_id) : null;\r\n\r\n    let xml = `\r\n  <!-- Inbound Route: ${route.name} -->\r\n  <extension name=\"inbound_${route.id}\">`;\r\n\r\n    // Add DID condition if specified\r\n    if (route.did_number) {\r\n      xml += `\r\n    <condition field=\"destination_number\" expression=\"^${this.escapeRegex(route.did_number)}$\">`;\r\n    } else {\r\n      xml += `\r\n    <condition field=\"destination_number\" expression=\"^(.+)$\">`;\r\n    }\r\n\r\n    // Add caller ID condition if specified\r\n    if (route.caller_id_pattern) {\r\n      xml += `\r\n      <condition field=\"caller_id_number\" expression=\"^${this.escapeRegex(route.caller_id_pattern)}$\">`;\r\n    }\r\n\r\n    // Add time condition if specified\r\n    if (timeCondition) {\r\n      xml += this.generateTimeConditionXML(timeCondition);\r\n    }\r\n\r\n    // Add destination action\r\n    xml += this.generateDestinationAction(route);\r\n\r\n    // Add failover if specified\r\n    if (route.failover_destination_type) {\r\n      xml += `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|USER_BUSY|UNALLOCATED_NUMBER\">\r\n        <action application=\"log\" data=\"INFO Failover triggered for route ${route.name}\"/>\r\n        ${this.generateDestinationAction({\r\n          ...route,\r\n          destination_type: route.failover_destination_type,\r\n          destination_id: route.failover_destination_id,\r\n          destination_data: route.failover_destination_data\r\n        } as any)}\r\n      </condition>`;\r\n    }\r\n\r\n    // Close conditions\r\n    if (route.caller_id_pattern) {\r\n      xml += `\r\n      </condition>`;\r\n    }\r\n    \r\n    xml += `\r\n    </condition>\r\n  </extension>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate outbound route XML\r\n  private generateOutboundRouteXML(route: OutboundRoute, timeConditions: TimeCondition[]): string {\r\n    const timeCondition = route.time_condition_id ? \r\n      timeConditions.find(tc => tc.id === route.time_condition_id) : null;\r\n\r\n    let xml = `\r\n  <!-- Outbound Route: ${route.name} -->\r\n  <extension name=\"outbound_${route.id}\">`;\r\n\r\n    // Add pattern condition\r\n    xml += `\r\n    <condition field=\"destination_number\" expression=\"^${route.pattern}$\">`;\r\n\r\n    // Add caller ID manipulation if specified\r\n    if (route.caller_id_prefix || route.caller_id_number) {\r\n      if (route.caller_id_prefix) {\r\n        xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_name=\\${effective_caller_id_name}\"/>\r\n      <action application=\"set\" data=\"effective_caller_id_number=${route.caller_id_prefix}\\${effective_caller_id_number}\"/>`;\r\n      }\r\n      if (route.caller_id_number) {\r\n        xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_number=${route.caller_id_number}\"/>`;\r\n      }\r\n    }\r\n\r\n    // Add time condition if specified\r\n    if (timeCondition) {\r\n      xml += this.generateTimeConditionXML(timeCondition);\r\n    }\r\n\r\n    // Add trunk routing\r\n    xml += this.generateTrunkRoutingXML(route);\r\n\r\n    xml += `\r\n    </condition>\r\n  </extension>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate dialplan context XML\r\n  private generateDialplanContextXML(context: DialplanContext): string {\r\n    let xml = `\r\n  <!-- Dialplan Context: ${context.name} -->\r\n  <extension name=\"context_${context.id}\">`;\r\n\r\n    // Add variables\r\n    for (const [key, value] of Object.entries(context.variables)) {\r\n      xml += `\r\n    <action application=\"set\" data=\"${key}=${value}\"/>`;\r\n    }\r\n\r\n    // Add conditions\r\n    for (const condition of context.conditions) {\r\n      xml += `\r\n    <condition field=\"${condition.condition}\" expression=\"^${condition.expression}$\">`;\r\n      \r\n      for (const action of condition.actions) {\r\n        xml += `\r\n      <action application=\"${action.application}\" data=\"${action.data}\"/>`;\r\n      }\r\n      \r\n      xml += `\r\n    </condition>`;\r\n    }\r\n\r\n    xml += `\r\n  </extension>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate time condition XML\r\n  private generateTimeConditionXML(timeCondition: TimeCondition): string {\r\n    let xml = `\r\n      <action application=\"set\" data=\"time_condition_id=${timeCondition.id}\"/>`;\r\n\r\n    // Generate time check logic\r\n    for (const timeGroup of timeCondition.time_groups) {\r\n      const days = timeGroup.days.join(',');\r\n      xml += `\r\n      <action application=\"set\" data=\"time_condition_days=${days}\"/>\r\n      <action application=\"set\" data=\"time_condition_start=${timeGroup.start_time}\"/>\r\n      <action application=\"set\" data=\"time_condition_end=${timeGroup.end_time}\"/>\r\n      <action application=\"set\" data=\"time_condition_timezone=${timeGroup.timezone}\"/>`;\r\n    }\r\n\r\n    xml += `\r\n      <action application=\"set\" data=\"time_condition_match_destination_type=${timeCondition.match_destination_type}\"/>\r\n      <action application=\"set\" data=\"time_condition_nomatch_destination_type=${timeCondition.nomatch_destination_type}\"/>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate destination action XML\r\n  private generateDestinationAction(route: InboundRoute): string {\r\n    switch (route.destination_type) {\r\n      case 'extension':\r\n        const extension = route.destination_data?.extension || route.destination_id;\r\n        return `\r\n      <action application=\"set\" data=\"domain_name=\\${domain_name}\"/>\r\n      <action application=\"set\" data=\"domain_uuid=\\${domain_uuid}\"/>\r\n      <action application=\"set\" data=\"call_direction=inbound\"/>\r\n      <action application=\"bridge\" data=\"user/${extension}@\\${domain_name}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      case 'ring_group':\r\n        return `\r\n      <action application=\"set\" data=\"ring_group_id=${route.destination_id}\"/>\r\n      <action application=\"bridge\" data=\"user/100@\\${domain_name} user/1001@\\${domain_name}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      case 'queue':\r\n        return `\r\n      <action application=\"set\" data=\"queue_id=${route.destination_id}\"/>\r\n      <action application=\"bridge\" data=\"queue/${route.destination_id}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      case 'ivr':\r\n        return `\r\n      <action application=\"set\" data=\"ivr_id=${route.destination_id}\"/>\r\n      <action application=\"answer\"/>\r\n      <action application=\"sleep\" data=\"1000\"/>\r\n      <action application=\"ivr\" data=\"ivr_${route.destination_id}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      case 'conference':\r\n        return `\r\n      <action application=\"set\" data=\"conference_id=${route.destination_id}\"/>\r\n      <action application=\"answer\"/>\r\n      <action application=\"conference\" data=\"${route.destination_id}@default\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      case 'voicemail':\r\n        return `\r\n      <action application=\"set\" data=\"voicemail_extension=${route.destination_data?.extension || '100'}\"/>\r\n      <action application=\"answer\"/>\r\n      <action application=\"voicemail\" data=\"default \\${domain_name} \\${voicemail_extension}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n      default:\r\n        return `\r\n      <action application=\"log\" data=\"ERROR Unknown destination type: ${route.destination_type}\"/>\r\n      <action application=\"hangup\" data=\"INVALID_DESTINATION\"/>`;\r\n    }\r\n  }\r\n\r\n  // Generate trunk routing XML\r\n  private generateTrunkRoutingXML(route: OutboundRoute): string {\r\n    let xml = `\r\n      <action application=\"set\" data=\"domain_name=\\${domain_name}\"/>\r\n      <action application=\"set\" data=\"domain_uuid=\\${domain_uuid}\"/>\r\n      <action application=\"set\" data=\"call_direction=outbound\"/>`;\r\n\r\n    // Add trunk routing based on priority\r\n    for (let i = 0; i < route.trunk_priority.length; i++) {\r\n      const trunk = route.trunk_priority[i];\r\n      const isLast = i === route.trunk_priority.length - 1;\r\n      \r\n      if (isLast) {\r\n        xml += `\r\n      <action application=\"bridge\" data=\"sofia/gateway/${trunk}/\\${destination_number}\"/>`;\r\n      } else {\r\n        xml += `\r\n      <action application=\"bridge\" data=\"sofia/gateway/${trunk}/\\${destination_number}\"/>\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|USER_BUSY|UNALLOCATED_NUMBER\">\r\n        <action application=\"log\" data=\"INFO Trying next trunk in priority list\"/>`;\r\n      }\r\n    }\r\n\r\n    // Close conditions for failover\r\n    for (let i = 0; i < route.trunk_priority.length - 1; i++) {\r\n      xml += `\r\n      </condition>`;\r\n    }\r\n\r\n    xml += `\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Helper method to escape regex special characters\r\n  private escapeRegex(str: string): string {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n  }\r\n\r\n  // Database methods\r\n  async getInboundRoutes(tenantId: string): Promise<InboundRoute[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM inbound_routes WHERE tenant_id = $1 ORDER BY priority ASC',\r\n        [tenantId]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        tenant_id: row.tenant_id,\r\n        store_id: row.store_id,\r\n        name: row.name,\r\n        description: row.description,\r\n        did_number: row.did_number,\r\n        caller_id_pattern: row.caller_id_pattern,\r\n        destination_type: row.destination_type,\r\n        destination_id: row.destination_id,\r\n        destination_data: typeof row.destination_data === 'string' ? JSON.parse(row.destination_data) : row.destination_data,\r\n        time_condition_id: row.time_condition_id,\r\n        priority: row.priority,\r\n        enabled: row.enabled,\r\n        failover_destination_type: row.failover_destination_type,\r\n        failover_destination_id: row.failover_destination_id,\r\n        failover_destination_data: typeof row.failover_destination_data === 'string' ? JSON.parse(row.failover_destination_data) : row.failover_destination_data,\r\n        settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async getOutboundRoutes(tenantId: string): Promise<OutboundRoute[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM outbound_routes WHERE tenant_id = $1 ORDER BY priority ASC',\r\n        [tenantId]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        tenant_id: row.tenant_id,\r\n        store_id: row.store_id,\r\n        name: row.name,\r\n        description: row.description,\r\n        pattern: row.pattern,\r\n        caller_id_prefix: row.caller_id_prefix,\r\n        caller_id_number: row.caller_id_number,\r\n        trunk_priority: typeof row.trunk_priority === 'string' ? JSON.parse(row.trunk_priority) : row.trunk_priority,\r\n        least_cost_routing: row.least_cost_routing,\r\n        time_condition_id: row.time_condition_id,\r\n        priority: row.priority,\r\n        enabled: row.enabled,\r\n        settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async getTimeConditions(tenantId: string): Promise<TimeCondition[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM time_conditions WHERE tenant_id = $1 ORDER BY name ASC',\r\n        [tenantId]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        tenant_id: row.tenant_id,\r\n        store_id: row.store_id,\r\n        name: row.name,\r\n        description: row.description,\r\n        time_groups: typeof row.time_groups === 'string' ? JSON.parse(row.time_groups) : row.time_groups,\r\n        holidays: typeof row.holidays === 'string' ? JSON.parse(row.holidays) : row.holidays,\r\n        timezone: row.timezone,\r\n        match_destination_type: row.match_destination_type,\r\n        match_destination_id: row.match_destination_id,\r\n        match_destination_data: typeof row.match_destination_data === 'string' ? JSON.parse(row.match_destination_data) : row.match_destination_data,\r\n        nomatch_destination_type: row.nomatch_destination_type,\r\n        nomatch_destination_id: row.nomatch_destination_id,\r\n        nomatch_destination_data: typeof row.nomatch_destination_data === 'string' ? JSON.parse(row.nomatch_destination_data) : row.nomatch_destination_data,\r\n        enabled: row.enabled,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async getDialplanContexts(tenantId: string): Promise<DialplanContext[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM dialplan_contexts WHERE tenant_id = $1 ORDER BY priority ASC',\r\n        [tenantId]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        tenant_id: row.tenant_id,\r\n        store_id: row.store_id,\r\n        name: row.name,\r\n        description: row.description,\r\n        context_type: row.context_type,\r\n        variables: typeof row.variables === 'string' ? JSON.parse(row.variables) : row.variables,\r\n        conditions: typeof row.conditions === 'string' ? JSON.parse(row.conditions) : row.conditions,\r\n        enabled: row.enabled,\r\n        priority: row.priority,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Sync dialplan to FreeSWITCH\r\n  async syncDialplanToFreeSWITCH(tenantId: string): Promise<void> {\r\n    try {\r\n      console.log(`🔄 Syncing dialplan to FreeSWITCH for tenant: ${tenantId}`);\r\n      \r\n      const xml = await this.generateCompleteDialplan(tenantId);\r\n      const filePath = `${this.configPath}/dialplan/default.xml`;\r\n      \r\n      // In real implementation, write XML file to FreeSWITCH config directory\r\n      console.log(`📝 Generated dialplan XML for tenant: ${tenantId}`);\r\n      console.log(`📁 File path: ${filePath}`);\r\n      console.log(`📄 XML content length: ${xml.length} characters`);\r\n      \r\n      console.log(`✅ Dialplan synced to FreeSWITCH for tenant: ${tenantId}`);\r\n    } catch (error) {\r\n      console.error('❌ Error syncing dialplan to FreeSWITCH:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const dialplanGeneratorService = new DialplanGeneratorService();\r\n","size_bytes":20193},"packages/database/src/migrate.ts":{"content":"import { Pool } from 'pg';\r\nimport { readFileSync } from 'fs';\r\nimport { join } from 'path';\r\nimport dotenv from 'dotenv';\r\n\r\n// Load environment variables\r\ndotenv.config();\r\n\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/edgvoip',\r\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\r\n});\r\n\r\nasync function runMigrations() {\r\n  const client = await pool.connect();\r\n  \r\n  try {\r\n    console.log('🚀 Starting database migrations...');\r\n    \r\n    // Create migrations table if it doesn't exist\r\n    await client.query(`\r\n      CREATE TABLE IF NOT EXISTS migrations (\r\n        id SERIAL PRIMARY KEY,\r\n        filename VARCHAR(255) UNIQUE NOT NULL,\r\n        executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\r\n      )\r\n    `);\r\n    \r\n    // Get list of migration files\r\n    const migrationFiles = [\r\n      '001_create_tenants_table.sql',\r\n      '002_create_rls_policies.sql',\r\n      '003_create_call_events_table.sql',\r\n      '004_enhance_sip_trunks.sql',\r\n      '005_dialplan_routes.sql',\r\n      '006_ring_groups.sql',\r\n      '007_call_queues.sql',\r\n      '008_time_conditions.sql',\r\n      '009_ivr_menus.sql',\r\n      '010_conference_rooms.sql',\r\n      '011_voicemail_boxes.sql',\r\n      '012_cdr_enhanced.sql',\r\n      '013_add_tenant_slug_and_companies.sql',\r\n      '014_create_users_table.sql',\r\n      '015_enhance_auth_system.sql',\r\n      '016_update_master_slug.sql'\r\n    ];\r\n    \r\n    for (const filename of migrationFiles) {\r\n      // Check if migration already executed\r\n      const result = await client.query(\r\n        'SELECT id FROM migrations WHERE filename = $1',\r\n        [filename]\r\n      );\r\n      \r\n      if (result.rows.length > 0) {\r\n        console.log(`⏭️  Skipping ${filename} (already executed)`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`📝 Executing ${filename}...`);\r\n      \r\n      // Read and execute migration file\r\n      const migrationPath = join(__dirname, 'migrations', filename);\r\n      const migrationSQL = readFileSync(migrationPath, 'utf8');\r\n      \r\n      await client.query(migrationSQL);\r\n      \r\n      // Record migration as executed\r\n      await client.query(\r\n        'INSERT INTO migrations (filename) VALUES ($1)',\r\n        [filename]\r\n      );\r\n      \r\n      console.log(`✅ ${filename} executed successfully`);\r\n    }\r\n    \r\n    console.log('🎉 All migrations completed successfully!');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Migration failed:', error);\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  try {\r\n    await runMigrations();\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('Migration process failed:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nif (require.main === module) {\r\n  main();\r\n}\r\n\r\nexport { runMigrations };\r\n\r\n","size_bytes":2880},"packages/backend/src/services/queue.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Queue interfaces\r\nexport interface CallQueue {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  strategy: 'ring-all' | 'longest-idle' | 'round-robin' | 'top-down' | 'agent-with-least-talk-time';\r\n  max_wait_time: number;\r\n  max_wait_time_with_no_agent: number;\r\n  max_wait_time_with_no_agent_time_reached: number;\r\n  tier_rules_apply: boolean;\r\n  tier_rule_wait_second: number;\r\n  tier_rule_wait_multiply_level: boolean;\r\n  tier_rule_no_agent_no_wait: boolean;\r\n  discard_abandoned_after: number;\r\n  abandoned_resume_allowed: boolean;\r\n  agents: Array<{\r\n    id: string;\r\n    extension_id: string;\r\n    agent_name: string;\r\n    agent_type: 'callback' | 'uuid-standby' | 'uuid-bridge';\r\n    contact: string;\r\n    status: 'Available' | 'On Break' | 'Logged Out';\r\n    state: 'Waiting' | 'Receiving' | 'In a queue call';\r\n    max_no_answer: number;\r\n    wrap_up_time: number;\r\n    reject_delay_time: number;\r\n    busy_delay_time: number;\r\n    no_answer_delay_time: number;\r\n    calls_answered: number;\r\n    talk_time: number;\r\n    tier_level: number;\r\n    tier_position: number;\r\n    enabled: boolean;\r\n  }>;\r\n  moh_sound?: string;\r\n  record_template?: string;\r\n  time_base_score: 'system' | 'queue' | 'member';\r\n  queue_timeout: number;\r\n  queue_timeout_action: 'hangup' | 'voicemail' | 'forward';\r\n  queue_timeout_destination?: string;\r\n  failover_enabled: boolean;\r\n  failover_destination_type?: string;\r\n  failover_destination_id?: string;\r\n  failover_destination_data?: any;\r\n  caller_id_name?: string;\r\n  caller_id_number?: string;\r\n  recording_enabled: boolean;\r\n  recording_path?: string;\r\n  recording_consent_required: boolean;\r\n  max_concurrent_calls: number;\r\n  current_calls: number;\r\n  settings: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface QueueAgent {\r\n  id: string;\r\n  queue_id: string;\r\n  extension_id: string;\r\n  agent_name: string;\r\n  agent_type: 'callback' | 'uuid-standby' | 'uuid-bridge';\r\n  contact: string;\r\n  status: 'Available' | 'On Break' | 'Logged Out';\r\n  state: 'Waiting' | 'Receiving' | 'In a queue call';\r\n  max_no_answer: number;\r\n  wrap_up_time: number;\r\n  reject_delay_time: number;\r\n  busy_delay_time: number;\r\n  no_answer_delay_time: number;\r\n  last_bridge_start?: Date;\r\n  last_bridge_end?: Date;\r\n  last_offered_call?: Date;\r\n  last_status_change?: Date;\r\n  no_answer_count: number;\r\n  calls_answered: number;\r\n  talk_time: number;\r\n  ready_time?: Date;\r\n  external_calls_count: number;\r\n  uuid?: string;\r\n  tier_level: number;\r\n  tier_position: number;\r\n  enabled: boolean;\r\n  settings: any;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface QueueCallLog {\r\n  id: string;\r\n  queue_id: string;\r\n  call_uuid: string;\r\n  caller_id_name?: string;\r\n  caller_id_number?: string;\r\n  destination_number?: string;\r\n  queue_position?: number;\r\n  queue_wait_time: number;\r\n  start_time: Date;\r\n  end_time?: Date;\r\n  duration: number;\r\n  hangup_cause?: string;\r\n  answered_by_agent?: string;\r\n  answered_by_extension?: string;\r\n  agent_wait_time: number;\r\n  agent_talk_time: number;\r\n  recording_path?: string;\r\n  settings: any;\r\n  created_at: Date;\r\n}\r\n\r\nexport interface QueueStatistics {\r\n  id: string;\r\n  queue_id: string;\r\n  date: Date;\r\n  total_calls: number;\r\n  answered_calls: number;\r\n  abandoned_calls: number;\r\n  total_wait_time: number;\r\n  average_wait_time: number;\r\n  longest_wait_time: number;\r\n  total_talk_time: number;\r\n  average_talk_time: number;\r\n  longest_talk_time: number;\r\n  service_level_percentage: number;\r\n  service_level_threshold: number;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class QueueService {\r\n  // Create a new call queue\r\n  async createCallQueue(queueData: Partial<CallQueue>): Promise<CallQueue> {\r\n    return withTransaction(async (client) => {\r\n      // Verify tenant exists\r\n      const tenantResult = await client.query(\r\n        'SELECT id FROM tenants WHERE id = $1 AND status = $2',\r\n        [queueData.tenant_id, 'active']\r\n      );\r\n\r\n      if (tenantResult.rows.length === 0) {\r\n        throw new Error('Tenant not found or inactive');\r\n      }\r\n\r\n      // Check if extension is already in use\r\n      const extensionCheck = await client.query(\r\n        'SELECT id FROM call_queues WHERE extension = $1 AND tenant_id = $2',\r\n        [queueData.extension, queueData.tenant_id]\r\n      );\r\n\r\n      if (extensionCheck.rows.length > 0) {\r\n        throw new Error('Extension already in use by another queue');\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO call_queues (\r\n          id, tenant_id, store_id, name, description, extension, strategy,\r\n          max_wait_time, max_wait_time_with_no_agent, max_wait_time_with_no_agent_time_reached,\r\n          tier_rules_apply, tier_rule_wait_second, tier_rule_wait_multiply_level,\r\n          tier_rule_no_agent_no_wait, discard_abandoned_after, abandoned_resume_allowed,\r\n          moh_sound, record_template, time_base_score, queue_timeout, queue_timeout_action,\r\n          queue_timeout_destination, failover_enabled, failover_destination_type,\r\n          failover_destination_id, failover_destination_data, caller_id_name, caller_id_number,\r\n          recording_enabled, recording_path, recording_consent_required,\r\n          max_concurrent_calls, current_calls, settings, enabled\r\n        ) VALUES (\r\n          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18,\r\n          $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35\r\n        ) RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          queueData.tenant_id,\r\n          queueData.store_id,\r\n          queueData.name,\r\n          queueData.description,\r\n          queueData.extension,\r\n          queueData.strategy || 'ring-all',\r\n          queueData.max_wait_time || 300,\r\n          queueData.max_wait_time_with_no_agent || 60,\r\n          queueData.max_wait_time_with_no_agent_time_reached || 5,\r\n          queueData.tier_rules_apply !== false,\r\n          queueData.tier_rule_wait_second || 300,\r\n          queueData.tier_rule_wait_multiply_level !== false,\r\n          queueData.tier_rule_no_agent_no_wait || false,\r\n          queueData.discard_abandoned_after || 60,\r\n          queueData.abandoned_resume_allowed || false,\r\n          queueData.moh_sound,\r\n          queueData.record_template,\r\n          queueData.time_base_score || 'system',\r\n          queueData.queue_timeout || 60,\r\n          queueData.queue_timeout_action || 'hangup',\r\n          queueData.queue_timeout_destination,\r\n          queueData.failover_enabled || false,\r\n          queueData.failover_destination_type,\r\n          queueData.failover_destination_id,\r\n          JSON.stringify(queueData.failover_destination_data || {}),\r\n          queueData.caller_id_name,\r\n          queueData.caller_id_number,\r\n          queueData.recording_enabled || false,\r\n          queueData.recording_path,\r\n          queueData.recording_consent_required !== false,\r\n          queueData.max_concurrent_calls || 10,\r\n          queueData.current_calls || 0,\r\n          JSON.stringify(queueData.settings || {}),\r\n          queueData.enabled !== false\r\n        ]\r\n      );\r\n\r\n      const queue = result.rows[0];\r\n      return this.mapRowToCallQueue(queue);\r\n    });\r\n  }\r\n\r\n  // Get call queues for a tenant\r\n  async getCallQueues(tenantId: string, storeId?: string): Promise<CallQueue[]> {\r\n    const client = await getClient();\r\n    try {\r\n      let query = `\r\n        SELECT cq.*, \r\n               COALESCE(\r\n                 (SELECT jsonb_agg(\r\n                   jsonb_build_object(\r\n                     'id', qa.id,\r\n                     'extension_id', qa.extension_id,\r\n                     'agent_name', qa.agent_name,\r\n                     'agent_type', qa.agent_type,\r\n                     'contact', qa.contact,\r\n                     'status', qa.status,\r\n                     'state', qa.state,\r\n                     'max_no_answer', qa.max_no_answer,\r\n                     'wrap_up_time', qa.wrap_up_time,\r\n                     'reject_delay_time', qa.reject_delay_time,\r\n                     'busy_delay_time', qa.busy_delay_time,\r\n                     'no_answer_delay_time', qa.no_answer_delay_time,\r\n                     'calls_answered', qa.calls_answered,\r\n                     'talk_time', qa.talk_time,\r\n                     'tier_level', qa.tier_level,\r\n                     'tier_position', qa.tier_position,\r\n                     'enabled', qa.enabled\r\n                   )\r\n                 )\r\n                 FROM queue_agents qa\r\n                 WHERE qa.queue_id = cq.id\r\n                 AND qa.enabled = true\r\n                 ORDER BY qa.tier_level ASC, qa.tier_position ASC\r\n                ), '[]'::jsonb\r\n               ) as agents\r\n        FROM call_queues cq\r\n        WHERE cq.tenant_id = $1\r\n      `;\r\n      \r\n      const params: any[] = [tenantId];\r\n      \r\n      if (storeId) {\r\n        query += ' AND cq.store_id = $2';\r\n        params.push(storeId);\r\n      }\r\n      \r\n      query += ' ORDER BY cq.name ASC';\r\n      \r\n      const result = await client.query(query, params);\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToCallQueue(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get call queue by ID\r\n  async getCallQueue(queueId: string): Promise<CallQueue | null> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT cq.*, \r\n                COALESCE(\r\n                  (SELECT jsonb_agg(\r\n                    jsonb_build_object(\r\n                      'id', qa.id,\r\n                      'extension_id', qa.extension_id,\r\n                      'agent_name', qa.agent_name,\r\n                      'agent_type', qa.agent_type,\r\n                      'contact', qa.contact,\r\n                      'status', qa.status,\r\n                      'state', qa.state,\r\n                      'max_no_answer', qa.max_no_answer,\r\n                      'wrap_up_time', qa.wrap_up_time,\r\n                      'reject_delay_time', qa.reject_delay_time,\r\n                      'busy_delay_time', qa.busy_delay_time,\r\n                      'no_answer_delay_time', qa.no_answer_delay_time,\r\n                      'calls_answered', qa.calls_answered,\r\n                      'talk_time', qa.talk_time,\r\n                      'tier_level', qa.tier_level,\r\n                      'tier_position', qa.tier_position,\r\n                      'enabled', qa.enabled\r\n                    )\r\n                  )\r\n                  FROM queue_agents qa\r\n                  WHERE qa.queue_id = cq.id\r\n                  AND qa.enabled = true\r\n                  ORDER BY qa.tier_level ASC, qa.tier_position ASC\r\n                 ), '[]'::jsonb\r\n                ) as agents\r\n         FROM call_queues cq\r\n         WHERE cq.id = $1`,\r\n        [queueId]\r\n      );\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      return this.mapRowToCallQueue(result.rows[0]);\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Add agent to queue\r\n  async addAgent(queueId: string, extensionId: string, agentData: Partial<QueueAgent>): Promise<QueueAgent> {\r\n    return withTransaction(async (client) => {\r\n      // Verify queue exists\r\n      const queueResult = await client.query(\r\n        'SELECT id FROM call_queues WHERE id = $1',\r\n        [queueId]\r\n      );\r\n\r\n      if (queueResult.rows.length === 0) {\r\n        throw new Error('Call queue not found');\r\n      }\r\n\r\n      // Verify extension exists\r\n      const extensionResult = await client.query(\r\n        'SELECT id, extension, display_name FROM extensions WHERE id = $1',\r\n        [extensionId]\r\n      );\r\n\r\n      if (extensionResult.rows.length === 0) {\r\n        throw new Error('Extension not found');\r\n      }\r\n\r\n      const extension = extensionResult.rows[0];\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO queue_agents (\r\n          id, queue_id, extension_id, agent_name, agent_type, contact,\r\n          status, state, max_no_answer, wrap_up_time, reject_delay_time,\r\n          busy_delay_time, no_answer_delay_time, tier_level, tier_position,\r\n          enabled, settings\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n        ON CONFLICT (queue_id, extension_id) \r\n        DO UPDATE SET \r\n          agent_name = EXCLUDED.agent_name,\r\n          agent_type = EXCLUDED.agent_type,\r\n          contact = EXCLUDED.contact,\r\n          max_no_answer = EXCLUDED.max_no_answer,\r\n          wrap_up_time = EXCLUDED.wrap_up_time,\r\n          reject_delay_time = EXCLUDED.reject_delay_time,\r\n          busy_delay_time = EXCLUDED.busy_delay_time,\r\n          no_answer_delay_time = EXCLUDED.no_answer_delay_time,\r\n          tier_level = EXCLUDED.tier_level,\r\n          tier_position = EXCLUDED.tier_position,\r\n          enabled = EXCLUDED.enabled,\r\n          settings = EXCLUDED.settings,\r\n          updated_at = CURRENT_TIMESTAMP\r\n        RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          queueId,\r\n          extensionId,\r\n          agentData.agent_name || `${extension.display_name} (${extension.extension})`,\r\n          agentData.agent_type || 'callback',\r\n          agentData.contact || `user/${extension.extension}@\\${domain_name}`,\r\n          agentData.status || 'Available',\r\n          agentData.state || 'Waiting',\r\n          agentData.max_no_answer || 3,\r\n          agentData.wrap_up_time || 10,\r\n          agentData.reject_delay_time || 10,\r\n          agentData.busy_delay_time || 60,\r\n          agentData.no_answer_delay_time || 60,\r\n          agentData.tier_level || 1,\r\n          agentData.tier_position || 1,\r\n          agentData.enabled !== false,\r\n          JSON.stringify(agentData.settings || {})\r\n        ]\r\n      );\r\n\r\n      return this.mapRowToQueueAgent(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Remove agent from queue\r\n  async removeAgent(queueId: string, extensionId: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        'DELETE FROM queue_agents WHERE queue_id = $1 AND extension_id = $2',\r\n        [queueId, extensionId]\r\n      );\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('Agent not found in queue');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Update agent status\r\n  async updateAgentStatus(queueId: string, extensionId: string, status: string, state?: string): Promise<QueueAgent> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `UPDATE queue_agents SET \r\n          status = $1,\r\n          state = COALESCE($2, state),\r\n          last_status_change = CURRENT_TIMESTAMP,\r\n          updated_at = CURRENT_TIMESTAMP\r\n        WHERE queue_id = $3 AND extension_id = $4\r\n        RETURNING *`,\r\n        [status, state, queueId, extensionId]\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Agent not found in queue');\r\n      }\r\n\r\n      return this.mapRowToQueueAgent(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Update call queue\r\n  async updateCallQueue(queueId: string, updateData: Partial<CallQueue>): Promise<CallQueue> {\r\n    return withTransaction(async (client) => {\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.description !== undefined) {\r\n        updateFields.push(`description = $${paramCount++}`);\r\n        updateValues.push(updateData.description);\r\n      }\r\n      if (updateData.strategy) {\r\n        updateFields.push(`strategy = $${paramCount++}`);\r\n        updateValues.push(updateData.strategy);\r\n      }\r\n      if (updateData.max_wait_time !== undefined) {\r\n        updateFields.push(`max_wait_time = $${paramCount++}`);\r\n        updateValues.push(updateData.max_wait_time);\r\n      }\r\n      if (updateData.enabled !== undefined) {\r\n        updateFields.push(`enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.enabled);\r\n      }\r\n      if (updateData.settings) {\r\n        updateFields.push(`settings = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.settings));\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        throw new Error('No fields to update');\r\n      }\r\n\r\n      updateFields.push(`updated_at = CURRENT_TIMESTAMP`);\r\n      updateValues.push(queueId);\r\n\r\n      const result = await client.query(\r\n        `UPDATE call_queues SET ${updateFields.join(', ')} WHERE id = $${paramCount} RETURNING *`,\r\n        updateValues\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Call queue not found');\r\n      }\r\n\r\n      return this.mapRowToCallQueue(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Delete call queue\r\n  async deleteCallQueue(queueId: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        'DELETE FROM call_queues WHERE id = $1',\r\n        [queueId]\r\n      );\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('Call queue not found');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Get queue call logs\r\n  async getCallLogs(queueId: string, limit: number = 50, offset: number = 0): Promise<QueueCallLog[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM queue_call_logs \r\n         WHERE queue_id = $1 \r\n         ORDER BY start_time DESC \r\n         LIMIT $2 OFFSET $3`,\r\n        [queueId, limit, offset]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToQueueCallLog(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get queue statistics\r\n  async getStatistics(queueId: string, startDate: Date, endDate: Date): Promise<QueueStatistics[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM queue_statistics WHERE queue_id = $1 AND date BETWEEN $2 AND $3 ORDER BY date ASC',\r\n        [queueId, startDate, endDate]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToQueueStatistics(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Log queue call\r\n  async logCall(callData: Partial<QueueCallLog>): Promise<string> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT log_queue_call($1, $2, $3, $4, $5, $6, $7)`,\r\n        [\r\n          callData.queue_id,\r\n          callData.call_uuid,\r\n          callData.caller_id_name,\r\n          callData.caller_id_number,\r\n          callData.destination_number,\r\n          callData.queue_position,\r\n          callData.settings ? JSON.stringify(callData.settings) : '{}'\r\n        ]\r\n      );\r\n\r\n      return result.rows[0].log_queue_call;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Update queue call log\r\n  async updateCallLog(callUuid: string, updateData: Partial<QueueCallLog>): Promise<void> {\r\n    const client = await getClient();\r\n    try {\r\n      await client.query(\r\n        `SELECT update_queue_call_log($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\r\n        [\r\n          callUuid,\r\n          updateData.end_time,\r\n          updateData.duration,\r\n          updateData.hangup_cause,\r\n          updateData.answered_by_agent,\r\n          updateData.answered_by_extension,\r\n          updateData.agent_wait_time,\r\n          updateData.agent_talk_time,\r\n          updateData.recording_path\r\n        ]\r\n      );\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Update queue statistics\r\n  async updateStatistics(queueId: string, date: Date, stats: {\r\n    total_calls?: number;\r\n    answered_calls?: number;\r\n    abandoned_calls?: number;\r\n    total_wait_time?: number;\r\n    total_talk_time?: number;\r\n  }): Promise<void> {\r\n    const client = await getClient();\r\n    try {\r\n      await client.query(\r\n        `SELECT update_queue_statistics($1, $2, $3, $4, $5, $6, $7)`,\r\n        [\r\n          queueId,\r\n          date,\r\n          stats.total_calls,\r\n          stats.answered_calls,\r\n          stats.abandoned_calls,\r\n          stats.total_wait_time,\r\n          stats.total_talk_time\r\n        ]\r\n      );\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Generate FreeSWITCH callcenter configuration XML\r\n  generateCallcenterXML(queue: CallQueue): string {\r\n    const agents = queue.agents.filter(a => a.enabled);\r\n    \r\n    let xml = `\r\n  <!-- Call Queue: ${queue.name} (${queue.extension}) -->\r\n  <extension name=\"queue_${queue.id}\">\r\n    <condition field=\"destination_number\" expression=\"^${queue.extension}$\">\r\n      <action application=\"answer\"/>\r\n      <action application=\"set\" data=\"queue_id=${queue.id}\"/>\r\n      <action application=\"set\" data=\"queue_name=${queue.name}\"/>\r\n      <action application=\"set\" data=\"queue_timeout=${queue.queue_timeout}\"/>`;\r\n\r\n    // Add caller ID settings\r\n    if (queue.caller_id_name) {\r\n      xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_name=${queue.caller_id_name}\"/>`;\r\n    }\r\n    if (queue.caller_id_number) {\r\n      xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_number=${queue.caller_id_number}\"/>`;\r\n    }\r\n\r\n    // Add music on hold if specified\r\n    if (queue.moh_sound) {\r\n      xml += `\r\n      <action application=\"set\" data=\"moh_sound=${queue.moh_sound}\"/>`;\r\n    }\r\n\r\n    // Generate queue bridge based on strategy\r\n    xml += this.generateQueueBridgeXML(queue);\r\n\r\n    // Add timeout action\r\n    xml += this.generateTimeoutActionXML(queue);\r\n\r\n    xml += `\r\n    </condition>\r\n  </extension>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate queue bridge XML based on strategy\r\n  private generateQueueBridgeXML(queue: CallQueue): string {\r\n    const agents = queue.agents.filter(a => a.enabled);\r\n    if (agents.length === 0) {\r\n      return `\r\n      <action application=\"log\" data=\"ERROR No active agents in queue ${queue.name}\"/>\r\n      <action application=\"hangup\" data=\"NO_ANSWER\"/>`;\r\n    }\r\n\r\n    // For mod_callcenter, we use the callcenter application\r\n    const agentTargets = agents\r\n      .map(agent => `agent/${agent.agent_name}`)\r\n      .join(' ');\r\n\r\n    return `\r\n      <action application=\"callcenter\" data=\"queue_${queue.id}\"/>`;\r\n  }\r\n\r\n  // Generate timeout action XML\r\n  private generateTimeoutActionXML(queue: CallQueue): string {\r\n    switch (queue.queue_timeout_action) {\r\n      case 'voicemail':\r\n        return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"voicemail\" data=\"default \\${domain_name} ${queue.queue_timeout_destination || '100'}\"/>\r\n        <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      </condition>`;\r\n      case 'forward':\r\n        if (queue.queue_timeout_destination) {\r\n          return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"bridge\" data=\"user/${queue.queue_timeout_destination}@\\${domain_name}\"/>\r\n        <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      </condition>`;\r\n        }\r\n        break;\r\n      case 'hangup':\r\n        return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"hangup\" data=\"NO_ANSWER\"/>\r\n      </condition>`;\r\n    }\r\n\r\n    return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"hangup\" data=\"NO_ANSWER\"/>\r\n      </condition>`;\r\n  }\r\n\r\n  // Helper methods to map database rows to objects\r\n  private mapRowToCallQueue(row: any): CallQueue {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      store_id: row.store_id,\r\n      name: row.name,\r\n      description: row.description,\r\n      extension: row.extension,\r\n      strategy: row.strategy,\r\n      max_wait_time: row.max_wait_time,\r\n      max_wait_time_with_no_agent: row.max_wait_time_with_no_agent,\r\n      max_wait_time_with_no_agent_time_reached: row.max_wait_time_with_no_agent_time_reached,\r\n      tier_rules_apply: row.tier_rules_apply,\r\n      tier_rule_wait_second: row.tier_rule_wait_second,\r\n      tier_rule_wait_multiply_level: row.tier_rule_wait_multiply_level,\r\n      tier_rule_no_agent_no_wait: row.tier_rule_no_agent_no_wait,\r\n      discard_abandoned_after: row.discard_abandoned_after,\r\n      abandoned_resume_allowed: row.abandoned_resume_allowed,\r\n      agents: typeof row.agents === 'string' ? JSON.parse(row.agents) : row.agents,\r\n      moh_sound: row.moh_sound,\r\n      record_template: row.record_template,\r\n      time_base_score: row.time_base_score,\r\n      queue_timeout: row.queue_timeout,\r\n      queue_timeout_action: row.queue_timeout_action,\r\n      queue_timeout_destination: row.queue_timeout_destination,\r\n      failover_enabled: row.failover_enabled,\r\n      failover_destination_type: row.failover_destination_type,\r\n      failover_destination_id: row.failover_destination_id,\r\n      failover_destination_data: typeof row.failover_destination_data === 'string' ? JSON.parse(row.failover_destination_data) : row.failover_destination_data,\r\n      caller_id_name: row.caller_id_name,\r\n      caller_id_number: row.caller_id_number,\r\n      recording_enabled: row.recording_enabled,\r\n      recording_path: row.recording_path,\r\n      recording_consent_required: row.recording_consent_required,\r\n      max_concurrent_calls: row.max_concurrent_calls,\r\n      current_calls: row.current_calls,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      enabled: row.enabled,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n\r\n  private mapRowToQueueAgent(row: any): QueueAgent {\r\n    return {\r\n      id: row.id,\r\n      queue_id: row.queue_id,\r\n      extension_id: row.extension_id,\r\n      agent_name: row.agent_name,\r\n      agent_type: row.agent_type,\r\n      contact: row.contact,\r\n      status: row.status,\r\n      state: row.state,\r\n      max_no_answer: row.max_no_answer,\r\n      wrap_up_time: row.wrap_up_time,\r\n      reject_delay_time: row.reject_delay_time,\r\n      busy_delay_time: row.busy_delay_time,\r\n      no_answer_delay_time: row.no_answer_delay_time,\r\n      last_bridge_start: row.last_bridge_start,\r\n      last_bridge_end: row.last_bridge_end,\r\n      last_offered_call: row.last_offered_call,\r\n      last_status_change: row.last_status_change,\r\n      no_answer_count: row.no_answer_count,\r\n      calls_answered: row.calls_answered,\r\n      talk_time: row.talk_time,\r\n      ready_time: row.ready_time,\r\n      external_calls_count: row.external_calls_count,\r\n      uuid: row.uuid,\r\n      tier_level: row.tier_level,\r\n      tier_position: row.tier_position,\r\n      enabled: row.enabled,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n\r\n  private mapRowToQueueCallLog(row: any): QueueCallLog {\r\n    return {\r\n      id: row.id,\r\n      queue_id: row.queue_id,\r\n      call_uuid: row.call_uuid,\r\n      caller_id_name: row.caller_id_name,\r\n      caller_id_number: row.caller_id_number,\r\n      destination_number: row.destination_number,\r\n      queue_position: row.queue_position,\r\n      queue_wait_time: row.queue_wait_time,\r\n      start_time: row.start_time,\r\n      end_time: row.end_time,\r\n      duration: row.duration,\r\n      hangup_cause: row.hangup_cause,\r\n      answered_by_agent: row.answered_by_agent,\r\n      answered_by_extension: row.answered_by_extension,\r\n      agent_wait_time: row.agent_wait_time,\r\n      agent_talk_time: row.agent_talk_time,\r\n      recording_path: row.recording_path,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      created_at: row.created_at\r\n    };\r\n  }\r\n\r\n  private mapRowToQueueStatistics(row: any): QueueStatistics {\r\n    return {\r\n      id: row.id,\r\n      queue_id: row.queue_id,\r\n      date: row.date,\r\n      total_calls: row.total_calls,\r\n      answered_calls: row.answered_calls,\r\n      abandoned_calls: row.abandoned_calls,\r\n      total_wait_time: row.total_wait_time,\r\n      average_wait_time: row.average_wait_time,\r\n      longest_wait_time: row.longest_wait_time,\r\n      total_talk_time: row.total_talk_time,\r\n      average_talk_time: row.average_talk_time,\r\n      longest_talk_time: row.longest_talk_time,\r\n      service_level_percentage: row.service_level_percentage,\r\n      service_level_threshold: row.service_level_threshold,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const queueService = new QueueService();\r\n","size_bytes":28864},"packages/frontend/src/components/SessionTimeout.tsx":{"content":"import React, { useState, useEffect } from 'react';\r\nimport { AlertTriangle, Clock } from 'lucide-react';\r\n\r\ninterface SessionTimeoutProps {\r\n  expiresAt: number;\r\n  onLogout: () => void;\r\n}\r\n\r\nexport default function SessionTimeout({ expiresAt, onLogout }: SessionTimeoutProps) {\r\n  const [timeLeft, setTimeLeft] = useState<number>(0);\r\n  const [showWarning, setShowWarning] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    const updateTimeLeft = () => {\r\n      const now = Date.now();\r\n      const remaining = Math.max(0, expiresAt - now);\r\n      setTimeLeft(remaining);\r\n\r\n      // Show warning when 2 minutes left\r\n      if (remaining <= 2 * 60 * 1000 && remaining > 0) {\r\n        setShowWarning(true);\r\n      } else if (remaining === 0) {\r\n        onLogout();\r\n      }\r\n    };\r\n\r\n    updateTimeLeft();\r\n    const interval = setInterval(updateTimeLeft, 1000);\r\n\r\n    return () => clearInterval(interval);\r\n  }, [expiresAt, onLogout]);\r\n\r\n  const formatTime = (ms: number) => {\r\n    const minutes = Math.floor(ms / (1000 * 60));\r\n    const seconds = Math.floor((ms % (1000 * 60)) / 1000);\r\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\r\n  };\r\n\r\n  if (!showWarning || timeLeft === 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div className=\"fixed top-4 right-4 z-50 bg-yellow-50 border border-yellow-200 rounded-lg p-4 shadow-lg max-w-sm\">\r\n      <div className=\"flex items-start space-x-3\">\r\n        <AlertTriangle className=\"h-5 w-5 text-yellow-600 mt-0.5 flex-shrink-0\" />\r\n        <div className=\"flex-1\">\r\n          <h3 className=\"text-sm font-medium text-yellow-800\">\r\n            Sessione in scadenza\r\n          </h3>\r\n          <p className=\"text-sm text-yellow-700 mt-1\">\r\n            La tua sessione scadrà tra{' '}\r\n            <span className=\"font-mono font-semibold\">{formatTime(timeLeft)}</span>\r\n          </p>\r\n          <div className=\"mt-3 flex items-center space-x-2\">\r\n            <Clock className=\"h-4 w-4 text-yellow-600\" />\r\n            <span className=\"text-xs text-yellow-600\">\r\n              Fai login per continuare\r\n            </span>\r\n          </div>\r\n        </div>\r\n        <button\r\n          onClick={onLogout}\r\n          className=\"text-yellow-600 hover:text-yellow-800 text-sm font-medium\"\r\n        >\r\n          Esci\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":2340},"packages/backend/src/routes/sip-trunks.ts":{"content":"import { Router } from 'express';\nimport { authenticateToken, requireTenant, setTenantContext } from '../middleware';\nimport { successResponse, errorResponse, asyncHandler } from '../utils/response';\nimport { getClient } from '@w3-voip/database';\n\nconst router = Router();\n\n// Apply authentication and tenant context to all routes\nrouter.use(authenticateToken);\nrouter.use(requireTenant);\nrouter.use(setTenantContext);\n\n// Get SIP trunks for tenant\nrouter.get('/', asyncHandler(async (req, res) => {\n  const client = await getClient();\n  \n  try {\n    const result = await client.query(\n      `SELECT \n        id, \n        tenant_id, \n        name, \n        provider, \n        status,\n        provider_config,\n        sip_config,\n        created_at,\n        updated_at\n      FROM sip_trunks \n      WHERE tenant_id = $1 \n      ORDER BY created_at DESC`,\n      [req.tenantId]\n    );\n    \n    successResponse(res, result.rows, 'SIP trunks retrieved successfully');\n  } catch (error) {\n    console.error('Error fetching SIP trunks:', error);\n    errorResponse(res, 'Failed to fetch SIP trunks', 500);\n  } finally {\n    await client.release();\n  }\n}));\n\n// Get SIP trunk status\nrouter.get('/:id/status', asyncHandler(async (req, res) => {\n  const trunkId = req.params.id;\n  const client = await getClient();\n  \n  try {\n    const result = await client.query(\n      `SELECT \n        id, \n        name, \n        status,\n        last_successful_registration,\n        current_calls,\n        max_concurrent_calls\n      FROM sip_trunks \n      WHERE id = $1 AND tenant_id = $2`,\n      [trunkId, req.tenantId]\n    );\n    \n    if (result.rows.length === 0) {\n      return errorResponse(res, 'SIP trunk not found', 404);\n    }\n    \n    const trunk = result.rows[0];\n    const status = {\n      id: trunk.id,\n      name: trunk.name,\n      status: trunk.status,\n      last_registration: trunk.last_successful_registration,\n      calls_in: trunk.current_calls || 0,\n      calls_out: 0,\n      failed_calls: 0\n    };\n    \n    successResponse(res, status, 'SIP trunk status retrieved successfully');\n  } catch (error) {\n    console.error('Error fetching SIP trunk status:', error);\n    errorResponse(res, 'Failed to fetch SIP trunk status', 500);\n  } finally {\n    await client.release();\n  }\n}));\n\nexport default router;\n","size_bytes":2298},"packages/frontend/src/lib/api.ts":{"content":"const API_BASE_URL = (import.meta as any).env?.VITE_API_BASE_URL || '/api';\r\n\r\nexport interface ApiResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: string;\r\n  message?: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Note: Shared types will be imported when the shared package is built\r\n\r\nclass ApiClient {\r\n  private baseURL: string;\r\n  private token: string | null = null;\r\n\r\n  constructor(baseURL: string) {\r\n    this.baseURL = baseURL;\r\n  }\r\n\r\n  setToken(token: string) {\r\n    this.token = token;\r\n  }\r\n\r\n  clearToken() {\r\n    this.token = null;\r\n  }\r\n\r\n  // Generic HTTP methods\r\n  async get<T>(endpoint: string): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { method: 'GET' });\r\n  }\r\n\r\n  async post<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, {\r\n      method: 'POST',\r\n      body: data ? JSON.stringify(data) : undefined,\r\n    });\r\n  }\r\n\r\n  async put<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, {\r\n      method: 'PUT',\r\n      body: data ? JSON.stringify(data) : undefined,\r\n    });\r\n  }\r\n\r\n  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {\r\n    return this.request<T>(endpoint, { method: 'DELETE' });\r\n  }\r\n\r\n  async login(email: string, password: string) {\r\n    return this.request('/auth/login', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ email, password }),\r\n    });\r\n  }\r\n\r\n  async request<T>(\r\n    endpoint: string,\r\n    options: RequestInit = {}\r\n  ): Promise<ApiResponse<T>> {\r\n    const url = `${this.baseURL}${endpoint}`;\r\n    const headers: HeadersInit = {\r\n      'Content-Type': 'application/json',\r\n      ...options.headers,\r\n    };\r\n\r\n    if (this.token) {\r\n      (headers as any).Authorization = `Bearer ${this.token}`;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(url, {\r\n        ...options,\r\n        headers,\r\n      });\r\n\r\n      const data = await response.json();\r\n\r\n      if (!response.ok) {\r\n        // Handle 401 Unauthorized - token expired\r\n        if (response.status === 401) {\r\n          // Clear token and redirect to login\r\n          this.clearToken();\r\n          localStorage.removeItem('token');\r\n          localStorage.removeItem('user');\r\n          window.location.href = '/login';\r\n        }\r\n        const errorMessage = typeof data.error === 'string' \r\n          ? data.error \r\n          : data.error?.message || data.error?.code || JSON.stringify(data.error) || `HTTP ${response.status}`;\r\n        throw new Error(errorMessage);\r\n      }\r\n\r\n      return data;\r\n    } catch (error) {\r\n      console.error('API request failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Health check\r\n  async health(): Promise<ApiResponse> {\r\n    return this.request('/health');\r\n  }\r\n\r\n  // Tenants\r\n  async getTenants(params?: { page?: number; limit?: number; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/tenants?${query.toString()}`);\r\n  }\r\n\r\n  async getTenant(id: string) {\r\n    return this.request(`/tenants/${id}`);\r\n  }\r\n\r\n  async createTenant(data: { name: string; domain: string; edg_suite_id: string }) {\r\n    return this.request('/tenants', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async updateTenant(id: string, data: Partial<{ name: string; domain: string; edg_suite_id: string }>) {\r\n    return this.request(`/tenants/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async deleteTenant(id: string) {\r\n    return this.request(`/tenants/${id}`, {\r\n      method: 'DELETE',\r\n    });\r\n  }\r\n\r\n  // Stores\r\n  async getStores(params?: { page?: number; limit?: number; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/stores?${query.toString()}`);\r\n  }\r\n\r\n  async getStore(id: string) {\r\n    return this.request(`/stores/${id}`);\r\n  }\r\n\r\n  async createStore(data: { name: string; store_id: string; sip_trunk_settings?: any }) {\r\n    return this.request('/stores', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async updateStore(id: string, data: Partial<{ name: string; store_id: string; sip_trunk_settings?: any }>) {\r\n    return this.request(`/stores/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async deleteStore(id: string) {\r\n    return this.request(`/stores/${id}`, {\r\n      method: 'DELETE',\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Extensions\r\n  async getExtensions(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/sip-extensions?${query.toString()}`);\r\n  }\r\n\r\n  async createW3Extension(data: { ext_number: string; display_name: string; enabled?: boolean; voicemail_enabled?: boolean; class_of_service?: string; note?: string; store_id?: string }) {\r\n    return this.request('/w3-voip/extensions', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - SIP Trunks\r\n  async getSipTrunks(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/sip-trunks?${query.toString()}`);\r\n  }\r\n\r\n  async createW3Trunk(data: { provider: string; proxy: string; port?: number; transport?: string; auth_username: string; secret_ref: string; register?: boolean; expiry_seconds?: number; codec_set?: string; note?: string; store_id?: string }) {\r\n    return this.request('/w3-voip/trunks', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Time Conditions\r\n  async getTimeConditions(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/time-conditions?${query.toString()}`);\r\n  }\r\n\r\n  async createTimeCondition(data: { name: string; description?: string; timezone?: string; store_id?: string }) {\r\n    return this.request('/voip/time-conditions', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - IVR Menus\r\n  async getIvrMenus(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/ivr-menus?${query.toString()}`);\r\n  }\r\n\r\n  async createIvrMenu(data: { name: string; description?: string; greeting_message?: string; store_id?: string }) {\r\n    return this.request('/voip/ivr-menus', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Ring Groups\r\n  async getRingGroups(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/ring-groups?${query.toString()}`);\r\n  }\r\n\r\n  async createRingGroup(data: { name: string; extension_number: string; description?: string; store_id?: string }) {\r\n    return this.request('/voip/ring-groups', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Queues\r\n  async getQueues(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/queues?${query.toString()}`);\r\n  }\r\n\r\n  async createQueue(data: { name: string; extension_number: string; description?: string; store_id?: string }) {\r\n    return this.request('/voip/queues', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Conference Rooms\r\n  async getConferenceRooms(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/conference-rooms?${query.toString()}`);\r\n  }\r\n\r\n  async createConferenceRoom(data: { name: string; extension_number: string; description?: string; store_id?: string }) {\r\n    return this.request('/voip/conference-rooms', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // VoIP Entities - Voicemail Boxes\r\n  async getVoicemailBoxes(params?: { page?: number; limit?: number; store_id?: string; search?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.page) query.append('page', params.page.toString());\r\n    if (params?.limit) query.append('limit', params.limit.toString());\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    if (params?.search) query.append('search', params.search);\r\n    \r\n    return this.request(`/voip/voicemail-boxes?${query.toString()}`);\r\n  }\r\n\r\n  async createVoicemailBox(data: { extension_number: string; password: string; display_name: string; email_address?: string; store_id?: string }) {\r\n    return this.request('/voip/voicemail-boxes', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // ===== W3 VOIP API METHODS =====\r\n  \r\n  // W3 Trunks\r\n  async getW3Trunks(params?: { store_id?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    \r\n    return this.request(`/w3-voip/trunks?${query.toString()}`);\r\n  }\r\n\r\n  async getW3Trunk(id: string) {\r\n    return this.request(`/w3-voip/trunks/${id}`);\r\n  }\r\n\r\n  async updateW3Trunk(id: string, data: any) {\r\n    return this.request(`/w3-voip/trunks/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async deleteW3Trunk(id: string) {\r\n    return this.request(`/w3-voip/trunks/${id}`, {\r\n      method: 'DELETE',\r\n    });\r\n  }\r\n\r\n  // W3 Extensions\r\n  async getW3Extensions(params?: { store_id?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    \r\n    return this.request(`/w3-voip/extensions?${query.toString()}`);\r\n  }\r\n\r\n  async getW3Extension(id: string) {\r\n    return this.request(`/w3-voip/extensions/${id}`);\r\n  }\r\n\r\n  async updateW3Extension(id: string, data: any) {\r\n    return this.request(`/w3-voip/extensions/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async deleteW3Extension(id: string) {\r\n    return this.request(`/w3-voip/extensions/${id}`, {\r\n      method: 'DELETE',\r\n    });\r\n  }\r\n\r\n  // W3 DIDs\r\n  async getW3Dids(params?: { store_id?: string }) {\r\n    const query = new URLSearchParams();\r\n    if (params?.store_id) query.append('store_id', params.store_id);\r\n    \r\n    return this.request(`/w3-voip/dids?${query.toString()}`);\r\n  }\r\n\r\n  async createW3Did(data: { trunk_id: string; e164: string; route_target_type: string; route_target_ref: string; label: string; active?: boolean; store_id?: string }) {\r\n    return this.request('/w3-voip/dids', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // W3 Routes\r\n  async getW3Routes() {\r\n    return this.request('/w3-voip/routes');\r\n  }\r\n\r\n  async createW3Route(data: { name: string; pattern: string; strip_digits?: number; prepend?: string; trunk_id: string; priority?: number; active?: boolean }) {\r\n    return this.request('/w3-voip/routes', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // W3 Contact Policies\r\n  async getW3ContactPolicies() {\r\n    return this.request('/w3-voip/contact-policies');\r\n  }\r\n\r\n  async createW3ContactPolicy(data: { scope_type: string; scope_ref: string; rules_json: any; label: string; active?: boolean }) {\r\n    return this.request('/w3-voip/contact-policies', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  // CDR and Activity Logs\r\n  async getCdrs(params?: { store_id?: string; start_date?: string; end_date?: string; direction?: string; disposition?: string; ext_number?: string; did_e164?: string; limit?: number; offset?: number }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr?${query.toString()}`);\r\n  }\r\n\r\n  async getCdrStats(params?: { store_id?: string; start_date?: string; end_date?: string }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr/stats?${query.toString()}`);\r\n  }\r\n\r\n  async getActivityLogs(params?: { actor?: string; action?: string; target_type?: string; target_id?: string; status?: string; start_date?: string; end_date?: string; limit?: number; offset?: number }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr-activity/activity-log?${query.toString()}`);\r\n  }\r\n\r\n  async getActivityStats(params?: { start_date?: string; end_date?: string }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr-activity/activity-log/stats?${query.toString()}`);\r\n  }\r\n\r\n  async getExtension(id: string) {\r\n    return this.request(`/extensions/${id}`);\r\n  }\r\n\r\n  async createExtension(data: {\r\n    store_id?: string;\r\n    extension_number: string;\r\n    password: string;\r\n    caller_id_name?: string;\r\n    caller_id_number?: string;\r\n    enabled?: boolean;\r\n  }) {\r\n    return this.request('/extensions', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async updateExtension(id: string, data: Partial<{\r\n    store_id?: string;\r\n    extension_number: string;\r\n    password: string;\r\n    caller_id_name?: string;\r\n    caller_id_number?: string;\r\n    enabled?: boolean;\r\n  }>) {\r\n    return this.request(`/extensions/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async deleteExtension(id: string) {\r\n    return this.request(`/extensions/${id}`, {\r\n      method: 'DELETE',\r\n    });\r\n  }\r\n\n  // Users\n  async getUsers() {\n    return this.request('/users');\n  }\n\n  async createUser(data: {\n    email: string;\n    password: string;\n    first_name: string;\n    last_name: string;\n    role: 'tenant_admin' | 'agent' | 'user';\n  }) {\n    return this.request('/users', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async updateUser(id: string, data: Partial<{\n    first_name: string;\n    last_name: string;\n    role: 'tenant_admin' | 'agent' | 'user';\n    status: 'active' | 'inactive' | 'suspended';\n  }>) {\n    return this.request(`/users/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async deleteUser(id: string) {\n    return this.request(`/users/${id}`, {\n      method: 'DELETE',\n    });\n  }\n\r\n  // CDR\r\n  async getCDR(params?: {\r\n    page?: number;\r\n    limit?: number;\r\n    start_date?: string;\r\n    end_date?: string;\r\n    call_direction?: string;\r\n    caller_number?: string;\r\n    callee_number?: string;\r\n  }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr?${query.toString()}`);\r\n  }\r\n\r\n  async getCDRStats(params?: {\r\n    start_date?: string;\r\n    end_date?: string;\r\n    call_direction?: string;\r\n  }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr/stats?${query.toString()}`);\r\n  }\r\n\r\n  async exportCDR(format: 'csv' | 'json', params?: any) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/cdr/export/${format}?${query.toString()}`);\r\n  }\r\n\r\n  // Calls\r\n  async getCallStatus() {\r\n    return this.request('/calls/status');\r\n  }\r\n\r\n  async originateCall(data: {\r\n    caller_extension: string;\r\n    callee_number: string;\r\n    domain: string;\r\n    options?: {\r\n      timeout?: number;\r\n      caller_id?: string;\r\n      context?: string;\r\n      recording?: boolean;\r\n    };\r\n  }) {\r\n    return this.request('/calls/originate', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async transferCall(data: {\r\n    call_uuid: string;\r\n    destination: string;\r\n    type?: 'attended' | 'blind';\r\n  }) {\r\n    return this.request('/calls/transfer', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async hangupCall(data: {\r\n    call_uuid: string;\r\n    cause?: string;\r\n  }) {\r\n    return this.request('/calls/hangup', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async holdCall(data: {\r\n    call_uuid: string;\r\n    hold?: boolean;\r\n  }) {\r\n    return this.request('/calls/hold', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async muteCall(data: {\r\n    call_uuid: string;\r\n    mute?: boolean;\r\n  }) {\r\n    return this.request('/calls/mute', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async recordCall(data: {\r\n    call_uuid: string;\r\n    record?: boolean;\r\n    path?: string;\r\n  }) {\r\n    return this.request('/calls/record', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async getCallInfo(callUuid: string) {\r\n    return this.request(`/calls/info/${callUuid}`);\r\n  }\r\n\r\n  // ===== SUPER ADMIN & TENANT MANAGEMENT =====\r\n\r\n  // Cross-tenant statistics\r\n  async getCrossTenantStats() {\r\n    return this.request('/tenants/stats');\r\n  }\r\n\r\n  async getTenantStatsList() {\r\n    return this.request('/tenants/stats-list');\r\n  }\r\n\r\n  // Tenant management with companies, contacts and admin user\r\n  async createTenantWithCompanies(data: {\r\n    name: string;\r\n    slug: string;\r\n    domain: string;\r\n    sip_domain: string;\r\n    admin_user: {\r\n      first_name: string;\r\n      last_name: string;\r\n      email: string;\r\n      password: string;\r\n      role: 'tenant_admin' | 'super_admin';\r\n    };\r\n    companies: Array<{\r\n      legal_name: string;\r\n      vat_number?: string;\r\n      tax_code?: string;\r\n      address?: string;\r\n      city?: string;\r\n      state?: string;\r\n      postal_code?: string;\r\n      country?: string;\r\n      is_primary: boolean;\r\n    }>;\r\n    contacts: Array<{\r\n      first_name: string;\r\n      last_name: string;\r\n      role?: string;\r\n      email?: string;\r\n      phone?: string;\r\n      mobile?: string;\r\n      is_primary: boolean;\r\n    }>;\r\n  }) {\r\n    return this.request('/tenants', {\r\n      method: 'POST',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async getTenantWithDetails(id: string) {\r\n    return this.request(`/tenants/${id}`);\r\n  }\r\n\r\n  async updateTenantWithDetails(id: string, data: any) {\r\n    return this.request(`/tenants/${id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(data),\r\n    });\r\n  }\r\n\r\n  async activateTenant(id: string) {\r\n    return this.request(`/tenants/${id}/activate`, {\r\n      method: 'POST',\r\n    });\r\n  }\r\n\r\n  async suspendTenant(id: string) {\r\n    return this.request(`/tenants/${id}/suspend`, {\r\n      method: 'POST',\r\n    });\r\n  }\r\n\r\n  // User impersonation\r\n  async impersonateUser(tenantId: string, userId: string) {\r\n    return this.request(`/tenants/${tenantId}/impersonate`, {\r\n      method: 'POST',\r\n      body: JSON.stringify({ userId }),\r\n    });\r\n  }\r\n\r\n  // Cross-tenant analytics\r\n  async getCrossTenantCalls(params?: {\r\n    start_date?: string;\r\n    end_date?: string;\r\n    tenant_id?: string;\r\n    limit?: number;\r\n  }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/analytics/cross-tenant/calls?${query.toString()}`);\r\n  }\r\n\r\n  async getCrossTenantExtensions() {\r\n    return this.request('/analytics/cross-tenant/extensions');\r\n  }\r\n\r\n  async getCrossTenantLiveCalls() {\r\n    return this.request('/analytics/cross-tenant/live-calls');\r\n  }\r\n\r\n  async getCrossTenantUsers() {\r\n    return this.request('/analytics/cross-tenant/users');\r\n  }\r\n\r\n  async getCrossTenantCompanies() {\r\n    return this.request('/analytics/cross-tenant/companies');\r\n  }\r\n\r\n  async getCrossTenantSummary(params?: {\r\n    period?: '1h' | '24h' | '7d' | '30d';\r\n  }) {\r\n    const query = new URLSearchParams();\r\n    Object.entries(params || {}).forEach(([key, value]) => {\r\n      if (value !== undefined) query.append(key, value.toString());\r\n    });\r\n    \r\n    return this.request(`/analytics/cross-tenant/summary?${query.toString()}`);\r\n  }\r\n\r\n  // Impersonation management\r\n  private originalToken: string | null = null;\r\n\r\n  startImpersonation(impersonationToken: string) {\r\n    // Save original token\r\n    this.originalToken = this.token;\r\n    // Set impersonation token\r\n    this.token = impersonationToken;\r\n  }\r\n\r\n  exitImpersonation() {\r\n    if (this.originalToken) {\r\n      this.token = this.originalToken;\r\n      this.originalToken = null;\r\n    }\r\n  }\r\n\r\n  isImpersonating(): boolean {\r\n    return this.originalToken !== null;\r\n  }\r\n}\r\n\r\nexport const apiClient = new ApiClient(API_BASE_URL);\r\nexport default apiClient;","size_bytes":23975},"packages/backend/src/services/w3-voip-service.ts":{"content":"// @ts-nocheck\nimport { v4 as uuidv4 } from 'uuid';\n// import { \n//   VoipTrunk, \n//   VoipDid, \n//   VoipExtension, \n//   VoipRoute, \n//   ContactPolicy,\n//   CreateTrunkRequest,\n//   CreateDidRequest,\n//   CreateExtensionRequest,\n//   CreateRouteRequest,\n//   CreateContactPolicyRequest\n// } from '@w3-voip/shared';\n\n// Define types locally\nexport interface VoipTrunk {\n  id: string;\n  tenant_id: string;\n  name: string;\n  provider: string;\n  host: string;\n  port: number;\n  transport: 'udp' | 'tcp' | 'tls';\n  username: string;\n  password: string;\n  status: 'active' | 'inactive' | 'testing';\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface VoipDid {\n  id: string;\n  tenant_id: string;\n  trunk_id: string;\n  number: string;\n  country_code: string;\n  local_number: string;\n  status: 'active' | 'inactive';\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface VoipExtension {\n  id: string;\n  tenant_id: string;\n  store_id?: string;\n  extension: string;\n  password: string;\n  display_name: string;\n  status: 'active' | 'inactive';\n  type: 'user' | 'queue' | 'conference';\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface VoipRoute {\n  id: string;\n  tenant_id: string;\n  name: string;\n  pattern: string;\n  destination: string;\n  priority: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface ContactPolicy {\n  id: string;\n  tenant_id: string;\n  name: string;\n  rules: any[];\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface CreateTrunkRequest {\n  name: string;\n  provider: string;\n  host: string;\n  port: number;\n  transport: 'udp' | 'tcp' | 'tls';\n  username: string;\n  password: string;\n}\n\nexport interface CreateDidRequest {\n  trunk_id: string;\n  number: string;\n  country_code: string;\n  local_number: string;\n}\n\nexport interface CreateExtensionRequest {\n  extension: string;\n  password: string;\n  display_name: string;\n  type: 'user' | 'queue' | 'conference';\n}\n\nexport interface CreateRouteRequest {\n  name: string;\n  pattern: string;\n  destination: string;\n  priority: number;\n}\n\nexport interface CreateContactPolicyRequest {\n  name: string;\n  rules: any[];\n}\n\nexport interface TenantContext {\n  tenant_id: string;\n  sip_domain: string;\n  store_id?: string;\n}\n\nexport class W3VoipService {\n  // Mock database - in production this would be real database operations\n  private mockTrunks: VoipTrunk[] = [];\n  private mockDids: VoipDid[] = [];\n  private mockExtensions: VoipExtension[] = [];\n  private mockRoutes: VoipRoute[] = [];\n  private mockPolicies: ContactPolicy[] = [];\n\n  // ===== VOIP TRUNKS =====\n  async createTrunk(tenantContext: TenantContext, data: CreateTrunkRequest): Promise<VoipTrunk> {\n    const trunk: VoipTrunk = {\n      id: uuidv4(),\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id,\n      sip_domain: tenantContext.sip_domain,\n      provider: data.provider,\n      proxy: data.proxy,\n      port: data.port,\n      transport: data.transport,\n      auth_username: data.auth_username,\n      secret_ref: data.secret_ref,\n      register: data.register,\n      expiry_seconds: data.expiry_seconds,\n      codec_set: data.codec_set,\n      status: 'UNKNOWN',\n      note: data.note\n    };\n\n    this.mockTrunks.push(trunk);\n    console.log(`Created trunk: ${trunk.id} for tenant: ${tenantContext.tenant_id}`);\n    return trunk;\n  }\n\n  async getTrunks(tenantId: string, storeId?: string): Promise<VoipTrunk[]> {\n    return this.mockTrunks.filter(trunk => \n      trunk.tenant_id === tenantId && \n      (!storeId || trunk.store_id === storeId)\n    );\n  }\n\n  async getTrunkById(trunkId: string, tenantId: string): Promise<VoipTrunk | null> {\n    return this.mockTrunks.find(trunk => \n      trunk.id === trunkId && trunk.tenant_id === tenantId\n    ) || null;\n  }\n\n  async updateTrunk(trunkId: string, tenantId: string, data: Partial<CreateTrunkRequest>): Promise<VoipTrunk | null> {\n    const trunkIndex = this.mockTrunks.findIndex(trunk => \n      trunk.id === trunkId && trunk.tenant_id === tenantId\n    );\n\n    if (trunkIndex === -1) return null;\n\n    this.mockTrunks[trunkIndex] = {\n      ...this.mockTrunks[trunkIndex],\n      ...data,\n      id: trunkId, // Ensure ID doesn't change\n      tenant_id: tenantId // Ensure tenant_id doesn't change\n    };\n\n    return this.mockTrunks[trunkIndex];\n  }\n\n  async deleteTrunk(trunkId: string, tenantId: string): Promise<boolean> {\n    const trunkIndex = this.mockTrunks.findIndex(trunk => \n      trunk.id === trunkId && trunk.tenant_id === tenantId\n    );\n\n    if (trunkIndex === -1) return false;\n\n    this.mockTrunks.splice(trunkIndex, 1);\n    return true;\n  }\n\n  // ===== VOIP DIDS =====\n  async createDid(tenantContext: TenantContext, data: CreateDidRequest): Promise<VoipDid> {\n    const did: VoipDid = {\n      id: uuidv4(),\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id,\n      trunk_id: data.trunk_id,\n      e164: data.e164,\n      sip_domain: tenantContext.sip_domain,\n      route_target_type: data.route_target_type,\n      route_target_ref: data.route_target_ref,\n      label: data.label,\n      active: data.active\n    };\n\n    this.mockDids.push(did);\n    console.log(`Created DID: ${did.e164} for tenant: ${tenantContext.tenant_id}`);\n    return did;\n  }\n\n  async getDids(tenantId: string, storeId?: string): Promise<VoipDid[]> {\n    return this.mockDids.filter(did => \n      did.tenant_id === tenantId && \n      (!storeId || did.store_id === storeId)\n    );\n  }\n\n  async getDidById(didId: string, tenantId: string): Promise<VoipDid | null> {\n    return this.mockDids.find(did => \n      did.id === didId && did.tenant_id === tenantId\n    ) || null;\n  }\n\n  async updateDid(didId: string, tenantId: string, data: Partial<CreateDidRequest>): Promise<VoipDid | null> {\n    const didIndex = this.mockDids.findIndex(did => \n      did.id === didId && did.tenant_id === tenantId\n    );\n\n    if (didIndex === -1) return null;\n\n    this.mockDids[didIndex] = {\n      ...this.mockDids[didIndex],\n      ...data,\n      id: didId,\n      tenant_id: tenantId\n    };\n\n    return this.mockDids[didIndex];\n  }\n\n  async deleteDid(didId: string, tenantId: string): Promise<boolean> {\n    const didIndex = this.mockDids.findIndex(did => \n      did.id === didId && did.tenant_id === tenantId\n    );\n\n    if (didIndex === -1) return false;\n\n    this.mockDids.splice(didIndex, 1);\n    return true;\n  }\n\n  // ===== VOIP EXTENSIONS =====\n  async createExtension(tenantContext: TenantContext, data: CreateExtensionRequest): Promise<VoipExtension> {\n    const extension: VoipExtension = {\n      id: uuidv4(),\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id,\n      sip_domain: tenantContext.sip_domain,\n      ext_number: data.ext_number,\n      display_name: data.display_name,\n      enabled: data.enabled,\n      voicemail_enabled: data.voicemail_enabled,\n      forward_rules: data.forward_rules,\n      class_of_service: data.class_of_service,\n      note: data.note\n    };\n\n    this.mockExtensions.push(extension);\n    console.log(`Created extension: ${extension.ext_number} for tenant: ${tenantContext.tenant_id}`);\n    return extension;\n  }\n\n  async getExtensions(tenantId: string, storeId?: string): Promise<VoipExtension[]> {\n    return this.mockExtensions.filter(extension => \n      extension.tenant_id === tenantId && \n      (!storeId || extension.store_id === storeId)\n    );\n  }\n\n  async getExtensionById(extensionId: string, tenantId: string): Promise<VoipExtension | null> {\n    return this.mockExtensions.find(extension => \n      extension.id === extensionId && extension.tenant_id === tenantId\n    ) || null;\n  }\n\n  async updateExtension(extensionId: string, tenantId: string, data: Partial<CreateExtensionRequest>): Promise<VoipExtension | null> {\n    const extensionIndex = this.mockExtensions.findIndex(extension => \n      extension.id === extensionId && extension.tenant_id === tenantId\n    );\n\n    if (extensionIndex === -1) return null;\n\n    this.mockExtensions[extensionIndex] = {\n      ...this.mockExtensions[extensionIndex],\n      ...data,\n      id: extensionId,\n      tenant_id: tenantId\n    };\n\n    return this.mockExtensions[extensionIndex];\n  }\n\n  async deleteExtension(extensionId: string, tenantId: string): Promise<boolean> {\n    const extensionIndex = this.mockExtensions.findIndex(extension => \n      extension.id === extensionId && extension.tenant_id === tenantId\n    );\n\n    if (extensionIndex === -1) return false;\n\n    this.mockExtensions.splice(extensionIndex, 1);\n    return true;\n  }\n\n  // ===== VOIP ROUTES =====\n  async createRoute(tenantContext: TenantContext, data: CreateRouteRequest): Promise<VoipRoute> {\n    const route: VoipRoute = {\n      id: uuidv4(),\n      tenant_id: tenantContext.tenant_id,\n      name: data.name,\n      pattern: data.pattern,\n      strip_digits: data.strip_digits,\n      prepend: data.prepend,\n      trunk_id: data.trunk_id,\n      priority: data.priority,\n      active: data.active\n    };\n\n    this.mockRoutes.push(route);\n    console.log(`Created route: ${route.name} for tenant: ${tenantContext.tenant_id}`);\n    return route;\n  }\n\n  async getRoutes(tenantId: string): Promise<VoipRoute[]> {\n    return this.mockRoutes.filter(route => route.tenant_id === tenantId);\n  }\n\n  async getRouteById(routeId: string, tenantId: string): Promise<VoipRoute | null> {\n    return this.mockRoutes.find(route => \n      route.id === routeId && route.tenant_id === tenantId\n    ) || null;\n  }\n\n  async updateRoute(routeId: string, tenantId: string, data: Partial<CreateRouteRequest>): Promise<VoipRoute | null> {\n    const routeIndex = this.mockRoutes.findIndex(route => \n      route.id === routeId && route.tenant_id === tenantId\n    );\n\n    if (routeIndex === -1) return null;\n\n    this.mockRoutes[routeIndex] = {\n      ...this.mockRoutes[routeIndex],\n      ...data,\n      id: routeId,\n      tenant_id: tenantId\n    };\n\n    return this.mockRoutes[routeIndex];\n  }\n\n  async deleteRoute(routeId: string, tenantId: string): Promise<boolean> {\n    const routeIndex = this.mockRoutes.findIndex(route => \n      route.id === routeId && route.tenant_id === tenantId\n    );\n\n    if (routeIndex === -1) return false;\n\n    this.mockRoutes.splice(routeIndex, 1);\n    return true;\n  }\n\n  // ===== CONTACT POLICIES =====\n  async createContactPolicy(tenantContext: TenantContext, data: CreateContactPolicyRequest): Promise<ContactPolicy> {\n    const policy: ContactPolicy = {\n      id: uuidv4(),\n      tenant_id: tenantContext.tenant_id,\n      scope_type: data.scope_type,\n      scope_ref: data.scope_ref,\n      rules_json: data.rules_json,\n      active: data.active,\n      label: data.label\n    };\n\n    this.mockPolicies.push(policy);\n    console.log(`Created contact policy: ${policy.label} for tenant: ${tenantContext.tenant_id}`);\n    return policy;\n  }\n\n  async getContactPolicies(tenantId: string): Promise<ContactPolicy[]> {\n    return this.mockPolicies.filter(policy => policy.tenant_id === tenantId);\n  }\n\n  async getContactPolicyById(policyId: string, tenantId: string): Promise<ContactPolicy | null> {\n    return this.mockPolicies.find(policy => \n      policy.id === policyId && policy.tenant_id === tenantId\n    ) || null;\n  }\n\n  async updateContactPolicy(policyId: string, tenantId: string, data: Partial<CreateContactPolicyRequest>): Promise<ContactPolicy | null> {\n    const policyIndex = this.mockPolicies.findIndex(policy => \n      policy.id === policyId && policy.tenant_id === tenantId\n    );\n\n    if (policyIndex === -1) return null;\n\n    this.mockPolicies[policyIndex] = {\n      ...this.mockPolicies[policyIndex],\n      ...data,\n      id: policyId,\n      tenant_id: tenantId\n    };\n\n    return this.mockPolicies[policyIndex];\n  }\n\n  async deleteContactPolicy(policyId: string, tenantId: string): Promise<boolean> {\n    const policyIndex = this.mockPolicies.findIndex(policy => \n      policy.id === policyId && policy.tenant_id === tenantId\n    );\n\n    if (policyIndex === -1) return false;\n\n    this.mockPolicies.splice(policyIndex, 1);\n    return true;\n  }\n\n  // ===== UTILITY METHODS =====\n  async getTrunkStatus(trunkId: string, tenantId: string): Promise<'REG_OK' | 'FAIL' | 'UNKNOWN'> {\n    const trunk = await this.getTrunkById(trunkId, tenantId);\n    return trunk?.status || 'UNKNOWN';\n  }\n\n  async updateTrunkStatus(trunkId: string, tenantId: string, status: 'REG_OK' | 'FAIL' | 'UNKNOWN'): Promise<boolean> {\n    const trunk = await this.getTrunkById(trunkId, tenantId);\n    if (!trunk) return false;\n\n    trunk.status = status;\n    return true;\n  }\n\n  async getExtensionsByStore(tenantId: string, storeId: string): Promise<VoipExtension[]> {\n    return this.mockExtensions.filter(extension => \n      extension.tenant_id === tenantId && extension.store_id === storeId\n    );\n  }\n\n  async getDidsByTrunk(tenantId: string, trunkId: string): Promise<VoipDid[]> {\n    return this.mockDids.filter(did => \n      did.tenant_id === tenantId && did.trunk_id === trunkId\n    );\n  }\n}\n","size_bytes":12968},"packages/frontend/server.py":{"content":"#!/usr/bin/env python3\r\nimport http.server\r\nimport socketserver\r\nimport os\r\nimport urllib.parse\r\n\r\nclass SPAHandler(http.server.SimpleHTTPRequestHandler):\r\n    def end_headers(self):\r\n        # Add CORS headers\r\n        self.send_header('Access-Control-Allow-Origin', '*')\r\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\r\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')\r\n        super().end_headers()\r\n\r\n    def do_GET(self):\r\n        # Parse the URL\r\n        parsed_path = urllib.parse.urlparse(self.path)\r\n        path = parsed_path.path\r\n        \r\n        # If it's a file that exists, serve it\r\n        if os.path.exists('.' + path) and not os.path.isdir('.' + path):\r\n            super().do_GET()\r\n            return\r\n        \r\n        # For SPA routing, serve index.html for all non-file requests\r\n        if not path.startswith('/api/') and not path.startswith('/assets/'):\r\n            self.path = '/index.html'\r\n        \r\n        super().do_GET()\r\n\r\nif __name__ == \"__main__\":\r\n    PORT = 5173\r\n    os.chdir('/home/ascozzari/voip/packages/frontend/dist')\r\n    \r\n    with socketserver.TCPServer((\"0.0.0.0\", PORT), SPAHandler) as httpd:\r\n        print(f\"🚀 Frontend server running on http://0.0.0.0:{PORT}\")\r\n        print(f\"📁 Serving from: {os.getcwd()}\")\r\n        print(\"🌐 SPA routing enabled - all routes will serve index.html\")\r\n        httpd.serve_forever()\r\n","size_bytes":1451},"packages/backend/src/services/sip-trunk-enhanced.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Enhanced SIP Trunk interface with multi-provider support\r\nexport interface SipTrunkEnhanced {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  provider: string;\r\n  provider_type: string;\r\n  provider_config: any;\r\n  status: 'active' | 'inactive' | 'testing';\r\n  sip_config: {\r\n    host: string;\r\n    port: number;\r\n    transport: 'udp' | 'tcp' | 'tls';\r\n    username: string;\r\n    password: string;\r\n    realm?: string;\r\n    from_user?: string;\r\n    from_domain?: string;\r\n    register: boolean;\r\n    register_proxy?: string;\r\n    register_transport?: 'udp' | 'tcp' | 'tls';\r\n    retry_seconds: number;\r\n    caller_id_in_from: boolean;\r\n    contact_params?: string;\r\n    ping: boolean;\r\n    ping_time: number;\r\n  };\r\n  did_config: {\r\n    number: string;\r\n    country_code: string;\r\n    area_code?: string;\r\n    local_number: string;\r\n    provider_did?: string;\r\n    inbound_route?: string;\r\n  };\r\n  security: {\r\n    encryption: 'none' | 'tls' | 'srtp';\r\n    authentication: 'none' | 'digest' | 'tls';\r\n    acl: string[];\r\n    rate_limit: {\r\n      enabled: boolean;\r\n      calls_per_minute: number;\r\n      calls_per_hour: number;\r\n    };\r\n  };\r\n  gdpr: {\r\n    data_retention_days: number;\r\n    recording_consent_required: boolean;\r\n    data_processing_purpose: string;\r\n    lawful_basis: 'consent' | 'contract' | 'legitimate_interest';\r\n    data_controller: string;\r\n    dpo_contact?: string;\r\n  };\r\n  // Enhanced fields for multi-provider support\r\n  codec_preferences: string[];\r\n  dtmf_mode: 'rfc2833' | 'inband' | 'info';\r\n  nat_traversal: boolean;\r\n  nat_type: 'none' | 'stun' | 'turn' | 'ice';\r\n  session_timers: boolean;\r\n  session_refresh_method: 'uas' | 'uac';\r\n  session_expires: number;\r\n  session_min_se: number;\r\n  media_timeout: number;\r\n  media_hold_timeout: number;\r\n  rtp_timeout: number;\r\n  rtp_hold_timeout: number;\r\n  call_timeout: number;\r\n  call_timeout_code: string;\r\n  hangup_after_bridge: boolean;\r\n  record_calls: boolean;\r\n  record_path?: string;\r\n  record_sample_rate: number;\r\n  record_channels: number;\r\n  failover_trunk_id?: string;\r\n  max_concurrent_calls: number;\r\n  current_calls: number;\r\n  last_registration_attempt?: Date;\r\n  last_successful_registration?: Date;\r\n  registration_attempts: number;\r\n  registration_failures: number;\r\n  last_error_message?: string;\r\n  health_check_interval: number;\r\n  health_check_timeout: number;\r\n  health_check_enabled: boolean;\r\n  last_health_check?: Date;\r\n  health_status: 'healthy' | 'unhealthy' | 'unknown';\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface SipProviderTemplate {\r\n  id: string;\r\n  name: string;\r\n  provider_type: string;\r\n  description: string;\r\n  default_config: any;\r\n  required_fields: string[];\r\n  optional_fields: string[];\r\n  codec_preferences: string[];\r\n  supported_features: any;\r\n  documentation_url?: string;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface SipTrunkHealthLog {\r\n  id: string;\r\n  trunk_id: string;\r\n  check_type: 'registration' | 'ping' | 'call_test';\r\n  status: 'success' | 'failure' | 'timeout';\r\n  response_time?: number;\r\n  error_message?: string;\r\n  details?: any;\r\n  checked_at: Date;\r\n}\r\n\r\nexport interface SipTrunkUsageStats {\r\n  id: string;\r\n  trunk_id: string;\r\n  date: Date;\r\n  total_calls: number;\r\n  successful_calls: number;\r\n  failed_calls: number;\r\n  total_duration: number;\r\n  total_cost: number;\r\n  peak_concurrent_calls: number;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class SipTrunkEnhancedService {\r\n  // Get all provider templates\r\n  async getProviderTemplates(): Promise<SipProviderTemplate[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_provider_templates ORDER BY name ASC'\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        name: row.name,\r\n        provider_type: row.provider_type,\r\n        description: row.description,\r\n        default_config: typeof row.default_config === 'string' ? JSON.parse(row.default_config) : row.default_config,\r\n        required_fields: typeof row.required_fields === 'string' ? JSON.parse(row.required_fields) : row.required_fields,\r\n        optional_fields: typeof row.optional_fields === 'string' ? JSON.parse(row.optional_fields) : row.optional_fields,\r\n        codec_preferences: typeof row.codec_preferences === 'string' ? JSON.parse(row.codec_preferences) : row.codec_preferences,\r\n        supported_features: typeof row.supported_features === 'string' ? JSON.parse(row.supported_features) : row.supported_features,\r\n        documentation_url: row.documentation_url,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get provider template by type\r\n  async getProviderTemplate(providerType: string): Promise<SipProviderTemplate | null> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_provider_templates WHERE provider_type = $1',\r\n        [providerType]\r\n      );\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      const row = result.rows[0];\r\n      return {\r\n        id: row.id,\r\n        name: row.name,\r\n        provider_type: row.provider_type,\r\n        description: row.description,\r\n        default_config: typeof row.default_config === 'string' ? JSON.parse(row.default_config) : row.default_config,\r\n        required_fields: typeof row.required_fields === 'string' ? JSON.parse(row.required_fields) : row.required_fields,\r\n        optional_fields: typeof row.optional_fields === 'string' ? JSON.parse(row.optional_fields) : row.optional_fields,\r\n        codec_preferences: typeof row.codec_preferences === 'string' ? JSON.parse(row.codec_preferences) : row.codec_preferences,\r\n        supported_features: typeof row.supported_features === 'string' ? JSON.parse(row.supported_features) : row.supported_features,\r\n        documentation_url: row.documentation_url,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      };\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Create enhanced SIP trunk\r\n  async createSipTrunk(trunkData: Partial<SipTrunkEnhanced>): Promise<SipTrunkEnhanced> {\r\n    return withTransaction(async (client) => {\r\n      // Get provider template if specified\r\n      let template: SipProviderTemplate | null = null;\r\n      if (trunkData.provider_type) {\r\n        template = await this.getProviderTemplate(trunkData.provider_type);\r\n      }\r\n\r\n      // Merge template config with provided config\r\n      const mergedConfig = template ? {\r\n        ...template.default_config,\r\n        ...trunkData.sip_config\r\n      } : trunkData.sip_config;\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO sip_trunks (\r\n          id, tenant_id, store_id, name, provider, provider_type, provider_config, status,\r\n          sip_config, did_config, security, gdpr, codec_preferences, dtmf_mode,\r\n          nat_traversal, nat_type, session_timers, session_refresh_method,\r\n          session_expires, session_min_se, media_timeout, media_hold_timeout,\r\n          rtp_timeout, rtp_hold_timeout, call_timeout, call_timeout_code,\r\n          hangup_after_bridge, record_calls, record_path, record_sample_rate,\r\n          record_channels, failover_trunk_id, max_concurrent_calls, current_calls,\r\n          registration_attempts, registration_failures, health_check_interval,\r\n          health_check_timeout, health_check_enabled, health_status\r\n        ) VALUES (\r\n          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,\r\n          $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,\r\n          $31, $32, $33, $34, $35, $36, $37, $38, $39, $40\r\n        ) RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          trunkData.tenant_id,\r\n          trunkData.store_id,\r\n          trunkData.name,\r\n          trunkData.provider || trunkData.provider_type || 'generic',\r\n          trunkData.provider_type || 'generic',\r\n          JSON.stringify(trunkData.provider_config || {}),\r\n          trunkData.status || 'inactive',\r\n          JSON.stringify(mergedConfig),\r\n          JSON.stringify(trunkData.did_config),\r\n          JSON.stringify(trunkData.security),\r\n          JSON.stringify(trunkData.gdpr),\r\n          JSON.stringify(trunkData.codec_preferences || template?.codec_preferences || ['PCMU', 'PCMA', 'G729']),\r\n          trunkData.dtmf_mode || 'rfc2833',\r\n          trunkData.nat_traversal || false,\r\n          trunkData.nat_type || 'none',\r\n          trunkData.session_timers || false,\r\n          trunkData.session_refresh_method || 'uas',\r\n          trunkData.session_expires || 1800,\r\n          trunkData.session_min_se || 90,\r\n          trunkData.media_timeout || 300,\r\n          trunkData.media_hold_timeout || 1800,\r\n          trunkData.rtp_timeout || 300,\r\n          trunkData.rtp_hold_timeout || 1800,\r\n          trunkData.call_timeout || 60,\r\n          trunkData.call_timeout_code || 'NO_ANSWER',\r\n          trunkData.hangup_after_bridge !== false,\r\n          trunkData.record_calls || false,\r\n          trunkData.record_path,\r\n          trunkData.record_sample_rate || 8000,\r\n          trunkData.record_channels || 1,\r\n          trunkData.failover_trunk_id,\r\n          trunkData.max_concurrent_calls || 10,\r\n          trunkData.current_calls || 0,\r\n          trunkData.registration_attempts || 0,\r\n          trunkData.registration_failures || 0,\r\n          trunkData.health_check_interval || 300,\r\n          trunkData.health_check_timeout || 30,\r\n          trunkData.health_check_enabled !== false,\r\n          trunkData.health_status || 'unknown'\r\n        ]\r\n      );\r\n\r\n      const trunk = result.rows[0];\r\n      return this.mapRowToSipTrunk(trunk);\r\n    });\r\n  }\r\n\r\n  // Get enhanced SIP trunks\r\n  async getSipTrunks(tenantId: string, storeId?: string): Promise<SipTrunkEnhanced[]> {\r\n    const client = await getClient();\r\n    try {\r\n      let query = 'SELECT * FROM sip_trunks WHERE tenant_id = $1';\r\n      const params: any[] = [tenantId];\r\n      \r\n      if (storeId) {\r\n        query += ' AND store_id = $2';\r\n        params.push(storeId);\r\n      }\r\n      \r\n      query += ' ORDER BY name ASC';\r\n      \r\n      const result = await client.query(query, params);\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToSipTrunk(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Test SIP trunk connection\r\n  async testSipTrunk(trunkId: string): Promise<{\r\n    success: boolean;\r\n    message: string;\r\n    response_time?: number;\r\n    error?: string;\r\n  }> {\r\n    const client = await getClient();\r\n    try {\r\n      // Get trunk configuration\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_trunks WHERE id = $1',\r\n        [trunkId]\r\n      );\r\n      \r\n      if (result.rows.length === 0) {\r\n        throw new Error('SIP trunk not found');\r\n      }\r\n      \r\n      const trunk = this.mapRowToSipTrunk(result.rows[0]);\r\n      \r\n      // Log health check attempt\r\n      const startTime = Date.now();\r\n      \r\n      try {\r\n        // Simulate SIP trunk test (in real implementation, use actual SIP testing)\r\n        await this.simulateSipTrunkTest(trunk);\r\n        \r\n        const responseTime = Date.now() - startTime;\r\n        \r\n        // Log successful test\r\n        await this.logHealthCheck(trunkId, 'call_test', 'success', responseTime);\r\n        \r\n        return {\r\n          success: true,\r\n          message: 'SIP trunk test successful',\r\n          response_time: responseTime\r\n        };\r\n      } catch (error) {\r\n        const responseTime = Date.now() - startTime;\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        \r\n        // Log failed test\r\n        await this.logHealthCheck(trunkId, 'call_test', 'failure', responseTime, errorMessage);\r\n        \r\n        return {\r\n          success: false,\r\n          message: 'SIP trunk test failed',\r\n          response_time: responseTime,\r\n          error: errorMessage\r\n        };\r\n      }\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get SIP trunk health logs\r\n  async getHealthLogs(trunkId: string, limit: number = 50): Promise<SipTrunkHealthLog[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_trunk_health_logs WHERE trunk_id = $1 ORDER BY checked_at DESC LIMIT $2',\r\n        [trunkId, limit]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        trunk_id: row.trunk_id,\r\n        check_type: row.check_type,\r\n        status: row.status,\r\n        response_time: row.response_time,\r\n        error_message: row.error_message,\r\n        details: typeof row.details === 'string' ? JSON.parse(row.details) : row.details,\r\n        checked_at: row.checked_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get SIP trunk usage statistics\r\n  async getUsageStats(trunkId: string, startDate: Date, endDate: Date): Promise<SipTrunkUsageStats[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_trunk_usage_stats WHERE trunk_id = $1 AND date BETWEEN $2 AND $3 ORDER BY date ASC',\r\n        [trunkId, startDate, endDate]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => ({\r\n        id: row.id,\r\n        trunk_id: row.trunk_id,\r\n        date: row.date,\r\n        total_calls: row.total_calls,\r\n        successful_calls: row.successful_calls,\r\n        failed_calls: row.failed_calls,\r\n        total_duration: row.total_duration,\r\n        total_cost: row.total_cost,\r\n        peak_concurrent_calls: row.peak_concurrent_calls,\r\n        created_at: row.created_at,\r\n        updated_at: row.updated_at\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Log health check\r\n  private async logHealthCheck(\r\n    trunkId: string,\r\n    checkType: string,\r\n    status: string,\r\n    responseTime?: number,\r\n    errorMessage?: string,\r\n    details?: any\r\n  ): Promise<void> {\r\n    const client = await getClient();\r\n    try {\r\n      await client.query(\r\n        `SELECT log_sip_trunk_health_check($1, $2, $3, $4, $5, $6)`,\r\n        [trunkId, checkType, status, responseTime, errorMessage, details ? JSON.stringify(details) : null]\r\n      );\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Simulate SIP trunk test (replace with actual SIP testing)\r\n  private async simulateSipTrunkTest(trunk: SipTrunkEnhanced): Promise<void> {\r\n    // Simulate network delay\r\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 100));\r\n    \r\n    // Simulate test failure for demonstration\r\n    if (trunk.sip_config.host === 'invalid.host') {\r\n      throw new Error('Connection timeout');\r\n    }\r\n    \r\n    // Simulate success\r\n    return;\r\n  }\r\n\r\n  // Map database row to SipTrunkEnhanced object\r\n  private mapRowToSipTrunk(row: any): SipTrunkEnhanced {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      store_id: row.store_id,\r\n      name: row.name,\r\n      provider: row.provider,\r\n      provider_type: row.provider_type,\r\n      provider_config: typeof row.provider_config === 'string' ? JSON.parse(row.provider_config) : row.provider_config,\r\n      status: row.status,\r\n      sip_config: typeof row.sip_config === 'string' ? JSON.parse(row.sip_config) : row.sip_config,\r\n      did_config: typeof row.did_config === 'string' ? JSON.parse(row.did_config) : row.did_config,\r\n      security: typeof row.security === 'string' ? JSON.parse(row.security) : row.security,\r\n      gdpr: typeof row.gdpr === 'string' ? JSON.parse(row.gdpr) : row.gdpr,\r\n      codec_preferences: typeof row.codec_preferences === 'string' ? JSON.parse(row.codec_preferences) : row.codec_preferences,\r\n      dtmf_mode: row.dtmf_mode,\r\n      nat_traversal: row.nat_traversal,\r\n      nat_type: row.nat_type,\r\n      session_timers: row.session_timers,\r\n      session_refresh_method: row.session_refresh_method,\r\n      session_expires: row.session_expires,\r\n      session_min_se: row.session_min_se,\r\n      media_timeout: row.media_timeout,\r\n      media_hold_timeout: row.media_hold_timeout,\r\n      rtp_timeout: row.rtp_timeout,\r\n      rtp_hold_timeout: row.rtp_hold_timeout,\r\n      call_timeout: row.call_timeout,\r\n      call_timeout_code: row.call_timeout_code,\r\n      hangup_after_bridge: row.hangup_after_bridge,\r\n      record_calls: row.record_calls,\r\n      record_path: row.record_path,\r\n      record_sample_rate: row.record_sample_rate,\r\n      record_channels: row.record_channels,\r\n      failover_trunk_id: row.failover_trunk_id,\r\n      max_concurrent_calls: row.max_concurrent_calls,\r\n      current_calls: row.current_calls,\r\n      last_registration_attempt: row.last_registration_attempt,\r\n      last_successful_registration: row.last_successful_registration,\r\n      registration_attempts: row.registration_attempts,\r\n      registration_failures: row.registration_failures,\r\n      last_error_message: row.last_error_message,\r\n      health_check_interval: row.health_check_interval,\r\n      health_check_timeout: row.health_check_timeout,\r\n      health_check_enabled: row.health_check_enabled,\r\n      last_health_check: row.last_health_check,\r\n      health_status: row.health_status,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const sipTrunkEnhancedService = new SipTrunkEnhancedService();\r\n","size_bytes":17686},"packages/frontend/src/components/layout/Sidebar.tsx":{"content":"import React, { useState, useEffect, useRef } from 'react';\nimport { NavLink } from 'react-router-dom';\nimport { \n  LayoutDashboard, \n  Users, \n  Building, \n  Phone, \n  Activity, \n  FileText, \n  Settings,\n  LogOut,\n  ChevronDown,\n  ChevronRight,\n  ChevronLeft,\n  Network,\n  BookOpen,\n  Terminal,\n  Users2,\n  Clock,\n  Menu,\n  MessageSquare,\n  Mic,\n  BarChart3,\n  Headphones\n} from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { cn } from '@/lib/utils';\n\n// Navigation based on user role\nconst getNavigationForRole = (role: string, tenantSlug: string) => {\n  const baseNavigation = [\n    { name: 'Dashboard', href: `/${tenantSlug}/dashboard`, icon: LayoutDashboard, level: 0 },\n  ];\n\n  if (role === 'super_admin') {\n    return [\n      { name: 'Dashboard', href: '/edgvoip/dashboard', icon: LayoutDashboard, level: 0 },\n      { name: 'Tenants', href: '/edgvoip/tenants', icon: Users, level: 0 },\n      { name: 'Users', href: '/edgvoip/users', icon: Users, level: 0 },\n      { name: 'Analytics', href: '/edgvoip/analytics', icon: BarChart3, level: 0 },\n      { name: 'System Settings', href: '/edgvoip/system-settings', icon: Settings, level: 0 },\n      { name: 'Logs', href: '/edgvoip/logs', icon: Terminal, level: 0 },\n    ];\n  } else if (role === 'tenant_admin') {\n    return [\n      ...baseNavigation,\n      { \n        name: 'Tenant Management', \n        icon: Users, \n        level: 0,\n        children: [\n          { name: 'Stores', href: `/${tenantSlug}/stores`, icon: Building, level: 1 },\n          { name: 'Users', href: `/${tenantSlug}/users`, icon: Users, level: 1 },\n        ]\n      },\n          {\n            name: 'VoIP Management',\n            icon: Phone,\n            level: 0,\n            children: [\n              { name: 'Extensions', href: `/${tenantSlug}/extensions`, icon: Phone, level: 1 },\n              { name: 'SIP Trunks', href: `/${tenantSlug}/sip-trunks`, icon: Network, level: 1 },\n              { name: 'Ring Groups', href: `/${tenantSlug}/ring-groups`, icon: Users2, level: 1 },\n              { name: 'Call Queues', href: `/${tenantSlug}/queues`, icon: Headphones, level: 1 },\n              { name: 'IVR Menus', href: `/${tenantSlug}/ivr-menus`, icon: Menu, level: 1 },\n              { name: 'Conference Rooms', href: `/${tenantSlug}/conference-rooms`, icon: MessageSquare, level: 1 },\n              { name: 'Voicemail', href: `/${tenantSlug}/voicemail`, icon: Mic, level: 1 },\n              { name: 'Time Conditions', href: `/${tenantSlug}/time-conditions`, icon: Clock, level: 1 },\n            ]\n      },\n      { name: 'Live Calls', href: `/${tenantSlug}/live-calls`, icon: Activity, level: 0 },\n      { name: 'CDR & Analytics', href: `/${tenantSlug}/cdr`, icon: BarChart3, level: 0 },\n      { name: 'Logs & Verbose', href: `/${tenantSlug}/logs`, icon: Terminal, level: 0 },\n    ];\n  } else {\n    // tenant_user\n    return [\n      ...baseNavigation,\n      { name: 'My Extensions', href: '/my-extensions', icon: Phone, level: 0 },\n      { name: 'Make Call', href: '/make-call', icon: Phone, level: 0 },\n      { name: 'My CDR', href: '/my-cdr', icon: FileText, level: 0 },\n    ];\n  }\n};\n\nexport default function Sidebar() {\n  const { logout, user } = useAuth();\n  const [expandedItems, setExpandedItems] = useState<string[]>([]);\n  const [isCollapsed, setIsCollapsed] = useState(false);\n  const [isHovered, setIsHovered] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const autoCollapseTimer = useRef<NodeJS.Timeout | null>(null);\n  \n  // Get navigation based on user role\n  const navigation = user ? getNavigationForRole(user.role, user.tenantSlug) : [];\n  \n  // Check if mobile\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 768);\n      if (window.innerWidth < 768) {\n        setIsCollapsed(true);\n      }\n    };\n    \n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n  \n  // Auto-collapse logic\n  useEffect(() => {\n    if (isMobile) return;\n    \n    const startAutoCollapse = () => {\n      if (autoCollapseTimer.current) {\n        clearTimeout(autoCollapseTimer.current);\n      }\n      autoCollapseTimer.current = setTimeout(() => {\n        if (!isHovered) {\n          setIsCollapsed(true);\n          // Emit event when auto-collapsing\n          const event = new CustomEvent('sidebar-state-change', {\n            detail: { collapsed: true }\n          });\n          window.dispatchEvent(event);\n        }\n      }, 3000);\n    };\n    \n    if (!isCollapsed) {\n      startAutoCollapse();\n    }\n    \n    return () => {\n      if (autoCollapseTimer.current) {\n        clearTimeout(autoCollapseTimer.current);\n      }\n    };\n  }, [isCollapsed, isHovered, isMobile]);\n  \n  // Set default expanded items based on role\n  React.useEffect(() => {\n    if (user) {\n      if (user.role === 'super_admin') {\n        setExpandedItems(['System Management', 'VoIP Management']);\n      } else if (user.role === 'tenant_admin') {\n        setExpandedItems(['Tenant Management', 'VoIP Management']);\n      }\n    }\n  }, [user]);\n\n  const toggleExpanded = (itemName: string) => {\n    setExpandedItems(prev => \n      prev.includes(itemName) \n        ? prev.filter(name => name !== itemName)\n        : [...prev, itemName]\n    );\n  };\n\n  const handleMouseEnter = () => {\n    if (!isMobile) {\n      setIsHovered(true);\n      if (autoCollapseTimer.current) {\n        clearTimeout(autoCollapseTimer.current);\n      }\n      setTimeout(() => {\n        if (isCollapsed) {\n          setIsCollapsed(false);\n          // Emit event when expanding on hover\n          const event = new CustomEvent('sidebar-state-change', {\n            detail: { collapsed: false }\n          });\n          window.dispatchEvent(event);\n        }\n      }, 200);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (!isMobile) {\n      setIsHovered(false);\n    }\n  };\n\n  const toggleCollapse = () => {\n    const newCollapsedState = !isCollapsed;\n    setIsCollapsed(newCollapsedState);\n    \n    // Emit custom event to notify layout\n    const event = new CustomEvent('sidebar-state-change', {\n      detail: { collapsed: newCollapsedState }\n    });\n    window.dispatchEvent(event);\n  };\n\n  const renderNavItem = (item: any) => {\n    if (item.children) {\n      const isExpanded = expandedItems.includes(item.name);\n      return (\n        <div key={item.name}>\n          <button\n            onClick={() => toggleExpanded(item.name)}\n            className={cn(\n              \"group flex items-center w-full px-2 py-2 text-sm font-medium rounded-md\",\n              \"text-gray-600 hover:bg-blue-50/50 hover:text-blue-700\",\n              \"hover:translate-x-1 transition-all duration-200 ease-smooth\",\n              isCollapsed && \"justify-center\"\n            )}\n            title={isCollapsed ? item.name : undefined}\n          >\n            <item.icon className={cn(\"h-5 w-5 flex-shrink-0\", isCollapsed ? \"\" : \"mr-3\")} />\n            {!isCollapsed && (\n              <>\n                <span className=\"truncate\">{item.name}</span>\n                {isExpanded ? (\n                  <ChevronDown className=\"ml-auto h-4 w-4\" />\n                ) : (\n                  <ChevronRight className=\"ml-auto h-4 w-4\" />\n                )}\n              </>\n            )}\n          </button>\n          {isExpanded && !isCollapsed && (\n            <div className=\"ml-4 space-y-1 animate-fadeIn\">\n              {item.children.map((child: any) => (\n                <NavLink\n                  key={child.name}\n                  to={child.href}\n                  className={({ isActive }) =>\n                    cn(\n                      \"group flex items-center px-2 py-2 text-sm font-medium rounded-md\",\n                      \"transition-all duration-200 ease-smooth\",\n                      \"hover:translate-x-1 hover:bg-blue-50/50\",\n                      isActive\n                        ? 'bg-blue-100/80 text-blue-900 shadow-sm'\n                        : 'text-gray-500 hover:text-blue-700'\n                    )\n                  }\n                >\n                  <child.icon className=\"mr-3 h-4 w-4 flex-shrink-0\" />\n                  {child.name}\n                </NavLink>\n              ))}\n            </div>\n          )}\n        </div>\n      );\n    }\n\n    return (\n      <NavLink\n        key={item.name}\n        to={item.href}\n        className={({ isActive }) =>\n          cn(\n            \"group flex items-center px-2 py-2 text-sm font-medium rounded-md\",\n            \"transition-all duration-200 ease-smooth\",\n            \"hover:translate-x-1 hover:bg-blue-50/50\",\n            isCollapsed && \"justify-center\",\n            isActive\n              ? 'bg-blue-100/80 text-blue-900 shadow-sm'\n              : 'text-gray-600 hover:text-blue-700'\n          )\n        }\n        title={isCollapsed ? item.name : undefined}\n      >\n        <item.icon className={cn(\"h-5 w-5 flex-shrink-0\", isCollapsed ? \"\" : \"mr-3\")} />\n        {!isCollapsed && <span className=\"truncate\">{item.name}</span>}\n      </NavLink>\n    );\n  };\n\n  return (\n    <div \n      className={cn(\n        \"hidden md:flex md:flex-col fixed left-0 top-0 h-full z-40\",\n        \"glass-nav transition-all duration-300 ease-smooth\",\n        isCollapsed ? \"w-16\" : \"w-64\"\n      )}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      <div className=\"flex flex-col flex-grow pt-5 overflow-y-auto\">\n        {/* Header with logo and toggle */}\n        <div className=\"flex items-center justify-between flex-shrink-0 px-4\">\n          <div className=\"flex items-center\">\n            <Phone className=\"h-8 w-8 text-blue-600\" />\n            {!isCollapsed && (\n              <span className=\"ml-2 text-xl font-bold text-gray-900 animate-fadeIn\">\n                EDG VoIP\n              </span>\n            )}\n          </div>\n          {!isMobile && (\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={toggleCollapse}\n              className=\"p-1 hover:bg-white/50 hover:scale-105 transition-all duration-200\"\n            >\n              {isCollapsed ? (\n                <ChevronRight className=\"h-4 w-4\" />\n              ) : (\n                <ChevronLeft className=\"h-4 w-4\" />\n              )}\n            </Button>\n          )}\n        </div>\n        \n        {/* Navigation */}\n        <div className=\"mt-5 flex-grow flex flex-col\">\n          <nav className=\"flex-1 px-2 pb-4 space-y-1\">\n            {navigation.map(renderNavItem)}\n          </nav>\n        </div>\n\n        {/* User section */}\n        <div className=\"flex-shrink-0 flex border-t border-white/20 p-4\">\n          <div className=\"flex items-center w-full\">\n            <div className=\"flex-shrink-0\">\n              <div className=\"h-8 w-8 rounded-full bg-gradient-to-br from-blue-500 to-blue-600 flex items-center justify-center shadow-sm\">\n                <span className=\"text-sm font-medium text-white\">\n                  {user?.firstName?.charAt(0)?.toUpperCase() || 'U'}\n                </span>\n              </div>\n            </div>\n            {!isCollapsed && (\n              <div className=\"ml-3 flex-1 animate-fadeIn\">\n                <p className=\"text-sm font-medium text-gray-700 truncate\">\n                  {user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : 'User'}\n                </p>\n                <p className=\"text-xs text-gray-500 truncate\">\n                  {user?.role === 'super_admin' && 'Super Administrator'}\n                  {user?.role === 'tenant_admin' && `Tenant Admin • ${user?.tenantId?.slice(0, 8)}...`}\n                  {user?.role === 'user' && `User • ${user?.tenantId?.slice(0, 8)}...`}\n                </p>\n              </div>\n            )}\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={logout}\n              className={cn(\n                \"hover:bg-white/50 hover:scale-105 transition-all duration-200\",\n                isCollapsed ? \"ml-0\" : \"ml-2\"\n              )}\n              title={isCollapsed ? \"Logout\" : undefined}\n            >\n              <LogOut className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":12303},"packages/backend/src/middleware/validation.ts":{"content":"import { Request, Response, NextFunction } from 'express';\r\nimport { ZodSchema } from 'zod';\r\nimport { body, param, query, validationResult } from 'express-validator';\r\nimport { TenantSchema, StoreSchema, ExtensionSchema, SipTrunkSchema, TrunkRegistrationSchema, CDRFilterSchema } from '@w3-voip/shared';\r\n\r\n// Validation Error Handler\r\nexport const handleValidationErrors = (req: Request, res: Response, next: NextFunction) => {\r\n  const errors = validationResult(req);\r\n  \r\n  if (!errors.isEmpty()) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: {\r\n        code: 'VALIDATION_ERROR',\r\n        message: 'Validation failed',\r\n        details: errors.array().map(error => ({\r\n          field: error.type === 'field' ? error.path : 'unknown',\r\n          message: error.msg,\r\n          value: error.type === 'field' ? error.value : undefined\r\n        }))\r\n      }\r\n    });\r\n  }\r\n  \r\n  next();\r\n};\r\n\r\n// Generic Zod validator for body/query/params\r\nexport function validateRequest(schema: ZodSchema<any>, source: 'body' | 'query' | 'params' = 'body') {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    try {\r\n      const data = source === 'body' ? req.body : source === 'query' ? req.query : req.params;\r\n      const parsed = schema.safeParse(data);\r\n      if (!parsed.success) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          error: {\r\n            code: 'VALIDATION_ERROR',\r\n            message: 'Validation failed',\r\n            details: parsed.error.errors.map(e => ({\r\n              field: e.path?.join('.') || 'unknown',\r\n              message: e.message\r\n            }))\r\n          }\r\n        });\r\n      }\r\n      // assign parsed data back to request to ensure types/values\r\n      if (source === 'body') req.body = parsed.data;\r\n      if (source === 'query') req.query = parsed.data;\r\n      if (source === 'params') req.params = parsed.data as any;\r\n      next();\r\n    } catch (err) {\r\n      return res.status(500).json({ success: false, error: { code: 'VALIDATION_MIDDLEWARE_ERROR', message: 'Unexpected validation error' } });\r\n    }\r\n  };\r\n}\r\n\r\n// UUID Validation\r\nexport const validateUUID = (field: string) => {\r\n  return param(field).isUUID().withMessage(`${field} must be a valid UUID`);\r\n};\r\n\r\n// Tenant Validation\r\nexport const validateTenant = [\r\n  body('name')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Name must be between 1 and 100 characters')\r\n    .trim(),\r\n  body('domain')\r\n    .matches(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/)\r\n    .withMessage('Domain must contain only alphanumeric characters and hyphens, cannot start or end with hyphen')\r\n    .isLength({ min: 3, max: 100 })\r\n    .withMessage('Domain must be between 3 and 100 characters'),\r\n  body('sip_domain')\r\n    .matches(/^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$/)\r\n    .withMessage('SIP domain must be a valid domain name')\r\n    .isLength({ min: 3, max: 100 })\r\n    .withMessage('SIP domain must be between 3 and 100 characters'),\r\n  body('status')\r\n    .optional()\r\n    .isIn(['active', 'suspended', 'pending'])\r\n    .withMessage('Status must be active, suspended, or pending'),\r\n  body('settings.max_concurrent_calls')\r\n    .optional()\r\n    .isInt({ min: 1, max: 1000 })\r\n    .withMessage('Max concurrent calls must be between 1 and 1000'),\r\n  body('settings.recording_enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Recording enabled must be a boolean'),\r\n  body('settings.gdpr_compliant')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('GDPR compliant must be a boolean'),\r\n  body('settings.timezone')\r\n    .optional()\r\n    .isLength({ min: 1, max: 50 })\r\n    .withMessage('Timezone must be between 1 and 50 characters'),\r\n  body('settings.language')\r\n    .optional()\r\n    .isLength({ min: 2, max: 5 })\r\n    .withMessage('Language must be between 2 and 5 characters')\r\n];\r\n\r\n// Store Validation\r\nexport const validateStore = [\r\n  body('name')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Name must be between 1 and 100 characters')\r\n    .trim(),\r\n  body('store_id')\r\n    .isLength({ min: 1, max: 50 })\r\n    .withMessage('Store ID must be between 1 and 50 characters')\r\n    .matches(/^[a-zA-Z0-9-_]+$/)\r\n    .withMessage('Store ID can only contain alphanumeric characters, hyphens, and underscores'),\r\n  body('status')\r\n    .optional()\r\n    .isIn(['active', 'inactive'])\r\n    .withMessage('Status must be active or inactive'),\r\n  body('settings.business_hours.enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Business hours enabled must be a boolean'),\r\n  body('settings.business_hours.timezone')\r\n    .optional()\r\n    .isLength({ min: 1, max: 50 })\r\n    .withMessage('Business hours timezone must be between 1 and 50 characters'),\r\n  body('settings.outbound_caller_id')\r\n    .optional()\r\n    .matches(/^\\+?[1-9]\\d{1,14}$/)\r\n    .withMessage('Outbound caller ID must be a valid E.164 number'),\r\n  body('settings.recording_consent_required')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Recording consent required must be a boolean')\r\n];\r\n\r\n// Extension Validation\r\nexport const validateExtension = [\r\n  body('extension')\r\n    .matches(/^[0-9]{3,6}$/)\r\n    .withMessage('Extension must be 3-6 digits'),\r\n  body('password')\r\n    .isLength({ min: 8, max: 32 })\r\n    .withMessage('Password must be between 8 and 32 characters')\r\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/)\r\n    .withMessage('Password must contain at least one lowercase letter, one uppercase letter, and one number'),\r\n  body('display_name')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Display name must be between 1 and 100 characters')\r\n    .trim(),\r\n  body('status')\r\n    .optional()\r\n    .isIn(['active', 'inactive', 'locked'])\r\n    .withMessage('Status must be active, inactive, or locked'),\r\n  body('type')\r\n    .optional()\r\n    .isIn(['user', 'queue', 'conference', 'voicemail'])\r\n    .withMessage('Type must be user, queue, conference, or voicemail'),\r\n  body('settings.voicemail_enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Voicemail enabled must be a boolean'),\r\n  body('settings.call_forwarding.enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Call forwarding enabled must be a boolean'),\r\n  body('settings.call_forwarding.destination')\r\n    .optional()\r\n    .matches(/^\\+?[1-9]\\d{1,14}$|^[0-9]{3,6}$/)\r\n    .withMessage('Call forwarding destination must be a valid E.164 number or extension'),\r\n  body('settings.dnd_enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('DND enabled must be a boolean'),\r\n  body('settings.recording_enabled')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Recording enabled must be a boolean')\r\n];\r\n\r\n// SIP Trunk Validation\r\nexport const validateSipTrunk = [\r\n  body('name')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Name must be between 1 and 100 characters')\r\n    .trim(),\r\n  body('provider')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Provider must be between 1 and 100 characters')\r\n    .trim(),\r\n  body('status')\r\n    .optional()\r\n    .isIn(['active', 'inactive', 'testing'])\r\n    .withMessage('Status must be active, inactive, or testing'),\r\n  body('sip_config.host')\r\n    .isLength({ min: 1, max: 255 })\r\n    .withMessage('SIP host must be between 1 and 255 characters'),\r\n  body('sip_config.port')\r\n    .isInt({ min: 1, max: 65535 })\r\n    .withMessage('SIP port must be between 1 and 65535'),\r\n  body('sip_config.transport')\r\n    .isIn(['udp', 'tcp', 'tls'])\r\n    .withMessage('SIP transport must be udp, tcp, or tls'),\r\n  body('sip_config.username')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('SIP username must be between 1 and 100 characters'),\r\n  body('sip_config.password')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('SIP password must be between 1 and 100 characters'),\r\n  body('did_config.number')\r\n    .matches(/^\\+?[1-9]\\d{1,14}$/)\r\n    .withMessage('DID number must be a valid E.164 number'),\r\n  body('did_config.country_code')\r\n    .isLength({ min: 2, max: 2 })\r\n    .withMessage('Country code must be exactly 2 characters'),\r\n  body('did_config.local_number')\r\n    .isLength({ min: 1, max: 20 })\r\n    .withMessage('Local number must be between 1 and 20 characters'),\r\n  body('security.encryption')\r\n    .optional()\r\n    .isIn(['none', 'tls', 'srtp'])\r\n    .withMessage('Encryption must be none, tls, or srtp'),\r\n  body('security.authentication')\r\n    .optional()\r\n    .isIn(['none', 'digest', 'tls'])\r\n    .withMessage('Authentication must be none, digest, or tls'),\r\n  body('gdpr.data_retention_days')\r\n    .optional()\r\n    .isInt({ min: 30, max: 2555 })\r\n    .withMessage('Data retention days must be between 30 and 2555'),\r\n  body('gdpr.recording_consent_required')\r\n    .optional()\r\n    .isBoolean()\r\n    .withMessage('Recording consent required must be a boolean'),\r\n  body('gdpr.data_controller')\r\n    .optional()\r\n    .isLength({ min: 1, max: 200 })\r\n    .withMessage('Data controller must be between 1 and 200 characters'),\r\n  body('gdpr.dpo_contact')\r\n    .optional()\r\n    .isEmail()\r\n    .withMessage('DPO contact must be a valid email address')\r\n];\r\n\r\n// Trunk Registration Validation (for UI form)\r\nexport const validateTrunkRegistration = [\r\n  body('name')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Nome trunk richiesto (1-100 caratteri)')\r\n    .trim(),\r\n  body('provider')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Provider richiesto (1-100 caratteri)')\r\n    .trim(),\r\n  body('host')\r\n    .isLength({ min: 1, max: 255 })\r\n    .withMessage('Host SIP richiesto (1-255 caratteri)'),\r\n  body('port')\r\n    .isInt({ min: 1, max: 65535 })\r\n    .withMessage('Porta SIP deve essere tra 1 e 65535'),\r\n  body('transport')\r\n    .isIn(['udp', 'tcp', 'tls'])\r\n    .withMessage('Trasporto deve essere udp, tcp o tls'),\r\n  body('username')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Username SIP richiesto (1-100 caratteri)'),\r\n  body('password')\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Password SIP richiesta (1-100 caratteri)'),\r\n  body('number')\r\n    .matches(/^\\+?[1-9]\\d{1,14}$/)\r\n    .withMessage('Formato numero non valido (E.164)'),\r\n  body('country_code')\r\n    .isLength({ min: 2, max: 2 })\r\n    .withMessage('Codice paese richiesto (2 caratteri)'),\r\n  body('local_number')\r\n    .isLength({ min: 1, max: 20 })\r\n    .withMessage('Numero locale richiesto (1-20 caratteri)'),\r\n  body('encryption')\r\n    .isIn(['none', 'tls', 'srtp'])\r\n    .withMessage('Crittografia deve essere none, tls o srtp'),\r\n  body('authentication')\r\n    .isIn(['none', 'digest', 'tls'])\r\n    .withMessage('Autenticazione deve essere none, digest o tls'),\r\n  body('data_retention_days')\r\n    .isInt({ min: 30, max: 2555 })\r\n    .withMessage('Conservazione dati deve essere tra 30 e 2555 giorni'),\r\n  body('recording_consent_required')\r\n    .isBoolean()\r\n    .withMessage('Consenso registrazione deve essere true o false'),\r\n  body('data_controller')\r\n    .isLength({ min: 1, max: 200 })\r\n    .withMessage('Titolare del trattamento richiesto (1-200 caratteri)'),\r\n  body('dpo_contact')\r\n    .optional()\r\n    .isEmail()\r\n    .withMessage('Email DPO non valida'),\r\n  body('gdpr_consent')\r\n    .isBoolean()\r\n    .custom((value) => {\r\n      if (!value) {\r\n        throw new Error('Consenso GDPR richiesto');\r\n      }\r\n      return true;\r\n    }),\r\n  body('terms_accepted')\r\n    .isBoolean()\r\n    .custom((value) => {\r\n      if (!value) {\r\n        throw new Error('Termini e condizioni richiesti');\r\n      }\r\n      return true;\r\n    })\r\n];\r\n\r\n// CDR Filter Validation\r\nexport const validateCDRFilter = [\r\n  query('tenant_id')\r\n    .optional()\r\n    .isUUID()\r\n    .withMessage('Tenant ID must be a valid UUID'),\r\n  query('store_id')\r\n    .optional()\r\n    .isUUID()\r\n    .withMessage('Store ID must be a valid UUID'),\r\n  query('start_date')\r\n    .optional()\r\n    .isISO8601()\r\n    .withMessage('Start date must be a valid ISO 8601 date'),\r\n  query('end_date')\r\n    .optional()\r\n    .isISO8601()\r\n    .withMessage('End date must be a valid ISO 8601 date'),\r\n  query('call_direction')\r\n    .optional()\r\n    .isIn(['inbound', 'outbound', 'internal'])\r\n    .withMessage('Call direction must be inbound, outbound, or internal'),\r\n  query('call_type')\r\n    .optional()\r\n    .isIn(['voice', 'video', 'fax'])\r\n    .withMessage('Call type must be voice, video, or fax'),\r\n  query('hangup_disposition')\r\n    .optional()\r\n    .isIn(['answered', 'busy', 'no_answer', 'congestion', 'fail', 'timeout'])\r\n    .withMessage('Hangup disposition must be answered, busy, no_answer, congestion, fail, or timeout'),\r\n  query('min_duration')\r\n    .optional()\r\n    .isInt({ min: 0 })\r\n    .withMessage('Min duration must be a non-negative integer'),\r\n  query('max_duration')\r\n    .optional()\r\n    .isInt({ min: 0 })\r\n    .withMessage('Max duration must be a non-negative integer'),\r\n  query('page')\r\n    .optional()\r\n    .isInt({ min: 1 })\r\n    .withMessage('Page must be a positive integer'),\r\n  query('limit')\r\n    .optional()\r\n    .isInt({ min: 1, max: 1000 })\r\n    .withMessage('Limit must be between 1 and 1000'),\r\n  query('sort_by')\r\n    .optional()\r\n    .isIn(['start_time', 'duration', 'caller_number', 'callee_number'])\r\n    .withMessage('Sort by must be start_time, duration, caller_number, or callee_number'),\r\n  query('sort_order')\r\n    .optional()\r\n    .isIn(['asc', 'desc'])\r\n    .withMessage('Sort order must be asc or desc')\r\n];\r\n\r\n// Pagination Validation\r\nexport const validatePagination = [\r\n  query('page')\r\n    .optional()\r\n    .isInt({ min: 1 })\r\n    .withMessage('Page must be a positive integer'),\r\n  query('limit')\r\n    .optional()\r\n    .isInt({ min: 1, max: 1000 })\r\n    .withMessage('Limit must be between 1 and 1000')\r\n];\r\n\r\n// Search Validation\r\nexport const validateSearch = [\r\n  query('q')\r\n    .optional()\r\n    .isLength({ min: 1, max: 100 })\r\n    .withMessage('Search query must be between 1 and 100 characters')\r\n    .trim()\r\n];\r\n\r\n","size_bytes":13944},"packages/frontend/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n            onOpenChange: (open: boolean) => {\n              if (!open) dismiss()\n            },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }","size_bytes":3793},"packages/database/src/seed.ts":{"content":"import { Pool } from 'pg';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport bcrypt from 'bcryptjs';\r\nimport dotenv from 'dotenv';\r\n\r\n// Load environment variables\r\ndotenv.config();\r\n\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/edgvoip',\r\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\r\n});\r\n\r\nasync function seedDatabase() {\r\n  const client = await pool.connect();\r\n  \r\n  try {\r\n    console.log('🌱 Starting database seeding...');\r\n    \r\n    // Check if data already exists\r\n    const tenantCount = await client.query('SELECT COUNT(*) FROM tenants');\r\n    if (parseInt(tenantCount.rows[0].count) > 0) {\r\n      console.log('⏭️  Database already seeded, skipping...');\r\n      // Print existing tenant IDs\r\n      const existingTenants = await client.query('SELECT id, name FROM tenants');\r\n      console.log('📋 Existing tenants:');\r\n      existingTenants.rows.forEach(t => console.log(`  - ${t.name}: ${t.id}`));\r\n      \r\n      // Print existing extensions\r\n      const existingExtensions = await client.query('SELECT extension, display_name, tenant_id FROM extensions');\r\n      console.log('📋 Existing extensions:', existingExtensions.rows.length);\r\n      existingExtensions.rows.forEach(e => console.log(`  - ${e.extension} (${e.display_name}) - tenant: ${e.tenant_id}`));\r\n      return;\r\n    }\r\n    \r\n    // Create demo tenant\r\n    const tenantId = uuidv4();\r\n    await client.query(`\r\n      INSERT INTO tenants (id, name, domain, sip_domain, status, settings)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n    `, [\r\n      tenantId,\r\n      'Demo Tenant',\r\n      'demo-tenant',\r\n      'demo-tenant.pbx.w3suite.it',\r\n      'active',\r\n      JSON.stringify({\r\n        max_concurrent_calls: 20,\r\n        recording_enabled: true,\r\n        gdpr_compliant: true,\r\n        timezone: 'Europe/Rome',\r\n        language: 'it'\r\n      })\r\n    ]);\r\n    \r\n    // Create demo store\r\n    const storeId = uuidv4();\r\n    await client.query(`\r\n      INSERT INTO stores (id, tenant_id, name, store_id, status, settings)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n    `, [\r\n      storeId,\r\n      tenantId,\r\n      'Demo Store Roma',\r\n      'store-roma-001',\r\n      'active',\r\n      JSON.stringify({\r\n        business_hours: {\r\n          enabled: true,\r\n          timezone: 'Europe/Rome',\r\n          schedule: {\r\n            monday: { open: '09:00', close: '18:00' },\r\n            tuesday: { open: '09:00', close: '18:00' },\r\n            wednesday: { open: '09:00', close: '18:00' },\r\n            thursday: { open: '09:00', close: '18:00' },\r\n            friday: { open: '09:00', close: '18:00' },\r\n            saturday: { open: '10:00', close: '16:00' },\r\n            sunday: { open: '10:00', close: '14:00' }\r\n          }\r\n        },\r\n        outbound_caller_id: '+393331234567',\r\n        recording_consent_required: true\r\n      })\r\n    ]);\r\n    \r\n    // Create demo extensions\r\n    const extensions = [\r\n      { extension: '1001', display_name: 'Mario Rossi', type: 'user' },\r\n      { extension: '1002', display_name: 'Giulia Bianchi', type: 'user' },\r\n      { extension: '1003', display_name: 'Alessandro Verdi', type: 'user' },\r\n      { extension: '2000', display_name: 'Coda Vendite', type: 'queue' },\r\n      { extension: '3000', display_name: 'Conferenza', type: 'conference' }\r\n    ];\r\n    \r\n    for (const ext of extensions) {\r\n      const extensionId = uuidv4();\r\n      const password = await bcrypt.hash('password123', 10);\r\n      \r\n      await client.query(`\r\n        INSERT INTO extensions (id, tenant_id, store_id, extension, password, display_name, type, settings)\r\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      `, [\r\n        extensionId,\r\n        tenantId,\r\n        storeId,\r\n        ext.extension,\r\n        password,\r\n        ext.display_name,\r\n        ext.type,\r\n        JSON.stringify({\r\n          voicemail_enabled: true,\r\n          call_forwarding: { enabled: false, destination: null },\r\n          dnd_enabled: false,\r\n          recording_enabled: true\r\n        })\r\n      ]);\r\n    }\r\n    \r\n    // Create demo SIP trunk\r\n    const trunkId = uuidv4();\r\n    await client.query(`\r\n      INSERT INTO sip_trunks (id, tenant_id, store_id, name, provider, status, sip_config, did_config, security, gdpr)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n    `, [\r\n      trunkId,\r\n      tenantId,\r\n      storeId,\r\n      'Demo Trunk Roma',\r\n      'Demo Provider',\r\n      'testing',\r\n      JSON.stringify({\r\n        host: 'sip.demo-provider.com',\r\n        port: 5060,\r\n        transport: 'udp',\r\n        username: 'demo_user',\r\n        password: 'demo_password',\r\n        realm: 'sip.demo-provider.com',\r\n        register: true,\r\n        retry_seconds: 60,\r\n        caller_id_in_from: false,\r\n        ping: true,\r\n        ping_time: 60\r\n      }),\r\n      JSON.stringify({\r\n        number: '+393331234567',\r\n        country_code: 'IT',\r\n        area_code: '333',\r\n        local_number: '1234567',\r\n        provider_did: 'IT_333_1234567',\r\n        inbound_route: 'demo-route'\r\n      }),\r\n      JSON.stringify({\r\n        encryption: 'tls',\r\n        authentication: 'digest',\r\n        acl: ['192.168.1.0/24', '10.0.0.0/8'],\r\n        rate_limit: {\r\n          enabled: true,\r\n          calls_per_minute: 60,\r\n          calls_per_hour: 1000\r\n        }\r\n      }),\r\n      JSON.stringify({\r\n        data_retention_days: 365,\r\n        recording_consent_required: true,\r\n        data_processing_purpose: 'Business communications',\r\n        lawful_basis: 'legitimate_interest',\r\n        data_controller: 'Demo Company SRL',\r\n        dpo_contact: 'dpo@demo-company.it'\r\n      })\r\n    ]);\r\n    \r\n    // Create some demo CDR records\r\n    const demoCDRs = [\r\n      {\r\n        call_uuid: uuidv4(),\r\n        call_direction: 'inbound',\r\n        caller_id_number: '+393339876543',\r\n        caller_id_name: 'Cliente Demo',\r\n        callee_extension: '1001',\r\n        start_time: new Date(Date.now() - 3600000), // 1 hour ago\r\n        answer_time: new Date(Date.now() - 3595000), // 5 seconds later\r\n        end_time: new Date(Date.now() - 3000000), // 10 minutes call\r\n        duration: 600,\r\n        bill_seconds: 600,\r\n        hangup_cause: 'NORMAL_CLEARING',\r\n        hangup_disposition: 'answered',\r\n        audio_codec: 'PCMU',\r\n        recording_enabled: true,\r\n        recording_consent: true,\r\n        fs_uuid: uuidv4(),\r\n        fs_domain: 'demo-tenant.pbx.w3suite.it'\r\n      },\r\n      {\r\n        call_uuid: uuidv4(),\r\n        call_direction: 'outbound',\r\n        caller_extension: '1002',\r\n        callee_id_number: '+393339876544',\r\n        callee_id_name: 'Fornitore Demo',\r\n        start_time: new Date(Date.now() - 1800000), // 30 minutes ago\r\n        answer_time: new Date(Date.now() - 1795000), // 5 seconds later\r\n        end_time: new Date(Date.now() - 1200000), // 10 minutes call\r\n        duration: 600,\r\n        bill_seconds: 600,\r\n        hangup_cause: 'NORMAL_CLEARING',\r\n        hangup_disposition: 'answered',\r\n        audio_codec: 'PCMU',\r\n        recording_enabled: true,\r\n        recording_consent: true,\r\n        fs_uuid: uuidv4(),\r\n        fs_domain: 'demo-tenant.pbx.w3suite.it'\r\n      }\r\n    ];\r\n    \r\n    for (const cdr of demoCDRs) {\r\n      await client.query(`\r\n        INSERT INTO cdr (\r\n          tenant_id, store_id, extension_id, trunk_id, call_uuid, call_direction,\r\n          caller_id_number, caller_id_name, caller_extension, callee_id_number,\r\n          callee_id_name, callee_extension, start_time, answer_time, end_time,\r\n          duration, bill_seconds, hangup_cause, hangup_disposition, audio_codec,\r\n          recording_enabled, recording_consent, fs_uuid, fs_domain\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24)\r\n      `, [\r\n        tenantId, storeId, null, trunkId, cdr.call_uuid, cdr.call_direction,\r\n        cdr.caller_id_number, cdr.caller_id_name, cdr.caller_extension, cdr.callee_id_number,\r\n        cdr.callee_id_name, cdr.callee_extension, cdr.start_time, cdr.answer_time, cdr.end_time,\r\n        cdr.duration, cdr.bill_seconds, cdr.hangup_cause, cdr.hangup_disposition, cdr.audio_codec,\r\n        cdr.recording_enabled, cdr.recording_consent, cdr.fs_uuid, cdr.fs_domain\r\n      ]);\r\n    }\r\n    \r\n    console.log('✅ Database seeded successfully!');\r\n    console.log('📊 Created:');\r\n    console.log('  - 1 Demo Tenant');\r\n    console.log('  - 1 Demo Store');\r\n    console.log('  - 5 Demo Extensions');\r\n    console.log('  - 1 Demo SIP Trunk');\r\n    console.log('  - 2 Demo CDR Records');\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Seeding failed:', error);\r\n    throw error;\r\n  } finally {\r\n    client.release();\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  try {\r\n    await seedDatabase();\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('Seeding process failed:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nif (require.main === module) {\r\n  main();\r\n}\r\n\r\nexport { seedDatabase };\r\n\r\n","size_bytes":9035},"packages/frontend/src/pages/RingGroups.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Switch } from '@/components/ui/switch';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Plus, \n  Search, \n  Edit, \n  Trash2, \n  Phone, \n  Users,\n  Settings,\n  Clock,\n  MoreHorizontal,\n  UserPlus,\n  UserMinus,\n  RefreshCw\n} from 'lucide-react';\nimport { useAuth } from '@/contexts/AuthContext';\n\ninterface RingGroup {\n  id: string;\n  name: string;\n  description?: string;\n  extension: string;\n  strategy: 'ringall' | 'hunt' | 'random' | 'simultaneous';\n  ring_time: number;\n  members: Array<{\n    extension_id: string;\n    extension: string;\n    display_name: string;\n    priority: number;\n    ring_delay: number;\n    ring_timeout: number;\n    enabled: boolean;\n  }>;\n  voicemail_enabled: boolean;\n  voicemail_extension?: string;\n  call_timeout: number;\n  call_timeout_action: 'voicemail' | 'hangup' | 'forward';\n  enabled: boolean;\n  current_calls: number;\n  max_concurrent_calls: number;\n}\n\ninterface Extension {\n  id: string;\n  extension: string;\n  display_name: string;\n}\n\nexport default function RingGroups() {\n  const { user } = useAuth();\n  const [ringGroups, setRingGroups] = useState<RingGroup[]>([]);\n  const [extensions, setExtensions] = useState<Extension[]>([]);\n  const [showModal, setShowModal] = useState(false);\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\n  const [loading, setLoading] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [formData, setFormData] = useState<Partial<RingGroup>>({});\n  const [editingItem, setEditingItem] = useState<RingGroup | null>(null);\n\n  // Load ring groups on component mount\n  useEffect(() => {\n    loadRingGroups();\n    loadExtensions();\n  }, []);\n\n  const loadRingGroups = async () => {\n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups`);\n      const data = await response.json();\n      \n      if (data?.success && Array.isArray(data?.data)) {\n        setRingGroups(data.data);\n      } else {\n        console.warn('⚠️ Invalid API response format');\n        setRingGroups([]);\n      }\n    } catch (error) {\n      console.error('❌ Error loading ring groups:', error);\n      setRingGroups([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadExtensions = async () => {\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/extensions`);\n      const data = await response.json();\n      \n      if (data?.success && Array.isArray(data?.extensions)) {\n        setExtensions(data.extensions.map((ext: any) => ({\n          id: ext.id,\n          extension: ext.extension,\n          display_name: ext.display_name\n        })));\n      }\n    } catch (error) {\n      console.error('❌ Error loading extensions:', error);\n    }\n  };\n\n  const handleCreate = async () => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          ...formData,\n          tenant_id: user.tenant_id\n        })\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadRingGroups();\n        setShowModal(false);\n        setFormData({});\n      } else {\n        console.error('❌ Error creating ring group:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error creating ring group:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleEdit = async () => {\n    if (!editingItem) return;\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups/${editingItem.id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(formData)\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadRingGroups();\n        setShowModal(false);\n        setFormData({});\n        setEditingItem(null);\n      } else {\n        console.error('❌ Error updating ring group:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error updating ring group:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDelete = async (ringGroup: RingGroup) => {\n    if (!confirm(`Are you sure you want to delete ring group \"${ringGroup.name}\"?`)) {\n      return;\n    }\n    \n    setLoading(true);\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups/${ringGroup.id}`, {\n        method: 'DELETE'\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadRingGroups();\n      } else {\n        console.error('❌ Error deleting ring group:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error deleting ring group:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleAddMember = async (ringGroupId: string, extensionId: string) => {\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups/${ringGroupId}/members`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ extension_id: extensionId })\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadRingGroups();\n      } else {\n        console.error('❌ Error adding member:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error adding member:', error);\n    }\n  };\n\n  const handleRemoveMember = async (ringGroupId: string, extensionId: string) => {\n    try {\n      const API_BASE_URL = import.meta.env?.VITE_API_BASE_URL || 'http://192.168.172.234:3000/api';\n      const response = await fetch(`${API_BASE_URL}/ring-groups/${ringGroupId}/members/${extensionId}`, {\n        method: 'DELETE'\n      });\n      \n      const data = await response.json();\n      \n      if (data.success) {\n        await loadRingGroups();\n      } else {\n        console.error('❌ Error removing member:', data.message);\n      }\n    } catch (error) {\n      console.error('❌ Error removing member:', error);\n    }\n  };\n\n  const filteredRingGroups = ringGroups.filter(rg =>\n    rg.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    rg.extension.includes(searchTerm) ||\n    rg.description?.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  const getStrategyLabel = (strategy: string) => {\n    switch (strategy) {\n      case 'ringall': return 'Ring All';\n      case 'hunt': return 'Hunt';\n      case 'random': return 'Random';\n      case 'simultaneous': return 'Simultaneous';\n      default: return strategy;\n    }\n  };\n\n  const getStrategyColor = (strategy: string) => {\n    switch (strategy) {\n      case 'ringall': return 'bg-blue-100 text-blue-800';\n      case 'hunt': return 'bg-green-100 text-green-800';\n      case 'random': return 'bg-purple-100 text-purple-800';\n      case 'simultaneous': return 'bg-orange-100 text-orange-800';\n      default: return 'bg-gray-100 text-gray-800';\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold\">Ring Groups</h1>\n          <p className=\"text-gray-600\">Manage ring groups for simultaneous or sequential ringing</p>\n        </div>\n        <Button onClick={() => {\n          setModalType('create');\n          setFormData({});\n          setShowModal(true);\n        }}>\n          <Plus className=\"h-4 w-4 mr-2\" />\n          Add Ring Group\n        </Button>\n      </div>\n\n      {/* Search and Stats */}\n      <div className=\"flex items-center space-x-4\">\n        <div className=\"relative flex-1 max-w-md\">\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\n          <Input\n            placeholder=\"Search ring groups...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n            className=\"pl-10\"\n          />\n        </div>\n        <Button variant=\"outline\" onClick={loadRingGroups} disabled={loading}>\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\n          Refresh\n        </Button>\n      </div>\n\n      {/* Ring Groups Grid */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        {filteredRingGroups.map((ringGroup) => (\n          <Card key={ringGroup.id} className=\"relative\">\n            <CardHeader className=\"pb-3\">\n              <div className=\"flex items-start justify-between\">\n                <div className=\"flex-1\">\n                  <CardTitle className=\"text-lg\">{ringGroup.name}</CardTitle>\n                  <CardDescription>{ringGroup.description}</CardDescription>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Badge variant={ringGroup.enabled ? 'default' : 'secondary'}>\n                    {ringGroup.enabled ? 'Active' : 'Inactive'}\n                  </Badge>\n                  <Button variant=\"ghost\" size=\"sm\">\n                    <MoreHorizontal className=\"h-4 w-4\" />\n                  </Button>\n                </div>\n              </div>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {/* Extension and Strategy */}\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  <Phone className=\"h-4 w-4 text-gray-500\" />\n                  <span className=\"font-medium\">{ringGroup.extension}</span>\n                </div>\n                <Badge className={getStrategyColor(ringGroup.strategy)}>\n                  {getStrategyLabel(ringGroup.strategy)}\n                </Badge>\n              </div>\n\n              {/* Members */}\n              <div className=\"flex items-center space-x-2\">\n                <Users className=\"h-4 w-4 text-gray-500\" />\n                <span className=\"text-sm text-gray-600\">\n                  {ringGroup.members.length} member{ringGroup.members.length !== 1 ? 's' : ''}\n                </span>\n              </div>\n\n              {/* Ring Time */}\n              <div className=\"flex items-center space-x-2\">\n                <Clock className=\"h-4 w-4 text-gray-500\" />\n                <span className=\"text-sm text-gray-600\">\n                  {ringGroup.ring_time}s ring time\n                </span>\n              </div>\n\n              {/* Current Calls */}\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  <Phone className=\"h-4 w-4 text-gray-500\" />\n                  <span className=\"text-sm text-gray-600\">\n                    {ringGroup.current_calls}/{ringGroup.max_concurrent_calls} calls\n                  </span>\n                </div>\n                <div className=\"flex items-center space-x-1\">\n                  {ringGroup.current_calls > 0 ? (\n                    <div className=\"w-2 h-2 bg-green-500 rounded-full animate-pulse\"></div>\n                  ) : (\n                    <div className=\"w-2 h-2 bg-gray-300 rounded-full\"></div>\n                  )}\n                </div>\n              </div>\n\n              {/* Actions */}\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setModalType('edit');\n                    setFormData(ringGroup);\n                    setEditingItem(ringGroup);\n                    setShowModal(true);\n                  }}\n                >\n                  <Edit className=\"h-4 w-4 mr-1\" />\n                  Edit\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setModalType('view');\n                    setFormData(ringGroup);\n                    setEditingItem(ringGroup);\n                    setShowModal(true);\n                  }}\n                >\n                  <Settings className=\"h-4 w-4 mr-1\" />\n                  View\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => handleDelete(ringGroup)}\n                  className=\"text-red-600 hover:text-red-700\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {/* Empty State */}\n      {filteredRingGroups.length === 0 && !loading && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <Users className=\"h-12 w-12 text-gray-400 mb-4\" />\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No Ring Groups Found</h3>\n            <p className=\"text-gray-500 text-center mb-4\">\n              {searchTerm ? 'No ring groups match your search criteria.' : 'Create your first ring group to get started.'}\n            </p>\n            {!searchTerm && (\n              <Button onClick={() => {\n                setModalType('create');\n                setFormData({});\n                setShowModal(true);\n              }}>\n                <Plus className=\"h-4 w-4 mr-2\" />\n                Create Ring Group\n              </Button>\n            )}\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Create/Edit Modal */}\n      {showModal && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n          <Card className=\"w-full max-w-2xl max-h-[90vh] overflow-y-auto\">\n            <CardHeader>\n              <CardTitle>\n                {modalType === 'create' ? 'Create Ring Group' : \n                 modalType === 'edit' ? 'Edit Ring Group' : 'View Ring Group'}\n              </CardTitle>\n              <CardDescription>\n                {modalType === 'create' ? 'Create a new ring group for your team' :\n                 modalType === 'edit' ? 'Update ring group settings' :\n                 'View ring group details and members'}\n              </CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Name</label>\n                  <Input\n                    value={formData.name || ''}\n                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}\n                    disabled={modalType === 'view'}\n                    placeholder=\"Sales Team\"\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Extension</label>\n                  <Input\n                    value={formData.extension || ''}\n                    onChange={(e) => setFormData({ ...formData, extension: e.target.value })}\n                    disabled={modalType === 'view'}\n                    placeholder=\"2000\"\n                  />\n                </div>\n              </div>\n\n              <div>\n                <label className=\"text-sm font-medium\">Description</label>\n                <Textarea\n                  value={formData.description || ''}\n                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}\n                  disabled={modalType === 'view'}\n                  placeholder=\"Ring group for sales team members\"\n                />\n              </div>\n\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Strategy</label>\n                  <Select\n                    value={formData.strategy || 'ringall'}\n                    onValueChange={(value) => setFormData({ ...formData, strategy: value as any })}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"ringall\">Ring All</SelectItem>\n                      <SelectItem value=\"hunt\">Hunt</SelectItem>\n                      <SelectItem value=\"random\">Random</SelectItem>\n                      <SelectItem value=\"simultaneous\">Simultaneous</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Ring Time (seconds)</label>\n                  <Input\n                    type=\"number\"\n                    value={formData.ring_time || 20}\n                    onChange={(e) => setFormData({ ...formData, ring_time: parseInt(e.target.value) })}\n                    disabled={modalType === 'view'}\n                    min=\"1\"\n                    max=\"60\"\n                  />\n                </div>\n              </div>\n\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Call Timeout (seconds)</label>\n                  <Input\n                    type=\"number\"\n                    value={formData.call_timeout || 60}\n                    onChange={(e) => setFormData({ ...formData, call_timeout: parseInt(e.target.value) })}\n                    disabled={modalType === 'view'}\n                    min=\"1\"\n                    max=\"300\"\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Max Concurrent Calls</label>\n                  <Input\n                    type=\"number\"\n                    value={formData.max_concurrent_calls || 10}\n                    onChange={(e) => setFormData({ ...formData, max_concurrent_calls: parseInt(e.target.value) })}\n                    disabled={modalType === 'view'}\n                    min=\"1\"\n                    max=\"100\"\n                  />\n                </div>\n              </div>\n\n              {/* Voicemail Settings */}\n              <div className=\"border-t pt-4\">\n                <h4 className=\"font-medium mb-3\">Voicemail Settings</h4>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-center space-x-2\">\n                    <Switch\n                      checked={formData.voicemail_enabled || false}\n                      onCheckedChange={(checked) => setFormData({ ...formData, voicemail_enabled: checked })}\n                      disabled={modalType === 'view'}\n                    />\n                    <label className=\"text-sm font-medium\">Enable Voicemail</label>\n                  </div>\n                  \n                  {formData.voicemail_enabled && (\n                    <div>\n                      <label className=\"text-sm font-medium\">Voicemail Extension</label>\n                      <Input\n                        value={formData.voicemail_extension || ''}\n                        onChange={(e) => setFormData({ ...formData, voicemail_extension: e.target.value })}\n                        disabled={modalType === 'view'}\n                        placeholder=\"100\"\n                      />\n                    </div>\n                  )}\n                </div>\n              </div>\n\n              {/* Members Section */}\n              {(modalType === 'edit' || modalType === 'view') && editingItem && (\n                <div className=\"border-t pt-4\">\n                  <h4 className=\"font-medium mb-3\">Members</h4>\n                  <div className=\"space-y-2\">\n                    {editingItem.members.map((member) => (\n                      <div key={member.extension_id} className=\"flex items-center justify-between p-2 border rounded\">\n                        <div className=\"flex items-center space-x-2\">\n                          <Phone className=\"h-4 w-4 text-gray-500\" />\n                          <span className=\"font-medium\">{member.extension}</span>\n                          <span className=\"text-sm text-gray-600\">- {member.display_name}</span>\n                        </div>\n                        {modalType === 'edit' && (\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => handleRemoveMember(editingItem.id, member.extension_id)}\n                            className=\"text-red-600 hover:text-red-700\"\n                          >\n                            <UserMinus className=\"h-4 w-4\" />\n                          </Button>\n                        )}\n                      </div>\n                    ))}\n                    \n                    {modalType === 'edit' && (\n                      <div className=\"pt-2\">\n                        <Select onValueChange={(value) => {\n                          if (value) {\n                            handleAddMember(editingItem.id, value);\n                          }\n                        }}>\n                          <SelectTrigger>\n                            <SelectValue placeholder=\"Add member...\" />\n                          </SelectTrigger>\n                          <SelectContent>\n                            {extensions\n                              .filter(ext => !editingItem.members.some(member => member.extension_id === ext.id))\n                              .map((ext) => (\n                                <SelectItem key={ext.id} value={ext.id}>\n                                  {ext.extension} - {ext.display_name}\n                                </SelectItem>\n                              ))}\n                          </SelectContent>\n                        </Select>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              )}\n\n              {/* Modal Actions */}\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\n                <Button\n                  variant=\"outline\"\n                  onClick={() => {\n                    setShowModal(false);\n                    setFormData({});\n                    setEditingItem(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                {modalType !== 'view' && (\n                  <Button\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\n                    disabled={loading}\n                  >\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      )}\n    </div>\n  );\n}\n","size_bytes":23856},"packages/frontend/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\r\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nconst Tabs = TabsPrimitive.Root\r\n\r\nconst TabsList = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.List>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.List\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsList.displayName = TabsPrimitive.List.displayName\r\n\r\nconst TabsTrigger = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(\r\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\r\n\r\nconst TabsContent = React.forwardRef<\r\n  React.ElementRef<typeof TabsPrimitive.Content>,\r\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <TabsPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n      className\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nTabsContent.displayName = TabsPrimitive.Content.displayName\r\n\r\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\r\n\r\n","size_bytes":1938},"packages/backend/src/services/freeswitch-config.service.ts":{"content":"// @ts-nocheck\r\nimport { getClient } from '@w3-voip/database';\r\n// import { Tenant, Store, Extension } from '@w3-voip/shared';\r\nimport { logFreeSWITCHEvent } from '../utils/logger';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\n// Define types locally\r\nexport interface Tenant {\r\n  id: string;\r\n  name: string;\r\n  domain: string;\r\n  sip_domain: string;\r\n  status: 'active' | 'suspended' | 'pending';\r\n}\r\n\r\nexport interface Store {\r\n  id: string;\r\n  tenant_id: string;\r\n  name: string;\r\n  address: string;\r\n  phone: string;\r\n  status: 'active' | 'inactive';\r\n}\r\n\r\nexport interface Extension {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  extension: string;\r\n  password: string;\r\n  display_name: string;\r\n  status: 'active' | 'inactive';\r\n  type: 'user' | 'queue' | 'conference';\r\n}\r\n\r\nexport class FreeSWITCHConfigService {\r\n  private configPath: string;\r\n  private templatePath: string;\r\n\r\n  constructor() {\r\n    this.configPath = process.env.FREESWITCH_CONFIG_PATH || '/etc/freeswitch';\r\n    this.templatePath = path.join(__dirname, '../../../../config/freeswitch');\r\n  }\r\n\r\n  // Generate tenant domain configuration\r\n  async generateTenantDomainConfig(tenant: Tenant): Promise<void> {\r\n    try {\r\n      const template = await fs.readFile(\r\n        path.join(this.templatePath, 'tenant-template.xml'),\r\n        'utf-8'\r\n      );\r\n\r\n      const config = template\r\n        .replace(/TENANT_ID/g, tenant.id)\r\n        .replace(/TENANT_NAME/g, tenant.name)\r\n        .replace(/TENANT_DOMAIN/g, tenant.domain)\r\n        .replace(/RECORDING_ENABLED/g, 'true')\r\n        .replace(/RECORDING_CONSENT/g, 'true')\r\n        .replace(/MAX_CONCURRENT_CALLS/g, '20')\r\n        .replace(/ALLOWED_CODECS/g, 'PCMU,PCMA,G722,OPUS')\r\n        .replace(/TIMEZONE/g, 'Europe/Rome')\r\n        .replace(/TENANT_PASSWORD/g, this.generateSecurePassword())\r\n        .replace(/TENANT_VM_PASSWORD/g, this.generateSecurePassword())\r\n        .replace(/TENANT_TOLL_ALLOW/g, 'domestic,international')\r\n        .replace(/TENANT_MAIN_NUMBER/g, tenant.main_number || '')\r\n        .replace(/TENANT_RECORDING_TEMPLATE/g, `tenant_${tenant.id}_%Y%m%d_%H%M%S`)\r\n        .replace(/TENANT_IP_RANGE/g, tenant.allowed_ip_range || '0.0.0.0/0')\r\n        .replace(/TENANT_TRUNK/g, `trunk_${tenant.id}`);\r\n\r\n      const domainConfigPath = path.join(this.configPath, 'domain', `${tenant.domain}.xml`);\r\n      await fs.writeFile(domainConfigPath, config);\r\n\r\n      // Create directory structure\r\n      await fs.mkdir(path.join(this.configPath, 'directory', tenant.domain), { recursive: true });\r\n      await fs.mkdir(path.join(this.configPath, 'dialplan', tenant.domain), { recursive: true });\r\n      await fs.mkdir(path.join(this.configPath, 'acl', tenant.domain), { recursive: true });\r\n\r\n      logFreeSWITCHEvent('tenant_config_generated', {\r\n        tenant_id: tenant.id,\r\n        tenant_domain: tenant.domain,\r\n        config_path: domainConfigPath\r\n      });\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('tenant_config_error', {\r\n        tenant_id: tenant.id,\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Generate extension configuration\r\n  async generateExtensionConfig(extension: Extension, tenant: Tenant): Promise<void> {\r\n    try {\r\n      const extensionConfig = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<include>\r\n  <user id=\"${extension.extension_number}\">\r\n    <params>\r\n      <param name=\"password\" value=\"${extension.password}\"/>\r\n      <param name=\"vm-password\" value=\"${extension.password}\"/>\r\n    </params>\r\n    \r\n    <variables>\r\n      <variable name=\"toll_allow\" value=\"domestic,international\"/>\r\n      <variable name=\"accountcode\" value=\"${tenant.id}\"/>\r\n      <variable name=\"user_context\" value=\"${tenant.domain}\"/>\r\n      <variable name=\"effective_caller_id_name\" value=\"${extension.caller_id_name || extension.extension_number}\"/>\r\n      <variable name=\"effective_caller_id_number\" value=\"${extension.caller_id_number || extension.extension_number}\"/>\r\n      <variable name=\"outbound_caller_id_name\" value=\"${extension.caller_id_name || extension.extension_number}\"/>\r\n      <variable name=\"outbound_caller_id_number\" value=\"${extension.caller_id_number || extension.extension_number}\"/>\r\n      <variable name=\"callgroup\" value=\"${tenant.id}\"/>\r\n      <variable name=\"user_record\" value=\"${extension.recording_enabled ? 'true' : 'false'}\"/>\r\n      <variable name=\"record_stereo\" value=\"true\"/>\r\n      <variable name=\"record_sample_rate\" value=\"8000\"/>\r\n      <variable name=\"record_channels\" value=\"2\"/>\r\n      <variable name=\"record_template\" value=\"tenant_${tenant.id}_ext_${extension.extension_number}_%Y%m%d_%H%M%S\"/>\r\n    </variables>\r\n  </user>\r\n</include>`;\r\n\r\n      const extensionConfigPath = path.join(\r\n        this.configPath,\r\n        'directory',\r\n        tenant.domain,\r\n        `${extension.extension_number}.xml`\r\n      );\r\n\r\n      await fs.writeFile(extensionConfigPath, extensionConfig);\r\n\r\n      logFreeSWITCHEvent('extension_config_generated', {\r\n        tenant_id: tenant.id,\r\n        extension_id: extension.id,\r\n        extension_number: extension.extension_number,\r\n        config_path: extensionConfigPath\r\n      });\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('extension_config_error', {\r\n        tenant_id: tenant.id,\r\n        extension_id: extension.id,\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Generate trunk configuration\r\n  async generateTrunkConfig(trunk: any, tenant: Tenant): Promise<void> {\r\n    try {\r\n      const trunkConfig = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<include>\r\n  <gateway name=\"trunk_${tenant.id}\">\r\n    <param name=\"username\" value=\"${trunk.username}\"/>\r\n    <param name=\"realm\" value=\"${trunk.from_domain}\"/>\r\n    <param name=\"password\" value=\"${trunk.password}\"/>\r\n    <param name=\"register\" value=\"${trunk.register_string}\"/>\r\n    <param name=\"caller-id-in-from\" value=\"true\"/>\r\n    <param name=\"supress-cng\" value=\"true\"/>\r\n    <param name=\"extension\" value=\"${trunk.username}\"/>\r\n    <param name=\"proxy\" value=\"${trunk.outbound_proxy}\"/>\r\n    <param name=\"register-proxy\" value=\"${trunk.outbound_proxy}\"/>\r\n    <param name=\"outbound-proxy\" value=\"${trunk.outbound_proxy}\"/>\r\n    <param name=\"expire-seconds\" value=\"600\"/>\r\n    <param name=\"register-transport\" value=\"udp\"/>\r\n    <param name=\"contact-params\" value=\"t=${tenant.id}\"/>\r\n    <param name=\"ping\" value=\"25\"/>\r\n    <param name=\"context\" value=\"${tenant.domain}\"/>\r\n    <param name=\"codec-prefs\" value=\"PCMU,PCMA,G722,OPUS\"/>\r\n    <param name=\"absolute-codec-string\" value=\"PCMU,PCMA\"/>\r\n    <param name=\"enable\" value=\"${trunk.enabled ? 'true' : 'false'}\"/>\r\n  </gateway>\r\n</include>`;\r\n\r\n      const trunkConfigPath = path.join(\r\n        this.configPath,\r\n        'sip_profiles',\r\n        'external',\r\n        `trunk_${tenant.id}.xml`\r\n      );\r\n\r\n      await fs.writeFile(trunkConfigPath, trunkConfig);\r\n\r\n      logFreeSWITCHEvent('trunk_config_generated', {\r\n        tenant_id: tenant.id,\r\n        trunk_id: trunk.id,\r\n        trunk_name: trunk.name,\r\n        config_path: trunkConfigPath\r\n      });\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('trunk_config_error', {\r\n        tenant_id: tenant.id,\r\n        trunk_id: trunk.id,\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Reload FreeSWITCH configuration\r\n  async reloadFreeSWITCHConfig(): Promise<void> {\r\n    try {\r\n      // This would typically use FreeSWITCH Event Socket Library\r\n      // For now, we'll just log the reload request\r\n      logFreeSWITCHEvent('config_reload_requested', {\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // In a real implementation, you would:\r\n      // 1. Connect to FreeSWITCH ESL\r\n      // 2. Send reloadxml command\r\n      // 3. Send reloadacl command\r\n      // 4. Send reload command for specific modules\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('config_reload_error', {\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Delete tenant configuration\r\n  async deleteTenantConfig(tenant: Tenant): Promise<void> {\r\n    try {\r\n      const domainConfigPath = path.join(this.configPath, 'domain', `${tenant.domain}.xml`);\r\n      const directoryPath = path.join(this.configPath, 'directory', tenant.domain);\r\n      const dialplanPath = path.join(this.configPath, 'dialplan', tenant.domain);\r\n      const aclPath = path.join(this.configPath, 'acl', tenant.domain);\r\n      const trunkConfigPath = path.join(this.configPath, 'sip_profiles', 'external', `trunk_${tenant.id}.xml`);\r\n\r\n      // Remove configuration files\r\n      await fs.unlink(domainConfigPath).catch(() => {});\r\n      await fs.rmdir(directoryPath, { recursive: true }).catch(() => {});\r\n      await fs.rmdir(dialplanPath, { recursive: true }).catch(() => {});\r\n      await fs.rmdir(aclPath, { recursive: true }).catch(() => {});\r\n      await fs.unlink(trunkConfigPath).catch(() => {});\r\n\r\n      logFreeSWITCHEvent('tenant_config_deleted', {\r\n        tenant_id: tenant.id,\r\n        tenant_domain: tenant.domain\r\n      });\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('tenant_config_delete_error', {\r\n        tenant_id: tenant.id,\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Generate secure password\r\n  private generateSecurePassword(): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';\r\n    let password = '';\r\n    for (let i = 0; i < 12; i++) {\r\n      password += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return password;\r\n  }\r\n\r\n  // Sync all tenant configurations\r\n  async syncAllTenantConfigs(): Promise<void> {\r\n    try {\r\n      const client = await getClient();\r\n      \r\n      try {\r\n        // Get all tenants\r\n        const tenantsResult = await client.query('SELECT * FROM tenants');\r\n        const tenants = tenantsResult.rows;\r\n\r\n        for (const tenant of tenants) {\r\n          // Generate domain configuration\r\n          await this.generateTenantDomainConfig(tenant);\r\n\r\n          // Get tenant extensions\r\n          const extensionsResult = await client.query(\r\n            'SELECT * FROM extensions WHERE tenant_id = $1',\r\n            [tenant.id]\r\n          );\r\n          const extensions = extensionsResult.rows;\r\n\r\n          // Generate extension configurations\r\n          for (const extension of extensions) {\r\n            await this.generateExtensionConfig(extension, tenant);\r\n          }\r\n\r\n          // Get tenant trunks\r\n          const trunksResult = await client.query(\r\n            'SELECT * FROM trunks WHERE tenant_id = $1',\r\n            [tenant.id]\r\n          );\r\n          const trunks = trunksResult.rows;\r\n\r\n          // Generate trunk configurations\r\n          for (const trunk of trunks) {\r\n            await this.generateTrunkConfig(trunk, tenant);\r\n          }\r\n        }\r\n\r\n        // Reload FreeSWITCH configuration\r\n        await this.reloadFreeSWITCHConfig();\r\n\r\n        logFreeSWITCHEvent('all_configs_synced', {\r\n          tenant_count: tenants.length,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n\r\n      } finally {\r\n        await client.release();\r\n      }\r\n\r\n    } catch (error) {\r\n      logFreeSWITCHEvent('config_sync_error', {\r\n        error: error.message\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n","size_bytes":11354},"packages/frontend/src/pages/CreateTenant.tsx":{"content":"import React, { useState } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Plus, Trash2, ArrowLeft, ArrowRight, Save, User, Building2, Users } from 'lucide-react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport apiClient from '@/lib/api';\r\n\r\ninterface AdminUser {\r\n  first_name: string;\r\n  last_name: string;\r\n  email: string;\r\n  password: string;\r\n  role: 'tenant_admin' | 'super_admin';\r\n}\r\n\r\ninterface Company {\r\n  legal_name: string;\r\n  vat_number: string;\r\n  tax_code: string;\r\n  address: string;\r\n  city: string;\r\n  state: string;\r\n  postal_code: string;\r\n  country: string;\r\n  is_primary: boolean;\r\n}\r\n\r\ninterface Contact {\r\n  first_name: string;\r\n  last_name: string;\r\n  role: string;\r\n  email: string;\r\n  phone: string;\r\n  mobile: string;\r\n  is_primary: boolean;\r\n}\r\n\r\nexport default function CreateTenant() {\r\n  const navigate = useNavigate();\r\n  const { toast } = useToast();\r\n  const [currentStep, setCurrentStep] = useState(1);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n\r\n  // Form data\r\n  const [tenantData, setTenantData] = useState({\r\n    name: '',\r\n    slug: '',\r\n    domain: '',\r\n    sip_domain: ''\r\n  });\r\n\r\n  const [adminUser, setAdminUser] = useState<AdminUser>({\r\n    first_name: '',\r\n    last_name: '',\r\n    email: '',\r\n    password: '',\r\n    role: 'tenant_admin'\r\n  });\r\n\r\n  const [companies, setCompanies] = useState<Company[]>([\r\n    {\r\n      legal_name: '',\r\n      vat_number: '',\r\n      tax_code: '',\r\n      address: '',\r\n      city: '',\r\n      state: '',\r\n      postal_code: '',\r\n      country: 'Italy',\r\n      is_primary: true\r\n    }\r\n  ]);\r\n\r\n  const [contacts, setContacts] = useState<Contact[]>([\r\n    {\r\n      first_name: '',\r\n      last_name: '',\r\n      role: '',\r\n      email: '',\r\n      phone: '',\r\n      mobile: '',\r\n      is_primary: true\r\n    }\r\n  ]);\r\n\r\n  const steps = [\r\n    { id: 1, title: 'Informazioni Tenant', icon: Building2 },\r\n    { id: 2, title: 'Utente Admin', icon: User },\r\n    { id: 3, title: 'Ragioni Sociali', icon: Building2 },\r\n    { id: 4, title: 'Contatti', icon: Users }\r\n  ];\r\n\r\n  const handleTenantDataChange = (field: string, value: string) => {\r\n    setTenantData(prev => ({ ...prev, [field]: value }));\r\n    \r\n    // Auto-generate slug from name\r\n    if (field === 'name') {\r\n      const slug = value.toLowerCase()\r\n        .replace(/[^a-z0-9\\s-]/g, '')\r\n        .replace(/\\s+/g, '-')\r\n        .replace(/-+/g, '-')\r\n        .trim();\r\n      setTenantData(prev => ({ ...prev, slug }));\r\n    }\r\n  };\r\n\r\n  const handleAdminUserChange = (field: keyof AdminUser, value: string) => {\r\n    setAdminUser(prev => ({ ...prev, [field]: value }));\r\n  };\r\n\r\n  const handleCompanyChange = (index: number, field: keyof Company, value: string | boolean) => {\r\n    setCompanies(prev => prev.map((company, i) => \r\n      i === index ? { ...company, [field]: value } : company\r\n    ));\r\n  };\r\n\r\n  const handleContactChange = (index: number, field: keyof Contact, value: string | boolean) => {\r\n    setContacts(prev => prev.map((contact, i) => \r\n      i === index ? { ...contact, [field]: value } : contact\r\n    ));\r\n  };\r\n\r\n  const addCompany = () => {\r\n    setCompanies(prev => [...prev, {\r\n      legal_name: '',\r\n      vat_number: '',\r\n      tax_code: '',\r\n      address: '',\r\n      city: '',\r\n      state: '',\r\n      postal_code: '',\r\n      country: 'Italy',\r\n      is_primary: false\r\n    }]);\r\n  };\r\n\r\n  const removeCompany = (index: number) => {\r\n    if (companies.length > 1) {\r\n      setCompanies(prev => prev.filter((_, i) => i !== index));\r\n    }\r\n  };\r\n\r\n  const addContact = () => {\r\n    setContacts(prev => [...prev, {\r\n      first_name: '',\r\n      last_name: '',\r\n      role: '',\r\n      email: '',\r\n      phone: '',\r\n      mobile: '',\r\n      is_primary: false\r\n    }]);\r\n  };\r\n\r\n  const removeContact = (index: number) => {\r\n    if (contacts.length > 1) {\r\n      setContacts(prev => prev.filter((_, i) => i !== index));\r\n    }\r\n  };\r\n\r\n  const validateStep = (step: number): boolean => {\r\n    switch (step) {\r\n      case 1:\r\n        return !!(tenantData.name && tenantData.slug && tenantData.domain && tenantData.sip_domain);\r\n      case 2:\r\n        return !!(adminUser.first_name && adminUser.last_name && adminUser.email && adminUser.password);\r\n      case 3:\r\n        return companies.every(c => c.legal_name) && companies.some(c => c.is_primary);\r\n      case 4:\r\n        return contacts.every(c => c.first_name && c.last_name) && contacts.some(c => c.is_primary);\r\n      default:\r\n        return false;\r\n    }\r\n  };\r\n\r\n  const handleNext = () => {\r\n    if (validateStep(currentStep)) {\r\n      setCurrentStep(prev => Math.min(prev + 1, steps.length));\r\n    } else {\r\n      toast({\r\n        title: \"Errore\",\r\n        description: \"Compila tutti i campi obbligatori prima di procedere\",\r\n        variant: \"destructive\",\r\n      });\r\n    }\r\n  };\r\n\r\n  const handlePrevious = () => {\r\n    setCurrentStep(prev => Math.max(prev - 1, 1));\r\n  };\r\n\r\n  const handleSubmit = async () => {\r\n    if (!validateStep(4)) {\r\n      toast({\r\n        title: \"Errore\",\r\n        description: \"Compila tutti i campi obbligatori\",\r\n        variant: \"destructive\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    try {\r\n      await apiClient.createTenantWithCompanies({\r\n        ...tenantData,\r\n        admin_user: adminUser,\r\n        companies,\r\n        contacts\r\n      });\r\n\r\n      toast({\r\n        title: \"Successo\",\r\n        description: \"Tenant creato con successo\",\r\n      });\r\n\r\n      navigate('/edgvoip/tenants');\r\n    } catch (error: any) {\r\n      toast({\r\n        title: \"Errore\",\r\n        description: error.message || \"Errore durante la creazione del tenant\",\r\n        variant: \"destructive\",\r\n      });\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const renderStepContent = () => {\r\n    switch (currentStep) {\r\n      case 1:\r\n        return (\r\n          <div className=\"space-y-4\">\r\n            <div className=\"grid grid-cols-2 gap-4\">\r\n              <div>\r\n                <Label htmlFor=\"name\">Nome Tenant *</Label>\r\n                <Input\r\n                  id=\"name\"\r\n                  value={tenantData.name}\r\n                  onChange={(e) => handleTenantDataChange('name', e.target.value)}\r\n                  placeholder=\"Es. Azienda Demo\"\r\n                />\r\n              </div>\r\n              <div>\r\n                <Label htmlFor=\"slug\">Slug *</Label>\r\n                <Input\r\n                  id=\"slug\"\r\n                  value={tenantData.slug}\r\n                  onChange={(e) => handleTenantDataChange('slug', e.target.value)}\r\n                  placeholder=\"Es. azienda-demo\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <div className=\"grid grid-cols-2 gap-4\">\r\n              <div>\r\n                <Label htmlFor=\"domain\">Dominio *</Label>\r\n                <Input\r\n                  id=\"domain\"\r\n                  value={tenantData.domain}\r\n                  onChange={(e) => handleTenantDataChange('domain', e.target.value)}\r\n                  placeholder=\"Es. azienda-demo.local\"\r\n                />\r\n              </div>\r\n              <div>\r\n                <Label htmlFor=\"sip_domain\">SIP Domain *</Label>\r\n                <Input\r\n                  id=\"sip_domain\"\r\n                  value={tenantData.sip_domain}\r\n                  onChange={(e) => handleTenantDataChange('sip_domain', e.target.value)}\r\n                  placeholder=\"Es. sip.azienda-demo.local\"\r\n                />\r\n              </div>\r\n            </div>\r\n          </div>\r\n        );\r\n\r\n      case 2:\r\n        return (\r\n          <div className=\"space-y-4\">\r\n            <div className=\"grid grid-cols-2 gap-4\">\r\n              <div>\r\n                <Label htmlFor=\"first_name\">Nome *</Label>\r\n                <Input\r\n                  id=\"first_name\"\r\n                  value={adminUser.first_name}\r\n                  onChange={(e) => handleAdminUserChange('first_name', e.target.value)}\r\n                  placeholder=\"Nome\"\r\n                />\r\n              </div>\r\n              <div>\r\n                <Label htmlFor=\"last_name\">Cognome *</Label>\r\n                <Input\r\n                  id=\"last_name\"\r\n                  value={adminUser.last_name}\r\n                  onChange={(e) => handleAdminUserChange('last_name', e.target.value)}\r\n                  placeholder=\"Cognome\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <div>\r\n              <Label htmlFor=\"email\">Email *</Label>\r\n              <Input\r\n                id=\"email\"\r\n                type=\"email\"\r\n                value={adminUser.email}\r\n                onChange={(e) => handleAdminUserChange('email', e.target.value)}\r\n                placeholder=\"admin@azienda-demo.local\"\r\n              />\r\n            </div>\r\n            <div>\r\n              <Label htmlFor=\"password\">Password *</Label>\r\n              <Input\r\n                id=\"password\"\r\n                type=\"password\"\r\n                value={adminUser.password}\r\n                onChange={(e) => handleAdminUserChange('password', e.target.value)}\r\n                placeholder=\"Password sicura\"\r\n              />\r\n            </div>\r\n            <div>\r\n              <Label htmlFor=\"role\">Ruolo</Label>\r\n              <Select value={adminUser.role} onValueChange={(value: 'tenant_admin' | 'super_admin') => handleAdminUserChange('role', value)}>\r\n                <SelectTrigger>\r\n                  <SelectValue />\r\n                </SelectTrigger>\r\n                <SelectContent>\r\n                  <SelectItem value=\"tenant_admin\">Tenant Admin</SelectItem>\r\n                  <SelectItem value=\"super_admin\">Super Admin</SelectItem>\r\n                </SelectContent>\r\n              </Select>\r\n            </div>\r\n          </div>\r\n        );\r\n\r\n      case 3:\r\n        return (\r\n          <div className=\"space-y-4\">\r\n            <div className=\"flex justify-between items-center\">\r\n              <h3 className=\"text-lg font-semibold\">Ragioni Sociali</h3>\r\n              <Button onClick={addCompany} size=\"sm\">\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Aggiungi\r\n              </Button>\r\n            </div>\r\n            {companies.map((company, index) => (\r\n              <Card key={index}>\r\n                <CardHeader className=\"pb-3\">\r\n                  <div className=\"flex justify-between items-center\">\r\n                    <CardTitle className=\"text-base\">Azienda {index + 1}</CardTitle>\r\n                    <div className=\"flex items-center space-x-2\">\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        <Switch\r\n                          checked={company.is_primary}\r\n                          onCheckedChange={(checked) => handleCompanyChange(index, 'is_primary', checked)}\r\n                        />\r\n                        <Label className=\"text-sm\">Primaria</Label>\r\n                      </div>\r\n                      {companies.length > 1 && (\r\n                        <Button\r\n                          onClick={() => removeCompany(index)}\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                        >\r\n                          <Trash2 className=\"h-4 w-4\" />\r\n                        </Button>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                </CardHeader>\r\n                <CardContent className=\"space-y-4\">\r\n                  <div>\r\n                    <Label>Ragione Sociale *</Label>\r\n                    <Input\r\n                      value={company.legal_name}\r\n                      onChange={(e) => handleCompanyChange(index, 'legal_name', e.target.value)}\r\n                      placeholder=\"Ragione sociale\"\r\n                    />\r\n                  </div>\r\n                  <div className=\"grid grid-cols-2 gap-4\">\r\n                    <div>\r\n                      <Label>Partita IVA</Label>\r\n                      <Input\r\n                        value={company.vat_number}\r\n                        onChange={(e) => handleCompanyChange(index, 'vat_number', e.target.value)}\r\n                        placeholder=\"IT12345678901\"\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <Label>Codice Fiscale</Label>\r\n                      <Input\r\n                        value={company.tax_code}\r\n                        onChange={(e) => handleCompanyChange(index, 'tax_code', e.target.value)}\r\n                        placeholder=\"RSSMRA80A01H501U\"\r\n                      />\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <Label>Indirizzo</Label>\r\n                    <Textarea\r\n                      value={company.address}\r\n                      onChange={(e) => handleCompanyChange(index, 'address', e.target.value)}\r\n                      placeholder=\"Via, numero civico\"\r\n                    />\r\n                  </div>\r\n                  <div className=\"grid grid-cols-3 gap-4\">\r\n                    <div>\r\n                      <Label>Città</Label>\r\n                      <Input\r\n                        value={company.city}\r\n                        onChange={(e) => handleCompanyChange(index, 'city', e.target.value)}\r\n                        placeholder=\"Milano\"\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <Label>Provincia</Label>\r\n                      <Input\r\n                        value={company.state}\r\n                        onChange={(e) => handleCompanyChange(index, 'state', e.target.value)}\r\n                        placeholder=\"MI\"\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <Label>CAP</Label>\r\n                      <Input\r\n                        value={company.postal_code}\r\n                        onChange={(e) => handleCompanyChange(index, 'postal_code', e.target.value)}\r\n                        placeholder=\"20100\"\r\n                      />\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <Label>Paese</Label>\r\n                    <Input\r\n                      value={company.country}\r\n                      onChange={(e) => handleCompanyChange(index, 'country', e.target.value)}\r\n                      placeholder=\"Italy\"\r\n                    />\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            ))}\r\n          </div>\r\n        );\r\n\r\n      case 4:\r\n        return (\r\n          <div className=\"space-y-4\">\r\n            <div className=\"flex justify-between items-center\">\r\n              <h3 className=\"text-lg font-semibold\">Contatti</h3>\r\n              <Button onClick={addContact} size=\"sm\">\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Aggiungi\r\n              </Button>\r\n            </div>\r\n            {contacts.map((contact, index) => (\r\n              <Card key={index}>\r\n                <CardHeader className=\"pb-3\">\r\n                  <div className=\"flex justify-between items-center\">\r\n                    <CardTitle className=\"text-base\">Contatto {index + 1}</CardTitle>\r\n                    <div className=\"flex items-center space-x-2\">\r\n                      <div className=\"flex items-center space-x-2\">\r\n                        <Switch\r\n                          checked={contact.is_primary}\r\n                          onCheckedChange={(checked) => handleContactChange(index, 'is_primary', checked)}\r\n                        />\r\n                        <Label className=\"text-sm\">Primario</Label>\r\n                      </div>\r\n                      {contacts.length > 1 && (\r\n                        <Button\r\n                          onClick={() => removeContact(index)}\r\n                          variant=\"outline\"\r\n                          size=\"sm\"\r\n                        >\r\n                          <Trash2 className=\"h-4 w-4\" />\r\n                        </Button>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                </CardHeader>\r\n                <CardContent className=\"space-y-4\">\r\n                  <div className=\"grid grid-cols-2 gap-4\">\r\n                    <div>\r\n                      <Label>Nome *</Label>\r\n                      <Input\r\n                        value={contact.first_name}\r\n                        onChange={(e) => handleContactChange(index, 'first_name', e.target.value)}\r\n                        placeholder=\"Nome\"\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <Label>Cognome *</Label>\r\n                      <Input\r\n                        value={contact.last_name}\r\n                        onChange={(e) => handleContactChange(index, 'last_name', e.target.value)}\r\n                        placeholder=\"Cognome\"\r\n                      />\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <Label>Ruolo</Label>\r\n                    <Input\r\n                      value={contact.role}\r\n                      onChange={(e) => handleContactChange(index, 'role', e.target.value)}\r\n                      placeholder=\"Es. Amministratore, Responsabile IT\"\r\n                    />\r\n                  </div>\r\n                  <div>\r\n                    <Label>Email</Label>\r\n                    <Input\r\n                      type=\"email\"\r\n                      value={contact.email}\r\n                      onChange={(e) => handleContactChange(index, 'email', e.target.value)}\r\n                      placeholder=\"contatto@azienda-demo.local\"\r\n                    />\r\n                  </div>\r\n                  <div className=\"grid grid-cols-2 gap-4\">\r\n                    <div>\r\n                      <Label>Telefono</Label>\r\n                      <Input\r\n                        value={contact.phone}\r\n                        onChange={(e) => handleContactChange(index, 'phone', e.target.value)}\r\n                        placeholder=\"02 1234567\"\r\n                      />\r\n                    </div>\r\n                    <div>\r\n                      <Label>Cellulare</Label>\r\n                      <Input\r\n                        value={contact.mobile}\r\n                        onChange={(e) => handleContactChange(index, 'mobile', e.target.value)}\r\n                        placeholder=\"+39 123 456 7890\"\r\n                      />\r\n                    </div>\r\n                  </div>\r\n                </CardContent>\r\n              </Card>\r\n            ))}\r\n          </div>\r\n        );\r\n\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold tracking-tight\">Crea Nuovo Tenant</h1>\r\n          <p className=\"text-muted-foreground\">\r\n            Configura un nuovo tenant con utenza admin, ragioni sociali e contatti\r\n          </p>\r\n        </div>\r\n        <Button variant=\"outline\" onClick={() => navigate('/edgvoip/tenants')}>\r\n          <ArrowLeft className=\"h-4 w-4 mr-2\" />\r\n          Torna ai Tenant\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Progress Steps */}\r\n      <div className=\"flex items-center space-x-4\">\r\n        {steps.map((step, index) => {\r\n          const Icon = step.icon;\r\n          const isActive = currentStep === step.id;\r\n          const isCompleted = currentStep > step.id;\r\n          \r\n          return (\r\n            <div key={step.id} className=\"flex items-center\">\r\n              <div className={`flex items-center justify-center w-10 h-10 rounded-full border-2 ${\r\n                isActive ? 'border-blue-600 bg-blue-600 text-white' :\r\n                isCompleted ? 'border-green-600 bg-green-600 text-white' :\r\n                'border-gray-300 bg-white text-gray-500'\r\n              }`}>\r\n                <Icon className=\"h-5 w-5\" />\r\n              </div>\r\n              <div className=\"ml-3\">\r\n                <p className={`text-sm font-medium ${\r\n                  isActive ? 'text-blue-600' : isCompleted ? 'text-green-600' : 'text-gray-500'\r\n                }`}>\r\n                  {step.title}\r\n                </p>\r\n              </div>\r\n              {index < steps.length - 1 && (\r\n                <div className={`w-8 h-0.5 mx-4 ${\r\n                  isCompleted ? 'bg-green-600' : 'bg-gray-300'\r\n                }`} />\r\n              )}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n\r\n      {/* Step Content */}\r\n      <Card>\r\n        <CardHeader>\r\n          <CardTitle className=\"flex items-center\">\r\n            {React.createElement(steps[currentStep - 1].icon, { className: \"h-5 w-5 mr-2\" })}\r\n            {steps[currentStep - 1].title}\r\n          </CardTitle>\r\n          <CardDescription>\r\n            {currentStep === 1 && \"Configura le informazioni base del tenant\"}\r\n            {currentStep === 2 && \"Crea l'utenza amministratore per il tenant\"}\r\n            {currentStep === 3 && \"Aggiungi le ragioni sociali associate al tenant\"}\r\n            {currentStep === 4 && \"Definisci i contatti di riferimento\"}\r\n          </CardDescription>\r\n        </CardHeader>\r\n        <CardContent>\r\n          {renderStepContent()}\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* Navigation */}\r\n      <div className=\"flex justify-between\">\r\n        <Button\r\n          variant=\"outline\"\r\n          onClick={handlePrevious}\r\n          disabled={currentStep === 1}\r\n        >\r\n          <ArrowLeft className=\"h-4 w-4 mr-2\" />\r\n          Precedente\r\n        </Button>\r\n        \r\n        <div className=\"flex space-x-2\">\r\n          {currentStep < steps.length ? (\r\n            <Button onClick={handleNext}>\r\n              Avanti\r\n              <ArrowRight className=\"h-4 w-4 ml-2\" />\r\n            </Button>\r\n          ) : (\r\n            <Button onClick={handleSubmit} disabled={isLoading}>\r\n              <Save className=\"h-4 w-4 mr-2\" />\r\n              {isLoading ? 'Creazione...' : 'Crea Tenant'}\r\n            </Button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":22543},"packages/backend/src/routes/voip.ts":{"content":"import { Router } from 'express';\r\nimport { ExtensionService } from '../services/extension.service';\r\nimport {\r\n  authenticateToken,\r\n  requireTenant,\r\n  setTenantContext,\r\n  validatePagination,\r\n  handleValidationErrors,\r\n} from '../middleware';\r\nimport {\r\n  paginatedResponse,\r\n  successResponse,\r\n  notFoundResponse,\r\n  asyncHandler\r\n} from '../utils/response';\r\n\r\nconst router = Router();\r\nconst extensionService = new ExtensionService();\r\n\r\n// Apply authentication and tenant context to all routes\r\nrouter.use(authenticateToken);\r\nrouter.use(requireTenant);\r\nrouter.use(setTenantContext);\r\n\r\n// List SIP Extensions for tenant\r\nrouter.get('/sip-extensions',\r\n  validatePagination,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const page = parseInt(req.query.page as string) || 1;\r\n    const limit = parseInt(req.query.limit as string) || 50;\r\n    const search = req.query.q as string;\r\n    const storeId = req.query.store_id as string;\r\n\r\n    const result = await extensionService.listExtensions(req.tenantId!, storeId, page, limit, search);\r\n\r\n    paginatedResponse(res, result.extensions, {\r\n      page,\r\n      limit,\r\n      total: result.total,\r\n      totalPages: result.totalPages\r\n    }, 'SIP Extensions retrieved successfully');\r\n  })\r\n);\r\n\r\n// Get SIP Extension by ID\r\nrouter.get('/sip-extensions/:id',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.getExtensionById(extensionId, req.tenantId);\r\n\r\n    if (!extension) {\r\n      return notFoundResponse(res, 'SIP Extension not found');\r\n    }\r\n\r\n    successResponse(res, extension, 'SIP Extension retrieved successfully');\r\n  })\r\n);\r\n\r\n// Get SIP Extension by number\r\nrouter.get('/sip-extensions/number/:extension',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionNumber = req.params.extension;\r\n    const extension = await extensionService.getExtensionByNumber(extensionNumber, req.tenantId!);\r\n\r\n    if (!extension) {\r\n      return notFoundResponse(res, 'SIP Extension not found');\r\n    }\r\n\r\n    successResponse(res, extension, 'SIP Extension retrieved successfully');\r\n  })\r\n);\r\n\r\nexport default router;\r\n","size_bytes":2179},"packages/frontend/src/pages/TrunkRegistration.tsx":{"content":"import { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Switch } from '@/components/ui/switch';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Save, TestTube, Settings, Shield, FileText } from 'lucide-react';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface TrunkSettings {\n  name: string;\n  provider: string;\n  username: string;\n  password: string;\n  server: string;\n  port: number;\n  protocol: 'udp' | 'tcp' | 'tls';\n  register: boolean;\n  caller_id: string;\n  recording_enabled: boolean;\n  recording_consent: boolean;\n  gdpr_compliant: boolean;\n  allowed_codecs: string[];\n  max_concurrent_calls: number;\n}\n\nexport default function TrunkRegistration() {\n  const [trunkSettings, setTrunkSettings] = useState<TrunkSettings>({\n    name: '',\n    provider: '',\n    username: '',\n    password: '',\n    server: '',\n    port: 5060,\n    protocol: 'udp',\n    register: true,\n    caller_id: '',\n    recording_enabled: false,\n    recording_consent: false,\n    gdpr_compliant: false,\n    allowed_codecs: ['PCMU', 'PCMA', 'G722'],\n    max_concurrent_calls: 20,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [isTesting, setIsTesting] = useState(false);\n  const { toast } = useToast();\n\n  const handleInputChange = (field: keyof TrunkSettings, value: any) => {\n    setTrunkSettings(prev => ({\n      ...prev,\n      [field]: value\n    }));\n  };\n\n  const handleCodecToggle = (codec: string) => {\n    setTrunkSettings(prev => ({\n      ...prev,\n      allowed_codecs: prev.allowed_codecs.includes(codec)\n        ? prev.allowed_codecs.filter(c => c !== codec)\n        : [...prev.allowed_codecs, codec]\n    }));\n  };\n\n  const testConnection = async () => {\n    setIsTesting(true);\n    try {\n      // Simulate connection test\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      toast({\n        title: \"Connection test successful\",\n        description: \"SIP trunk configuration is valid\",\n      });\n    } catch (error) {\n      toast({\n        title: \"Connection test failed\",\n        description: \"Please check your configuration\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsTesting(false);\n    }\n  };\n\n  const saveTrunk = async () => {\n    setIsLoading(true);\n    try {\n      // Simulate save operation\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      toast({\n        title: \"Trunk saved successfully\",\n        description: \"SIP trunk configuration has been saved\",\n      });\n    } catch (error) {\n      toast({\n        title: \"Save failed\",\n        description: \"Failed to save trunk configuration\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Trunk Registration</h1>\n          <p className=\"text-muted-foreground\">\n            Configure SIP trunk connections for external calling\n          </p>\n        </div>\n        <div className=\"flex space-x-2\">\n          <Button variant=\"outline\" onClick={testConnection} disabled={isTesting}>\n            <TestTube className=\"h-4 w-4 mr-2\" />\n            {isTesting ? 'Testing...' : 'Test Connection'}\n          </Button>\n          <Button onClick={saveTrunk} disabled={isLoading}>\n            <Save className=\"h-4 w-4 mr-2\" />\n            {isLoading ? 'Saving...' : 'Save Trunk'}\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"grid gap-6 lg:grid-cols-2\">\n        {/* Basic Configuration */}\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center\">\n              <Settings className=\"h-5 w-5 mr-2\" />\n              Basic Configuration\n            </CardTitle>\n            <CardDescription>\n              Essential SIP trunk settings\n            </CardDescription>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"name\">Trunk Name</Label>\n              <Input\n                id=\"name\"\n                value={trunkSettings.name}\n                onChange={(e) => handleInputChange('name', e.target.value)}\n                placeholder=\"Enter trunk name\"\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"provider\">Provider</Label>\n              <Select value={trunkSettings.provider} onValueChange={(value) => handleInputChange('provider', value)}>\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select provider\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"twilio\">Twilio</SelectItem>\n                  <SelectItem value=\"vonage\">Vonage</SelectItem>\n                  <SelectItem value=\"bandwidth\">Bandwidth</SelectItem>\n                  <SelectItem value=\"custom\">Custom Provider</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n\n            <div className=\"grid gap-4 md:grid-cols-2\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"username\">Username</Label>\n                <Input\n                  id=\"username\"\n                  value={trunkSettings.username}\n                  onChange={(e) => handleInputChange('username', e.target.value)}\n                  placeholder=\"SIP username\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"password\">Password</Label>\n                <Input\n                  id=\"password\"\n                  type=\"password\"\n                  value={trunkSettings.password}\n                  onChange={(e) => handleInputChange('password', e.target.value)}\n                  placeholder=\"SIP password\"\n                />\n              </div>\n            </div>\n\n            <div className=\"grid gap-4 md:grid-cols-2\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"server\">Server</Label>\n                <Input\n                  id=\"server\"\n                  value={trunkSettings.server}\n                  onChange={(e) => handleInputChange('server', e.target.value)}\n                  placeholder=\"sip.provider.com\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"port\">Port</Label>\n                <Input\n                  id=\"port\"\n                  type=\"number\"\n                  value={trunkSettings.port}\n                  onChange={(e) => handleInputChange('port', parseInt(e.target.value))}\n                  placeholder=\"5060\"\n                />\n              </div>\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"protocol\">Protocol</Label>\n              <Select value={trunkSettings.protocol} onValueChange={(value) => handleInputChange('protocol', value)}>\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"udp\">UDP</SelectItem>\n                  <SelectItem value=\"tcp\">TCP</SelectItem>\n                  <SelectItem value=\"tls\">TLS</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"caller_id\">Caller ID</Label>\n              <Input\n                id=\"caller_id\"\n                value={trunkSettings.caller_id}\n                onChange={(e) => handleInputChange('caller_id', e.target.value)}\n                placeholder=\"+1234567890\"\n              />\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <Switch\n                id=\"register\"\n                checked={trunkSettings.register}\n                onCheckedChange={(checked) => handleInputChange('register', checked)}\n              />\n              <Label htmlFor=\"register\">Auto-register with provider</Label>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Advanced Settings */}\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center\">\n              <Shield className=\"h-5 w-5 mr-2\" />\n              Advanced Settings\n            </CardTitle>\n            <CardDescription>\n              Security and performance configuration\n            </CardDescription>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label>Allowed Codecs</Label>\n              <div className=\"grid gap-2 md:grid-cols-2\">\n                {['PCMU', 'PCMA', 'G722', 'G729', 'OPUS', 'AMR'].map((codec) => (\n                  <div key={codec} className=\"flex items-center space-x-2\">\n                    <Checkbox\n                      id={codec}\n                      checked={trunkSettings.allowed_codecs.includes(codec)}\n                      onCheckedChange={() => handleCodecToggle(codec)}\n                    />\n                    <Label htmlFor={codec} className=\"text-sm\">{codec}</Label>\n                  </div>\n                ))}\n              </div>\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"max_calls\">Max Concurrent Calls</Label>\n              <Input\n                id=\"max_calls\"\n                type=\"number\"\n                value={trunkSettings.max_concurrent_calls}\n                onChange={(e) => handleInputChange('max_concurrent_calls', parseInt(e.target.value))}\n                placeholder=\"20\"\n              />\n            </div>\n\n            <div className=\"space-y-4\">\n              <div className=\"flex items-center space-x-2\">\n                <Switch\n                  id=\"recording_enabled\"\n                  checked={trunkSettings.recording_enabled}\n                  onCheckedChange={(checked) => handleInputChange('recording_enabled', checked)}\n                />\n                <Label htmlFor=\"recording_enabled\">Enable call recording</Label>\n              </div>\n\n              <div className=\"flex items-center space-x-2\">\n                <Switch\n                  id=\"recording_consent\"\n                  checked={trunkSettings.recording_consent}\n                  onCheckedChange={(checked) => handleInputChange('recording_consent', checked)}\n                />\n                <Label htmlFor=\"recording_consent\">Require recording consent</Label>\n              </div>\n\n              <div className=\"flex items-center space-x-2\">\n                <Switch\n                  id=\"gdpr_compliant\"\n                  checked={trunkSettings.gdpr_compliant}\n                  onCheckedChange={(checked) => handleInputChange('gdpr_compliant', checked)}\n                />\n                <Label htmlFor=\"gdpr_compliant\">GDPR compliant</Label>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* GDPR Compliance Notice */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <FileText className=\"h-5 w-5 mr-2\" />\n            GDPR Compliance\n          </CardTitle>\n          <CardDescription>\n            Data protection and privacy settings\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-4\">\n            <div className=\"p-4 bg-blue-50 rounded-lg\">\n              <h4 className=\"font-medium text-blue-900 mb-2\">Recording Consent</h4>\n              <p className=\"text-sm text-blue-800\">\n                When recording consent is enabled, all calls will require explicit consent from all parties before recording begins.\n                This ensures compliance with GDPR and local privacy regulations.\n              </p>\n            </div>\n            \n            <div className=\"p-4 bg-green-50 rounded-lg\">\n              <h4 className=\"font-medium text-green-900 mb-2\">Data Retention</h4>\n              <p className=\"text-sm text-green-800\">\n                Call recordings and metadata will be automatically deleted according to your data retention policy.\n                Users can request data deletion at any time through the GDPR portal.\n              </p>\n            </div>\n\n            <div className=\"flex items-center space-x-2\">\n              <Checkbox\n                id=\"gdpr_acknowledge\"\n                checked={trunkSettings.gdpr_compliant}\n                onCheckedChange={(checked) => handleInputChange('gdpr_compliant', checked)}\n              />\n              <Label htmlFor=\"gdpr_acknowledge\" className=\"text-sm\">\n                I acknowledge and agree to comply with GDPR requirements for call recording and data processing.\n              </Label>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}","size_bytes":13123},"scripts/setup-w3-voip.sh":{"content":"#!/bin/bash\n\n# W3 VoIP System Setup Script\n# Complete installation and configuration for local development\n\nset -e\n\necho \"🚀 Setting up W3 VoIP System...\"\n\n# Check if running as root\nif [[ $EUID -eq 0 ]]; then\n   echo \"❌ This script should not be run as root for security reasons\"\n   exit 1\nfi\n\n# Create project directory\nPROJECT_DIR=\"$HOME/w3-voip\"\nmkdir -p \"$PROJECT_DIR\"\ncd \"$PROJECT_DIR\"\n\necho \"📁 Project directory: $PROJECT_DIR\"\n\n# Clone or setup the monorepo\nif [ ! -d \"packages\" ]; then\n    echo \"📦 Setting up monorepo structure...\"\n    mkdir -p packages/{backend,frontend,shared,database}\n    \n    # Initialize root package.json\n    cat > package.json <<EOF\n{\n  \"name\": \"w3-voip\",\n  \"version\": \"1.0.0\",\n  \"description\": \"W3 VoIP System - Enterprise Multi-tenant VoIP Platform\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"scripts\": {\n    \"dev\": \"concurrently \\\"npm run dev:backend\\\" \\\"npm run dev:frontend\\\"\",\n    \"dev:backend\": \"cd packages/backend && npm run dev\",\n    \"dev:frontend\": \"cd packages/frontend && npm run dev\",\n    \"build\": \"npm run build:shared && npm run build:backend && npm run build:frontend\",\n    \"build:shared\": \"cd packages/shared && npm run build\",\n    \"build:backend\": \"cd packages/backend && npm run build\",\n    \"build:frontend\": \"cd packages/frontend && npm run build\",\n    \"test\": \"npm run test:shared && npm run test:backend && npm run test:frontend\",\n    \"test:shared\": \"cd packages/shared && npm test\",\n    \"test:backend\": \"cd packages/backend && npm test\",\n    \"test:frontend\": \"cd packages/frontend && npm test\",\n    \"db:migrate\": \"cd packages/database && npm run migrate\",\n    \"db:seed\": \"cd packages/database && npm run seed\",\n    \"db:reset\": \"cd packages/database && npm run reset\",\n    \"install:all\": \"npm install && npm run install:packages\",\n    \"install:packages\": \"cd packages/shared && npm install && cd ../database && npm install && cd ../backend && npm install && cd ../frontend && npm install\"\n  },\n  \"devDependencies\": {\n    \"concurrently\": \"^8.2.2\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\nEOF\nfi\n\n# Install Node.js dependencies\necho \"📦 Installing Node.js dependencies...\"\nnpm install\n\n# Setup environment files\necho \"🔧 Setting up environment configuration...\"\n\n# Backend environment\ncat > packages/backend/.env <<EOF\n# Database Configuration\nDATABASE_URL=postgresql://w3voip:w3voip123@localhost:5432/w3voip\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=w3voip\nDB_USER=w3voip\nDB_PASSWORD=w3voip123\n\n# JWT Configuration\nJWT_SECRET=w3voip-super-secret-jwt-key-$(openssl rand -hex 16)\nJWT_EXPIRES_IN=24h\n\n# FreeSWITCH Configuration\nFREESWITCH_HOST=localhost\nFREESWITCH_PORT=8021\nFREESWITCH_PASSWORD=ClueCon\n\n# Webhook Configuration\nWEBHOOK_SECRET=w3voip-webhook-secret-$(openssl rand -hex 16)\nW3_SUITE_WEBHOOK_URL=http://localhost:3001/api/voip/webhook\nW3_SUITE_WEBHOOK_SECRET=w3suite-webhook-secret-$(openssl rand -hex 16)\n\n# API Configuration\nAPI_BASE_URL=http://localhost:3000\nCORS_ORIGIN=http://localhost:5173\nPORT=3000\nNODE_ENV=development\n\n# Security\nRATE_LIMIT_WINDOW_MS=900000\nRATE_LIMIT_MAX_REQUESTS=100\nRATE_LIMIT_AUTH_MAX_REQUESTS=5\n\n# Logging\nLOG_LEVEL=debug\nLOG_FILE=logs/w3-voip.log\nEOF\n\n# Database environment\ncat > packages/database/.env <<EOF\n# Database Configuration\nDATABASE_URL=postgresql://w3voip:w3voip123@localhost:5432/w3voip\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=w3voip\nDB_USER=w3voip\nDB_PASSWORD=w3voip123\n\n# Migration Configuration\nMIGRATIONS_PATH=src/migrations\nSEEDS_PATH=src/seeds\nEOF\n\n# Frontend environment\ncat > packages/frontend/.env <<EOF\n# API Configuration\nVITE_API_BASE_URL=http://localhost:3000/api\nVITE_WS_URL=ws://localhost:3000/ws\n\n# Application Configuration\nVITE_APP_NAME=W3 VoIP System\nVITE_APP_VERSION=1.0.0\nVITE_APP_DESCRIPTION=Enterprise Multi-tenant VoIP Platform\n\n# Development Configuration\nVITE_DEV_MODE=true\nVITE_DEBUG=true\nEOF\n\n# Create PostgreSQL database and user\necho \"🗄️ Setting up PostgreSQL database...\"\nsudo -u postgres psql -c \"CREATE DATABASE w3voip;\" 2>/dev/null || echo \"Database w3voip already exists\"\nsudo -u postgres psql -c \"CREATE USER w3voip WITH PASSWORD 'w3voip123';\" 2>/dev/null || echo \"User w3voip already exists\"\nsudo -u postgres psql -c \"GRANT ALL PRIVILEGES ON DATABASE w3voip TO w3voip;\" 2>/dev/null || echo \"Privileges already granted\"\nsudo -u postgres psql -c \"ALTER USER w3voip CREATEDB;\" 2>/dev/null || echo \"User already has CREATEDB privilege\"\n\n# Run database migrations\necho \"🔄 Running database migrations...\"\ncd packages/database\nnpm run migrate\ncd ../..\n\n# Create systemd service for W3 VoIP\necho \"⚙️ Creating systemd service...\"\nsudo tee /etc/systemd/system/w3-voip.service > /dev/null <<EOF\n[Unit]\nDescription=W3 VoIP System\nAfter=network.target postgresql.service freeswitch.service\n\n[Service]\nType=simple\nUser=$USER\nGroup=$USER\nWorkingDirectory=$PROJECT_DIR\nEnvironment=NODE_ENV=production\nExecStart=/usr/bin/npm run dev\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# Create log directory\nmkdir -p logs\n\n# Create startup script\ncat > start-w3-voip.sh <<EOF\n#!/bin/bash\necho \"🚀 Starting W3 VoIP System...\"\n\n# Check if PostgreSQL is running\nif ! systemctl is-active --quiet postgresql; then\n    echo \"❌ PostgreSQL is not running. Starting PostgreSQL...\"\n    sudo systemctl start postgresql\nfi\n\n# Check if FreeSWITCH is running\nif ! systemctl is-active --quiet freeswitch; then\n    echo \"❌ FreeSWITCH is not running. Starting FreeSWITCH...\"\n    sudo systemctl start freeswitch\nfi\n\n# Start W3 VoIP System\necho \"✅ Starting W3 VoIP System...\"\nnpm run dev\nEOF\n\nchmod +x start-w3-voip.sh\n\n# Create stop script\ncat > stop-w3-voip.sh <<EOF\n#!/bin/bash\necho \"🛑 Stopping W3 VoIP System...\"\npkill -f \"npm run dev\" || true\npkill -f \"node.*backend\" || true\npkill -f \"vite.*frontend\" || true\necho \"✅ W3 VoIP System stopped\"\nEOF\n\nchmod +x stop-w3-voip.sh\n\n# Create status script\ncat > status-w3-voip.sh <<EOF\n#!/bin/bash\necho \"📊 W3 VoIP System Status:\"\necho \"\"\necho \"🔧 Services:\"\nsystemctl is-active postgresql && echo \"  ✅ PostgreSQL: Running\" || echo \"  ❌ PostgreSQL: Stopped\"\nsystemctl is-active freeswitch && echo \"  ✅ FreeSWITCH: Running\" || echo \"  ❌ FreeSWITCH: Stopped\"\nsystemctl is-active nginx && echo \"  ✅ Nginx: Running\" || echo \"  ❌ Nginx: Stopped\"\necho \"\"\necho \"🌐 Web Services:\"\ncurl -s http://localhost:3000/api/health > /dev/null && echo \"  ✅ Backend API: Running\" || echo \"  ❌ Backend API: Stopped\"\ncurl -s http://localhost:5173 > /dev/null && echo \"  ✅ Frontend: Running\" || echo \"  ❌ Frontend: Stopped\"\ncurl -s http://localhost > /dev/null && echo \"  ✅ FusionPBX: Running\" || echo \"  ❌ FusionPBX: Stopped\"\necho \"\"\necho \"📞 VoIP Services:\"\nnetstat -tlnp | grep :5060 > /dev/null && echo \"  ✅ SIP Internal: Running\" || echo \"  ❌ SIP Internal: Stopped\"\nnetstat -tlnp | grep :5080 > /dev/null && echo \"  ✅ SIP External: Running\" || echo \"  ❌ SIP External: Stopped\"\nnetstat -tlnp | grep :8021 > /dev/null && echo \"  ✅ Event Socket: Running\" || echo \"  ❌ Event Socket: Stopped\"\nEOF\n\nchmod +x status-w3-voip.sh\n\n# Create README\ncat > README.md <<EOF\n# W3 VoIP System\n\nEnterprise Multi-tenant VoIP Platform for W3 Suite integration.\n\n## Quick Start\n\n1. **Start the system:**\n   \\`\\`\\`bash\n   ./start-w3-voip.sh\n   \\`\\`\\`\n\n2. **Check status:**\n   \\`\\`\\`bash\n   ./status-w3-voip.sh\n   \\`\\`\\`\n\n3. **Stop the system:**\n   \\`\\`\\`bash\n   ./stop-w3-voip.sh\n   \\`\\`\\`\n\n## Web Interfaces\n\n- **W3 VoIP Frontend:** http://localhost:5173\n- **Backend API:** http://localhost:3000/api\n- **FusionPBX Admin:** http://localhost (admin/admin123)\n\n## API Endpoints\n\n- **Health Check:** GET /api/health\n- **Tenants:** /api/tenants\n- **Stores:** /api/stores\n- **Extensions:** /api/extensions\n- **Calls:** /api/calls\n- **CDR:** /api/cdr\n- **Webhooks:** /api/webhooks\n\n## Database\n\n- **Host:** localhost:5432\n- **Database:** w3voip\n- **Username:** w3voip\n- **Password:** w3voip123\n\n## FreeSWITCH\n\n- **Event Socket:** localhost:8021 (ClueCon)\n- **SIP Internal:** localhost:5060\n- **SIP External:** localhost:5080\n\n## Development\n\n\\`\\`\\`bash\n# Install dependencies\nnpm run install:all\n\n# Run migrations\nnpm run db:migrate\n\n# Start development\nnpm run dev\n\n# Build for production\nnpm run build\n\\`\\`\\`\n\n## Configuration\n\nEnvironment files are located in each package:\n- \\`packages/backend/.env\\`\n- \\`packages/database/.env\\`\n- \\`packages/frontend/.env\\`\n\n## Logs\n\n- **Application logs:** \\`logs/w3-voip.log\\`\n- **FreeSWITCH logs:** \\`/var/log/freeswitch/\\`\n- **System logs:** \\`journalctl -u w3-voip\\`\nEOF\n\necho \"\"\necho \"✅ W3 VoIP System setup completed!\"\necho \"\"\necho \"📁 Project location: $PROJECT_DIR\"\necho \"\"\necho \"🚀 To start the system:\"\necho \"   cd $PROJECT_DIR\"\necho \"   ./start-w3-voip.sh\"\necho \"\"\necho \"📊 To check status:\"\necho \"   ./status-w3-voip.sh\"\necho \"\"\necho \"🌐 Web interfaces will be available at:\"\necho \"   - Frontend: http://localhost:5173\"\necho \"   - Backend API: http://localhost:3000/api\"\necho \"   - FusionPBX: http://localhost\"\necho \"\"\necho \"🔧 Configuration files:\"\necho \"   - Backend: packages/backend/.env\"\necho \"   - Database: packages/database/.env\"\necho \"   - Frontend: packages/frontend/.env\"\necho \"\"\necho \"📚 Documentation: README.md\"\necho \"\"\necho \"🎉 W3 VoIP System is ready for development!\"\n\n","size_bytes":9323},"packages/backend/src/routes/calls.ts":{"content":"// @ts-nocheck\r\nimport { Router } from 'express';\r\nimport { z } from 'zod';\r\nimport { FreeSWITCHService } from '../services/freeswitch.service';\r\nimport { MockFreeSWITCHService } from '../services/mock-freeswitch.service';\r\nimport { CDRService } from '../services/cdr.service';\r\nimport { authenticateToken } from '../middleware/auth';\r\nimport { setTenantContext } from '../middleware/tenant';\r\nimport { validateRequest } from '../middleware/validation';\r\nimport { successResponse, errorResponse } from '../utils/response';\r\n// Removed unused import: logAPICall\r\n\r\nconst router = Router();\r\n\r\n// Initialize services\r\n// Use Mock FreeSWITCH if FREESWITCH_MOCK=true or FreeSWITCH not available\r\nconst USE_MOCK = process.env.FREESWITCH_MOCK === 'true' || process.env.FREESWITCH_MOCK === '1';\r\nconst fsService: FreeSWITCHService | MockFreeSWITCHService = USE_MOCK \r\n  ? new MockFreeSWITCHService() \r\n  : new FreeSWITCHService();\r\nconst cdrService = new CDRService();\r\n\r\n// Connect to FreeSWITCH on startup\r\nfsService.connect().catch((error) => {\r\n  console.error('Failed to connect to FreeSWITCH:', error);\r\n  console.log('💡 Tip: Set FREESWITCH_MOCK=true to use mock service for testing');\r\n});\r\n\r\n// Validation schemas\r\nconst originateCallSchema = z.object({\r\n  caller_extension: z.string().min(1, 'Caller extension is required'),\r\n  callee_number: z.string().min(1, 'Callee number is required'),\r\n  domain: z.string().min(1, 'Domain is required'),\r\n  options: z.object({\r\n    timeout: z.number().min(1).max(300).optional(),\r\n    caller_id: z.string().optional(),\r\n    context: z.string().optional(),\r\n    recording: z.boolean().optional()\r\n  }).optional()\r\n});\r\n\r\nconst transferCallSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID'),\r\n  destination: z.string().min(1, 'Destination is required'),\r\n  type: z.enum(['attended', 'blind']).optional()\r\n});\r\n\r\nconst hangupCallSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID'),\r\n  cause: z.string().optional()\r\n});\r\n\r\nconst holdCallSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID'),\r\n  hold: z.boolean().optional()\r\n});\r\n\r\nconst muteCallSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID'),\r\n  mute: z.boolean().optional()\r\n});\r\n\r\nconst recordCallSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID'),\r\n  record: z.boolean().optional(),\r\n  path: z.string().optional()\r\n});\r\n\r\nconst getCallInfoSchema = z.object({\r\n  call_uuid: z.string().uuid('Invalid call UUID')\r\n});\r\n\r\n// Originate a call\r\nrouter.post('/originate', \r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(originateCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { caller_extension, callee_number, domain, options } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('originate_call', { \r\n        tenant_id: tenantId, \r\n        caller_extension, \r\n        callee_number, \r\n        domain \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Originate the call\r\n      const callUuid = await fsService.originateCall(\r\n        caller_extension,\r\n        callee_number,\r\n        domain,\r\n        options\r\n      );\r\n\r\n      // Create initial CDR record\r\n      const cdrData = {\r\n        tenant_id: tenantId,\r\n        call_uuid: callUuid,\r\n        call_direction: 'outbound' as const,\r\n        call_type: 'voice' as const,\r\n        caller_extension: caller_extension,\r\n        callee_id_number: callee_number,\r\n        start_time: new Date(),\r\n        duration: 0,\r\n        bill_seconds: 0,\r\n        hangup_cause: 'UNKNOWN',\r\n        hangup_disposition: 'UNKNOWN' as const,\r\n        recording_enabled: options?.recording || false,\r\n        fs_uuid: callUuid,\r\n        fs_domain: domain,\r\n        fs_context: options?.context || 'default',\r\n        fs_profile: 'internal'\r\n      };\r\n\r\n      const cdr = await cdrService.createCDR(cdrData);\r\n\r\n      successResponse(res, {\r\n        call_uuid: callUuid,\r\n        cdr_id: cdr.id,\r\n        status: 'originated'\r\n      }, 201);\r\n\r\n    } catch (error) {\r\n      console.error('Error originating call:', error);\r\n      errorResponse(res, 'Failed to originate call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Transfer a call\r\nrouter.post('/transfer',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(transferCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid, destination, type } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('transfer_call', { \r\n        tenant_id: tenantId, \r\n        call_uuid, \r\n        destination, \r\n        type \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Verify CDR exists for this tenant\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Transfer the call\r\n      await fsService.transferCall(call_uuid, destination, type);\r\n\r\n      successResponse(res, {\r\n        call_uuid,\r\n        destination,\r\n        type: type || 'blind',\r\n        status: 'transferred'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error transferring call:', error);\r\n      errorResponse(res, 'Failed to transfer call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Hangup a call\r\nrouter.post('/hangup',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(hangupCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid, cause } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('hangup_call', { \r\n        tenant_id: tenantId, \r\n        call_uuid, \r\n        cause \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Verify CDR exists for this tenant\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Hangup the call\r\n      await fsService.hangupCall(call_uuid, cause);\r\n\r\n      successResponse(res, {\r\n        call_uuid,\r\n        cause: cause || 'NORMAL_CLEARING',\r\n        status: 'hungup'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error hanging up call:', error);\r\n      errorResponse(res, 'Failed to hangup call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Hold/Unhold a call\r\nrouter.post('/hold',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(holdCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid, hold } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('hold_call', { \r\n        tenant_id: tenantId, \r\n        call_uuid, \r\n        hold \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Verify CDR exists for this tenant\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Hold/Unhold the call\r\n      await fsService.holdCall(call_uuid, hold);\r\n\r\n      successResponse(res, {\r\n        call_uuid,\r\n        hold: hold !== false,\r\n        status: hold !== false ? 'held' : 'unheld'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error holding/unholding call:', error);\r\n      errorResponse(res, 'Failed to hold/unhold call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Mute/Unmute a call\r\nrouter.post('/mute',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(muteCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid, mute } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('mute_call', { \r\n        tenant_id: tenantId, \r\n        call_uuid, \r\n        mute \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Verify CDR exists for this tenant\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Mute/Unmute the call\r\n      await fsService.muteCall(call_uuid, mute);\r\n\r\n      successResponse(res, {\r\n        call_uuid,\r\n        mute: mute !== false,\r\n        status: mute !== false ? 'muted' : 'unmuted'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error muting/unmuting call:', error);\r\n      errorResponse(res, 'Failed to mute/unmute call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Start/Stop recording\r\nrouter.post('/record',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(recordCallSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid, record, path } = req.body;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('record_call', { \r\n        tenant_id: tenantId, \r\n        call_uuid, \r\n        record, \r\n        path \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Verify CDR exists for this tenant\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Start/Stop recording\r\n      await fsService.recordCall(call_uuid, record, path);\r\n\r\n      // Update CDR with recording info\r\n      if (record && path) {\r\n        await cdrService.updateCDR(cdr.id, {\r\n          recording_path: path,\r\n          recording_enabled: true\r\n        }, tenantId);\r\n      } else if (!record) {\r\n        await cdrService.updateCDR(cdr.id, {\r\n          recording_enabled: false\r\n        }, tenantId);\r\n      }\r\n\r\n      successResponse(res, {\r\n        call_uuid,\r\n        record: record !== false,\r\n        recording_path: path,\r\n        status: record !== false ? 'recording' : 'stopped'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error recording call:', error);\r\n      errorResponse(res, 'Failed to record call', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Get call information\r\nrouter.get('/info/:call_uuid',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  validateRequest(getCallInfoSchema, 'params'),\r\n  async (req, res) => {\r\n    try {\r\n      const { call_uuid } = req.params;\r\n      const tenantId = req.tenantId!;\r\n\r\n      logAPICall('get_call_info', { \r\n        tenant_id: tenantId, \r\n        call_uuid \r\n      });\r\n\r\n      // Check if FreeSWITCH is connected\r\n      if (!fsService.isConnected()) {\r\n        return errorResponse(res, 'FreeSWITCH not connected', 503);\r\n      }\r\n\r\n      // Get CDR from database\r\n      const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\r\n      if (!cdr) {\r\n        return errorResponse(res, 'Call not found', 404);\r\n      }\r\n\r\n      // Get live call info from FreeSWITCH\r\n      const callInfo = await fsService.getCallInfo(call_uuid);\r\n\r\n      successResponse(res, {\r\n        cdr,\r\n        live_info: callInfo,\r\n        status: 'active'\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error getting call info:', error);\r\n      errorResponse(res, 'Failed to get call info', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Get FreeSWITCH connection status\r\nrouter.get('/status',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  async (req, res) => {\r\n    try {\r\n      const status = fsService.getStatus();\r\n\r\n      successResponse(res, {\r\n        freeswitch: status,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error getting status:', error);\r\n      errorResponse(res, 'Failed to get status', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// WebSocket endpoint for real-time call events\r\nrouter.get('/events',\r\n  authenticateToken,\r\n  setTenantContext,\r\n  async (req, res) => {\r\n    try {\r\n      const tenantId = req.tenantId!;\r\n\r\n      // Set up WebSocket connection\r\n      res.writeHead(200, {\r\n        'Content-Type': 'text/event-stream',\r\n        'Cache-Control': 'no-cache',\r\n        'Connection': 'keep-alive',\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Headers': 'Cache-Control'\r\n      });\r\n\r\n      // Send initial connection event\r\n      res.write(`data: ${JSON.stringify({\r\n        type: 'connected',\r\n        tenant_id: tenantId,\r\n        timestamp: new Date().toISOString()\r\n      })}\\n\\n`);\r\n\r\n      // Set up event listeners\r\n      const onCallStarted = (callInfo: any) => {\r\n        if (callInfo.domain === tenantId) {\r\n          res.write(`data: ${JSON.stringify({\r\n            type: 'call_started',\r\n            data: callInfo,\r\n            timestamp: new Date().toISOString()\r\n          })}\\n\\n`);\r\n        }\r\n      };\r\n\r\n      const onCallAnswered = (callInfo: any) => {\r\n        res.write(`data: ${JSON.stringify({\r\n          type: 'call_answered',\r\n          data: callInfo,\r\n          timestamp: new Date().toISOString()\r\n        })}\\n\\n`);\r\n      };\r\n\r\n      const onCallEnded = (callInfo: any) => {\r\n        res.write(`data: ${JSON.stringify({\r\n          type: 'call_ended',\r\n          data: callInfo,\r\n          timestamp: new Date().toISOString()\r\n        })}\\n\\n`);\r\n      };\r\n\r\n      // Add event listeners\r\n      fsService.on('call_started', onCallStarted);\r\n      fsService.on('call_answered', onCallAnswered);\r\n      fsService.on('call_ended', onCallEnded);\r\n\r\n      // Handle client disconnect\r\n      req.on('close', () => {\r\n        fsService.off('call_started', onCallStarted);\r\n        fsService.off('call_answered', onCallAnswered);\r\n        fsService.off('call_ended', onCallEnded);\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error setting up call events:', error);\r\n      errorResponse(res, 'Failed to setup call events', 500);\r\n    }\r\n  }\r\n);\r\n\r\nexport default router;\r\n\r\n","size_bytes":14065},"packages/backend/test-db-simple.js":{"content":"const { getClient } = require('@w3-voip/database');\r\n\r\nasync function testDB() {\r\n  try {\r\n    console.log('Testing database connection...');\r\n    const client = await getClient();\r\n    console.log('Database connected successfully');\r\n    \r\n    const result = await client.query('SELECT COUNT(*) FROM users');\r\n    console.log('Users count:', result.rows[0].count);\r\n    \r\n    const tenantResult = await client.query('SELECT * FROM tenants WHERE slug = $1', ['demo']);\r\n    console.log('Demo tenant:', tenantResult.rows[0]);\r\n    \r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('Database error:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\ntestDB();\r\n","size_bytes":664},"packages/database/src/index.ts":{"content":"import { Pool, PoolClient } from 'pg';\n\n// Validate DATABASE_URL is set\nif (!process.env.DATABASE_URL) {\n  console.error('❌ DATABASE_URL environment variable is required');\n  console.error('💡 Please set DATABASE_URL in your .env file');\n  console.error('Example: DATABASE_URL=postgresql://user:password@host:5432/database');\n  process.exit(1);\n}\n\n// Database connection pool with optimized settings for Replit environment\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  max: 20,\n  min: 2,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000,\n  keepAlive: true,\n  keepAliveInitialDelayMillis: 10000,\n  allowExitOnIdle: false,\n});\n\n// Pool event handlers for resilience\npool.on('error', (err: Error, client: PoolClient) => {\n  console.error('⚠️ Unexpected database pool error:', err.message);\n  console.error('⚠️ Error code:', (err as any).code);\n  \n  // Don't crash on connection termination - pool will recover\n  if ((err as any).code === '57P01' || err.message.includes('terminating connection')) {\n    console.warn('⚠️ Connection terminated by database server - pool will create new connections');\n    return;\n  }\n  \n  // Log other errors but don't crash\n  console.error('⚠️ Pool error details:', err);\n});\n\npool.on('connect', (client: PoolClient) => {\n  console.log('✅ New database connection established in pool');\n});\n\npool.on('acquire', (client: PoolClient) => {\n  // Client acquired from pool - uncomment for debugging\n  // console.log('📊 Database client acquired from pool');\n});\n\npool.on('remove', (client: PoolClient) => {\n  console.log('🔄 Database client removed from pool');\n});\n\n// Graceful pool cleanup\nlet isPoolClosing = false;\n\nasync function gracefulPoolShutdown() {\n  if (isPoolClosing) return;\n  isPoolClosing = true;\n  \n  console.log('🛑 Closing database connection pool...');\n  try {\n    await pool.end();\n    console.log('✅ Database pool closed gracefully');\n  } catch (error) {\n    console.error('❌ Error closing database pool:', error);\n  }\n}\n\nprocess.on('SIGTERM', gracefulPoolShutdown);\nprocess.on('SIGINT', gracefulPoolShutdown);\n\n// Database client with tenant context\nexport class DatabaseClient {\n  private client: any;\n  private tenantId: string | null = null;\n  private userRole: string | null = null;\n  private released: boolean = false;\n\n  constructor(client: any) {\n    this.client = client;\n  }\n\n  // Set tenant context for RLS\n  async setTenantContext(tenantId: string, userRole: string = 'user') {\n    this.tenantId = tenantId;\n    this.userRole = userRole;\n    try {\n      await this.client.query('SELECT set_tenant_context($1, $2)', [tenantId, userRole]);\n    } catch (error: any) {\n      // If tenant context function doesn't exist, just skip it\n      if (error.code === '42883') {\n        console.warn('⚠️ set_tenant_context function not found - skipping RLS setup');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  // Clear tenant context\n  async clearTenantContext() {\n    this.tenantId = null;\n    this.userRole = null;\n    try {\n      await this.client.query('SELECT clear_tenant_context()');\n    } catch (error: any) {\n      // If function doesn't exist, just skip it\n      if (error.code === '42883') {\n        // Function doesn't exist - that's ok\n      } else {\n        console.warn('⚠️ Error clearing tenant context:', error.message);\n      }\n    }\n  }\n\n  // Get current tenant ID\n  getCurrentTenantId(): string | null {\n    return this.tenantId;\n  }\n\n  // Get current user role\n  getCurrentUserRole(): string | null {\n    return this.userRole;\n  }\n\n  // Query with tenant context\n  async query(text: string, params?: any[]) {\n    if (this.released) {\n      throw new Error('Cannot query on released client');\n    }\n    return this.client.query(text, params);\n  }\n\n  // Release client\n  async release() {\n    if (this.released) return;\n    \n    try {\n      await this.clearTenantContext();\n    } catch (error) {\n      console.warn('⚠️ Error clearing context before release:', error);\n    }\n    \n    this.client.release();\n    this.released = true;\n  }\n}\n\n// Retry helper with exponential backoff\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  initialDelay: number = 1000\n): Promise<T> {\n  let lastError: any;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n      \n      // Don't retry on certain errors\n      if (error.code === '42P01' || error.code === '42883') {\n        throw error;\n      }\n      \n      if (attempt < maxRetries - 1) {\n        const delay = initialDelay * Math.pow(2, attempt);\n        console.warn(`⚠️ Database operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  throw lastError;\n}\n\n// Get database client with tenant context and retry logic\nexport async function getClient(tenantId?: string, userRole?: string): Promise<DatabaseClient> {\n  const client = await retryWithBackoff(async () => {\n    return await pool.connect();\n  }, 3, 500);\n  \n  const dbClient = new DatabaseClient(client);\n  \n  if (tenantId) {\n    await dbClient.setTenantContext(tenantId, userRole || 'user');\n  }\n  \n  return dbClient;\n}\n\n// Execute query with tenant context\nexport async function queryWithTenant(\n  text: string, \n  params: any[] = [], \n  tenantId?: string, \n  userRole?: string\n) {\n  const client = await getClient(tenantId, userRole);\n  \n  try {\n    const result = await client.query(text, params);\n    return result;\n  } finally {\n    await client.release();\n  }\n}\n\n// Transaction helper\nexport async function withTransaction<T>(\n  callback: (client: DatabaseClient) => Promise<T>,\n  tenantId?: string,\n  userRole?: string\n): Promise<T> {\n  const client = await getClient(tenantId, userRole);\n  \n  try {\n    await client.query('BEGIN');\n    const result = await callback(client);\n    await client.query('COMMIT');\n    return result;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    await client.release();\n  }\n}\n\n// Health check with retry\nexport async function healthCheck(): Promise<boolean> {\n  try {\n    const result = await retryWithBackoff(async () => {\n      return await pool.query('SELECT 1 as health');\n    }, 2, 500);\n    \n    return result.rows.length > 0 && result.rows[0].health === 1;\n  } catch (error) {\n    console.error('❌ Database health check failed:', error);\n    return false;\n  }\n}\n\n// Periodic health check (runs every 30 seconds)\nlet healthCheckInterval: NodeJS.Timeout | null = null;\n\nexport function startPeriodicHealthCheck(intervalMs: number = 30000) {\n  if (healthCheckInterval) {\n    clearInterval(healthCheckInterval);\n  }\n  \n  healthCheckInterval = setInterval(async () => {\n    const isHealthy = await healthCheck();\n    if (!isHealthy) {\n      console.warn('⚠️ Periodic health check failed - database may be unavailable');\n    }\n  }, intervalMs);\n  \n  console.log(`🏥 Started periodic database health check (every ${intervalMs / 1000}s)`);\n}\n\nexport function stopPeriodicHealthCheck() {\n  if (healthCheckInterval) {\n    clearInterval(healthCheckInterval);\n    healthCheckInterval = null;\n    console.log('🛑 Stopped periodic database health check');\n  }\n}\n\n// Close all connections\nexport async function closePool(): Promise<void> {\n  stopPeriodicHealthCheck();\n  await gracefulPoolShutdown();\n}\n\n// Pool statistics\nexport function getPoolStats() {\n  return {\n    totalCount: pool.totalCount,\n    idleCount: pool.idleCount,\n    waitingCount: pool.waitingCount,\n  };\n}\n\nexport { pool };\n","size_bytes":7779},"packages/frontend/src/utils/error-handler.ts":{"content":"// Error handler utility to suppress browser extension errors\nexport const suppressExtensionErrors = () => {\n  // Suppress Chrome extension errors\n  const originalError = console.error;\n  const originalWarn = console.warn;\n  const originalLog = console.log;\n  \n  console.error = (...args: any[]) => {\n    const message = args[0]?.toString() || '';\n    \n    // Filter out common extension errors\n    if (\n      message.includes('runtime.lastError') ||\n      message.includes('message port closed') ||\n      message.includes('FrameDoesNotExistError') ||\n      message.includes('chrome-extension://') ||\n      message.includes('background.js') ||\n      message.includes('Could not establish connection') ||\n      message.includes('disconnected port object') ||\n      message.includes('back/forward cache') ||\n      message.includes('completion_list.html') ||\n      message.includes('utils.js') ||\n      message.includes('extensionState.js') ||\n      message.includes('heuristicsRedefinitions.js') ||\n      message.includes('net::ERR_FILE_NOT_FOUND') ||\n      message.includes('pejdijmoenmkgeppbflobdenhhabjlaj') ||\n      message.includes('chrome-extension://pejdijmoenmkgeppbflobdenhhabjlaj')\n    ) {\n      return; // Suppress these errors\n    }\n    \n    // Log other errors normally\n    originalError.apply(console, args);\n  };\n\n  console.warn = (...args: any[]) => {\n    const message = args[0]?.toString() || '';\n    \n    if (\n      message.includes('chrome-extension://') ||\n      message.includes('completion_list.html') ||\n      message.includes('utils.js') ||\n      message.includes('extensionState.js') ||\n      message.includes('heuristicsRedefinitions.js') ||\n      message.includes('pejdijmoenmkgeppbflobdenhhabjlaj')\n    ) {\n      return; // Suppress these warnings\n    }\n    \n    originalWarn.apply(console, args);\n  };\n\n  console.log = (...args: any[]) => {\n    const message = args[0]?.toString() || '';\n    \n    if (\n      message.includes('chrome-extension://') ||\n      message.includes('completion_list.html') ||\n      message.includes('pejdijmoenmkgeppbflobdenhhabjlaj')\n    ) {\n      return; // Suppress these logs\n    }\n    \n    originalLog.apply(console, args);\n  };\n\n  // Suppress unhandled promise rejections from extensions\n  window.addEventListener('unhandledrejection', (event) => {\n    const message = event.reason?.toString() || '';\n    \n    if (\n      message.includes('runtime.lastError') ||\n      message.includes('message port closed') ||\n      message.includes('FrameDoesNotExistError') ||\n      message.includes('chrome-extension://') ||\n      message.includes('background.js') ||\n      message.includes('Could not establish connection') ||\n      message.includes('disconnected port object') ||\n      message.includes('completion_list.html') ||\n      message.includes('utils.js') ||\n      message.includes('extensionState.js') ||\n      message.includes('heuristicsRedefinitions.js') ||\n      message.includes('net::ERR_FILE_NOT_FOUND')\n    ) {\n      event.preventDefault(); // Suppress these errors\n    }\n  });\n\n  // Block network requests to extensions completely\n  const originalFetch = window.fetch;\n  window.fetch = async (...args) => {\n    const url = args[0]?.toString() || '';\n    \n    // Block all requests to chrome extensions\n    if (\n      url.includes('chrome-extension://') ||\n      url.includes('pejdijmoenmkgeppbflobdenhhabjlaj') ||\n      url.includes('completion_list.html') ||\n      url.includes('utils.js') ||\n      url.includes('extensionState.js') ||\n      url.includes('heuristicsRedefinitions.js')\n    ) {\n      // Return a mock response to prevent errors\n      return new Response('', { \n        status: 404, \n        statusText: 'Not Found',\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    try {\n      return await originalFetch(...args);\n    } catch (error: any) {\n      const message = error?.message || '';\n      if (\n        message.includes('chrome-extension://') ||\n        message.includes('net::ERR_FILE_NOT_FOUND') ||\n        message.includes('completion_list.html') ||\n        message.includes('utils.js') ||\n        message.includes('extensionState.js') ||\n        message.includes('heuristicsRedefinitions.js') ||\n        message.includes('pejdijmoenmkgeppbflobdenhhabjlaj')\n      ) {\n        // Suppress these network errors silently\n        return new Response('', { \n          status: 404, \n          statusText: 'Not Found',\n          headers: { 'Content-Type': 'text/plain' }\n        });\n      }\n      throw error;\n    }\n  };\n\n  // Block XMLHttpRequest to extensions\n  const originalXHROpen = XMLHttpRequest.prototype.open;\n  XMLHttpRequest.prototype.open = function(method: string, url: string | URL, ...args: any[]) {\n    const urlString = url.toString();\n    \n    if (\n      urlString.includes('chrome-extension://') ||\n      urlString.includes('pejdijmoenmkgeppbflobdenhhabjlaj') ||\n      urlString.includes('completion_list.html') ||\n      urlString.includes('utils.js') ||\n      urlString.includes('extensionState.js') ||\n      urlString.includes('heuristicsRedefinitions.js')\n    ) {\n      // Block the request by throwing an error that will be caught\n      throw new Error('Blocked extension request');\n    }\n    \n    return originalXHROpen.call(this, method, url, ...(args as any));\n  };\n};\n\n// Initialize error suppression\nif (typeof window !== 'undefined') {\n  suppressExtensionErrors();\n}\n","size_bytes":5402},"packages/frontend/src/pages/SuperAdminTenants.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { \n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog';\nimport { \n  Building2, \n  Plus, \n  Search, \n  Eye, \n  Edit, \n  Trash2, \n  ArrowLeft,\n  Users,\n  Phone,\n  AlertCircle,\n  CheckCircle,\n  XCircle\n} from 'lucide-react';\nimport apiClient from '@/lib/api';\n\ninterface Tenant {\n  id: string;\n  name: string;\n  slug: string;\n  domain: string;\n  sip_domain: string;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface TenantWithDetails extends Tenant {\n  companies: Array<{\n    id: string;\n    legal_name: string;\n    vat_number?: string;\n    address?: string;\n    city?: string;\n    is_primary: boolean;\n  }>;\n  contacts: Array<{\n    id: string;\n    first_name: string;\n    last_name: string;\n    email?: string;\n    phone?: string;\n    role?: string;\n    is_primary: boolean;\n  }>;\n}\n\nexport default function SuperAdminTenants() {\n  const navigate = useNavigate();\n  const [tenants, setTenants] = useState<Tenant[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [showDetailsModal, setShowDetailsModal] = useState(false);\n  const [selectedTenant, setSelectedTenant] = useState<TenantWithDetails | null>(null);\n\n  useEffect(() => {\n    loadTenants();\n  }, []);\n\n  const loadTenants = async () => {\n    try {\n      setLoading(true);\n      const response = await apiClient.getTenants();\n      setTenants((response.data as any)?.tenants || []);\n    } catch (error: any) {\n      setError(error.message || 'Failed to load tenants');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleViewTenant = async (tenant: Tenant) => {\n    try {\n      const response = await apiClient.getTenantWithDetails(tenant.id);\n      setSelectedTenant(response.data as TenantWithDetails);\n      setShowDetailsModal(true);\n    } catch (error: any) {\n      setError(error.message || 'Failed to load tenant details');\n    }\n  };\n\n  const handleDeleteTenant = async (tenantId: string) => {\n    if (!confirm('Are you sure you want to delete this tenant?')) {\n      return;\n    }\n\n    try {\n      await apiClient.deleteTenant(tenantId);\n      await loadTenants();\n    } catch (error: any) {\n      setError(error.message || 'Failed to delete tenant');\n    }\n  };\n\n  const filteredTenants = tenants.filter(tenant =>\n    tenant.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    tenant.domain.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    tenant.sip_domain.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  const getStatusBadge = (status: string) => {\n    switch (status) {\n      case 'active':\n        return <Badge className=\"bg-green-100 text-green-800\"><CheckCircle className=\"h-3 w-3 mr-1\" />Active</Badge>;\n      case 'suspended':\n        return <Badge className=\"bg-red-100 text-red-800\"><XCircle className=\"h-3 w-3 mr-1\" />Suspended</Badge>;\n      case 'pending':\n        return <Badge className=\"bg-yellow-100 text-yellow-800\"><AlertCircle className=\"h-3 w-3 mr-1\" />Pending</Badge>;\n      default:\n        return <Badge variant=\"secondary\">{status}</Badge>;\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"flex justify-between items-center mb-6\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-gray-900\">Tenant Management</h1>\n            <p className=\"text-gray-600\">Manage all tenants in the system</p>\n          </div>\n          <Button onClick={() => navigate('/edgvoip/tenants/create')}>\n            <Plus className=\"h-4 w-4 mr-2\" />\n            Create Tenant\n          </Button>\n        </div>\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-6\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {/* Search */}\n        <div className=\"mb-6\">\n          <div className=\"relative max-w-md\">\n            <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n            <Input\n              placeholder=\"Search tenants...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"pl-10\"\n            />\n          </div>\n        </div>\n\n        {/* Tenants Table */}\n        <Card>\n          <CardHeader>\n            <CardTitle>All Tenants</CardTitle>\n            <CardDescription>\n              Manage tenant configurations and access\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">Name</th>\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">Domain</th>\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">SIP Domain</th>\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">Status</th>\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">Created</th>\n                    <th className=\"text-left py-3 px-4 font-medium text-gray-900\">Actions</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {filteredTenants.map((tenant) => (\n                    <tr key={tenant.id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div className=\"font-medium text-gray-900\">{tenant.name}</div>\n                        <div className=\"text-sm text-gray-500\">Slug: {tenant.slug}</div>\n                      </td>\n                      <td className=\"py-3 px-4 text-gray-900\">{tenant.domain}</td>\n                      <td className=\"py-3 px-4 text-gray-900\">{tenant.sip_domain}</td>\n                      <td className=\"py-3 px-4\">{getStatusBadge(tenant.status)}</td>\n                      <td className=\"py-3 px-4 text-gray-500\">\n                        {new Date(tenant.created_at).toLocaleDateString()}\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        <div className=\"flex space-x-2\">\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => handleViewTenant(tenant)}\n                          >\n                            <Eye className=\"h-4 w-4\" />\n                          </Button>\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => navigate(`/edgvoip/tenants/${tenant.id}/users`)}\n                          >\n                            <Users className=\"h-4 w-4\" />\n                          </Button>\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => handleDeleteTenant(tenant.id)}\n                            className=\"text-red-600 hover:text-red-700\"\n                          >\n                            <Trash2 className=\"h-4 w-4\" />\n                          </Button>\n                        </div>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Tenant Details Modal */}\n      <Dialog open={showDetailsModal} onOpenChange={setShowDetailsModal}>\n        <DialogContent className=\"max-w-4xl max-h-[90vh] overflow-y-auto\">\n          <DialogHeader>\n            <DialogTitle>Tenant Details</DialogTitle>\n            <DialogDescription>\n              Complete information about the selected tenant\n            </DialogDescription>\n          </DialogHeader>\n\n          {selectedTenant && (\n            <div className=\"space-y-6\">\n              {/* Basic Information */}\n              <Card>\n                <CardHeader>\n                  <CardTitle>Basic Information</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"grid grid-cols-2 gap-4\">\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">Name</label>\n                      <p className=\"text-gray-900\">{selectedTenant.name}</p>\n                    </div>\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">Slug</label>\n                      <p className=\"text-gray-900\">{selectedTenant.slug}</p>\n                    </div>\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">Domain</label>\n                      <p className=\"text-gray-900\">{selectedTenant.domain}</p>\n                    </div>\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">SIP Domain</label>\n                      <p className=\"text-gray-900\">{selectedTenant.sip_domain}</p>\n                    </div>\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">Status</label>\n                      <div className=\"mt-1\">{getStatusBadge(selectedTenant.status)}</div>\n                    </div>\n                    <div>\n                      <label className=\"text-sm font-medium text-gray-500\">Created</label>\n                      <p className=\"text-gray-900\">\n                        {new Date(selectedTenant.created_at).toLocaleString()}\n                      </p>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n\n              {/* Companies */}\n              {selectedTenant.companies && selectedTenant.companies.length > 0 && (\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Companies</CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"space-y-4\">\n                      {selectedTenant.companies.map((company) => (\n                        <div key={company.id} className=\"border rounded-lg p-4\">\n                          <div className=\"flex justify-between items-start mb-2\">\n                            <h4 className=\"font-medium text-gray-900\">{company.legal_name}</h4>\n                            {company.is_primary && (\n                              <Badge variant=\"secondary\">Primary</Badge>\n                            )}\n                          </div>\n                          <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                            {company.vat_number && (\n                              <div>\n                                <span className=\"text-gray-500\">VAT:</span> {company.vat_number}\n                              </div>\n                            )}\n                            {company.address && (\n                              <div>\n                                <span className=\"text-gray-500\">Address:</span> {company.address}\n                              </div>\n                            )}\n                            {company.city && (\n                              <div>\n                                <span className=\"text-gray-500\">City:</span> {company.city}\n                              </div>\n                            )}\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  </CardContent>\n                </Card>\n              )}\n\n              {/* Contacts */}\n              {selectedTenant.contacts && selectedTenant.contacts.length > 0 && (\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Contacts</CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"space-y-4\">\n                      {selectedTenant.contacts.map((contact) => (\n                        <div key={contact.id} className=\"border rounded-lg p-4\">\n                          <div className=\"flex justify-between items-start mb-2\">\n                            <h4 className=\"font-medium text-gray-900\">\n                              {contact.first_name} {contact.last_name}\n                            </h4>\n                            {contact.is_primary && (\n                              <Badge variant=\"secondary\">Primary</Badge>\n                            )}\n                          </div>\n                          <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                            {contact.role && (\n                              <div>\n                                <span className=\"text-gray-500\">Role:</span> {contact.role}\n                              </div>\n                            )}\n                            {contact.email && (\n                              <div>\n                                <span className=\"text-gray-500\">Email:</span> {contact.email}\n                              </div>\n                            )}\n                            {contact.phone && (\n                              <div>\n                                <span className=\"text-gray-500\">Phone:</span> {contact.phone}\n                              </div>\n                            )}\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  </CardContent>\n                </Card>\n              )}\n            </div>\n          )}\n\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setShowDetailsModal(false)}>\n              Close\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}","size_bytes":14593},"packages/shared/src/types/call.ts":{"content":"import { z } from 'zod';\r\n\r\n// Active call schema\r\nexport const ActiveCallSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  call_uuid: z.string().uuid(),\r\n  direction: z.enum(['inbound', 'outbound', 'internal']),\r\n  state: z.enum(['ringing', 'answered', 'hold', 'transfer', 'conference']),\r\n  caller_number: z.string().optional(),\r\n  caller_name: z.string().optional(),\r\n  callee_number: z.string().optional(),\r\n  callee_name: z.string().optional(),\r\n  start_time: z.date(),\r\n  duration: z.number().min(0),\r\n  recording_enabled: z.boolean().default(false),\r\n  created_at: z.date()\r\n});\r\n\r\nexport type ActiveCall = z.infer<typeof ActiveCallSchema>;\r\n\r\n// Call control actions\r\nexport const CallActionSchema = z.object({\r\n  action: z.enum(['answer', 'hangup', 'hold', 'unhold', 'transfer', 'conference', 'mute', 'unmute', 'record_start', 'record_stop']),\r\n  call_uuid: z.string().uuid(),\r\n  target_extension: z.string().optional(), // for transfer\r\n  target_number: z.string().optional(), // for transfer\r\n  conference_uuid: z.string().uuid().optional() // for conference\r\n});\r\n\r\nexport type CallAction = z.infer<typeof CallActionSchema>;\r\n\r\n","size_bytes":1215},"scripts/setup-debian-server.sh":{"content":"#!/bin/bash\n\n# EDG VoIP System - Debian Server Setup Script\n# Per server di produzione con installazione nativa\n\nset -e\n\necho \"🚀 EDG VoIP System - Debian Server Setup\"\necho \"========================================\"\necho \"Server: Debian $(lsb_release -d | cut -f2)\"\necho \"User: $(whoami)\"\necho \"Date: $(date)\"\necho \"\"\n\n# Colori per output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Funzione per log\nlog() {\n    echo -e \"${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}\"\n}\n\nwarn() {\n    echo -e \"${YELLOW}[WARNING] $1${NC}\"\n}\n\nerror() {\n    echo -e \"${RED}[ERROR] $1${NC}\"\n    exit 1\n}\n\n# Verifica che sia root\nif [ \"$EUID\" -ne 0 ]; then\n    error \"Questo script deve essere eseguito come root\"\nfi\n\nlog \"Inizio setup server Debian per EDG VoIP System\"\n\n# 1. Aggiornamento sistema\nlog \"Aggiornamento sistema...\"\napt update && apt upgrade -y\n\n# 2. Installazione dipendenze base\nlog \"Installazione dipendenze base...\"\napt install -y \\\n    curl \\\n    wget \\\n    git \\\n    unzip \\\n    software-properties-common \\\n    apt-transport-https \\\n    ca-certificates \\\n    gnupg \\\n    lsb-release \\\n    build-essential \\\n    python3 \\\n    python3-pip \\\n    htop \\\n    vim \\\n    ufw \\\n    fail2ban\n\n# 3. Installazione Node.js 20 LTS\nlog \"Installazione Node.js 20 LTS...\"\ncurl -fsSL https://deb.nodesource.com/setup_20.x | bash -\napt install -y nodejs\n\n# Verifica installazione Node.js\nNODE_VERSION=$(node --version)\nNPM_VERSION=$(npm --version)\nlog \"Node.js installato: $NODE_VERSION\"\nlog \"npm installato: $NPM_VERSION\"\n\n# 4. Installazione PostgreSQL 15\nlog \"Installazione PostgreSQL 15...\"\napt install -y postgresql postgresql-contrib postgresql-client\n\n# Configurazione PostgreSQL\nlog \"Configurazione PostgreSQL...\"\nsystemctl start postgresql\nsystemctl enable postgresql\n\n# Creazione database e utente\nsudo -u postgres psql << EOF\nCREATE DATABASE voip_production;\nCREATE USER voip_user WITH ENCRYPTED PASSWORD 'VoipSecure2025!';\nGRANT ALL PRIVILEGES ON DATABASE voip_production TO voip_user;\nALTER USER voip_user CREATEDB;\n\\q\nEOF\n\nlog \"PostgreSQL configurato con database voip_production\"\n\n# 5. Installazione Redis\nlog \"Installazione Redis...\"\napt install -y redis-server\n\n# Configurazione Redis\nlog \"Configurazione Redis...\"\nsed -i 's/^# requirepass foobared/requirepass RedisSecure2025!/' /etc/redis/redis.conf\nsed -i 's/^bind 127.0.0.1/bind 0.0.0.0/' /etc/redis/redis.conf\nsystemctl restart redis-server\nsystemctl enable redis-server\n\nlog \"Redis configurato con password\"\n\n# 6. Installazione Nginx\nlog \"Installazione Nginx...\"\napt install -y nginx\n\n# Configurazione firewall\nlog \"Configurazione firewall...\"\nufw --force enable\nufw allow 22/tcp\nufw allow 80/tcp\nufw allow 443/tcp\nufw allow 5060/tcp\nufw allow 5060/udp\nufw allow 5061/tcp\nufw allow 8021/tcp\nufw allow 16384:32768/udp\n\nlog \"Firewall configurato\"\n\n# 7. Installazione FreeSWITCH\nlog \"Installazione FreeSWITCH...\"\napt install -y \\\n    freeswitch \\\n    freeswitch-mod-commands \\\n    freeswitch-mod-conference \\\n    freeswitch-mod-db \\\n    freeswitch-mod-dptools \\\n    freeswitch-mod-enum \\\n    freeswitch-mod-esf \\\n    freeswitch-mod-expr \\\n    freeswitch-mod-fifo \\\n    freeswitch-mod-hash \\\n    freeswitch-mod-httapi \\\n    freeswitch-mod-esl \\\n    freeswitch-mod-local-stream \\\n    freeswitch-mod-lua \\\n    freeswitch-mod-nibblebill \\\n    freeswitch-mod-rtc \\\n    freeswitch-mod-say-en \\\n    freeswitch-mod-sndfile \\\n    freeswitch-mod-sofia \\\n    freeswitch-mod-tone-stream \\\n    freeswitch-mod-voicemail \\\n    freeswitch-mod-voicemail-ivr \\\n    freeswitch-mod-dialplan-xml \\\n    freeswitch-mod-dialplan-asterisk \\\n    freeswitch-mod-loopback \\\n    freeswitch-mod-cdr-csv \\\n    freeswitch-mod-cdr-sqlite \\\n    freeswitch-mod-cdr-pg-csv \\\n    freeswitch-mod-curl \\\n    freeswitch-mod-event-socket \\\n    freeswitch-mod-format-cdr \\\n    freeswitch-mod-json-cdr \\\n    freeswitch-mod-syslog \\\n    freeswitch-mod-logfile \\\n    freeswitch-mod-console \\\n    freeswitch-mod-graylog2 \\\n    freeswitch-mod-native-file \\\n    freeswitch-mod-spandsp \\\n    freeswitch-mod-g723-1 \\\n    freeswitch-mod-amr \\\n    freeswitch-mod-amrwb \\\n    freeswitch-mod-g729 \\\n    freeswitch-mod-h26x \\\n    freeswitch-mod-opus \\\n    freeswitch-mod-vp8 \\\n    freeswitch-mod-vp9 \\\n    freeswitch-mod-bv \\\n    freeswitch-mod-b64\n\n# 8. Creazione directory per l'applicazione\nlog \"Creazione directory applicazione...\"\nmkdir -p /var/www/voip-system\nmkdir -p /var/www/voip-uploads\nmkdir -p /var/www/voip-recordings\nmkdir -p /var/log/voip-system\nmkdir -p /etc/voip-system\n\n# 9. Configurazione servizi\nlog \"Configurazione servizi...\"\nsystemctl enable postgresql\nsystemctl enable redis-server\nsystemctl enable nginx\nsystemctl enable freeswitch\n\n# 10. Installazione PM2 per gestione processi Node.js\nlog \"Installazione PM2...\"\nnpm install -g pm2\n\n# 11. Configurazione fail2ban\nlog \"Configurazione fail2ban...\"\ncat > /etc/fail2ban/jail.local << EOF\n[DEFAULT]\nbantime = 3600\nfindtime = 600\nmaxretry = 3\n\n[sshd]\nenabled = true\nport = ssh\nlogpath = /var/log/auth.log\n\n[nginx-http-auth]\nenabled = true\nfilter = nginx-http-auth\nport = http,https\nlogpath = /var/log/nginx/error.log\n\n[nginx-limit-req]\nenabled = true\nfilter = nginx-limit-req\nport = http,https\nlogpath = /var/log/nginx/error.log\nmaxretry = 10\nEOF\n\nsystemctl restart fail2ban\nsystemctl enable fail2ban\n\nlog \"Fail2ban configurato\"\n\n# 12. Ottimizzazioni sistema\nlog \"Ottimizzazioni sistema...\"\n\n# Aumentare limiti file descriptor\necho \"* soft nofile 65536\" >> /etc/security/limits.conf\necho \"* hard nofile 65536\" >> /etc/security/limits.conf\n\n# Ottimizzazioni kernel per VoIP\ncat >> /etc/sysctl.conf << EOF\n\n# VoIP Optimizations\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\nnet.ipv4.tcp_rmem = 4096 87380 16777216\nnet.ipv4.tcp_wmem = 4096 65536 16777216\nnet.core.netdev_max_backlog = 5000\nnet.ipv4.udp_mem = 102400 873800 16777216\nEOF\n\nsysctl -p\n\nlog \"Ottimizzazioni sistema applicate\"\n\n# 13. Creazione utente per l'applicazione\nlog \"Creazione utente voip...\"\nuseradd -r -s /bin/false -d /var/www/voip-system voip\nchown -R voip:voip /var/www/voip-system\nchown -R voip:voip /var/www/voip-uploads\nchown -R voip:voip /var/www/voip-recordings\n\n# 14. Configurazione logrotate\nlog \"Configurazione logrotate...\"\ncat > /etc/logrotate.d/voip-system << EOF\n/var/log/voip-system/*.log {\n    daily\n    missingok\n    rotate 30\n    compress\n    delaycompress\n    notifempty\n    create 644 voip voip\n    postrotate\n        systemctl reload voip-backend || true\n    endscript\n}\nEOF\n\nlog \"Setup base completato!\"\n\necho \"\"\necho \"✅ Setup server Debian completato con successo!\"\necho \"\"\necho \"📋 Servizi installati:\"\necho \"  - Node.js $(node --version)\"\necho \"  - PostgreSQL 15\"\necho \"  - Redis 7\"\necho \"  - Nginx\"\necho \"  - FreeSWITCH\"\necho \"  - PM2\"\necho \"  - Fail2ban\"\necho \"\"\necho \"🔧 Prossimi passi:\"\necho \"  1. Copiare il codice dell'applicazione in /var/www/voip-system\"\necho \"  2. Configurare le variabili d'ambiente\"\necho \"  3. Eseguire le migrazioni database\"\necho \"  4. Configurare Nginx\"\necho \"  5. Avviare i servizi\"\necho \"\"\necho \"📁 Directory create:\"\necho \"  - /var/www/voip-system (applicazione)\"\necho \"  - /var/www/voip-uploads (upload files)\"\necho \"  - /var/www/voip-recordings (registrazioni)\"\necho \"  - /var/log/voip-system (log applicazione)\"\necho \"  - /etc/voip-system (configurazioni)\"\necho \"\"\n","size_bytes":7341},"packages/frontend/src/components/layout/SuperAdminHeader.tsx":{"content":"import React from 'react';\nimport { NavLink } from 'react-router-dom';\nimport { \n  LayoutDashboard, \n  Users, \n  Building2, \n  BarChart3, \n  Settings, \n  Terminal,\n  LogOut,\n  Phone\n} from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { useAuth } from '@/contexts/AuthContext';\n\nconst navigation = [\n  { name: 'Dashboard', href: '/edgvoip/dashboard', icon: LayoutDashboard },\n  { name: 'Tenants', href: '/edgvoip/tenants', icon: Building2 },\n  { name: 'Users', href: '/edgvoip/users', icon: Users },\n  { name: 'Analytics', href: '/edgvoip/analytics', icon: BarChart3 },\n  { name: 'System Settings', href: '/edgvoip/system-settings', icon: Settings },\n  { name: 'Logs', href: '/edgvoip/logs', icon: Terminal },\n];\n\nexport default function SuperAdminHeader() {\n  const { logout, user } = useAuth();\n\n  return (\n    <header className=\"bg-white border-b border-gray-200\">\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"flex justify-between items-center h-16\">\n          {/* Logo */}\n          <div className=\"flex items-center\">\n            <div className=\"flex items-center\">\n              <Phone className=\"h-8 w-8 text-blue-600\" />\n              <span className=\"ml-2 text-xl font-bold text-gray-900\">EDG VoIP</span>\n              <span className=\"ml-2 text-sm text-gray-500\">Super Admin</span>\n            </div>\n          </div>\n\n          {/* Navigation */}\n          <nav className=\"hidden md:flex space-x-8\">\n            {navigation.map((item) => (\n              <NavLink\n                key={item.name}\n                to={item.href}\n                className={({ isActive }) =>\n                  `inline-flex items-center px-1 pt-1 text-sm font-medium transition-colors ${\n                    isActive\n                      ? 'text-blue-600 border-b-2 border-blue-600'\n                      : 'text-gray-500 hover:text-gray-700 hover:border-b-2 hover:border-gray-300'\n                  }`\n                }\n              >\n                <item.icon className=\"mr-2 h-4 w-4\" />\n                {item.name}\n              </NavLink>\n            ))}\n          </nav>\n\n          {/* User menu */}\n          <div className=\"flex items-center space-x-4\">\n            <div className=\"flex items-center\">\n              <div className=\"flex-shrink-0\">\n                <div className=\"h-8 w-8 rounded-full bg-blue-500 flex items-center justify-center\">\n                <span className=\"text-sm font-medium text-white\">\n                  {user?.firstName?.charAt(0)?.toUpperCase() || 'S'}\n                </span>\n                </div>\n              </div>\n              <div className=\"ml-3 hidden sm:block\">\n                <p className=\"text-sm font-medium text-gray-700\">\n                  {user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : 'Super Admin'}\n                </p>\n                <p className=\"text-xs text-gray-500\">Super Administrator</p>\n              </div>\n            </div>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={logout}\n              className=\"ml-2\"\n            >\n              <LogOut className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n      </div>\n\n      {/* Mobile navigation */}\n      <div className=\"md:hidden\">\n        <div className=\"px-2 pt-2 pb-3 space-y-1 sm:px-3 bg-gray-50\">\n          {navigation.map((item) => (\n            <NavLink\n              key={item.name}\n              to={item.href}\n              className={({ isActive }) =>\n                `flex items-center px-3 py-2 text-base font-medium rounded-md transition-colors ${\n                  isActive\n                    ? 'text-blue-600 bg-blue-50'\n                    : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'\n                }`\n              }\n            >\n              <item.icon className=\"mr-3 h-5 w-5\" />\n              {item.name}\n            </NavLink>\n          ))}\n        </div>\n      </div>\n    </header>\n  );\n}\n","size_bytes":4009},"packages/backend/src/routes/queue-routes.ts":{"content":"// @ts-nocheck\r\nimport express from 'express';\r\nimport { QueueService } from '../services/queue.service';\r\nimport { authenticateToken, AuthenticatedRequest as AuthRequest } from '../middleware/auth.middleware';\r\n\r\nconst router = express.Router();\r\nconst queueService = new QueueService();\r\n\r\n// Apply authentication middleware to all routes\r\nrouter.use(authenticateToken);\r\n\r\n// Get all queues for tenant\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const tenantId = (req as any).user.tenant_id;\r\n    const queues = await queueService.listQueues(tenantId);\r\n    res.json({ success: true, data: queues });\r\n  } catch (error) {\r\n    console.error('❌ Error listing queues:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to list queues' });\r\n  }\r\n});\r\n\r\n// Get queue by ID\r\nrouter.get('/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const queue = await queueService.getQueueById(id, tenantId);\r\n    if (!queue) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, data: queue });\r\n  } catch (error) {\r\n    console.error('❌ Error getting queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to get queue' });\r\n  }\r\n});\r\n\r\n// Create new queue\r\nrouter.post('/', async (req, res) => {\r\n  try {\r\n    const tenantId = (req as any).user.tenant_id;\r\n    const queueData = {\r\n      ...req.body,\r\n      tenant_id: tenantId,\r\n      agents: req.body.agents || []\r\n    };\r\n    \r\n    const queue = await queueService.createQueue(queueData);\r\n    res.status(201).json({ success: true, data: queue });\r\n  } catch (error) {\r\n    console.error('❌ Error creating queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to create queue' });\r\n  }\r\n});\r\n\r\n// Update queue\r\nrouter.put('/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const queue = await queueService.updateQueue(id, tenantId, req.body);\r\n    if (!queue) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, data: queue });\r\n  } catch (error) {\r\n    console.error('❌ Error updating queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to update queue' });\r\n  }\r\n});\r\n\r\n// Delete queue\r\nrouter.delete('/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const success = await queueService.deleteQueue(id, tenantId);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, message: 'Queue deleted successfully' });\r\n  } catch (error) {\r\n    console.error('❌ Error deleting queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to delete queue' });\r\n  }\r\n});\r\n\r\n// Add agent to queue\r\nrouter.post('/:id/agents', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { extension_id } = req.body;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    if (!extension_id) {\r\n      return res.status(400).json({ success: false, message: 'Extension ID is required' });\r\n    }\r\n    \r\n    const success = await queueService.addAgentToQueue(id, tenantId, extension_id);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, message: 'Agent added to queue successfully' });\r\n  } catch (error) {\r\n    console.error('❌ Error adding agent to queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to add agent to queue' });\r\n  }\r\n});\r\n\r\n// Remove agent from queue\r\nrouter.delete('/:id/agents/:extensionId', async (req, res) => {\r\n  try {\r\n    const { id, extensionId } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const success = await queueService.removeAgentFromQueue(id, tenantId, extensionId);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, message: 'Queue or agent not found' });\r\n    }\r\n    \r\n    res.json({ success: true, message: 'Agent removed from queue successfully' });\r\n  } catch (error) {\r\n    console.error('❌ Error removing agent from queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to remove agent from queue' });\r\n  }\r\n});\r\n\r\n// Update agent status\r\nrouter.put('/:id/agents/:extensionId/status', async (req, res) => {\r\n  try {\r\n    const { id, extensionId } = req.params;\r\n    const { status, tier_level } = req.body;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const success = await queueService.updateAgentStatus(id, tenantId, extensionId, status, tier_level);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, message: 'Queue or agent not found' });\r\n    }\r\n    \r\n    res.json({ success: true, message: 'Agent status updated successfully' });\r\n  } catch (error) {\r\n    console.error('❌ Error updating agent status:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to update agent status' });\r\n  }\r\n});\r\n\r\n// Get queue statistics\r\nrouter.get('/:id/stats', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const stats = await queueService.getQueueStats(id, tenantId);\r\n    if (!stats) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, data: stats });\r\n  } catch (error) {\r\n    console.error('❌ Error getting queue stats:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to get queue statistics' });\r\n  }\r\n});\r\n\r\n// Pause/Resume queue\r\nrouter.put('/:id/pause', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const { paused } = req.body;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const success = await queueService.pauseQueue(id, tenantId, paused);\r\n    if (!success) {\r\n      return res.status(404).json({ success: false, message: 'Queue not found' });\r\n    }\r\n    \r\n    res.json({ success: true, message: `Queue ${paused ? 'paused' : 'resumed'} successfully` });\r\n  } catch (error) {\r\n    console.error('❌ Error pausing/resuming queue:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to pause/resume queue' });\r\n  }\r\n});\r\n\r\n// Get agent statistics\r\nrouter.get('/:id/agents/:extensionId/stats', async (req, res) => {\r\n  try {\r\n    const { id, extensionId } = req.params;\r\n    const tenantId = (req as any).user.tenant_id;\r\n    \r\n    const stats = await queueService.getAgentStats(id, tenantId, extensionId);\r\n    if (!stats) {\r\n      return res.status(404).json({ success: false, message: 'Agent not found' });\r\n    }\r\n    \r\n    res.json({ success: true, data: stats });\r\n  } catch (error) {\r\n    console.error('❌ Error getting agent stats:', error);\r\n    res.status(500).json({ success: false, message: 'Failed to get agent statistics' });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":7205},"packages/frontend/src/pages/CDRViewer.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Download, Search, Filter, Phone, PhoneIncoming, PhoneOutgoing } from 'lucide-react';\nimport apiClient from '@/lib/api';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface CDR {\n  id: string;\n  call_uuid: string;\n  call_direction: 'inbound' | 'outbound' | 'internal';\n  call_type: string;\n  caller_id_number?: string;\n  caller_id_name?: string;\n  callee_id_number?: string;\n  callee_id_name?: string;\n  start_time: string;\n  answer_time?: string;\n  end_time: string;\n  duration: number;\n  bill_seconds: number;\n  hangup_cause: string;\n  hangup_disposition: string;\n  recording_enabled: boolean;\n  recording_path?: string;\n}\n\nexport default function CDRViewer() {\n  const [cdr, setCdr] = useState<CDR[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [directionFilter, setDirectionFilter] = useState<string>('all');\n  const [dispositionFilter, setDispositionFilter] = useState<string>('all');\n  const { toast } = useToast();\n\n  useEffect(() => {\n    loadCDR();\n  }, []);\n\n  const loadCDR = async () => {\n    try {\n      setIsLoading(true);\n      const response = await apiClient.getCDR({\n        limit: 50,\n        start_date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), // Last 7 days\n      });\n      setCdr((response.data as any)?.cdr || []);\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load CDR records\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const filteredCDR = cdr.filter(record => {\n    const matchesSearch = \n      record.caller_id_number?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      record.callee_id_number?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      record.caller_id_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      record.callee_id_name?.toLowerCase().includes(searchTerm.toLowerCase());\n    \n    const matchesDirection = directionFilter === 'all' || record.call_direction === directionFilter;\n    const matchesDisposition = dispositionFilter === 'all' || record.hangup_disposition === dispositionFilter;\n    \n    return matchesSearch && matchesDirection && matchesDisposition;\n  });\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const getDirectionIcon = (direction: string) => {\n    switch (direction) {\n      case 'inbound':\n        return <PhoneIncoming className=\"h-4 w-4 text-green-600\" />;\n      case 'outbound':\n        return <PhoneOutgoing className=\"h-4 w-4 text-blue-600\" />;\n      case 'internal':\n        return <Phone className=\"h-4 w-4 text-purple-600\" />;\n      default:\n        return <Phone className=\"h-4 w-4 text-gray-600\" />;\n    }\n  };\n\n  const getDispositionBadge = (disposition: string) => {\n    switch (disposition) {\n      case 'answered':\n        return <Badge variant=\"default\">Answered</Badge>;\n      case 'no_answer':\n        return <Badge variant=\"secondary\">No Answer</Badge>;\n      case 'busy':\n        return <Badge variant=\"destructive\">Busy</Badge>;\n      case 'failed':\n        return <Badge variant=\"destructive\">Failed</Badge>;\n      default:\n        return <Badge variant=\"outline\">Unknown</Badge>;\n    }\n  };\n\n  const exportCDR = async (format: 'csv' | 'json') => {\n    try {\n      const response = await apiClient.exportCDR(format);\n      \n      if (format === 'csv') {\n        const blob = new Blob([response as any], { type: 'text/csv' });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `cdr_export_${new Date().toISOString().split('T')[0]}.csv`;\n        a.click();\n        window.URL.revokeObjectURL(url);\n      } else {\n        const blob = new Blob([JSON.stringify(response, null, 2)], { type: 'application/json' });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `cdr_export_${new Date().toISOString().split('T')[0]}.json`;\n        a.click();\n        window.URL.revokeObjectURL(url);\n      }\n      \n      toast({\n        title: \"Export successful\",\n        description: `CDR data exported as ${format.toUpperCase()}`,\n      });\n    } catch (error) {\n      toast({\n        title: \"Export failed\",\n        description: \"Failed to export CDR data\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">CDR Viewer</h1>\n          <p className=\"text-muted-foreground\">\n            Call Detail Records and call history\n          </p>\n        </div>\n        <div className=\"flex space-x-2\">\n          <Button variant=\"outline\" onClick={() => exportCDR('csv')}>\n            <Download className=\"h-4 w-4 mr-2\" />\n            Export CSV\n          </Button>\n          <Button variant=\"outline\" onClick={() => exportCDR('json')}>\n            <Download className=\"h-4 w-4 mr-2\" />\n            Export JSON\n          </Button>\n        </div>\n      </div>\n\n      {/* Filters */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <Filter className=\"h-5 w-5 mr-2\" />\n            Filters\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid gap-4 md:grid-cols-4\">\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium\">Search</label>\n              <div className=\"relative\">\n                <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n                <Input\n                  placeholder=\"Search calls...\"\n                  value={searchTerm}\n                  onChange={(e) => setSearchTerm(e.target.value)}\n                  className=\"pl-10\"\n                />\n              </div>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium\">Direction</label>\n              <Select value={directionFilter} onValueChange={setDirectionFilter}>\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Directions</SelectItem>\n                  <SelectItem value=\"inbound\">Inbound</SelectItem>\n                  <SelectItem value=\"outbound\">Outbound</SelectItem>\n                  <SelectItem value=\"internal\">Internal</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium\">Disposition</label>\n              <Select value={dispositionFilter} onValueChange={setDispositionFilter}>\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Dispositions</SelectItem>\n                  <SelectItem value=\"answered\">Answered</SelectItem>\n                  <SelectItem value=\"no_answer\">No Answer</SelectItem>\n                  <SelectItem value=\"busy\">Busy</SelectItem>\n                  <SelectItem value=\"failed\">Failed</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium\">Actions</label>\n              <Button variant=\"outline\" className=\"w-full\" onClick={loadCDR}>\n                Refresh\n              </Button>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* CDR Table */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Call Records ({filteredCDR.length})</CardTitle>\n          <CardDescription>\n            Recent call detail records\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"overflow-x-auto\">\n            <table className=\"w-full\">\n              <thead>\n                <tr className=\"border-b\">\n                  <th className=\"text-left p-2\">Direction</th>\n                  <th className=\"text-left p-2\">Caller</th>\n                  <th className=\"text-left p-2\">Callee</th>\n                  <th className=\"text-left p-2\">Start Time</th>\n                  <th className=\"text-left p-2\">Duration</th>\n                  <th className=\"text-left p-2\">Disposition</th>\n                  <th className=\"text-left p-2\">Recording</th>\n                </tr>\n              </thead>\n              <tbody>\n                {filteredCDR.map((record) => (\n                  <tr key={record.id} className=\"border-b hover:bg-gray-50\">\n                    <td className=\"p-2\">\n                      <div className=\"flex items-center space-x-2\">\n                        {getDirectionIcon(record.call_direction)}\n                        <span className=\"capitalize\">{record.call_direction}</span>\n                      </div>\n                    </td>\n                    <td className=\"p-2\">\n                      <div>\n                        <div className=\"font-medium\">{record.caller_id_number || 'Unknown'}</div>\n                        {record.caller_id_name && (\n                          <div className=\"text-sm text-gray-500\">{record.caller_id_name}</div>\n                        )}\n                      </div>\n                    </td>\n                    <td className=\"p-2\">\n                      <div>\n                        <div className=\"font-medium\">{record.callee_id_number || 'Unknown'}</div>\n                        {record.callee_id_name && (\n                          <div className=\"text-sm text-gray-500\">{record.callee_id_name}</div>\n                        )}\n                      </div>\n                    </td>\n                    <td className=\"p-2\">\n                      {new Date(record.start_time).toLocaleString()}\n                    </td>\n                    <td className=\"p-2\">\n                      {formatDuration(record.duration)}\n                    </td>\n                    <td className=\"p-2\">\n                      {getDispositionBadge(record.hangup_disposition)}\n                    </td>\n                    <td className=\"p-2\">\n                      {record.recording_enabled ? (\n                        <Badge variant=\"secondary\">Available</Badge>\n                      ) : (\n                        <Badge variant=\"outline\">None</Badge>\n                      )}\n                    </td>\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n          </div>\n        </CardContent>\n      </Card>\n\n      {filteredCDR.length === 0 && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <div className=\"text-center\">\n              <Phone className=\"h-12 w-12 text-gray-400 mx-auto mb-4\" />\n              <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                No call records found\n              </h3>\n              <p className=\"text-gray-500\">\n                {searchTerm || directionFilter !== 'all' || dispositionFilter !== 'all' \n                  ? 'Try adjusting your filters.' \n                  : 'No calls have been made yet.'}\n              </p>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}","size_bytes":12298},"packages/frontend/src/hooks/useAuthenticatedApi.ts":{"content":"import { useNavigate } from 'react-router-dom';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\nexport const useAuthenticatedApi = () => {\r\n  const { logout } = useAuth();\r\n  const navigate = useNavigate();\r\n\r\n  const apiCall = async (url: string, options: RequestInit = {}) => {\r\n    const response = await fetch(url, {\r\n      ...options,\r\n      headers: {\r\n        'Authorization': `Bearer ${localStorage.getItem('token')}`,\r\n        'Content-Type': 'application/json',\r\n        ...options.headers\r\n      }\r\n    });\r\n    \r\n    // Check if session expired\r\n    if (response.status === 401 || response.status === 403) {\r\n      console.warn('⚠️ Session expired, redirecting to login');\r\n      logout();\r\n      navigate('/login');\r\n      throw new Error('Session expired');\r\n    }\r\n    \r\n    return response;\r\n  };\r\n\r\n  return { apiCall };\r\n};\r\n","size_bytes":853},"packages/backend/src/routes/cdr.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { authenticateToken } from '../middleware/auth';\n\nconst router = Router();\n\n// Mock CDR statistics endpoint\nrouter.get('/stats', authenticateToken, async (req: Request, res: Response) => {\n  try {\n    // Return mock statistics\n    const mockStats = {\n      success: true,\n      data: {\n        total_calls: 0,\n        answered_calls: 0,\n        missed_calls: 0,\n        total_duration: 0,\n        average_duration: 0,\n        inbound_calls: 0,\n        outbound_calls: 0,\n        internal_calls: 0,\n      }\n    };\n    \n    res.json(mockStats);\n  } catch (error) {\n    console.error('Error fetching CDR stats:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Failed to fetch CDR statistics'\n    });\n  }\n});\n\n// Mock CDR list endpoint\nrouter.get('/', authenticateToken, async (req: Request, res: Response) => {\n  try {\n    res.json({\n      success: true,\n      data: {\n        items: [],\n        pagination: {\n          total: 0,\n          page: 1,\n          limit: 20,\n          totalPages: 0\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching CDR records:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Failed to fetch CDR records'\n    });\n  }\n});\n\nexport default router;\n","size_bytes":1314},"packages/backend/src/routes/tenants.ts":{"content":"// @ts-nocheck\nimport express from 'express';\nimport { TenantService } from '../services/tenant.service';\nimport { authenticateToken, requireSuperAdmin, AuthRequest } from '../middleware/auth';\nimport { asyncHandler, successResponse, errorResponse } from '../utils/response';\nimport { CreateTenantRequestSchema } from '@w3-voip/shared';\n\nconst router = express.Router();\nconst tenantService = new TenantService();\n\n// Apply authentication and super admin middleware to all routes\nrouter.use(authenticateToken);\nrouter.use(requireSuperAdmin);\n\n// GET /api/tenants - List all tenants with statistics\nrouter.get('/', asyncHandler(async (req: AuthRequest, res) => {\n  const { page = 1, limit = 50, search } = req.query;\n  \n  const result = await tenantService.listTenants(\n    parseInt(page as string),\n    parseInt(limit as string),\n    search as string\n  );\n\n  successResponse(res, {\n    tenants: result.tenants,\n    pagination: {\n      page: parseInt(page as string),\n      limit: parseInt(limit as string),\n      total: result.total,\n      total_pages: result.totalPages\n    }\n  }, 'Tenants retrieved successfully');\n}));\n\n// GET /api/tenants/stats - Get cross-tenant statistics\nrouter.get('/stats', asyncHandler(async (req: AuthRequest, res) => {\n  const stats = await tenantService.getCrossTenantStats();\n  successResponse(res, stats, 'Cross-tenant statistics retrieved successfully');\n}));\n\n// GET /api/tenants/stats-list - Get detailed statistics for all tenants\nrouter.get('/stats-list', asyncHandler(async (req: AuthRequest, res) => {\n  const statsList = await tenantService.getTenantStatsList();\n  successResponse(res, statsList, 'Tenant statistics list retrieved successfully');\n}));\n\n// POST /api/tenants - Create new tenant with companies and contacts\nrouter.post('/', asyncHandler(async (req: AuthRequest, res) => {\n  // Validate request body\n  const validationResult = CreateTenantRequestSchema.safeParse(req.body);\n  if (!validationResult.success) {\n    return errorResponse(res, 'Invalid request data', 400, 'VALIDATION_ERROR', validationResult.error.errors);\n  }\n\n  const tenantData = validationResult.data;\n  \n  // Determine if this is a super admin tenant\n  const isSuperAdmin = tenantData.slug === 'edg-voip' || \n                       tenantData.admin_user?.role === 'super_admin';\n  \n  // Auto-generate sip_domain if not provided\n  if (!tenantData.sip_domain) {\n    if (isSuperAdmin) {\n      // Super admin tenants don't need SIP domain (they only manage other tenants)\n      tenantData.sip_domain = null;\n      console.log('Super admin tenant - no SIP domain needed');\n    } else {\n      // Regular tenants get auto-generated SIP domain\n      tenantData.sip_domain = tenantData.slug + '.edgvoip.it';\n      console.log('Auto-generated SIP domain: ' + tenantData.sip_domain);\n    }\n  }\n  \n  const tenant = await tenantService.createTenantWithCompanies(tenantData);\n  \n  successResponse(res, tenant, 'Tenant created successfully');\n}));\n\n// GET /api/tenants/:id - Get tenant details with companies and contacts\nrouter.get('/:id', asyncHandler(async (req: AuthRequest, res) => {\n  const { id } = req.params;\n  \n  const result = await tenantService.getTenantWithDetails(id);\n  successResponse(res, result, 'Tenant details retrieved successfully');\n}));\n\n// PUT /api/tenants/:id - Update tenant\nrouter.put('/:id', asyncHandler(async (req: AuthRequest, res) => {\n  const { id } = req.params;\n  const updateData = req.body;\n  \n  const tenant = await tenantService.updateTenant(id, updateData);\n  successResponse(res, tenant, 'Tenant updated successfully');\n}));\n\n// DELETE /api/tenants/:id - Delete tenant (soft delete)\nrouter.delete('/:id', asyncHandler(async (req: AuthRequest, res) => {\n  const { id } = req.params;\n  \n  await tenantService.deleteTenant(id);\n  successResponse(res, null, 'Tenant deleted successfully');\n}));\n\nexport default router;\n","size_bytes":3865},"packages/frontend/src/pages/Login.tsx":{"content":"import { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useToast } from '@/hooks/use-toast';\nimport { Phone, Lock, User } from 'lucide-react';\nimport apiClient from '@/lib/api';\n\ninterface LoginProps {\n  tenantSlug: string;\n}\n\nexport default function Login({ tenantSlug }: LoginProps) {\n  const [formData, setFormData] = useState({\n    username: '',\n    password: '',\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const { login } = useAuth();\n  const { toast } = useToast();\n  const navigate = useNavigate();\n\n  // Redirect is now handled by AuthContext\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsLoading(true);\n\n    try {\n      // Call the tenant-scoped login API\n      const response = await fetch(`/api/${tenantSlug}/login`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          email: formData.username,\n          password: formData.password,\n        }),\n      });\n\n      const data = await response.json();\n      \n      if (data.success && data.data?.token) {\n        // Use AuthContext login function to update auth state\n        await login(data.data.token);\n        \n        toast({\n          title: \"Login successful\",\n          description: `Welcome to ${data.data.user.tenantSlug}`,\n        });\n        \n        // Navigate to tenant dashboard\n        navigate(`/${tenantSlug}/dashboard`);\n      } else {\n        throw new Error(data.error || 'Login failed');\n      }\n    } catch (error: any) {\n      toast({\n        title: \"Login failed\",\n        description: error.message || \"Invalid credentials. Please try again.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setFormData(prev => ({\n      ...prev,\n      [e.target.name]: e.target.value\n    }));\n  };\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center \n                bg-gradient-to-br from-blue-600 via-blue-500 to-indigo-600\n                bg-[length:400%_400%] animate-gradient py-12 px-4 sm:px-6 lg:px-8\">\n      <div className=\"max-w-md w-full space-y-8\">\n        <div className=\"text-center\">\n          <div className=\"mx-auto h-16 w-16 flex items-center justify-center rounded-full \n                        bg-white/20 backdrop-blur-sm border border-white/30 shadow-glass\">\n            <Phone className=\"h-8 w-8 text-white\" />\n          </div>\n          <h2 className=\"mt-6 text-3xl font-extrabold text-white\">\n            EDG VoIP System\n          </h2>\n          <p className=\"mt-2 text-sm text-white/80\">\n            Enterprise Multi-tenant VoIP Platform\n          </p>\n        </div>\n\n        <Card variant=\"glass\" className=\"p-8\">\n          <CardHeader>\n            <CardTitle className=\"text-center text-2xl font-bold\">Sign in to your account</CardTitle>\n            <CardDescription className=\"text-center\">\n              Enter your credentials to access the VoIP management system\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            <form onSubmit={handleSubmit} className=\"space-y-6\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"username\" className=\"text-sm font-medium\">Email</Label>\n                <div className=\"relative\">\n                  <User className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                  <Input\n                    id=\"username\"\n                    name=\"username\"\n                    type=\"text\"\n                    required\n                    className=\"glass-input pl-10 focus:ring-2 focus:ring-blue-500/50 \n                              transition-all duration-200\"\n                    placeholder=\"Enter your email\"\n                    value={formData.username}\n                    onChange={handleInputChange}\n                    disabled={isLoading}\n                  />\n                </div>\n              </div>\n\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"password\" className=\"text-sm font-medium\">Password</Label>\n                <div className=\"relative\">\n                  <Lock className=\"absolute left-3 top-3 h-4 w-4 text-gray-400\" />\n                  <Input\n                    id=\"password\"\n                    name=\"password\"\n                    type=\"password\"\n                    required\n                    className=\"glass-input pl-10 focus:ring-2 focus:ring-blue-500/50 \n                              transition-all duration-200\"\n                    placeholder=\"Enter your password\"\n                    value={formData.password}\n                    onChange={handleInputChange}\n                    disabled={isLoading}\n                  />\n                </div>\n              </div>\n\n              <Button\n                type=\"submit\"\n                variant=\"gradient\"\n                className=\"w-full hover:scale-[1.02] transition-all duration-200\"\n                disabled={isLoading}\n              >\n                {isLoading ? 'Signing in...' : 'Sign in'}\n              </Button>\n            </form>\n\n            <div className=\"mt-6 text-center\">\n              <p className=\"text-sm text-gray-600 mb-2\">Demo credentials:</p>\n              <div className=\"text-xs text-gray-500 space-y-1\">\n                {tenantSlug === 'demo' && (\n                  <div>👨‍💼 Demo Tenant Admin: admin@demo.local / tenantadmin123</div>\n                )}\n                {tenantSlug === 'edgvoip' && (\n                  <div>👑 Super Admin: admin@edgvoip.it / admin123</div>\n                )}\n                {tenantSlug !== 'demo' && tenantSlug !== 'edgvoip' && (\n                  <>\n                    <div>👨‍💼 Tenant Admin: tenantadmin@edgvoip.local / tenantadmin123</div>\n                    <div>👤 Regular User: user@edgvoip.local / user123</div>\n                  </>\n                )}\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n}","size_bytes":6405},"packages/backend/update-admin-password.ts":{"content":"import bcrypt from 'bcrypt';\r\nimport { Client } from 'pg';\r\n\r\nasync function updatePassword() {\r\n  const password = 'password';\r\n  const hash = await bcrypt.hash(password, 10);\r\n  \r\n  console.log('Generated hash for password \"password\":', hash);\r\n  \r\n  const client = new Client({\r\n    connectionString: process.env.DATABASE_URL || 'postgresql://voip_user:VoipSecure2025!@localhost:5432/voip_production'\r\n  });\r\n  \r\n  await client.connect();\r\n  console.log('Connected to database');\r\n  \r\n  // Update super admin password\r\n  const result = await client.query(\r\n    'UPDATE users SET password_hash = $1 WHERE email = $2 RETURNING email, role',\r\n    [hash, 'admin@edgvoip.local']\r\n  );\r\n  \r\n  console.log('Updated users:', result.rows);\r\n  \r\n  // Update demo admin password\r\n  const result2 = await client.query(\r\n    'UPDATE users SET password_hash = $1 WHERE email = $2 RETURNING email, role',\r\n    [hash, 'admin@demo.local']\r\n  );\r\n  \r\n  console.log('Updated demo users:', result2.rows);\r\n  \r\n  // Verify the hash works\r\n  const testResult = await bcrypt.compare(password, hash);\r\n  console.log('Hash verification test:', testResult ? '✅ PASS' : '❌ FAIL');\r\n  \r\n  await client.end();\r\n  console.log('Done!');\r\n}\r\n\r\nupdatePassword().catch(console.error);\r\n\r\n","size_bytes":1261},"packages/backend/src/routes/stores.ts":{"content":"import { Router } from 'express';\r\nimport { StoreService } from '../services/store.service';\r\nimport {\r\n  authenticateToken,\r\n  requireTenant,\r\n  setTenantContext,\r\n  setStoreContext,\r\n  validateStore,\r\n  handleValidationErrors,\r\n  validatePagination\r\n} from '../middleware';\r\nimport {\r\n  successResponse,\r\n  errorResponse,\r\n  paginatedResponse,\r\n  createdResponse,\r\n  updatedResponse,\r\n  deletedResponse,\r\n  notFoundResponse,\r\n  asyncHandler\r\n} from '../utils/response';\r\n\r\nconst router = Router();\r\nconst storeService = new StoreService();\r\n\r\n// Apply authentication and tenant context to all routes\r\nrouter.use(authenticateToken);\r\nrouter.use(requireTenant);\r\nrouter.use(setTenantContext);\r\n\r\n// Create store\r\nrouter.post('/',\r\n  validateStore,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const storeData = {\r\n      ...req.body,\r\n      tenant_id: req.tenantId\r\n    };\r\n    \r\n    const store = await storeService.createStore(storeData);\r\n    createdResponse(res, store, 'Store created successfully');\r\n  })\r\n);\r\n\r\n// List stores for tenant\r\nrouter.get('/',\r\n  validatePagination,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const page = parseInt(req.query.page as string) || 1;\r\n    const limit = parseInt(req.query.limit as string) || 50;\r\n    const search = req.query.q as string;\r\n\r\n    const result = await storeService.listStores(req.tenantId!, page, limit, search);\r\n    \r\n    paginatedResponse(res, result.stores, {\r\n      page,\r\n      limit,\r\n      total: result.total,\r\n      totalPages: result.totalPages\r\n    }, 'Stores retrieved successfully');\r\n  })\r\n);\r\n\r\n// Get store by ID\r\nrouter.get('/:id',\r\n  setStoreContext,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    const store = await storeService.getStoreById(storeId, req.tenantId);\r\n    \r\n    if (!store) {\r\n      return notFoundResponse(res, 'Store not found');\r\n    }\r\n\r\n    successResponse(res, store, 'Store retrieved successfully');\r\n  })\r\n);\r\n\r\n// Update store\r\nrouter.put('/:id',\r\n  setStoreContext,\r\n  validateStore,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    const store = await storeService.updateStore(storeId, req.body, req.tenantId);\r\n    updatedResponse(res, store, 'Store updated successfully');\r\n  })\r\n);\r\n\r\n// Delete store\r\nrouter.delete('/:id',\r\n  setStoreContext,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    await storeService.deleteStore(storeId, req.tenantId);\r\n    deletedResponse(res, 'Store deleted successfully');\r\n  })\r\n);\r\n\r\n// Get store statistics\r\nrouter.get('/:id/stats',\r\n  setStoreContext,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    const stats = await storeService.getStoreStats(storeId, req.tenantId);\r\n    successResponse(res, stats, 'Store statistics retrieved successfully');\r\n  })\r\n);\r\n\r\n// Activate store\r\nrouter.post('/:id/activate',\r\n  setStoreContext,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    const store = await storeService.activateStore(storeId, req.tenantId);\r\n    updatedResponse(res, store, 'Store activated successfully');\r\n  })\r\n);\r\n\r\n// Deactivate store\r\nrouter.post('/:id/deactivate',\r\n  setStoreContext,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.id;\r\n    const store = await storeService.deactivateStore(storeId, req.tenantId);\r\n    updatedResponse(res, store, 'Store deactivated successfully');\r\n  })\r\n);\r\n\r\n// Validate store_id uniqueness within tenant\r\nrouter.post('/validate-store-id',\r\n  asyncHandler(async (req, res) => {\r\n    const { store_id, exclude_store_id } = req.body;\r\n    \r\n    if (!store_id) {\r\n      return errorResponse(res, 'Store ID is required', 400, 'MISSING_FIELDS');\r\n    }\r\n\r\n    const isUnique = await storeService.validateStoreIdUniqueness(store_id, req.tenantId!, exclude_store_id);\r\n    \r\n    successResponse(res, { is_unique: isUnique }, 'Store ID validation completed');\r\n  })\r\n);\r\n\r\nexport default router;\r\n\r\n","size_bytes":4044},"packages/backend/src/services/store.service.ts":{"content":"// @ts-nocheck\r\nimport { getClient, withTransaction } from '@w3-voip/database';\r\n// import { Store, StoreSchema } from '@w3-voip/shared';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Define Store type locally\r\nexport interface Store {\r\n  id: string;\r\n  tenant_id: string;\r\n  name: string;\r\n  address: string;\r\n  phone: string;\r\n  status: 'active' | 'inactive';\r\n  settings: {\r\n    timezone: string;\r\n    business_hours: {\r\n      open: string;\r\n      close: string;\r\n      days: string[];\r\n    };\r\n  };\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class StoreService {\r\n  // Create a new store\r\n  async createStore(storeData: Omit<Store, 'id' | 'created_at' | 'updated_at'>): Promise<Store> {\r\n    return withTransaction(async (client) => {\r\n      // Verify tenant exists\r\n      const tenantResult = await client.query(\r\n        'SELECT id FROM tenants WHERE id = $1 AND status = $2',\r\n        [storeData.tenant_id, 'active']\r\n      );\r\n\r\n      if (tenantResult.rows.length === 0) {\r\n        throw new Error('Tenant not found or inactive');\r\n      }\r\n\r\n      // Check if store_id already exists for this tenant\r\n      const existingStore = await client.query(\r\n        'SELECT id FROM stores WHERE tenant_id = $1 AND store_id = $2',\r\n        [storeData.tenant_id, storeData.store_id]\r\n      );\r\n\r\n      if (existingStore.rows.length > 0) {\r\n        throw new Error('Store ID already exists for this tenant');\r\n      }\r\n\r\n      // Create store\r\n      const result = await client.query(\r\n        `INSERT INTO stores (id, tenant_id, name, store_id, status, settings)\r\n         VALUES ($1, $2, $3, $4, $5, $6)\r\n         RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          storeData.tenant_id,\r\n          storeData.name,\r\n          storeData.store_id,\r\n          storeData.status || 'active',\r\n          JSON.stringify(storeData.settings)\r\n        ]\r\n      );\r\n\r\n      const store = result.rows[0];\r\n      return {\r\n        ...store,\r\n        settings: store.settings\r\n      };\r\n    });\r\n  }\r\n\r\n  // Get store by ID\r\n  async getStoreById(storeId: string, tenantId?: string): Promise<Store | null> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      let query = 'SELECT * FROM stores WHERE id = $1';\r\n      let params: any[] = [storeId];\r\n      \r\n      if (tenantId) {\r\n        query += ' AND tenant_id = $2';\r\n        params.push(tenantId);\r\n      }\r\n\r\n      const result = await client.query(query, params);\r\n\r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const store = result.rows[0];\r\n      return {\r\n        ...store,\r\n        settings: store.settings\r\n      };\r\n    } finally {\r\n      await client.release();\r\n    }\r\n  }\r\n\r\n  // Get store by store_id and tenant_id\r\n  async getStoreByStoreId(storeId: string, tenantId: string): Promise<Store | null> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM stores WHERE store_id = $1 AND tenant_id = $2',\r\n        [storeId, tenantId]\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const store = result.rows[0];\r\n      return {\r\n        ...store,\r\n        settings: store.settings\r\n      };\r\n    } finally {\r\n      await client.release();\r\n    }\r\n  }\r\n\r\n  // Update store\r\n  async updateStore(storeId: string, updates: Partial<Omit<Store, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>, tenantId?: string): Promise<Store> {\r\n    return withTransaction(async (client) => {\r\n      // Check if store_id conflicts with other stores in the same tenant\r\n      if (updates.store_id) {\r\n        const existingStore = await client.query(\r\n          'SELECT id FROM stores WHERE tenant_id = $1 AND store_id = $2 AND id != $3',\r\n          [tenantId, updates.store_id, storeId]\r\n        );\r\n\r\n        if (existingStore.rows.length > 0) {\r\n          throw new Error('Store ID already exists for this tenant');\r\n        }\r\n      }\r\n\r\n      // Build update query\r\n      const updateFields: string[] = [];\r\n      const values: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updates.name !== undefined) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        values.push(updates.name);\r\n      }\r\n      if (updates.store_id !== undefined) {\r\n        updateFields.push(`store_id = $${paramCount++}`);\r\n        values.push(updates.store_id);\r\n      }\r\n      if (updates.status !== undefined) {\r\n        updateFields.push(`status = $${paramCount++}`);\r\n        values.push(updates.status);\r\n      }\r\n      if (updates.settings !== undefined) {\r\n        updateFields.push(`settings = $${paramCount++}`);\r\n        values.push(JSON.stringify(updates.settings));\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        throw new Error('No fields to update');\r\n      }\r\n\r\n      values.push(storeId);\r\n      \r\n      let query = `UPDATE stores SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $${paramCount}`;\r\n      \r\n      if (tenantId) {\r\n        query += ` AND tenant_id = $${paramCount + 1}`;\r\n        values.push(tenantId);\r\n      }\r\n      \r\n      query += ' RETURNING *';\r\n\r\n      const result = await client.query(query, values);\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Store not found');\r\n      }\r\n\r\n      const store = result.rows[0];\r\n      return {\r\n        ...store,\r\n        settings: store.settings\r\n      };\r\n    });\r\n  }\r\n\r\n  // Delete store\r\n  async deleteStore(storeId: string, tenantId?: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      let query = 'DELETE FROM stores WHERE id = $1';\r\n      let params: any[] = [storeId];\r\n      \r\n      if (tenantId) {\r\n        query += ' AND tenant_id = $2';\r\n        params.push(tenantId);\r\n      }\r\n\r\n      const result = await client.query(query, params);\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('Store not found');\r\n      }\r\n    });\r\n  }\r\n\r\n  // List stores for a tenant\r\n  async listStores(tenantId: string, page: number = 1, limit: number = 50, search?: string): Promise<{\r\n    stores: Store[];\r\n    total: number;\r\n    totalPages: number;\r\n  }> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      const offset = (page - 1) * limit;\r\n      \r\n      let whereClause = 'WHERE tenant_id = $1';\r\n      let queryParams: any[] = [tenantId];\r\n      \r\n      if (search) {\r\n        whereClause += ' AND (name ILIKE $2 OR store_id ILIKE $2)';\r\n        queryParams.push(`%${search}%`);\r\n      }\r\n\r\n      // Get total count\r\n      const countResult = await client.query(\r\n        `SELECT COUNT(*) FROM stores ${whereClause}`,\r\n        queryParams\r\n      );\r\n      const total = parseInt(countResult.rows[0].count);\r\n\r\n      // Get stores\r\n      const result = await client.query(\r\n        `SELECT * FROM stores ${whereClause}\r\n         ORDER BY created_at DESC\r\n         LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`,\r\n        [...queryParams, limit, offset]\r\n      );\r\n\r\n      const stores = result.rows.map(row => ({\r\n        ...row,\r\n        settings: row.settings\r\n      }));\r\n\r\n      return {\r\n        stores,\r\n        total,\r\n        totalPages: Math.ceil(total / limit)\r\n      };\r\n    } finally {\r\n      await client.release();\r\n    }\r\n  }\r\n\r\n  // Get store statistics\r\n  async getStoreStats(storeId: string, tenantId?: string): Promise<{\r\n    extension_count: number;\r\n    trunk_count: number;\r\n    total_calls: number;\r\n    active_calls: number;\r\n    last_call_time: Date | null;\r\n  }> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      let whereClause = 'WHERE s.id = $1';\r\n      let params: any[] = [storeId];\r\n      \r\n      if (tenantId) {\r\n        whereClause += ' AND s.tenant_id = $2';\r\n        params.push(tenantId);\r\n      }\r\n\r\n      const result = await client.query(\r\n        `SELECT \r\n           COUNT(DISTINCT e.id) as extension_count,\r\n           COUNT(DISTINCT st.id) as trunk_count,\r\n           COUNT(DISTINCT c.id) as total_calls,\r\n           COUNT(DISTINCT ac.id) as active_calls,\r\n           MAX(c.start_time) as last_call_time\r\n         FROM stores s\r\n         LEFT JOIN extensions e ON s.id = e.store_id\r\n         LEFT JOIN sip_trunks st ON s.id = st.store_id\r\n         LEFT JOIN cdr c ON s.id = c.store_id\r\n         LEFT JOIN active_calls ac ON s.id = ac.store_id\r\n         ${whereClause}\r\n         GROUP BY s.id`,\r\n        params\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Store not found');\r\n      }\r\n\r\n      return result.rows[0];\r\n    } finally {\r\n      await client.release();\r\n    }\r\n  }\r\n\r\n  // Activate store\r\n  async activateStore(storeId: string, tenantId?: string): Promise<Store> {\r\n    return this.updateStore(storeId, { status: 'active' }, tenantId);\r\n  }\r\n\r\n  // Deactivate store\r\n  async deactivateStore(storeId: string, tenantId?: string): Promise<Store> {\r\n    return this.updateStore(storeId, { status: 'inactive' }, tenantId);\r\n  }\r\n\r\n  // Validate store_id uniqueness within tenant\r\n  async validateStoreIdUniqueness(storeId: string, tenantId: string, excludeStoreId?: string): Promise<boolean> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      let query = 'SELECT id FROM stores WHERE tenant_id = $1 AND store_id = $2';\r\n      let params: any[] = [tenantId, storeId];\r\n      \r\n      if (excludeStoreId) {\r\n        query += ' AND id != $3';\r\n        params.push(excludeStoreId);\r\n      }\r\n\r\n      const result = await client.query(query, params);\r\n      return result.rows.length === 0;\r\n    } finally {\r\n      await client.release();\r\n    }\r\n  }\r\n}\r\n\r\n","size_bytes":9559},"packages/backend/src/middleware/auth.ts":{"content":"// @ts-nocheck\nimport { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { JWTPayload } from '@w3-voip/shared';\n\n// Extend Express Request interface\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: JWTPayload;\n      tenantId?: string;\n      storeId?: string;\n    }\n  }\n}\n\nexport interface AuthRequest extends Request {\n  user: JWTPayload;\n  tenantId: string;\n  storeId?: string;\n}\n\n// JWT Authentication Middleware\nexport const authenticateToken = (req: Request, res: Response, next: NextFunction) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      error: {\n        code: 'MISSING_TOKEN',\n        message: 'Access token required'\n      }\n    });\n  }\n\n  try {\n    const secret = process.env.JWT_SECRET;\n    if (!secret) {\n      throw new Error('JWT_SECRET not configured');\n    }\n\n    const decoded = jwt.verify(token, secret) as JWTPayload;\n    \n    // Set user context\n    req.user = decoded;\n    req.tenantId = decoded.tenant_id;\n    req.storeId = decoded.store_id;\n    \n    next();\n  } catch (error) {\n    return res.status(403).json({\n      success: false,\n      error: {\n        code: 'INVALID_TOKEN',\n        message: 'Invalid or expired token'\n      }\n    });\n  }\n};\n\n// Tenant Isolation Middleware\nexport const requireTenant = (req: AuthRequest, res: Response, next: NextFunction) => {\n  if (!req.tenantId) {\n    return res.status(400).json({\n      success: false,\n      error: {\n        code: 'TENANT_REQUIRED',\n        message: 'Tenant context required'\n      }\n    });\n  }\n  next();\n};\n\n// Super Admin Access Middleware\nexport const requireSuperAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {\n  if (req.user?.role !== 'super_admin') {\n    return res.status(403).json({\n      success: false,\n      error: {\n        code: 'SUPER_ADMIN_REQUIRED',\n        message: 'Super admin access required'\n      }\n    });\n  }\n  next();\n};\n\n// Role-based Authorization Middleware\nexport const requireRole = (roles: string[]) => {\n  return (req: AuthRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({\n        success: false,\n        error: {\n          code: 'INSUFFICIENT_PERMISSIONS',\n          message: `Required role: ${roles.join(' or ')}`\n        }\n      });\n    }\n\n    next();\n  };\n};\n\n// Permission-based Authorization Middleware\nexport const requirePermission = (permission: string) => {\n  return (req: AuthRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: 'Authentication required'\n        }\n      });\n    }\n\n    if (!req.user.permissions.includes(permission)) {\n      return res.status(403).json({\n        success: false,\n        error: {\n          code: 'INSUFFICIENT_PERMISSIONS',\n          message: `Required permission: ${permission}`\n        }\n      });\n    }\n\n    next();\n  };\n};\n\n// Store Access Middleware\nexport const requireStoreAccess = (req: AuthRequest, res: Response, next: NextFunction) => {\n  const storeId = req.params.storeId || req.body.storeId || req.query.storeId;\n  \n  if (!storeId) {\n    return res.status(400).json({\n      success: false,\n      error: {\n        code: 'STORE_ID_REQUIRED',\n        message: 'Store ID required'\n      }\n    });\n  }\n\n  // If user has store_id in token, verify it matches\n  if (req.user.store_id && req.user.store_id !== storeId) {\n    return res.status(403).json({\n      success: false,\n      error: {\n        code: 'STORE_ACCESS_DENIED',\n        message: 'Access denied to this store'\n      }\n    });\n  }\n\n  req.storeId = storeId;\n  next();\n};\n\n// Optional Authentication Middleware (for public endpoints)\nexport const optionalAuth = (req: Request, res: Response, next: NextFunction) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (token) {\n    try {\n      const secret = process.env.JWT_SECRET;\n      if (secret) {\n        const decoded = jwt.verify(token, secret) as JWTPayload;\n        req.user = decoded;\n        req.tenantId = decoded.tenant_id;\n        req.storeId = decoded.store_id;\n      }\n    } catch (error) {\n      // Ignore token errors for optional auth\n    }\n  }\n\n  next();\n};\n\n// Generate JWT Token\nexport const generateToken = (payload: Omit<JWTPayload, 'iat' | 'exp'>): string => {\n  const secret = process.env.JWT_SECRET;\n  if (!secret) {\n    throw new Error('JWT_SECRET not configured');\n  }\n\n  const expiresIn: string | number = process.env.JWT_EXPIRES_IN || '24h';\n  \n  return jwt.sign(payload, secret, { expiresIn });\n};\n\n// Verify JWT Token\nexport const verifyToken = (token: string): JWTPayload => {\n  const secret = process.env.JWT_SECRET;\n  if (!secret) {\n    throw new Error('JWT_SECRET not configured');\n  }\n\n  return jwt.verify(token, secret) as JWTPayload;\n};\n\n","size_bytes":5312},"packages/frontend/src/pages/ConferenceRooms.tsx":{"content":"import { useState, useEffect } from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Textarea } from '@/components/ui/textarea';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { \r\n  Plus, \r\n  Search, \r\n  Edit, \r\n  Trash2, \r\n  Phone, \r\n  Users,\r\n  Mic,\r\n  Eye,\r\n  MoreHorizontal,\r\n  RefreshCw,\r\n  Hash,\r\n  Lock,\r\n  MessageSquare\r\n} from 'lucide-react';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\ninterface ConferenceRoom {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  pin?: string;\r\n  moderator_pin?: string;\r\n  max_members: number;\r\n  record: boolean;\r\n  record_path?: string;\r\n  moh_sound?: string;\r\n  announce_sound?: string;\r\n  settings: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\n\r\nexport default function ConferenceRooms() {\r\n  const { user } = useAuth();\r\n  const [conferenceRooms, setConferenceRooms] = useState<ConferenceRoom[]>([]);\r\n  const [showModal, setShowModal] = useState(false);\r\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\r\n  const [loading, setLoading] = useState(false);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [formData, setFormData] = useState<Partial<ConferenceRoom>>({});\r\n  const [editingItem, setEditingItem] = useState<ConferenceRoom | null>(null);\r\n\r\n  // Load conference rooms on component mount\r\n  useEffect(() => {\r\n    loadConferenceRooms();\r\n  }, []);\r\n\r\n  const loadConferenceRooms = async () => {\r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/conference-rooms`);\r\n      const data = await response.json();\r\n      \r\n      if (data?.success && Array.isArray(data?.data)) {\r\n        setConferenceRooms(data.data);\r\n      } else {\r\n        console.warn('⚠️ Invalid API response format');\r\n        setConferenceRooms([]);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error loading conference rooms:', error);\r\n      setConferenceRooms([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleCreate = async () => {\r\n    if (!user?.tenant_id) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/conference-rooms`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          ...formData,\r\n          tenant_id: user.tenant_id\r\n        })\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadConferenceRooms();\r\n        setShowModal(false);\r\n        setFormData({});\r\n      } else {\r\n        console.error('❌ Error creating conference room:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error creating conference room:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleEdit = async () => {\r\n    if (!editingItem) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/conference-rooms/${editingItem.id}`, {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(formData)\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadConferenceRooms();\r\n        setShowModal(false);\r\n        setFormData({});\r\n        setEditingItem(null);\r\n      } else {\r\n        console.error('❌ Error updating conference room:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error updating conference room:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (room: ConferenceRoom) => {\r\n    if (!confirm(`Are you sure you want to delete conference room \"${room.name}\"?`)) {\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/conference-rooms/${room.id}`, {\r\n        method: 'DELETE'\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadConferenceRooms();\r\n      } else {\r\n        console.error('❌ Error deleting conference room:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error deleting conference room:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const filteredRooms = conferenceRooms.filter(room =>\r\n    room.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n    room.extension.includes(searchTerm) ||\r\n    room.description?.toLowerCase().includes(searchTerm.toLowerCase())\r\n  );\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Conference Rooms</h1>\r\n          <p className=\"text-gray-600\">Create and manage audio conference rooms</p>\r\n        </div>\r\n        <Button onClick={() => {\r\n          setModalType('create');\r\n          setFormData({\r\n            max_members: 50,\r\n            record: false,\r\n            settings: {}\r\n          });\r\n          setShowModal(true);\r\n        }}>\r\n          <Plus className=\"h-4 w-4 mr-2\" />\r\n          Add Conference Room\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Search and Stats */}\r\n      <div className=\"flex items-center space-x-4\">\r\n        <div className=\"relative flex-1 max-w-md\">\r\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\r\n          <Input\r\n            placeholder=\"Search conference rooms...\"\r\n            value={searchTerm}\r\n            onChange={(e) => setSearchTerm(e.target.value)}\r\n            className=\"pl-10\"\r\n          />\r\n        </div>\r\n        <Button variant=\"outline\" onClick={loadConferenceRooms} disabled={loading}>\r\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\r\n          Refresh\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Conference Rooms Grid */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n        {filteredRooms.map((room) => (\r\n          <Card key={room.id} className=\"relative\">\r\n            <CardHeader className=\"pb-3\">\r\n              <div className=\"flex items-start justify-between\">\r\n                <div className=\"flex-1\">\r\n                  <CardTitle className=\"text-lg\">{room.name}</CardTitle>\r\n                  <CardDescription>{room.description}</CardDescription>\r\n                </div>\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Badge variant={room.enabled ? 'default' : 'secondary'}>\r\n                    {room.enabled ? 'Active' : 'Inactive'}\r\n                  </Badge>\r\n                  <Button variant=\"ghost\" size=\"sm\">\r\n                    <MoreHorizontal className=\"h-4 w-4\" />\r\n                  </Button>\r\n                </div>\r\n              </div>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              {/* Extension */}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Phone className=\"h-4 w-4 text-gray-500\" />\r\n                <span className=\"font-medium\">{room.extension}</span>\r\n              </div>\r\n\r\n              {/* PINs */}\r\n              <div className=\"grid grid-cols-2 gap-2 text-sm\">\r\n                {room.pin && (\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Hash className=\"h-4 w-4 text-gray-500\" />\r\n                    <span>PIN: {room.pin}</span>\r\n                  </div>\r\n                )}\r\n                {room.moderator_pin && (\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Lock className=\"h-4 w-4 text-gray-500\" />\r\n                    <span>Mod: {room.moderator_pin}</span>\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              {/* Max Members */}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Users className=\"h-4 w-4 text-gray-500\" />\r\n                <span className=\"text-sm text-gray-600\">\r\n                  Max {room.max_members} members\r\n                </span>\r\n              </div>\r\n\r\n              {/* Recording */}\r\n              {room.record && (\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Mic className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"text-sm text-gray-600\">Recording enabled</span>\r\n                </div>\r\n              )}\r\n\r\n              {/* Actions */}\r\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('edit');\r\n                    setFormData(room);\r\n                    setEditingItem(room);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Edit className=\"h-4 w-4 mr-1\" />\r\n                  Edit\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('view');\r\n                    setFormData(room);\r\n                    setEditingItem(room);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Eye className=\"h-4 w-4 mr-1\" />\r\n                  View\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => handleDelete(room)}\r\n                  className=\"text-red-600 hover:text-red-700\"\r\n                >\r\n                  <Trash2 className=\"h-4 w-4\" />\r\n                </Button>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Empty State */}\r\n      {filteredRooms.length === 0 && !loading && (\r\n        <Card>\r\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n            <MessageSquare className=\"h-12 w-12 text-gray-400 mb-4\" />\r\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No Conference Rooms Found</h3>\r\n            <p className=\"text-gray-500 text-center mb-4\">\r\n              {searchTerm ? 'No conference rooms match your search criteria.' : 'Create your first conference room to get started.'}\r\n            </p>\r\n            {!searchTerm && (\r\n              <Button onClick={() => {\r\n                setModalType('create');\r\n                setFormData({\r\n                  max_members: 50,\r\n                  record: false,\r\n                  settings: {}\r\n                });\r\n                setShowModal(true);\r\n              }}>\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Create Conference Room\r\n              </Button>\r\n            )}\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Create/Edit Modal */}\r\n      {showModal && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <Card className=\"w-full max-w-2xl max-h-[90vh] overflow-y-auto\">\r\n            <CardHeader>\r\n              <CardTitle>\r\n                {modalType === 'create' ? 'Create Conference Room' : \r\n                 modalType === 'edit' ? 'Edit Conference Room' : 'View Conference Room'}\r\n              </CardTitle>\r\n              <CardDescription>\r\n                {modalType === 'create' ? 'Create a new audio conference room' :\r\n                 modalType === 'edit' ? 'Update conference room settings' :\r\n                 'View conference room details'}\r\n              </CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Name</label>\r\n                  <Input\r\n                    value={formData.name || ''}\r\n                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"Sales Conference\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Extension</label>\r\n                  <Input\r\n                    value={formData.extension || ''}\r\n                    onChange={(e) => setFormData({ ...formData, extension: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"3000\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div>\r\n                <label className=\"text-sm font-medium\">Description</label>\r\n                <Textarea\r\n                  value={formData.description || ''}\r\n                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}\r\n                  disabled={modalType === 'view'}\r\n                  placeholder=\"Sales team conference room\"\r\n                />\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Participant PIN (optional)</label>\r\n                  <Input\r\n                    value={formData.pin || ''}\r\n                    onChange={(e) => setFormData({ ...formData, pin: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"1234\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Moderator PIN (optional)</label>\r\n                  <Input\r\n                    value={formData.moderator_pin || ''}\r\n                    onChange={(e) => setFormData({ ...formData, moderator_pin: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"5678\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Max Members</label>\r\n                  <Input\r\n                    type=\"number\"\r\n                    value={formData.max_members || 50}\r\n                    onChange={(e) => setFormData({ ...formData, max_members: parseInt(e.target.value) })}\r\n                    disabled={modalType === 'view'}\r\n                    min=\"2\"\r\n                    max=\"1000\"\r\n                  />\r\n                </div>\r\n                <div className=\"flex items-center space-x-2 pt-6\">\r\n                  <Switch\r\n                    checked={formData.record || false}\r\n                    onCheckedChange={(checked) => setFormData({ ...formData, record: checked })}\r\n                    disabled={modalType === 'view'}\r\n                  />\r\n                  <label className=\"text-sm font-medium\">Enable Recording</label>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Modal Actions */}\r\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  onClick={() => {\r\n                    setShowModal(false);\r\n                    setFormData({});\r\n                    setEditingItem(null);\r\n                  }}\r\n                >\r\n                  Cancel\r\n                </Button>\r\n                {modalType !== 'view' && (\r\n                  <Button\r\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\r\n                    disabled={loading}\r\n                  >\r\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\r\n                  </Button>\r\n                )}\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":16449},"packages/backend/test-db.js":{"content":"const { getClient } = require('./dist/database');\r\n\r\nasync function testDB() {\r\n  try {\r\n    console.log('Testing database connection...');\r\n    const client = await getClient();\r\n    console.log('Database connected successfully');\r\n    \r\n    const result = await client.query('SELECT COUNT(*) FROM users');\r\n    console.log('Users count:', result.rows[0].count);\r\n    \r\n    const tenantResult = await client.query('SELECT * FROM tenants WHERE slug = $1', ['demo']);\r\n    console.log('Demo tenant:', tenantResult.rows[0]);\r\n    \r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('Database error:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\ntestDB();\r\n","size_bytes":662},"packages/backend/src/services/freeswitch-xml.service.ts":{"content":"import { getClient } from '@w3-voip/database';\n\nexport interface FreeSwitchXmlParams {\n  section?: string;\n  tag_name?: string;\n  key_name?: string;\n  key_value?: string;\n  user?: string;\n  domain?: string;\n  action?: string;\n  'Event-Name'?: string;\n  'Caller-Caller-ID-Number'?: string;\n  'Caller-Destination-Number'?: string;\n  'Hunt-Destination-Number'?: string;\n  'variable_domain_name'?: string;\n  [key: string]: string | undefined;\n}\n\nexport class FreeSwitchXmlService {\n  /**\n   * Genera XML per user registration/authentication\n   */\n  async generateUserXml(extension: any, tenant: any): Promise<string> {\n    const xml = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<document type=\"freeswitch/xml\">\n  <section name=\"directory\">\n    <domain name=\"${tenant.sip_domain}\">\n      <params>\n        <param name=\"dial-string\" value=\"{presence_id=\\${dialed_user}@\\${dialed_domain}}\\${sofia_contact(\\${dialed_user}@\\${dialed_domain})}\"/>\n      </params>\n      <groups>\n        <group name=\"default\">\n          <users>\n            <user id=\"${extension.extension}\">\n              <params>\n                <param name=\"password\" value=\"${extension.password}\"/>\n                <param name=\"vm-password\" value=\"${extension.extension}\"/>\n              </params>\n              <variables>\n                <variable name=\"tenant_id\" value=\"${tenant.id}\"/>\n                <variable name=\"tenant_slug\" value=\"${tenant.slug}\"/>\n                <variable name=\"toll_allow\" value=\"domestic,international,local\"/>\n                <variable name=\"accountcode\" value=\"${extension.extension}\"/>\n                <variable name=\"user_context\" value=\"${tenant.slug}\"/>\n                <variable name=\"effective_caller_id_name\" value=\"${extension.display_name || extension.extension}\"/>\n                <variable name=\"effective_caller_id_number\" value=\"${extension.extension}\"/>\n                <variable name=\"callgroup\" value=\"${tenant.id}\"/>\n                <variable name=\"outbound_caller_id_number\" value=\"${extension.extension}\"/>\n              </variables>\n            </user>\n          </users>\n        </group>\n      </groups>\n    </domain>\n  </section>\n</document>`;\n    return xml;\n  }\n\n  /**\n   * Genera XML per dialplan completo con routing italiano, trunk, IVR, code, voicemail\n   */\n  async generateDialplanXml(tenant: any, params: FreeSwitchXmlParams): Promise<string> {\n    const client = await getClient();\n    \n    try {\n      // Recupera trunks attivi del tenant\n      const trunksResult = await client.query(\n        'SELECT * FROM sip_trunks WHERE tenant_id = $1 AND status = $2 ORDER BY name LIMIT 1',\n        [tenant.id, 'active']\n      );\n      \n      const trunk = trunksResult.rows.length > 0 ? trunksResult.rows[0] : null;\n      const gatewayName = trunk ? `trunk_${trunk.id}` : 'messagenet';\n      \n      // Recupera IVR menus\n      const ivrResult = await client.query(\n        'SELECT * FROM ivr_menus WHERE tenant_id = $1 AND enabled = true',\n        [tenant.id]\n      );\n      \n      // Recupera call queues\n      const queuesResult = await client.query(\n        'SELECT * FROM call_queues WHERE tenant_id = $1 AND enabled = true',\n        [tenant.id]\n      );\n      \n      // Recupera voicemail boxes\n      const voicemailResult = await client.query(\n        'SELECT * FROM voicemail_boxes WHERE tenant_id = $1 AND enabled = true',\n        [tenant.id]\n      );\n\n      // Genera IVR extensions\n      let ivrExtensions = '';\n      for (const ivr of ivrResult.rows) {\n        ivrExtensions += `\n      <!-- IVR Menu: ${ivr.name} -->\n      <extension name=\"${tenant.slug}_ivr_${ivr.extension}\">\n        <condition field=\"destination_number\" expression=\"^${ivr.extension}$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=ivr\"/>\n          <action application=\"answer\"/>\n          <action application=\"sleep\" data=\"1000\"/>\n          <action application=\"ivr\" data=\"ivr_${ivr.id}\"/>\n        </condition>\n      </extension>`;\n      }\n\n      // Genera Queue extensions\n      let queueExtensions = '';\n      for (const queue of queuesResult.rows) {\n        queueExtensions += `\n      <!-- Call Queue: ${queue.name} -->\n      <extension name=\"${tenant.slug}_queue_${queue.extension}\">\n        <condition field=\"destination_number\" expression=\"^${queue.extension}$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=queue\"/>\n          <action application=\"answer\"/>\n          <action application=\"callcenter\" data=\"queue_${queue.id}@${tenant.slug}\"/>\n        </condition>\n      </extension>`;\n      }\n\n      // Genera Voicemail extensions\n      let voicemailExtensions = '';\n      for (const vm of voicemailResult.rows) {\n        voicemailExtensions += `\n      <!-- Voicemail: ${vm.mailbox_id} -->\n      <extension name=\"${tenant.slug}_voicemail_${vm.mailbox_id}\">\n        <condition field=\"destination_number\" expression=\"^\\\\*97$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"answer\"/>\n          <action application=\"sleep\" data=\"1000\"/>\n          <action application=\"voicemail\" data=\"check default \\${domain} ${vm.mailbox_id}\"/>\n        </condition>\n      </extension>`;\n      }\n\n      const xml = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<document type=\"freeswitch/xml\">\n  <section name=\"dialplan\">\n    <context name=\"${tenant.slug}\">\n      \n      <!-- Emergency Numbers -->\n      <extension name=\"${tenant.slug}_emergency\">\n        <condition field=\"destination_number\" expression=\"^(112|113|115|118)$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=emergency\"/>\n          <action application=\"bridge\" data=\"sofia/gateway/${gatewayName}/\\${destination_number}\"/>\n        </condition>\n      </extension>\n      \n      ${ivrExtensions}\n      ${queueExtensions}\n      ${voicemailExtensions}\n      \n      <!-- Internal Extension to Extension Calls -->\n      <extension name=\"${tenant.slug}_internal\">\n        <condition field=\"destination_number\" expression=\"^(\\\\d{3,5})$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=internal\"/>\n          <action application=\"set\" data=\"hangup_after_bridge=true\"/>\n          <action application=\"bridge\" data=\"user/\\${destination_number}@${tenant.sip_domain}\"/>\n        </condition>\n      </extension>\n      \n      <!-- Italian Mobile Numbers (cellulari) - 3XX XXXXXXXX -->\n      <extension name=\"${tenant.slug}_italian_mobile\">\n        <condition field=\"destination_number\" expression=\"^(3\\\\d{8,9})$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=outbound\"/>\n          <action application=\"set\" data=\"destination_type=mobile_it\"/>\n          <action application=\"set\" data=\"effective_caller_id_number=\\${outbound_caller_id_number}\"/>\n          <action application=\"bridge\" data=\"sofia/gateway/${gatewayName}/\\${destination_number}\"/>\n        </condition>\n      </extension>\n      \n      <!-- Italian Landline Numbers (fissi) - 0XX XXXXXXX -->\n      <extension name=\"${tenant.slug}_italian_landline\">\n        <condition field=\"destination_number\" expression=\"^(0\\\\d{8,10})$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=outbound\"/>\n          <action application=\"set\" data=\"destination_type=landline_it\"/>\n          <action application=\"set\" data=\"effective_caller_id_number=\\${outbound_caller_id_number}\"/>\n          <action application=\"bridge\" data=\"sofia/gateway/${gatewayName}/\\${destination_number}\"/>\n        </condition>\n      </extension>\n      \n      <!-- International Numbers - +XX... -->\n      <extension name=\"${tenant.slug}_international\">\n        <condition field=\"destination_number\" expression=\"^(\\\\+\\\\d{7,15})$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=outbound\"/>\n          <action application=\"set\" data=\"destination_type=international\"/>\n          <action application=\"set\" data=\"effective_caller_id_number=\\${outbound_caller_id_number}\"/>\n          <action application=\"bridge\" data=\"sofia/gateway/${gatewayName}/\\${destination_number}\"/>\n        </condition>\n      </extension>\n      \n      <!-- International Numbers without + prefix - 00XX... -->\n      <extension name=\"${tenant.slug}_international_00\">\n        <condition field=\"destination_number\" expression=\"^(00\\\\d{7,15})$\">\n          <action application=\"set\" data=\"tenant_id=${tenant.id}\"/>\n          <action application=\"set\" data=\"tenant_slug=${tenant.slug}\"/>\n          <action application=\"set\" data=\"call_direction=outbound\"/>\n          <action application=\"set\" data=\"destination_type=international\"/>\n          <action application=\"set\" data=\"effective_caller_id_number=\\${outbound_caller_id_number}\"/>\n          <action application=\"bridge\" data=\"sofia/gateway/${gatewayName}/\\${destination_number}\"/>\n        </condition>\n      </extension>\n      \n    </context>\n  </section>\n</document>`;\n      \n      return xml;\n      \n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Genera XML vuoto/not found\n   */\n  generateNotFoundXml(): string {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<document type=\"freeswitch/xml\">\n  <section name=\"result\">\n    <result status=\"not found\"/>\n  </section>\n</document>`;\n  }\n\n  /**\n   * Processa richiesta FreeSWITCH XML curl con fallback via extension\n   */\n  async processXmlRequest(params: FreeSwitchXmlParams): Promise<string> {\n    try {\n      console.log('📞 FreeSWITCH XML Request:', JSON.stringify(params, null, 2));\n\n      // Estrai parametri da diverse sorgenti\n      let sipDomain = params.domain || params['variable_domain_name'];\n      let user = params.user || params['Caller-Caller-ID-Number'];\n      \n      // xml_locate può inviare formati diversi\n      if (params.key_value) {\n        const keyVal = params.key_value.toString();\n        if (keyVal.startsWith('user ')) {\n          user = keyVal.replace('user ', '').trim();\n          sipDomain = sipDomain || params.key_name;\n        } else {\n          sipDomain = sipDomain || keyVal;\n        }\n      }\n      \n      sipDomain = sipDomain || params.key_name;\n      \n      const section = Array.isArray(params.section) ? params.section[0] : params.section;\n\n      console.log(`🔍 Searching - Section: ${section}, Domain: ${sipDomain}, User: ${user}`);\n\n      const client = await getClient();\n      try {\n        let tenant = null;\n        \n        // Tentativo 1: Trova tenant dal sip_domain\n        if (sipDomain) {\n          const tenantResult = await client.query(\n            'SELECT id, slug, name, sip_domain FROM tenants WHERE sip_domain = $1 AND status = $2',\n            [sipDomain, 'active']\n          );\n\n          if (tenantResult.rows.length > 0) {\n            tenant = tenantResult.rows[0];\n            console.log(`✅ Found tenant by domain: ${tenant.slug} (${tenant.sip_domain})`);\n          }\n        }\n\n        // Tentativo 2: Trova tenant dall'extension (FALLBACK CRITICO per dialplan)\n        if (!tenant && user) {\n          console.log(`🔍 Tenant not found by domain, trying lookup by extension ${user}...`);\n          \n          const extResult = await client.query(`\n            SELECT t.id, t.slug, t.name, t.sip_domain, e.extension\n            FROM tenants t\n            JOIN extensions e ON e.tenant_id = t.id\n            WHERE e.extension = $1 AND t.status = $2 AND e.status = $3\n            LIMIT 1\n          `, [user, 'active', 'active']);\n\n          if (extResult.rows.length > 0) {\n            tenant = extResult.rows[0];\n            console.log(`✅ Found tenant by extension: ${tenant.slug} (extension: ${user})`);\n          }\n        }\n\n        // Nessun tenant trovato\n        if (!tenant) {\n          console.log(`❌ Tenant not found for domain: ${sipDomain}, user: ${user}`);\n          return this.generateNotFoundXml();\n        }\n\n        // Gestisci richiesta directory (user authentication)\n        if (section === 'directory' && user) {\n          const extensionResult = await client.query(\n            'SELECT * FROM extensions WHERE extension = $1 AND tenant_id = $2 AND status = $3',\n            [user, tenant.id, 'active']\n          );\n\n          if (extensionResult.rows.length === 0) {\n            console.log(`❌ Extension ${user} not found for tenant ${tenant.slug}`);\n            return this.generateNotFoundXml();\n          }\n\n          const extension = extensionResult.rows[0];\n          console.log(`✅ Found extension: ${extension.extension} for directory auth`);\n          return await this.generateUserXml(extension, tenant);\n        }\n\n        // Gestisci richiesta dialplan\n        if (section === 'dialplan') {\n          console.log(`✅ Generating dialplan for tenant: ${tenant.slug}`);\n          return await this.generateDialplanXml(tenant, params);\n        }\n\n        // Richiesta non gestita\n        console.log(`⚠️ Unhandled section: ${section}`);\n        return this.generateNotFoundXml();\n\n      } finally {\n        await client.release();\n      }\n\n    } catch (error) {\n      console.error('❌ FreeSWITCH XML Service Error:', error);\n      return this.generateNotFoundXml();\n    }\n  }\n}\n\nexport const freeSwitchXmlService = new FreeSwitchXmlService();\n","size_bytes":14053},"scripts/install-fusionpbx.sh":{"content":"#!/bin/bash\n\n# FusionPBX Installation Script for Ubuntu/Debian\n# W3 VoIP System - Local Development Environment\n\nset -e\n\necho \"🚀 Installing FusionPBX for W3 VoIP System...\"\n\n# Update system\nsudo apt update && sudo apt upgrade -y\n\n# Install dependencies\nsudo apt install -y \\\n    nginx \\\n    php8.1-fpm \\\n    php8.1-cli \\\n    php8.1-common \\\n    php8.1-curl \\\n    php8.1-gd \\\n    php8.1-mbstring \\\n    php8.1-mysql \\\n    php8.1-pgsql \\\n    php8.1-xml \\\n    php8.1-zip \\\n    php8.1-json \\\n    php8.1-bcmath \\\n    php8.1-intl \\\n    php8.1-soap \\\n    php8.1-xmlrpc \\\n    php8.1-dev \\\n    postgresql \\\n    postgresql-contrib \\\n    git \\\n    curl \\\n    wget \\\n    unzip \\\n    build-essential\n\n# Install Node.js and npm\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt install -y nodejs\n\n# Install Composer\ncurl -sS https://getcomposer.org/installer | php\nsudo mv composer.phar /usr/local/bin/composer\nsudo chmod +x /usr/local/bin/composer\n\n# Create PostgreSQL database and user\nsudo -u postgres psql -c \"CREATE DATABASE fusionpbx;\"\nsudo -u postgres psql -c \"CREATE USER fusionpbx WITH PASSWORD 'fusionpbx123';\"\nsudo -u postgres psql -c \"GRANT ALL PRIVILEGES ON DATABASE fusionpbx TO fusionpbx;\"\nsudo -u postgres psql -c \"ALTER USER fusionpbx CREATEDB;\"\n\n# Download and install FusionPBX\ncd /var/www\nsudo git clone https://github.com/fusionpbx/fusionpbx.git\nsudo chown -R www-data:www-data /var/www/fusionpbx\nsudo chmod -R 755 /var/www/fusionpbx\n\n# Install FusionPBX dependencies\ncd /var/www/fusionpbx\nsudo -u www-data composer install --no-dev\n\n# Configure PHP\nsudo sed -i 's/;cgi.fix_pathinfo=1/cgi.fix_pathinfo=0/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/upload_max_filesize = 2M/upload_max_filesize = 100M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/post_max_size = 8M/post_max_size = 100M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/max_execution_time = 30/max_execution_time = 300/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/max_input_time = 60/max_input_time = 300/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/memory_limit = 128M/memory_limit = 256M/' /etc/php/8.1/fpm/php.ini\n\n# Configure Nginx\nsudo tee /etc/nginx/sites-available/fusionpbx > /dev/null <<EOF\nserver {\n    listen 80;\n    server_name localhost;\n    root /var/www/fusionpbx;\n    index index.php index.html index.htm;\n\n    # Security headers\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header Referrer-Policy \"no-referrer-when-downgrade\" always;\n    add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always;\n\n    # Handle PHP files\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;\n        fastcgi_param SCRIPT_FILENAME \\$document_root\\$fastcgi_script_name;\n        include fastcgi_params;\n    }\n\n    # Deny access to hidden files\n    location ~ /\\. {\n        deny all;\n    }\n\n    # Deny access to backup files\n    location ~ ~$ {\n        deny all;\n    }\n\n    # Handle static files\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)$ {\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n\n    # Main location block\n    location / {\n        try_files \\$uri \\$uri/ /index.php?\\$query_string;\n    }\n}\nEOF\n\n# Enable FusionPBX site\nsudo ln -sf /etc/nginx/sites-available/fusionpbx /etc/nginx/sites-enabled/\nsudo rm -f /etc/nginx/sites-enabled/default\n\n# Test and reload Nginx\nsudo nginx -t\nsudo systemctl reload nginx\n\n# Start and enable services\nsudo systemctl start php8.1-fpm\nsudo systemctl enable php8.1-fpm\nsudo systemctl start nginx\nsudo systemctl enable nginx\nsudo systemctl start postgresql\nsudo systemctl enable postgresql\n\n# Create FusionPBX configuration\nsudo tee /var/www/fusionpbx/app/config.php > /dev/null <<EOF\n<?php\n// Database configuration\n\\$db_type = 'pgsql';\n\\$db_host = 'localhost';\n\\$db_port = '5432';\n\\$db_name = 'fusionpbx';\n\\$db_username = 'fusionpbx';\n\\$db_password = 'fusionpbx123';\n\n// Application configuration\n\\$app_path = '/var/www/freeswitch';\n\\$app_logs = '/var/log/freeswitch';\n\\$app_temp = '/tmp';\n\\$app_www = '/var/www/fusionpbx';\n\n// Security\n\\$app_encryption_key = '$(openssl rand -hex 32)';\n\\$app_password_hash = 'bcrypt';\n\n// Multi-tenant configuration\n\\$app_multi_tenant = true;\n\\$app_domain_separator = '.';\n\n// FreeSWITCH configuration\n\\$switch_event_socket_ip = '127.0.0.1';\n\\$switch_event_socket_port = '8021';\n\\$switch_event_socket_password = 'ClueCon';\n\n// Recording configuration\n\\$app_recording_path = '/var/lib/freeswitch/recordings';\n\\$app_recording_enabled = true;\n\\$app_gdpr_compliance = true;\n\n// API configuration\n\\$app_api_enabled = true;\n\\$app_api_key_required = true;\n\\$app_webhook_enabled = true;\n\\$app_webhook_secret = '$(openssl rand -hex 32)';\n?>\nEOF\n\n# Set permissions\nsudo chown www-data:www-data /var/www/fusionpbx/app/config.php\nsudo chmod 600 /var/www/fusionpbx/app/config.php\n\n# Create initial admin user\nsudo -u www-data php /var/www/fusionpbx/core/install/install.php \\\n    --db_type=pgsql \\\n    --db_host=localhost \\\n    --db_port=5432 \\\n    --db_name=fusionpbx \\\n    --db_username=fusionpbx \\\n    --db_password=fusionpbx123 \\\n    --admin_username=admin \\\n    --admin_password=admin123 \\\n    --admin_email=admin@localhost\n\n# Create W3 VoIP specific configuration\nsudo mkdir -p /var/www/fusionpbx/app/w3-voip\nsudo tee /var/www/fusionpbx/app/w3-voip/config.php > /dev/null <<EOF\n<?php\n// W3 VoIP System Integration Configuration\n\\$w3_voip_config = [\n    'api_url' => 'http://localhost:3000/api',\n    'webhook_url' => 'http://localhost:3000/api/webhooks',\n    'tenant_isolation' => true,\n    'domain_mapping' => true,\n    'recording_consent' => true,\n    'gdpr_compliance' => true,\n    'multi_store_support' => true,\n    'extension_auto_provision' => true,\n    'trunk_auto_register' => true\n];\n?>\nEOF\n\n# Set permissions\nsudo chown -R www-data:www-data /var/www/fusionpbx/app/w3-voip\nsudo chmod -R 755 /var/www/fusionpbx/app/w3-voip\n\n# Create systemd service for FusionPBX\nsudo tee /etc/systemd/system/fusionpbx.service > /dev/null <<EOF\n[Unit]\nDescription=FusionPBX Web Interface\nAfter=network.target postgresql.service freeswitch.service\n\n[Service]\nType=forking\nUser=www-data\nGroup=www-data\nWorkingDirectory=/var/www/fusionpbx\nExecStart=/usr/bin/php /var/www/fusionpbx/core/start.php\nExecReload=/bin/kill -HUP \\$MAINPID\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# Enable FusionPBX service\nsudo systemctl daemon-reload\nsudo systemctl enable fusionpbx\n\n# Check status\necho \"✅ FusionPBX installation completed!\"\necho \"📊 Service Status:\"\nsudo systemctl status nginx --no-pager\nsudo systemctl status php8.1-fpm --no-pager\nsudo systemctl status postgresql --no-pager\n\necho \"\"\necho \"🌐 FusionPBX Web Interface:\"\necho \"   - URL: http://localhost\"\necho \"   - Username: admin\"\necho \"   - Password: admin123\"\necho \"\"\necho \"🗄️ Database Configuration:\"\necho \"   - Host: localhost\"\necho \"   - Port: 5432\"\necho \"   - Database: fusionpbx\"\necho \"   - Username: fusionpbx\"\necho \"   - Password: fusionpbx123\"\necho \"\"\necho \"🔧 Configuration files:\"\necho \"   - Main config: /var/www/fusionpbx/app/config.php\"\necho \"   - W3 VoIP config: /var/www/fusionpbx/app/w3-voip/config.php\"\necho \"   - Nginx config: /etc/nginx/sites-available/fusionpbx\"\necho \"\"\necho \"🚀 FusionPBX is ready for W3 VoIP System integration!\"\n\n","size_bytes":7463},"packages/shared/src/index.ts":{"content":"// Export all types and schemas\nexport * from './types/tenant';\nexport * from './types/trunk';\nexport * from './types/cdr';\nexport * from './types/call';\nexport * from './types/api';\nexport * from './types/user';\nexport * from './types/sip';\n","size_bytes":242},"packages/frontend/src/index.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 84% 4.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 84% 4.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 84% 4.9%;\n    --primary: 221.2 83.2% 53.3%;\n    --primary-foreground: 210 40% 98%;\n    --secondary: 210 40% 96%;\n    --secondary-foreground: 222.2 84% 4.9%;\n    --muted: 210 40% 96%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n    --accent: 210 40% 96%;\n    --accent-foreground: 222.2 84% 4.9%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n    --ring: 221.2 83.2% 53.3%;\n    --radius: 0.5rem;\n    \n    /* Glassmorphism variables */\n    --glass-bg: rgba(255, 255, 255, 0.8);\n    --glass-border: rgba(255, 255, 255, 0.2);\n    --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n    --gradient-primary: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);\n    --gradient-accent: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);\n  }\n\n  .dark {\n    --background: 222.2 84% 4.9%;\n    --foreground: 210 40% 98%;\n    --card: 222.2 84% 4.9%;\n    --card-foreground: 210 40% 98%;\n    --popover: 222.2 84% 4.9%;\n    --popover-foreground: 210 40% 98%;\n    --primary: 217.2 91.2% 59.8%;\n    --primary-foreground: 222.2 84% 4.9%;\n    --secondary: 217.2 32.6% 17.5%;\n    --secondary-foreground: 210 40% 98%;\n    --muted: 217.2 32.6% 17.5%;\n    --muted-foreground: 215 20.2% 65.1%;\n    --accent: 217.2 32.6% 17.5%;\n    --accent-foreground: 210 40% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 217.2 32.6% 17.5%;\n    --input: 217.2 32.6% 17.5%;\n    --ring: 224.3 76.3% 94.1%;\n    \n    /* Dark mode glassmorphism */\n    --glass-bg: rgba(15, 23, 42, 0.8);\n    --glass-border: rgba(255, 255, 255, 0.1);\n    --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);\n    --gradient-primary: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);\n    --gradient-accent: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n    transition: all 0.2s ease-smooth;\n  }\n}\n\n@layer components {\n  /* Glassmorphism utility classes */\n  .glass-light {\n    @apply backdrop-blur-md bg-white/80 dark:bg-slate-900/80;\n    @apply border border-white/20 dark:border-white/10;\n    @apply shadow-lg shadow-black/5 dark:shadow-black/20;\n  }\n  \n  .glass-card {\n    @apply backdrop-blur-sm bg-white/60 dark:bg-slate-900/60;\n    @apply border border-white/20 dark:border-white/10;\n    @apply shadow-xl shadow-black/5 dark:shadow-black/30;\n    @apply hover:shadow-2xl hover:-translate-y-0.5;\n    @apply transition-all duration-300 ease-in-out;\n    @apply rounded-xl;\n  }\n  \n  .glass-nav {\n    @apply backdrop-blur-md bg-white/80 dark:bg-slate-900/80;\n    @apply border-r border-white/20 dark:border-white/10;\n    @apply shadow-lg shadow-black/5 dark:shadow-black/20;\n  }\n  \n  .glass-header {\n    @apply backdrop-blur-lg bg-white/90 dark:bg-slate-900/90;\n    @apply border-b border-white/20 dark:border-white/10;\n    @apply shadow-md shadow-black/5 dark:shadow-black/20;\n  }\n  \n  .glass-sidebar {\n    @apply backdrop-blur-xl bg-white/85 dark:bg-slate-900/85;\n    @apply border-r border-white/20 dark:border-white/10;\n    @apply shadow-xl shadow-black/10 dark:shadow-black/30;\n  }\n  \n  .glass-modal {\n    @apply backdrop-blur-2xl bg-white/90 dark:bg-slate-900/90;\n    @apply border border-white/30 dark:border-white/20;\n    @apply shadow-2xl shadow-black/20 dark:shadow-black/50;\n    @apply rounded-2xl;\n  }\n  \n  .glass-input {\n    @apply backdrop-blur-sm bg-white/50 dark:bg-slate-800/50;\n    @apply border border-white/30 dark:border-white/20;\n    @apply focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500/50;\n    @apply transition-all duration-200;\n    @apply rounded-lg;\n  }\n  \n  .glass-button {\n    @apply backdrop-blur-md bg-blue-500/90 dark:bg-blue-600/90;\n    @apply border border-white/20 dark:border-white/10;\n    @apply text-white font-medium;\n    @apply shadow-lg shadow-blue-500/20;\n    @apply hover:shadow-xl hover:shadow-blue-500/30 hover:-translate-y-0.5;\n    @apply transition-all duration-200;\n    @apply rounded-lg;\n  }\n  \n  /* Gradient backgrounds */\n  .bg-gradient-primary {\n    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);\n  }\n  \n  .bg-gradient-accent {\n    background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);\n  }\n  \n  .bg-gradient-success {\n    background: linear-gradient(135deg, #10b981 0%, #14b8a6 100%);\n  }\n  \n  .bg-gradient-danger {\n    background: linear-gradient(135deg, #ef4444 0%, #f97316 100%);\n  }\n  \n  .bg-gradient-dark {\n    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);\n  }\n  \n  /* Shimmer loading effect */\n  .shimmer {\n    @apply relative overflow-hidden;\n  }\n  \n  .shimmer::before {\n    content: '';\n    @apply absolute inset-0 -translate-x-full;\n    @apply bg-gradient-to-r from-transparent via-white/20 to-transparent;\n    animation: shimmer 2s infinite;\n  }\n  \n  @keyframes shimmer {\n    0% {\n      transform: translateX(-100%);\n    }\n    100% {\n      transform: translateX(100%);\n    }\n  }\n  \n  /* Pulse effect for live indicators */\n  .pulse-dot {\n    @apply relative;\n  }\n  \n  .pulse-dot::before {\n    content: '';\n    @apply absolute inset-0 rounded-full;\n    @apply bg-current opacity-75;\n    animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n  }\n  \n  @keyframes pulse-ring {\n    0%, 100% {\n      transform: scale(1);\n      opacity: 0.75;\n    }\n    50% {\n      transform: scale(1.5);\n      opacity: 0;\n    }\n  }\n  \n  /* Smooth transitions for interactive elements */\n  .interactive {\n    @apply transition-all duration-200 ease-in-out;\n    @apply hover:scale-105 active:scale-95;\n  }\n  \n  .interactive-subtle {\n    @apply transition-all duration-200 ease-in-out;\n    @apply hover:scale-[1.02] active:scale-[0.98];\n  }\n  \n  /* Status badges */\n  .badge-active {\n    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;\n    @apply bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300;\n    @apply border border-green-200/50 dark:border-green-700/50;\n  }\n  \n  .badge-inactive {\n    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;\n    @apply bg-gray-100 text-gray-800 dark:bg-gray-900/50 dark:text-gray-300;\n    @apply border border-gray-200/50 dark:border-gray-700/50;\n  }\n  \n  .badge-warning {\n    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;\n    @apply bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300;\n    @apply border border-yellow-200/50 dark:border-yellow-700/50;\n  }\n  \n  .badge-error {\n    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;\n    @apply bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300;\n    @apply border border-red-200/50 dark:border-red-700/50;\n  }\n  \n  /* Scrollbar styling */\n  .custom-scrollbar::-webkit-scrollbar {\n    @apply w-2 h-2;\n  }\n  \n  .custom-scrollbar::-webkit-scrollbar-track {\n    @apply bg-transparent;\n  }\n  \n  .custom-scrollbar::-webkit-scrollbar-thumb {\n    @apply bg-gray-300 dark:bg-gray-700 rounded-full;\n    @apply hover:bg-gray-400 dark:hover:bg-gray-600;\n  }\n}","size_bytes":7360},"packages/frontend/src/components/debug/SidebarDebug.tsx":{"content":"import React, { useState, useEffect } from 'react';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport default function SidebarDebug() {\r\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\r\n  const [eventCount, setEventCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const handleSidebarStateChange = (event: CustomEvent) => {\r\n      setSidebarCollapsed(event.detail.collapsed);\r\n      setEventCount(prev => prev + 1);\r\n    };\r\n\r\n    window.addEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\r\n    return () => {\r\n      window.removeEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\r\n    };\r\n  }, []);\r\n\r\n  const triggerTestEvent = () => {\r\n    const event = new CustomEvent('sidebar-state-change', {\r\n      detail: { collapsed: !sidebarCollapsed }\r\n    });\r\n    window.dispatchEvent(event);\r\n  };\r\n\r\n  return (\r\n    <Card className=\"fixed bottom-4 right-4 z-50 w-80\">\r\n      <CardHeader>\r\n        <CardTitle className=\"text-sm\">Sidebar Debug</CardTitle>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-3\">\r\n        <div className=\"text-xs space-y-1\">\r\n          <div>Status: <span className={cn(\r\n            \"font-mono px-2 py-1 rounded text-xs\",\r\n            sidebarCollapsed ? \"bg-red-100 text-red-800\" : \"bg-green-100 text-green-800\"\r\n          )}>\r\n            {sidebarCollapsed ? \"COLLAPSED\" : \"EXPANDED\"}\r\n          </span></div>\r\n          <div>Events: <span className=\"font-mono\">{eventCount}</span></div>\r\n          <div>Layout Margin: <span className=\"font-mono\">\r\n            {sidebarCollapsed ? \"ml-16\" : \"ml-64\"}\r\n          </span></div>\r\n        </div>\r\n        \r\n        <Button \r\n          onClick={triggerTestEvent}\r\n          variant=\"outline\" \r\n          size=\"sm\"\r\n          className=\"w-full\"\r\n        >\r\n          Toggle Sidebar (Test)\r\n        </Button>\r\n        \r\n        <div className=\"text-xs text-gray-500\">\r\n          This debug panel shows the current sidebar state and layout responsiveness.\r\n          The main content should adjust its margin when sidebar collapses/expands.\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n","size_bytes":2291},"packages/frontend/src/components/ui/dialog.tsx":{"content":"import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}","size_bytes":3855},"packages/frontend/src/hooks/use-auth.ts":{"content":"import { useState, useEffect, useCallback } from 'react';\nimport apiClient from '@/lib/api';\n\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  tenant_id: string | null;\n  role: 'super_admin' | 'tenant_admin' | 'tenant_user';\n  iat?: number;\n  exp?: number;\n}\n\nexport interface AuthState {\n  user: User | null;\n  token: string | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n}\n\nexport function useAuth() {\n  const [authState, setAuthState] = useState<AuthState>({\n    user: null,\n    token: null,\n    isAuthenticated: false,\n    isLoading: true,\n  });\n\n  // Initialize auth state from localStorage\n  useEffect(() => {\n    const token = localStorage.getItem('edg-voip-token');\n    if (token) {\n      try {\n        // Check if token is a valid JWT format\n        if (token.split('.').length !== 3) {\n          throw new Error('Invalid token format');\n        }\n        \n        // Decode JWT token to get user info\n        const payload = JSON.parse(atob(token.split('.')[1]));\n        const user: User = {\n          id: payload.id,\n          email: payload.email,\n          name: payload.name,\n          tenant_id: payload.tenant_id,\n          role: payload.role,\n          iat: payload.iat,\n          exp: payload.exp,\n        };\n\n        // Check if token is expired\n        if (user.exp && user.exp * 1000 < Date.now()) {\n          localStorage.removeItem('edg-voip-token');\n          setAuthState({\n            user: null,\n            token: null,\n            isAuthenticated: false,\n            isLoading: false,\n          });\n        } else {\n          apiClient.setToken(token);\n          setAuthState({\n            user,\n            token,\n            isAuthenticated: true,\n            isLoading: false,\n          });\n        }\n      } catch (error) {\n        console.error('Invalid token:', error);\n        localStorage.removeItem('edg-voip-token');\n        setAuthState({\n          user: null,\n          token: null,\n          isAuthenticated: false,\n          isLoading: false,\n        });\n      }\n    } else {\n      setAuthState({\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        isLoading: false,\n      });\n    }\n  }, []);\n\n  const login = useCallback((token: string) => {\n    try {\n      // Check if token is a valid JWT format\n      if (!token || typeof token !== 'string' || token.split('.').length !== 3) {\n        throw new Error('Invalid token format');\n      }\n      \n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const user: User = {\n        id: payload.id,\n        email: payload.email,\n        name: payload.name,\n        tenant_id: payload.tenant_id,\n        role: payload.role,\n        iat: payload.iat,\n        exp: payload.exp,\n      };\n\n      localStorage.setItem('edg-voip-token', token);\n      apiClient.setToken(token);\n      \n      setAuthState({\n        user,\n        token,\n        isAuthenticated: true,\n        isLoading: false,\n      });\n    } catch (error) {\n      console.error('Invalid token:', error);\n      // Clear any invalid token\n      localStorage.removeItem('edg-voip-token');\n      throw new Error('Invalid token');\n    }\n  }, []);\n\n  const logout = useCallback(() => {\n    localStorage.removeItem('edg-voip-token');\n    apiClient.clearToken();\n    setAuthState({\n      user: null,\n      token: null,\n      isAuthenticated: false,\n      isLoading: false,\n    });\n  }, []);\n\n  const refreshToken = useCallback(async () => {\n    if (!authState.token) return false;\n\n    try {\n      // Check if token is a valid JWT format\n      if (authState.token.split('.').length !== 3) {\n        logout();\n        return false;\n      }\n      \n      // In a real implementation, you would call a refresh endpoint\n      // For now, we'll just check if the current token is still valid\n      const payload = JSON.parse(atob(authState.token.split('.')[1]));\n      if (payload.exp && payload.exp * 1000 < Date.now()) {\n        logout();\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      logout();\n      return false;\n    }\n  }, [authState.token, logout]);\n\n  return {\n    ...authState,\n    login,\n    logout,\n    refreshToken,\n  };\n}","size_bytes":4228},"packages/backend/src/routes/index.ts":{"content":"import { Router } from 'express';\nimport authRouter from './auth.routes';\nimport tenantsRouter from './tenants';\nimport storesRouter from './stores';\nimport usersRouter from './users.routes';\nimport extensionsRouter from './extensions';\nimport callRoutes from './calls';\nimport cdrRoutes from './cdr';\nimport webhookRoutes from './webhooks';\nimport analyticsRouter from './analytics';\nimport systemRouter from './system';\nimport voipRouter from './voip';\nimport sipTrunksRouter from './sip-trunks';\nimport freeswitchXmlRouter from './freeswitch-xml.routes';\n\nconst router = Router();\n\n// FreeSWITCH XML Curl endpoint (NO auth - internal FreeSWITCH call)\nrouter.use('/freeswitch', freeswitchXmlRouter);\n\n// API routes\nrouter.use('/', authRouter); // Auth routes at root level (/:tenantSlug/login)\nrouter.use('/tenants', tenantsRouter);\nrouter.use('/stores', storesRouter);\nrouter.use('/users', usersRouter);\nrouter.use('/extensions', extensionsRouter);\nrouter.use('/calls', callRoutes);\nrouter.use('/cdr', cdrRoutes);\nrouter.use('/webhooks', webhookRoutes);\nrouter.use('/analytics', analyticsRouter);\nrouter.use('/voip', voipRouter);\nrouter.use('/sip-trunks', sipTrunksRouter);\nrouter.use('/', systemRouter);\n\n// Health check endpoint\nrouter.get('/health', (req, res) => {\n  res.json({\n    success: true,\n    data: {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: process.env.npm_package_version || '1.0.0'\n    }\n  });\n});\n\nexport default router;\n","size_bytes":1482},"packages/backend/src/routes/cdr-activity-routes.ts":{"content":"import { Router } from 'express';\r\nimport { CdrActivityService, CdrFilters, ActivityLogFilters } from '../services/cdr-activity-service';\r\nimport { tenantContextMiddleware } from '../middleware/tenant-context';\r\n\r\nconst router = Router();\r\nconst cdrActivityService = new CdrActivityService();\r\n\r\n// Apply tenant context middleware to all routes\r\nrouter.use(tenantContextMiddleware);\r\n\r\n// ===== VOIP CDR =====\r\nrouter.post('/cdr', async (req, res) => {\r\n  try {\r\n    const cdrData = req.body;\r\n    const cdr = await cdrActivityService.createCdr(cdrData);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: cdr\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating CDR:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create CDR',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/cdr', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const filters: CdrFilters = {\r\n      tenant_id: tenantId,\r\n      store_id: req.query.store_id as string,\r\n      start_date: req.query.start_date as string,\r\n      end_date: req.query.end_date as string,\r\n      direction: req.query.direction as 'in' | 'out',\r\n      disposition: req.query.disposition as 'ANSWERED' | 'NO_ANSWER' | 'BUSY' | 'FAILED',\r\n      ext_number: req.query.ext_number as string,\r\n      did_e164: req.query.did_e164 as string,\r\n      limit: req.query.limit ? parseInt(req.query.limit as string) : 100,\r\n      offset: req.query.offset ? parseInt(req.query.offset as string) : 0\r\n    };\r\n\r\n    const result = await cdrActivityService.getCdrs(filters);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: result.cdrs,\r\n      pagination: {\r\n        total: result.total,\r\n        limit: filters.limit,\r\n        offset: filters.offset,\r\n        has_more: (filters.offset! + filters.limit!) < result.total\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching CDRs:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch CDRs',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/cdr/stats', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const storeId = req.query.store_id as string;\r\n    const startDate = req.query.start_date as string;\r\n    const endDate = req.query.end_date as string;\r\n\r\n    const stats = await cdrActivityService.getCdrStats(tenantId, storeId, startDate, endDate);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: stats\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching CDR stats:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch CDR stats',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/cdr/:id', async (req, res) => {\r\n  try {\r\n    const cdrId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const cdr = await cdrActivityService.getCdrById(cdrId, tenantId);\r\n    \r\n    if (!cdr) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'CDR not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: cdr\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching CDR:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch CDR',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== VOIP ACTIVITY LOG =====\r\nrouter.post('/activity-log', async (req, res) => {\r\n  try {\r\n    const logData = req.body;\r\n    const log = await cdrActivityService.createActivityLog(req.tenantContext!, logData);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: log\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating activity log:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create activity log',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/activity-log', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const filters: ActivityLogFilters = {\r\n      tenant_id: tenantId,\r\n      actor: req.query.actor as string,\r\n      action: req.query.action as 'create' | 'update' | 'delete' | 'provision' | 'sync',\r\n      target_type: req.query.target_type as 'trunk' | 'did' | 'ext' | 'route' | 'policy',\r\n      target_id: req.query.target_id as string,\r\n      status: req.query.status as 'ok' | 'fail',\r\n      start_date: req.query.start_date as string,\r\n      end_date: req.query.end_date as string,\r\n      limit: req.query.limit ? parseInt(req.query.limit as string) : 100,\r\n      offset: req.query.offset ? parseInt(req.query.offset as string) : 0\r\n    };\r\n\r\n    const result = await cdrActivityService.getActivityLogs(filters);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: result.logs,\r\n      pagination: {\r\n        total: result.total,\r\n        limit: filters.limit,\r\n        offset: filters.offset,\r\n        has_more: (filters.offset! + filters.limit!) < result.total\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching activity logs:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch activity logs',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/activity-log/:id', async (req, res) => {\r\n  try {\r\n    const logId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const log = await cdrActivityService.getActivityLogById(logId, tenantId);\r\n    \r\n    if (!log) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Activity log not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: log\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching activity log:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch activity log',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/activity-log/stats', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const startDate = req.query.start_date as string;\r\n    const endDate = req.query.end_date as string;\r\n\r\n    const stats = await cdrActivityService.getActivityStats(tenantId, startDate, endDate);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: stats\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching activity stats:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch activity stats',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== UTILITY ENDPOINTS =====\r\nrouter.post('/generate-mock-data', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const sipDomain = req.tenantContext!.sip_domain;\r\n    \r\n    await cdrActivityService.generateMockData(tenantId, sipDomain);\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: 'Mock data generated successfully'\r\n    });\r\n  } catch (error) {\r\n    console.error('Error generating mock data:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to generate mock data',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":7559},"packages/backend/src/services/sip-test-service.ts":{"content":"import { EventEmitter } from 'events';\r\n\r\nexport interface SipTestConfig {\r\n  provider: string;\r\n  proxy: string;\r\n  port: number;\r\n  transport: 'udp' | 'tcp' | 'tls';\r\n  auth_username: string;\r\n  auth_password: string;\r\n  from_domain?: string;\r\n}\r\n\r\nexport interface SipTestResult {\r\n  success: boolean;\r\n  status: 'REG_OK' | 'FAIL' | 'TIMEOUT' | 'AUTH_FAILED' | 'NETWORK_ERROR';\r\n  message: string;\r\n  response_time_ms?: number;\r\n  error_details?: string;\r\n  registration_details?: {\r\n    expires?: number;\r\n    contact?: string;\r\n    user_agent?: string;\r\n  };\r\n}\r\n\r\nexport class SipTestService extends EventEmitter {\r\n  private testTimeout = 10000; // 10 seconds timeout\r\n\r\n  /**\r\n   * Test SIP registration with provider\r\n   */\r\n  async testSipRegistration(config: SipTestConfig): Promise<SipTestResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`Testing SIP registration with ${config.provider}...`);\r\n      console.log(`Proxy: ${config.proxy}:${config.port} (${config.transport})`);\r\n      console.log(`Username: ${config.auth_username}`);\r\n\r\n      // Simulate SIP registration test\r\n      // In a real implementation, this would use a SIP library like node-sip\r\n      const result = await this.simulateSipRegistration(config);\r\n      \r\n      const responseTime = Date.now() - startTime;\r\n      \r\n      return {\r\n        success: result.success,\r\n        status: result.status,\r\n        message: result.message,\r\n        response_time_ms: responseTime,\r\n        registration_details: result.registration_details\r\n      };\r\n\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      console.error('SIP test error:', error);\r\n      \r\n      return {\r\n        success: false,\r\n        status: 'NETWORK_ERROR',\r\n        message: 'Network or connection error',\r\n        response_time_ms: responseTime,\r\n        error_details: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test SIP trunk connectivity (ping/OPTIONS)\r\n   */\r\n  async testSipTrunkConnectivity(config: SipTestConfig): Promise<SipTestResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`Testing SIP trunk connectivity to ${config.proxy}:${config.port}...`);\r\n      \r\n      // Simulate SIP OPTIONS ping\r\n      const result = await this.simulateSipOptions(config);\r\n      \r\n      const responseTime = Date.now() - startTime;\r\n      \r\n      return {\r\n        success: result.success,\r\n        status: result.status,\r\n        message: result.message,\r\n        response_time_ms: responseTime\r\n      };\r\n\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      console.error('SIP trunk test error:', error);\r\n      \r\n      return {\r\n        success: false,\r\n        status: 'NETWORK_ERROR',\r\n        message: 'Network or connection error',\r\n        response_time_ms: responseTime,\r\n        error_details: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test specific Messagenet configuration\r\n   */\r\n  async testMessagenetConnection(): Promise<SipTestResult> {\r\n    const messagenetConfig: SipTestConfig = {\r\n      provider: 'Messagenet',\r\n      proxy: 'sip.messagenet.it', // Standard Messagenet SIP proxy\r\n      port: 5060,\r\n      transport: 'udp',\r\n      auth_username: '5406594427',\r\n      auth_password: 'UjcHYnZa',\r\n      from_domain: 'messagenet.it'\r\n    };\r\n\r\n    console.log('Testing Messagenet SIP connection...');\r\n    return await this.testSipRegistration(messagenetConfig);\r\n  }\r\n\r\n  /**\r\n   * Simulate SIP registration (mock implementation)\r\n   * In production, this would use a real SIP library\r\n   */\r\n  private async simulateSipRegistration(config: SipTestConfig): Promise<{\r\n    success: boolean;\r\n    status: 'REG_OK' | 'FAIL' | 'TIMEOUT' | 'AUTH_FAILED';\r\n    message: string;\r\n    registration_details?: any;\r\n  }> {\r\n    // Simulate network delay\r\n    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\r\n\r\n    // Mock different scenarios based on provider\r\n    if (config.provider === 'Messagenet') {\r\n      // Simulate successful Messagenet registration\r\n      return {\r\n        success: true,\r\n        status: 'REG_OK',\r\n        message: 'Successfully registered with Messagenet',\r\n        registration_details: {\r\n          expires: 3600,\r\n          contact: `sip:${config.auth_username}@${config.proxy}`,\r\n          user_agent: 'EDG-VoIP/1.0'\r\n        }\r\n      };\r\n    }\r\n\r\n    // Simulate other providers or random failures\r\n    const random = Math.random();\r\n    if (random > 0.8) {\r\n      return {\r\n        success: false,\r\n        status: 'AUTH_FAILED',\r\n        message: 'Authentication failed - invalid credentials'\r\n      };\r\n    } else if (random > 0.6) {\r\n      return {\r\n        success: false,\r\n        status: 'TIMEOUT',\r\n        message: 'Registration timeout - server not responding'\r\n      };\r\n    } else {\r\n      return {\r\n        success: true,\r\n        status: 'REG_OK',\r\n        message: 'Successfully registered',\r\n        registration_details: {\r\n          expires: 300,\r\n          contact: `sip:${config.auth_username}@${config.proxy}`,\r\n          user_agent: 'EDG-VoIP/1.0'\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simulate SIP OPTIONS ping (mock implementation)\r\n   */\r\n  private async simulateSipOptions(config: SipTestConfig): Promise<{\r\n    success: boolean;\r\n    status: 'REG_OK' | 'FAIL' | 'TIMEOUT';\r\n    message: string;\r\n  }> {\r\n    // Simulate network delay\r\n    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));\r\n\r\n    // Mock connectivity test\r\n    const random = Math.random();\r\n    if (random > 0.2) {\r\n      return {\r\n        success: true,\r\n        status: 'REG_OK',\r\n        message: 'SIP trunk is reachable and responding'\r\n      };\r\n    } else {\r\n      return {\r\n        success: false,\r\n        status: 'FAIL',\r\n        message: 'SIP trunk is not responding'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test multiple configurations\r\n   */\r\n  async testMultipleConfigurations(configs: SipTestConfig[]): Promise<SipTestResult[]> {\r\n    const results: SipTestResult[] = [];\r\n    \r\n    for (const config of configs) {\r\n      try {\r\n        const result = await this.testSipRegistration(config);\r\n        results.push(result);\r\n      } catch (error) {\r\n        results.push({\r\n          success: false,\r\n          status: 'NETWORK_ERROR',\r\n          message: 'Test failed',\r\n          error_details: error instanceof Error ? error.message : 'Unknown error'\r\n        });\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n}\r\n","size_bytes":6604},"packages/backend/src/middleware/tenant.middleware.ts":{"content":"import { Request, Response, NextFunction } from 'express';\r\nimport { getClient } from '@w3-voip/database';\r\n\r\nexport interface TenantRequest extends Request {\r\n  tenant?: {\r\n    id: string;\r\n    slug: string;\r\n    name: string;\r\n    domain: string;\r\n    sip_domain: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Middleware to validate tenant slug from URL parameters\r\n * Extracts tenant information and attaches it to the request object\r\n */\r\nexport async function validateTenantSlug(\r\n  req: TenantRequest,\r\n  res: Response,\r\n  next: NextFunction\r\n) {\r\n  console.log('=== validateTenantSlug called ===');\r\n  console.log('validateTenantSlug - req.body:', JSON.stringify(req.body));\r\n  console.log('validateTenantSlug - req.params:', req.params);\r\n  const tenantSlug = req.params.tenantSlug || req.query.tenantSlug;\r\n  \r\n  if (!tenantSlug) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      error: 'Tenant slug is required'\r\n    });\r\n  }\r\n\r\n  try {\r\n    console.log('Looking for tenant with slug:', tenantSlug);\r\n    const client = await getClient();\r\n    const result = await client.query(\r\n      'SELECT id, slug, name, domain, sip_domain FROM tenants WHERE slug = $1 AND status = $2',\r\n      [tenantSlug, 'active']\r\n    );\r\n\r\n    console.log('Query result:', result.rows);\r\n    \r\n    if (result.rows.length === 0) {\r\n      console.log('Tenant not found for slug:', tenantSlug);\r\n      return res.status(404).json({\r\n        success: false,\r\n        error: 'Tenant not found',\r\n        tenantSlug\r\n      });\r\n    }\r\n\r\n    const tenant = result.rows[0];\r\n    req.tenant = tenant as any;\r\n    \r\n    console.log('✅ Tenant validated successfully, calling next() - FORCED RESTART');\r\n    next();\r\n  } catch (error) {\r\n    console.error('Error validating tenant slug:', error);\r\n    return res.status(500).json({\r\n      success: false,\r\n      error: 'Failed to validate tenant'\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Middleware to extract tenant slug from JWT token\r\n * Used for API calls that don't have tenant slug in URL\r\n */\r\nexport function extractTenantFromToken(\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n) {\r\n  const authHeader = req.headers.authorization;\r\n  \r\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n    return res.status(401).json({\r\n      success: false,\r\n      error: 'Authorization token required'\r\n    });\r\n  }\r\n\r\n  try {\r\n    const token = authHeader.substring(7);\r\n    const decoded = require('jsonwebtoken').verify(\r\n      token, \r\n      process.env.JWT_SECRET || 'your-secret-key'\r\n    );\r\n    \r\n    (req as any).tenantSlug = decoded.tenantSlug;\r\n    (req as any).tenantId = decoded.tenantId;\r\n    (req as any).userId = decoded.userId;\r\n    (req as any).userRole = decoded.role;\r\n    \r\n    next();\r\n  } catch (error) {\r\n    return res.status(401).json({\r\n      success: false,\r\n      error: 'Invalid or expired token'\r\n    });\r\n  }\r\n}\r\n","size_bytes":2874},"packages/database/check-extension.js":{"content":"const { getClient } = require('./dist/index.js');\r\n\r\nasync function checkExtension() {\r\n  try {\r\n    const client = await getClient();\r\n    \r\n    // Verifica extension 100\r\n    const result = await client.query('SELECT * FROM extensions WHERE extension = $1', ['100']);\r\n    \r\n    console.log('🔍 Verifica Extension 100:');\r\n    console.log('Trovata:', result.rows.length > 0 ? '✅ SI' : '❌ NO');\r\n    \r\n    if (result.rows.length > 0) {\r\n      const ext = result.rows[0];\r\n      console.log('Dettagli:');\r\n      console.log('- ID:', ext.id);\r\n      console.log('- Extension:', ext.extension);\r\n      console.log('- Password:', ext.password);\r\n      console.log('- Display Name:', ext.display_name);\r\n      console.log('- Tenant ID:', ext.tenant_id);\r\n      console.log('- Enabled:', ext.enabled);\r\n    }\r\n    \r\n    // Verifica SIP trunks\r\n    const trunksResult = await client.query('SELECT * FROM sip_trunks WHERE name ILIKE $1', ['%messagenet%']);\r\n    \r\n    console.log('\\n🔍 Verifica SIP Trunk Messagenet:');\r\n    console.log('Trovato:', trunksResult.rows.length > 0 ? '✅ SI' : '❌ NO');\r\n    \r\n    if (trunksResult.rows.length > 0) {\r\n      const trunk = trunksResult.rows[0];\r\n      console.log('Dettagli:');\r\n      console.log('- ID:', trunk.id);\r\n      console.log('- Name:', trunk.name);\r\n      console.log('- Provider:', trunk.provider);\r\n      console.log('- Status:', trunk.status);\r\n      console.log('- Enabled:', trunk.enabled);\r\n    }\r\n    \r\n    client.release();\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('❌ Errore:', error.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\ncheckExtension();\r\n","size_bytes":1636},"packages/frontend/src/pages/Destinations.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Plus, \n  Search, \n  Edit, \n  Trash2, \n  Users, \n  MessageSquare, \n  Video, \n  Clock, \n  Headphones,\n  Save,\n  X,\n  RefreshCw,\n  Eye\n} from 'lucide-react';\nimport { \n  RingGroup, \n  Queue, \n  ConferenceRoom, \n  VoicemailBox, \n  TimeCondition, \n  IvrMenu \n} from '@voip/shared';\nimport { apiClient } from '@/lib/api';\nimport { useAuth } from '@/contexts/AuthContext';\n\nexport default function Destinations() {\n  const { user } = useAuth();\n  const [activeTab, setActiveTab] = useState('ring-groups');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedItem, setSelectedItem] = useState<string | null>(null);\n  const [showModal, setShowModal] = useState(false);\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\n  const [loading, setLoading] = useState(false);\n  \n  // Data states\n  const [ringGroups, setRingGroups] = useState<RingGroup[]>([]);\n  const [queues, setQueues] = useState<Queue[]>([]);\n  const [conferenceRooms, setConferenceRooms] = useState<ConferenceRoom[]>([]);\n  const [voicemailBoxes, setVoicemailBoxes] = useState<VoicemailBox[]>([]);\n  const [timeConditions, setTimeConditions] = useState<TimeCondition[]>([]);\n  const [ivrMenus, setIvrMenus] = useState<IvrMenu[]>([]);\n\n  // Form states\n  const [formData, setFormData] = useState<any>({});\n  const [editingItem, setEditingItem] = useState<any>(null);\n\n  // Load data on component mount\n  useEffect(() => {\n    loadAllData();\n  }, []);\n\n  const loadAllData = async () => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const [ringRes, queueRes, confRes, vmRes, timeRes, ivrRes] = await Promise.all([\n        apiClient.getRingGroups(),\n        apiClient.getQueues(),\n        apiClient.getConferenceRooms(),\n        apiClient.getVoicemailBoxes(),\n        apiClient.getTimeConditions(),\n        apiClient.getIvrMenus()\n      ]);\n\n      setRingGroups((ringRes.data as RingGroup[]) || []);\n      setQueues((queueRes.data as Queue[]) || []);\n      setConferenceRooms((confRes.data as ConferenceRoom[]) || []);\n      setVoicemailBoxes((vmRes.data as VoicemailBox[]) || []);\n      setTimeConditions((timeRes.data as TimeCondition[]) || []);\n      setIvrMenus((ivrRes.data as IvrMenu[]) || []);\n    } catch (error) {\n      console.error('Error loading data:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCreate = async (type: string, data: any) => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const response = await apiClient.post(`/voip/${type}`, {\n        ...data,\n        tenant_id: user.tenant_id\n      });\n      \n      // Update local state\n      switch (type) {\n        case 'ring-groups':\n          setRingGroups(prev => [...prev, response.data]);\n          break;\n        case 'queues':\n          setQueues(prev => [...prev, response.data]);\n          break;\n        case 'conference-rooms':\n          setConferenceRooms(prev => [...prev, response.data]);\n          break;\n        case 'voicemail-boxes':\n          setVoicemailBoxes(prev => [...prev, response.data]);\n          break;\n        case 'time-conditions':\n          setTimeConditions(prev => [...prev, response.data]);\n          break;\n        case 'ivr-menus':\n          setIvrMenus(prev => [...prev, response.data]);\n          break;\n      }\n      \n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error creating item:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleUpdate = async (type: string, id: string, data: any) => {\n    setLoading(true);\n    try {\n      const response = await apiClient.put(`/voip/${type}/${id}`, data);\n      \n      // Update local state\n      switch (type) {\n        case 'ring-groups':\n          setRingGroups(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n        case 'queues':\n          setQueues(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n        case 'conference-rooms':\n          setConferenceRooms(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n        case 'voicemail-boxes':\n          setVoicemailBoxes(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n        case 'time-conditions':\n          setTimeConditions(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n        case 'ivr-menus':\n          setIvrMenus(prev => prev.map(item => item.id === id ? response.data : item));\n          break;\n      }\n      \n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error updating item:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDelete = async (type: string, id: string) => {\n    if (!confirm('Are you sure you want to delete this item?')) return;\n    \n    setLoading(true);\n    try {\n      await apiClient.delete(`/voip/${type}/${id}`);\n      \n      // Update local state\n      switch (type) {\n        case 'ring-groups':\n          setRingGroups(prev => prev.filter(item => item.id !== id));\n          break;\n        case 'queues':\n          setQueues(prev => prev.filter(item => item.id !== id));\n          break;\n        case 'conference-rooms':\n          setConferenceRooms(prev => prev.filter(item => item.id !== id));\n          break;\n        case 'voicemail-boxes':\n          setVoicemailBoxes(prev => prev.filter(item => item.id !== id));\n          break;\n        case 'time-conditions':\n          setTimeConditions(prev => prev.filter(item => item.id !== id));\n          break;\n        case 'ivr-menus':\n          setIvrMenus(prev => prev.filter(item => item.id !== id));\n          break;\n      }\n      \n      if (selectedItem === id) {\n        setSelectedItem(null);\n      }\n    } catch (error) {\n      console.error('Error deleting item:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const openModal = (type: 'create' | 'edit' | 'view', item?: any) => {\n    setModalType(type);\n    if (item) {\n      setEditingItem(item);\n      setFormData(item);\n    } else {\n      setEditingItem(null);\n      setFormData({});\n    }\n    setShowModal(true);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setEditingItem(null);\n    setFormData({});\n  };\n\n  const renderDataTable = (data: any[], type: string, columns: any[]) => (\n    <div className=\"w-full\">\n      <div className=\"overflow-x-auto\">\n        <table className=\"w-full border-collapse\">\n          <thead>\n            <tr className=\"border-b bg-gray-50\">\n              {columns.map((col, index) => (\n                <th key={index} className=\"text-left p-3 font-medium text-gray-700\">\n                  {col.header}\n                </th>\n              ))}\n              <th className=\"text-right p-3 font-medium text-gray-700\">Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {data.map((item, index) => (\n              <tr key={item.id || index} className=\"border-b hover:bg-gray-50\">\n                {columns.map((col, colIndex) => (\n                  <td key={colIndex} className=\"p-3\">\n                    {col.render ? col.render(item) : item[col.key]}\n                  </td>\n                ))}\n                <td className=\"p-3\">\n                  <div className=\"flex items-center justify-end space-x-1\">\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('view', item)}\n                      title=\"View Details\"\n                    >\n                      <Eye className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('edit', item)}\n                      title=\"Edit\"\n                    >\n                      <Edit className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => handleDelete(type, item.id)}\n                      title=\"Delete\"\n                      className=\"text-red-600 hover:text-red-700\"\n                    >\n                      <Trash2 className=\"h-4 w-4\" />\n                    </Button>\n                  </div>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n\n  const renderRingGroups = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Extension', key: 'extension_number' },\n      { header: 'Strategy', key: 'strategy' },\n      { header: 'Members', key: 'members', render: (item: any) => `${item.members?.length || 0} members` },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_calls && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <Users className=\"h-5 w-5 mr-2\" />\n            Ring Groups ({ringGroups.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Ring Group\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(ringGroups, 'ring-groups', columns)}\n      </div>\n    );\n  };\n\n  const renderQueues = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Extension', key: 'extension_number' },\n      { header: 'Strategy', key: 'strategy' },\n      { header: 'Agents', key: 'agents', render: (item: any) => `${item.agents?.length || 0} agents` },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_calls && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <MessageSquare className=\"h-5 w-5 mr-2\" />\n            Queues ({queues.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Queue\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(queues, 'queues', columns)}\n      </div>\n    );\n  };\n\n  const renderConferenceRooms = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Extension', key: 'extension_number' },\n      { header: 'Max Members', key: 'max_members' },\n      { header: 'PIN', key: 'pin', render: (item: any) => item.pin ? '***' : 'None' },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_conference && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <Video className=\"h-5 w-5 mr-2\" />\n            Conference Rooms ({conferenceRooms.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Conference Room\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(conferenceRooms, 'conference-rooms', columns)}\n      </div>\n    );\n  };\n\n  const renderVoicemailBoxes = () => {\n    const columns = [\n      { header: 'Display Name', key: 'display_name' },\n      { header: 'Extension', key: 'extension_number' },\n      { header: 'Email', key: 'email_address' },\n      { header: 'Max Messages', key: 'max_messages' },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.email_notification && (\n              <Badge variant=\"outline\" className=\"text-blue-600\">\n                <MessageSquare className=\"h-3 w-3 mr-1\" />\n                Email\n              </Badge>\n            )}\n          </div>\n        )\n      }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <MessageSquare className=\"h-5 w-5 mr-2\" />\n            Voicemail Boxes ({voicemailBoxes.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Voicemail Box\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(voicemailBoxes, 'voicemail-boxes', columns)}\n      </div>\n    );\n  };\n\n  const renderTimeConditions = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Timezone', key: 'timezone' },\n      { header: 'Business Hours', key: 'business_hours', render: () => 'Mon-Fri 09:00-17:00' },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <Badge variant={item.enabled ? 'default' : 'secondary'}>\n            {item.enabled ? 'Enabled' : 'Disabled'}\n          </Badge>\n        )\n      },\n      { header: 'Description', key: 'description' }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <Clock className=\"h-5 w-5 mr-2\" />\n            Time Conditions ({timeConditions.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Time Condition\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(timeConditions, 'time-conditions', columns)}\n      </div>\n    );\n  };\n\n  const renderIvrMenus = () => {\n    const columns = [\n      { header: 'Name', key: 'name' },\n      { header: 'Timeout', key: 'timeout_seconds', render: (item: any) => `${item.timeout_seconds}s` },\n      { header: 'Options', key: 'options', render: (item: any) => `${item.options?.length || 0} options` },\n      { \n        header: 'Status', \n        key: 'status',\n        render: (item: any) => (\n          <div className=\"flex items-center space-x-2\">\n            <Badge variant={item.enabled ? 'default' : 'secondary'}>\n              {item.enabled ? 'Enabled' : 'Disabled'}\n            </Badge>\n            {item.record_calls && (\n              <Badge variant=\"outline\" className=\"text-red-600\">\n                <Mic className=\"h-3 w-3 mr-1\" />\n                Recording\n              </Badge>\n            )}\n          </div>\n        )\n      },\n      { header: 'Description', key: 'description' }\n    ];\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold flex items-center\">\n            <Headphones className=\"h-5 w-5 mr-2\" />\n            IVR Menus ({ivrMenus.length})\n          </h3>\n          <div className=\"flex items-center space-x-2\">\n            <Button onClick={loadAllData} variant=\"outline\" size=\"sm\">\n              <RefreshCw className=\"h-4 w-4 mr-2\" />\n              Refresh\n            </Button>\n            <Button \n              onClick={() => openModal('create')} \n              size=\"sm\"\n              className=\"bg-blue-600 hover:bg-blue-700\"\n            >\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add IVR Menu\n            </Button>\n          </div>\n        </div>\n        {renderDataTable(ivrMenus, 'ivr-menus', columns)}\n      </div>\n    );\n  };\n\n  const renderModal = () => {\n    if (!showModal) return null;\n\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className=\"bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-xl font-semibold\">\n              {modalType === 'create' ? 'Create New' : modalType === 'edit' ? 'Edit' : 'View'} {activeTab}\n            </h2>\n            <Button variant=\"ghost\" size=\"sm\" onClick={closeModal}>\n              <X className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          \n          <Tabs defaultValue=\"basic\" className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-4\">\n              <TabsTrigger value=\"basic\">Basic</TabsTrigger>\n              <TabsTrigger value=\"configuration\">Configuration</TabsTrigger>\n              <TabsTrigger value=\"advanced\">Advanced</TabsTrigger>\n              <TabsTrigger value=\"recording\">Recording</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"basic\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Name</label>\n                  <Input \n                    placeholder=\"Item name\" \n                    value={formData.name || ''}\n                    onChange={(e) => setFormData({...formData, name: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Description</label>\n                  <Input \n                    placeholder=\"Item description\" \n                    value={formData.description || ''}\n                    onChange={(e) => setFormData({...formData, description: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n              <div className=\"flex items-center space-x-2\">\n                <Switch \n                  id=\"enabled\" \n                  checked={formData.enabled || false}\n                  onCheckedChange={(checked) => setFormData({...formData, enabled: checked})}\n                  disabled={modalType === 'view'}\n                />\n                <label htmlFor=\"enabled\" className=\"text-sm font-medium\">Enabled</label>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"configuration\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Extension Number</label>\n                  <Input \n                    placeholder=\"1001\" \n                    value={formData.extension_number || ''}\n                    onChange={(e) => setFormData({...formData, extension_number: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Strategy</label>\n                  <Select \n                    value={formData.strategy || ''}\n                    onValueChange={(value) => setFormData({...formData, strategy: value})}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select strategy\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"simultaneous\">Simultaneous</SelectItem>\n                      <SelectItem value=\"sequential\">Sequential</SelectItem>\n                      <SelectItem value=\"round_robin\">Round Robin</SelectItem>\n                      <SelectItem value=\"random\">Random</SelectItem>\n                      <SelectItem value=\"longest_idle\">Longest Idle</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"advanced\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Timeout (seconds)</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"30\" \n                    value={formData.timeout || ''}\n                    onChange={(e) => setFormData({...formData, timeout: parseInt(e.target.value)})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Max Calls</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"10\" \n                    value={formData.max_calls || ''}\n                    onChange={(e) => setFormData({...formData, max_calls: parseInt(e.target.value)})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"recording\" className=\"space-y-4\">\n              <div className=\"flex items-center space-x-2\">\n                <Switch \n                  id=\"record-calls\" \n                  checked={formData.record_calls || false}\n                  onCheckedChange={(checked) => setFormData({...formData, record_calls: checked})}\n                  disabled={modalType === 'view'}\n                />\n                <label htmlFor=\"record-calls\" className=\"text-sm font-medium\">Record Calls</label>\n              </div>\n              <div>\n                <label className=\"text-sm font-medium\">Recording Path</label>\n                <Input \n                  placeholder=\"/var/recordings/\" \n                  value={formData.recording_path || ''}\n                  onChange={(e) => setFormData({...formData, recording_path: e.target.value})}\n                  disabled={modalType === 'view'}\n                />\n              </div>\n            </TabsContent>\n          </Tabs>\n          \n          {modalType !== 'view' && (\n            <div className=\"flex justify-end space-x-2 mt-6\">\n              <Button \n                variant=\"outline\"\n                onClick={closeModal}\n              >\n                <X className=\"h-4 w-4 mr-2\" />\n                Cancel\n              </Button>\n              <Button \n                onClick={() => {\n                  if (editingItem) {\n                    handleUpdate(activeTab, editingItem.id, formData);\n                  } else {\n                    handleCreate(activeTab, formData);\n                  }\n                }}\n                disabled={loading}\n                className=\"bg-blue-600 hover:bg-blue-700\"\n              >\n                <Save className=\"h-4 w-4 mr-2\" />\n                {loading ? 'Saving...' : 'Save Configuration'}\n              </Button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Destinations & Time</h1>\n          <p className=\"text-muted-foreground\">\n            Create and manage destinations (Ring Groups, Queues, Conference Rooms, Voicemail Boxes) and time conditions\n          </p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search destinations...\"\n              className=\"pl-8 w-64\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content */}\n      <div className=\"space-y-8\">\n        <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-6\">\n            <TabsTrigger value=\"ring-groups\">Ring Groups</TabsTrigger>\n            <TabsTrigger value=\"queues\">Queues</TabsTrigger>\n            <TabsTrigger value=\"conference-rooms\">Conference</TabsTrigger>\n            <TabsTrigger value=\"voicemail-boxes\">Voicemail</TabsTrigger>\n            <TabsTrigger value=\"time-conditions\">Time Conditions</TabsTrigger>\n            <TabsTrigger value=\"ivr-menus\">IVR Menus</TabsTrigger>\n          </TabsList>\n          \n          <TabsContent value=\"ring-groups\" className=\"mt-6\">\n            {renderRingGroups()}\n          </TabsContent>\n          \n          <TabsContent value=\"queues\" className=\"mt-6\">\n            {renderQueues()}\n          </TabsContent>\n          \n          <TabsContent value=\"conference-rooms\" className=\"mt-6\">\n            {renderConferenceRooms()}\n          </TabsContent>\n          \n          <TabsContent value=\"voicemail-boxes\" className=\"mt-6\">\n            {renderVoicemailBoxes()}\n          </TabsContent>\n          \n          <TabsContent value=\"time-conditions\" className=\"mt-6\">\n            {renderTimeConditions()}\n          </TabsContent>\n          \n          <TabsContent value=\"ivr-menus\" className=\"mt-6\">\n            {renderIvrMenus()}\n          </TabsContent>\n        </Tabs>\n      </div>\n\n      {/* Modal */}\n      {renderModal()}\n    </div>\n  );\n}\n\n","size_bytes":28708},"packages/backend/src/routes/extensions.ts":{"content":"import { Router } from 'express';\r\nimport { ExtensionService } from '../services/extension.service';\r\nimport {\r\n  authenticateToken,\r\n  requireTenant,\r\n  setTenantContext,\r\n  setStoreContext,\r\n  validateExtension,\r\n  handleValidationErrors,\r\n  validatePagination\r\n} from '../middleware';\r\nimport {\r\n  successResponse,\r\n  errorResponse,\r\n  paginatedResponse,\r\n  createdResponse,\r\n  updatedResponse,\r\n  deletedResponse,\r\n  notFoundResponse,\r\n  asyncHandler\r\n} from '../utils/response';\r\n\r\nconst router = Router();\r\nconst extensionService = new ExtensionService();\r\n\r\n// Apply authentication and tenant context to all routes\r\nrouter.use(authenticateToken);\r\nrouter.use(requireTenant);\r\nrouter.use(setTenantContext);\r\n\r\n// Create extension\r\nrouter.post('/',\r\n  validateExtension,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const extensionData = {\r\n      ...req.body,\r\n      tenant_id: req.tenantId,\r\n      store_id: req.body.store_id || null\r\n    };\r\n    \r\n    const extension = await extensionService.createExtension(extensionData);\r\n    createdResponse(res, extension, 'Extension created successfully');\r\n  })\r\n);\r\n\r\n// List extensions for tenant\r\nrouter.get('/',\r\n  validatePagination,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const page = parseInt(req.query.page as string) || 1;\r\n    const limit = parseInt(req.query.limit as string) || 50;\r\n    const search = req.query.q as string;\r\n    const storeId = req.query.store_id as string;\r\n\r\n    const result = await extensionService.listExtensions(req.tenantId!, storeId, page, limit, search);\r\n    \r\n    paginatedResponse(res, result.extensions, {\r\n      page,\r\n      limit,\r\n      total: result.total,\r\n      totalPages: result.totalPages\r\n    }, 'Extensions retrieved successfully');\r\n  })\r\n);\r\n\r\n// Get extension by ID\r\nrouter.get('/:id',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.getExtensionById(extensionId, req.tenantId);\r\n    \r\n    if (!extension) {\r\n      return notFoundResponse(res, 'Extension not found');\r\n    }\r\n\r\n    successResponse(res, extension, 'Extension retrieved successfully');\r\n  })\r\n);\r\n\r\n// Get extension by number\r\nrouter.get('/number/:extension',\r\n  asyncHandler(async (req, res) => {\r\n    const extension = req.params.extension;\r\n    const ext = await extensionService.getExtensionByNumber(extension, req.tenantId!);\r\n    \r\n    if (!ext) {\r\n      return notFoundResponse(res, 'Extension not found');\r\n    }\r\n\r\n    successResponse(res, ext, 'Extension retrieved successfully');\r\n  })\r\n);\r\n\r\n// Update extension\r\nrouter.put('/:id',\r\n  validateExtension,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.updateExtension(extensionId, req.body, req.tenantId);\r\n    updatedResponse(res, extension, 'Extension updated successfully');\r\n  })\r\n);\r\n\r\n// Delete extension\r\nrouter.delete('/:id',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    await extensionService.deleteExtension(extensionId, req.tenantId);\r\n    deletedResponse(res, 'Extension deleted successfully');\r\n  })\r\n);\r\n\r\n// Verify extension password (for authentication)\r\nrouter.post('/verify-password',\r\n  asyncHandler(async (req, res) => {\r\n    const { extension, password } = req.body;\r\n    \r\n    if (!extension || !password) {\r\n      return errorResponse(res, 'Extension and password are required', 400, 'MISSING_FIELDS');\r\n    }\r\n\r\n    const ext = await extensionService.verifyExtensionPassword(extension, password, req.tenantId!);\r\n    \r\n    if (!ext) {\r\n      return errorResponse(res, 'Invalid extension or password', 401, 'INVALID_CREDENTIALS');\r\n    }\r\n\r\n    successResponse(res, ext, 'Extension authenticated successfully');\r\n  })\r\n);\r\n\r\n// Get extension statistics\r\nrouter.get('/:id/stats',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const stats = await extensionService.getExtensionStats(extensionId, req.tenantId);\r\n    successResponse(res, stats, 'Extension statistics retrieved successfully');\r\n  })\r\n);\r\n\r\n// Activate extension\r\nrouter.post('/:id/activate',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.activateExtension(extensionId, req.tenantId);\r\n    updatedResponse(res, extension, 'Extension activated successfully');\r\n  })\r\n);\r\n\r\n// Deactivate extension\r\nrouter.post('/:id/deactivate',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.deactivateExtension(extensionId, req.tenantId);\r\n    updatedResponse(res, extension, 'Extension deactivated successfully');\r\n  })\r\n);\r\n\r\n// Lock extension\r\nrouter.post('/:id/lock',\r\n  asyncHandler(async (req, res) => {\r\n    const extensionId = req.params.id;\r\n    const extension = await extensionService.lockExtension(extensionId, req.tenantId);\r\n    updatedResponse(res, extension, 'Extension locked successfully');\r\n  })\r\n);\r\n\r\n// Validate extension number uniqueness within tenant\r\nrouter.post('/validate-extension',\r\n  asyncHandler(async (req, res) => {\r\n    const { extension, exclude_extension_id } = req.body;\r\n    \r\n    if (!extension) {\r\n      return errorResponse(res, 'Extension number is required', 400, 'MISSING_FIELDS');\r\n    }\r\n\r\n    const isUnique = await extensionService.validateExtensionUniqueness(extension, req.tenantId!, exclude_extension_id);\r\n    \r\n    successResponse(res, { is_unique: isUnique }, 'Extension validation completed');\r\n  })\r\n);\r\n\r\n// Get extensions by store\r\nrouter.get('/store/:storeId',\r\n  setStoreContext,\r\n  validatePagination,\r\n  handleValidationErrors,\r\n  asyncHandler(async (req, res) => {\r\n    const storeId = req.params.storeId;\r\n    const page = parseInt(req.query.page as string) || 1;\r\n    const limit = parseInt(req.query.limit as string) || 50;\r\n    const search = req.query.q as string;\r\n\r\n    const result = await extensionService.listExtensions(req.tenantId!, storeId, page, limit, search);\r\n    \r\n    paginatedResponse(res, result.extensions, {\r\n      page,\r\n      limit,\r\n      total: result.total,\r\n      totalPages: result.totalPages\r\n    }, 'Store extensions retrieved successfully');\r\n  })\r\n);\r\n\r\nexport default router;\r\n\r\n","size_bytes":6343},"packages/frontend/src/pages/SuperAdminUsers.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { \n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog';\nimport { \n  Users, \n  Search, \n  ArrowLeft,\n  UserCheck,\n  Edit,\n  Trash2,\n  AlertCircle,\n  Shield,\n  Building2\n} from 'lucide-react';\nimport apiClient from '@/lib/api';\n\ninterface User {\n  id: string;\n  email: string;\n  first_name: string;\n  last_name: string;\n  role: string;\n  status: string;\n  tenant_id: string;\n  tenant_name: string;\n  tenant_slug: string;\n  last_login?: string;\n  created_at: string;\n}\n\nexport default function SuperAdminUsers() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedTenant, setSelectedTenant] = useState<string>('all');\n  const [showImpersonateModal, setShowImpersonateModal] = useState(false);\n  const [selectedUser, setSelectedUser] = useState<User | null>(null);\n  const [impersonating, setImpersonating] = useState(false);\n  const navigate = useNavigate();\n  const { tenantId } = useParams();\n\n  useEffect(() => {\n    loadUsers();\n  }, [tenantId]);\n\n  const loadUsers = async () => {\n    try {\n      setLoading(true);\n      const response = await apiClient.getCrossTenantUsers();\n      if (response.success) {\n        setUsers(response.data || []);\n      } else {\n        throw new Error(response.error || 'Failed to load users');\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to load users');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleImpersonate = async (user: User) => {\n    setSelectedUser(user);\n    setShowImpersonateModal(true);\n  };\n\n  const confirmImpersonate = async () => {\n    if (!selectedUser) return;\n\n    try {\n      setImpersonating(true);\n      const response = await apiClient.impersonateUser(selectedUser.tenant_id, selectedUser.id);\n      \n      if (response.success && response.data?.token) {\n        // Start impersonation\n        apiClient.startImpersonation(response.data.token);\n        \n        // Store impersonation info\n        localStorage.setItem('impersonation_info', JSON.stringify({\n          originalUser: selectedUser,\n          impersonatedAt: new Date().toISOString()\n        }));\n\n        // Redirect to tenant dashboard\n        navigate(`/${selectedUser.tenant_slug}/dashboard`);\n      } else {\n        throw new Error(response.error || 'Failed to impersonate user');\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to impersonate user');\n    } finally {\n      setImpersonating(false);\n      setShowImpersonateModal(false);\n    }\n  };\n\n  const getRoleBadge = (role: string) => {\n    switch (role) {\n      case 'super_admin':\n        return <Badge variant=\"default\" className=\"bg-purple-100 text-purple-800\">Super Admin</Badge>;\n      case 'tenant_admin':\n        return <Badge variant=\"default\" className=\"bg-blue-100 text-blue-800\">Tenant Admin</Badge>;\n      case 'user':\n        return <Badge variant=\"secondary\">User</Badge>;\n      default:\n        return <Badge variant=\"outline\">{role}</Badge>;\n    }\n  };\n\n  const getStatusBadge = (status: string) => {\n    switch (status) {\n      case 'active':\n        return <Badge variant=\"default\" className=\"bg-green-100 text-green-800\">Active</Badge>;\n      case 'inactive':\n        return <Badge variant=\"destructive\">Inactive</Badge>;\n      case 'suspended':\n        return <Badge variant=\"destructive\">Suspended</Badge>;\n      default:\n        return <Badge variant=\"outline\">{status}</Badge>;\n    }\n  };\n\n  const filteredUsers = users.filter(user => {\n    const matchesSearch = \n      user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      user.first_name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      user.last_name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      user.tenant_name.toLowerCase().includes(searchTerm.toLowerCase());\n    \n    const matchesTenant = selectedTenant === 'all' || user.tenant_id === selectedTenant;\n    \n    return matchesSearch && matchesTenant;\n  });\n\n  const uniqueTenants = Array.from(new Set(users.map(user => user.tenant_id)))\n    .map(id => users.find(user => user.tenant_id === id))\n    .filter(Boolean) as User[];\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"></div>\n          <p className=\"text-gray-600\">Loading users...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"mb-6\">\n          <h1 className=\"text-2xl font-bold text-gray-900\">User Management</h1>\n          <p className=\"text-gray-600\">Manage users across all tenants</p>\n        </div>\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-6\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {/* Search and Filters */}\n        <Card className=\"mb-6\">\n          <CardContent className=\"pt-6\">\n            <div className=\"flex items-center space-x-4\">\n              <div className=\"flex-1\">\n                <div className=\"relative\">\n                  <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n                  <Input\n                    placeholder=\"Search users by name, email, or tenant...\"\n                    value={searchTerm}\n                    onChange={(e) => setSearchTerm(e.target.value)}\n                    className=\"pl-10\"\n                  />\n                </div>\n              </div>\n              <div className=\"w-64\">\n                <Label htmlFor=\"tenant-filter\">Filter by Tenant</Label>\n                <select\n                  id=\"tenant-filter\"\n                  value={selectedTenant}\n                  onChange={(e) => setSelectedTenant(e.target.value)}\n                  className=\"w-full mt-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                >\n                  <option value=\"all\">All Tenants</option>\n                  {uniqueTenants.map((user) => (\n                    <option key={user.tenant_id} value={user.tenant_id}>\n                      {user.tenant_name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Users Table */}\n        <Card>\n          <CardHeader>\n            <CardTitle>All Users ({filteredUsers.length})</CardTitle>\n            <CardDescription>Manage user accounts and permissions across tenants</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4\">User</th>\n                    <th className=\"text-left py-3 px-4\">Role</th>\n                    <th className=\"text-left py-3 px-4\">Tenant</th>\n                    <th className=\"text-left py-3 px-4\">Status</th>\n                    <th className=\"text-left py-3 px-4\">Last Login</th>\n                    <th className=\"text-left py-3 px-4\">Actions</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {filteredUsers.map((user) => (\n                    <tr key={user.id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{user.first_name} {user.last_name}</div>\n                          <div className=\"text-sm text-gray-500\">{user.email}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        {getRoleBadge(user.role)}\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{user.tenant_name}</div>\n                          <div className=\"text-sm text-gray-500\">{user.tenant_slug}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        {getStatusBadge(user.status)}\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        {user.last_login ? (\n                          <div>\n                            <div className=\"text-sm\">{new Date(user.last_login).toLocaleDateString()}</div>\n                            <div className=\"text-xs text-gray-500\">\n                              {new Date(user.last_login).toLocaleTimeString()}\n                            </div>\n                          </div>\n                        ) : (\n                          <span className=\"text-gray-400\">Never</span>\n                        )}\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        <div className=\"flex space-x-2\">\n                          {user.role !== 'super_admin' && (\n                            <Button \n                              size=\"sm\" \n                              variant=\"outline\"\n                              onClick={() => handleImpersonate(user)}\n                            >\n                              <UserCheck className=\"h-3 w-3 mr-1\" />\n                              Impersonate\n                            </Button>\n                          )}\n                          <Button \n                            size=\"sm\" \n                            variant=\"outline\"\n                            onClick={() => navigate(`/edgvoip/users/${user.id}/edit`)}\n                          >\n                            <Edit className=\"h-3 w-3 mr-1\" />\n                            Edit\n                          </Button>\n                          {user.role !== 'super_admin' && (\n                            <Button \n                              size=\"sm\" \n                              variant=\"outline\"\n                              onClick={() => {\n                                if (confirm('Are you sure you want to delete this user?')) {\n                                  // TODO: Implement delete user\n                                }\n                              }}\n                            >\n                              <Trash2 className=\"h-3 w-3 mr-1\" />\n                              Delete\n                            </Button>\n                          )}\n                        </div>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Impersonation Confirmation Modal */}\n      <Dialog open={showImpersonateModal} onOpenChange={setShowImpersonateModal}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Confirm Impersonation</DialogTitle>\n            <DialogDescription>\n              You are about to impersonate this user. This will log you in as them and give you access to their tenant.\n            </DialogDescription>\n          </DialogHeader>\n\n          {selectedUser && (\n            <div className=\"space-y-4\">\n              <div className=\"bg-gray-50 p-4 rounded-lg\">\n                <div className=\"flex items-center space-x-3\">\n                  <div className=\"p-2 bg-blue-100 rounded-full\">\n                    <Shield className=\"h-5 w-5 text-blue-600\" />\n                  </div>\n                  <div>\n                    <h4 className=\"font-medium\">{selectedUser.first_name} {selectedUser.last_name}</h4>\n                    <p className=\"text-sm text-gray-500\">{selectedUser.email}</p>\n                  </div>\n                </div>\n                <div className=\"mt-3 flex items-center space-x-4\">\n                  <div className=\"flex items-center space-x-2\">\n                    <Building2 className=\"h-4 w-4 text-gray-400\" />\n                    <span className=\"text-sm\">{selectedUser.tenant_name}</span>\n                  </div>\n                  <div className=\"flex items-center space-x-2\">\n                    <Users className=\"h-4 w-4 text-gray-400\" />\n                    <span className=\"text-sm\">{getRoleBadge(selectedUser.role)}</span>\n                  </div>\n                </div>\n              </div>\n\n              <Alert>\n                <AlertCircle className=\"h-4 w-4\" />\n                <AlertDescription>\n                  You will be redirected to their tenant dashboard. You can exit impersonation at any time using the banner at the top of the page.\n                </AlertDescription>\n              </Alert>\n            </div>\n          )}\n\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setShowImpersonateModal(false)}>\n              Cancel\n            </Button>\n            <Button \n              onClick={confirmImpersonate} \n              disabled={impersonating}\n              className=\"bg-orange-600 hover:bg-orange-700\"\n            >\n              {impersonating ? 'Impersonating...' : 'Confirm Impersonation'}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n","size_bytes":13971},"scripts/install-freeswitch.sh":{"content":"#!/bin/bash\n\n# FreeSWITCH Installation Script for Ubuntu/Debian\n# W3 VoIP System - Local Development Environment\n\nset -e\n\necho \"🚀 Installing FreeSWITCH for W3 VoIP System...\"\n\n# Update system\nsudo apt update && sudo apt upgrade -y\n\n# Install dependencies\nsudo apt install -y \\\n    wget \\\n    gnupg2 \\\n    software-properties-common \\\n    build-essential \\\n    cmake \\\n    git \\\n    pkg-config \\\n    libssl-dev \\\n    libncurses5-dev \\\n    libnewt-dev \\\n    libxml2-dev \\\n    libsqlite3-dev \\\n    uuid-dev \\\n    libjansson-dev \\\n    libbzip2-dev \\\n    libcurl4-openssl-dev \\\n    libpcre3-dev \\\n    libspeex-dev \\\n    libspeexdsp-dev \\\n    libldns-dev \\\n    libedit-dev \\\n    libtiff5-dev \\\n    libsndfile1-dev \\\n    libmpg123-dev \\\n    libmp3lame-dev \\\n    libopus-dev \\\n    libavcodec-dev \\\n    libavformat-dev \\\n    libavutil-dev \\\n    libswscale-dev \\\n    libavresample-dev \\\n    libavfilter-dev \\\n    libavdevice-dev \\\n    libflite1-dev \\\n    libsndfile1-dev \\\n    libsamplerate0-dev \\\n    libsoxr-dev \\\n    libgstreamer1.0-dev \\\n    libgstreamer-plugins-base1.0-dev \\\n    libgstreamer-plugins-bad1.0-dev \\\n    gstreamer1.0-plugins-base \\\n    gstreamer1.0-plugins-good \\\n    gstreamer1.0-plugins-bad \\\n    gstreamer1.0-plugins-ugly \\\n    gstreamer1.0-libav \\\n    gstreamer1.0-tools \\\n    gstreamer1.0-x \\\n    gstreamer1.0-alsa \\\n    gstreamer1.0-gl \\\n    gstreamer1.0-gtk3 \\\n    gstreamer1.0-qt5 \\\n    gstreamer1.0-pulseaudio \\\n    libav-tools \\\n    ffmpeg\n\n# Add FreeSWITCH repository\nwget -O - https://files.freeswitch.org/repo/deb/debian-release/fsstretch-archive-keyring.asc | sudo apt-key add -\necho \"deb http://files.freeswitch.org/repo/deb/debian-release/ `lsb_release -sc` main\" | sudo tee /etc/apt/sources.list.d/freeswitch.list\necho \"deb-src http://files.freeswitch.org/repo/deb/debian-release/ `lsb_release -sc` main\" | sudo tee -a /etc/apt/sources.list.d/freeswitch.list\n\n# Update package list\nsudo apt update\n\n# Install FreeSWITCH\nsudo apt install -y freeswitch freeswitch-mod-commands freeswitch-mod-conference freeswitch-mod-dptools freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-db freeswitch-mod-dialplan-xml freeswitch-mod-dingaling freeswitch-mod-directory freeswitch-mod-distributor freeswitch-mod-easyroute freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-json-cdr freeswitch-mod-local-stream freeswitch-mod-logfile freeswitch-mod-loopback freeswitch-mod-commands freeswitch-mod-conference freeswitch-mod-dptools freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-db freeswitch-mod-dialplan-xml freeswitch-mod-dingaling freeswitch-mod-directory freeswitch-mod-distributor freeswitch-mod-easyroute freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-json-cdr freeswitch-mod-local-stream freeswitch-mod-logfile freeswitch-mod-loopback freeswitch-mod-lua freeswitch-mod-nibblebill freeswitch-mod-odbc-cdr freeswitch-mod-oreka freeswitch-mod-perl freeswitch-mod-python freeswitch-mod-random freeswitch-mod-redis freeswitch-mod-rss freeswitch-mod-say-it freeswitch-mod-sndfile freeswitch-mod-snmp freeswitch-mod-sonar freeswitch-mod-soundtouch freeswitch-mod-spandsp freeswitch-mod-spy freeswitch-mod-stress freeswitch-mod-translate freeswitch-mod-valet-parking freeswitch-mod-vmd freeswitch-mod-voicemail freeswitch-mod-voicemail-ivr freeswitch-mod-xml-cdr freeswitch-mod-xml-curl freeswitch-mod-xml-rpc freeswitch-mod-xml-scgi freeswitch-mod-yaml freeswitch-mod-yuv freeswitch-mod-conference freeswitch-mod-dptools freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-db freeswitch-mod-dialplan-xml freeswitch-mod-dingaling freeswitch-mod-directory freeswitch-mod-distributor freeswitch-mod-easyroute freeswitch-mod-enum freeswitch-mod-esf freeswitch-mod-expr freeswitch-mod-fifo freeswitch-mod-fsv freeswitch-mod-hash freeswitch-mod-httapi freeswitch-mod-json-cdr freeswitch-mod-local-stream freeswitch-mod-logfile freeswitch-mod-loopback freeswitch-mod-lua freeswitch-mod-nibblebill freeswitch-mod-odbc-cdr freeswitch-mod-oreka freeswitch-mod-perl freeswitch-mod-python freeswitch-mod-random freeswitch-mod-redis freeswitch-mod-rss freeswitch-mod-say-it freeswitch-mod-sndfile freeswitch-mod-snmp freeswitch-mod-sonar freeswitch-mod-soundtouch freeswitch-mod-spandsp freeswitch-mod-spy freeswitch-mod-stress freeswitch-mod-translate freeswitch-mod-valet-parking freeswitch-mod-vmd freeswitch-mod-voicemail freeswitch-mod-voicemail-ivr freeswitch-mod-xml-cdr freeswitch-mod-xml-curl freeswitch-mod-xml-rpc freeswitch-mod-xml-scgi freeswitch-mod-yaml freeswitch-mod-yuv\n\n# Install additional FreeSWITCH modules\nsudo apt install -y \\\n    freeswitch-mod-av \\\n    freeswitch-mod-avmd \\\n    freeswitch-mod-b64 \\\n    freeswitch-mod-basic \\\n    freeswitch-mod-broadcast \\\n    freeswitch-mod-callcenter \\\n    freeswitch-mod-cdr-csv \\\n    freeswitch-mod-cdr-mongodb \\\n    freeswitch-mod-cdr-pg-csv \\\n    freeswitch-mod-cdr-sqlite \\\n    freeswitch-mod-cidlookup \\\n    freeswitch-mod-commands \\\n    freeswitch-mod-conference \\\n    freeswitch-mod-curl \\\n    freeswitch-mod-db \\\n    freeswitch-mod-dialplan-asterisk \\\n    freeswitch-mod-dialplan-xml \\\n    freeswitch-mod-directory \\\n    freeswitch-mod-distributor \\\n    freeswitch-mod-dptools \\\n    freeswitch-mod-easyroute \\\n    freeswitch-mod-enum \\\n    freeswitch-mod-esf \\\n    freeswitch-mod-esl \\\n    freeswitch-mod-expr \\\n    freeswitch-mod-fifo \\\n    freeswitch-mod-format-cdr \\\n    freeswitch-mod-fsv \\\n    freeswitch-mod-hash \\\n    freeswitch-mod-httapi \\\n    freeswitch-mod-http-cache \\\n    freeswitch-mod-json-cdr \\\n    freeswitch-mod-local-stream \\\n    freeswitch-mod-logfile \\\n    freeswitch-mod-loopback \\\n    freeswitch-mod-lua \\\n    freeswitch-mod-memcache \\\n    freeswitch-mod-nibblebill \\\n    freeswitch-mod-odbc-cdr \\\n    freeswitch-mod-oreka \\\n    freeswitch-mod-perl \\\n    freeswitch-mod-python \\\n    freeswitch-mod-random \\\n    freeswitch-mod-redis \\\n    freeswitch-mod-rss \\\n    freeswitch-mod-say-it \\\n    freeswitch-mod-sndfile \\\n    freeswitch-mod-snmp \\\n    freeswitch-mod-sonar \\\n    freeswitch-mod-soundtouch \\\n    freeswitch-mod-spandsp \\\n    freeswitch-mod-spy \\\n    freeswitch-mod-stress \\\n    freeswitch-mod-translate \\\n    freeswitch-mod-valet-parking \\\n    freeswitch-mod-vmd \\\n    freeswitch-mod-voicemail \\\n    freeswitch-mod-voicemail-ivr \\\n    freeswitch-mod-xml-cdr \\\n    freeswitch-mod-xml-curl \\\n    freeswitch-mod-xml-rpc \\\n    freeswitch-mod-xml-scgi \\\n    freeswitch-mod-yaml \\\n    freeswitch-mod-yuv\n\n# Create FreeSWITCH directories\nsudo mkdir -p /var/lib/freeswitch/recordings\nsudo mkdir -p /var/lib/freeswitch/storage\nsudo mkdir -p /var/lib/freeswitch/db\nsudo mkdir -p /var/log/freeswitch\n\n# Set permissions\nsudo chown -R freeswitch:freeswitch /var/lib/freeswitch\nsudo chown -R freeswitch:freeswitch /var/log/freeswitch\nsudo chown -R freeswitch:freeswitch /etc/freeswitch\n\n# Enable and start FreeSWITCH\nsudo systemctl enable freeswitch\nsudo systemctl start freeswitch\n\n# Check status\necho \"✅ FreeSWITCH installation completed!\"\necho \"📊 FreeSWITCH Status:\"\nsudo systemctl status freeswitch --no-pager\n\necho \"\"\necho \"🔧 Configuration files location:\"\necho \"   - Main config: /etc/freeswitch\"\necho \"   - Logs: /var/log/freeswitch\"\necho \"   - Recordings: /var/lib/freeswitch/recordings\"\necho \"\"\necho \"🌐 Event Socket Library (ESL) available on:\"\necho \"   - Host: localhost\"\necho \"   - Port: 8021\"\necho \"   - Password: ClueCon\"\necho \"\"\necho \"📞 SIP Profile available on:\"\necho \"   - Internal: 5060\"\necho \"   - External: 5080\"\necho \"\"\necho \"🚀 FreeSWITCH is ready for W3 VoIP System!\"\n\n","size_bytes":8025},"packages/backend/src/services/cdr-activity-service.ts":{"content":"// @ts-nocheck\r\nimport { v4 as uuidv4 } from 'uuid';\r\n// import { VoipCdr, VoipActivityLog } from '@w3-voip/shared';\r\n\r\n// Define types locally\r\nexport interface VoipCdr {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  extension_id?: string;\r\n  trunk_id?: string;\r\n  call_uuid: string;\r\n  direction: 'inbound' | 'outbound' | 'internal';\r\n  caller_id: string;\r\n  called_id: string;\r\n  start_time: Date;\r\n  answer_time?: Date;\r\n  end_time?: Date;\r\n  duration: number;\r\n  bill_seconds: number;\r\n  disposition: 'ANSWERED' | 'NO_ANSWER' | 'BUSY' | 'FAILED';\r\n  hangup_cause: string;\r\n  recording_path?: string;\r\n  created_at: Date;\r\n}\r\n\r\nexport interface VoipActivityLog {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  extension_id?: string;\r\n  trunk_id?: string;\r\n  action: string;\r\n  details: any;\r\n  timestamp: Date;\r\n  created_at: Date;\r\n}\r\n\r\nexport interface TenantContext {\r\n  tenant_id: string;\r\n  sip_domain: string;\r\n  store_id?: string;\r\n}\r\n\r\nexport interface CdrFilters {\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  start_date?: string;\r\n  end_date?: string;\r\n  direction?: 'in' | 'out';\r\n  disposition?: 'ANSWERED' | 'NO_ANSWER' | 'BUSY' | 'FAILED';\r\n  ext_number?: string;\r\n  did_e164?: string;\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport interface ActivityLogFilters {\r\n  tenant_id: string;\r\n  actor?: string;\r\n  action?: 'create' | 'update' | 'delete' | 'provision' | 'sync';\r\n  target_type?: 'trunk' | 'did' | 'ext' | 'route' | 'policy';\r\n  target_id?: string;\r\n  status?: 'ok' | 'fail';\r\n  start_date?: string;\r\n  end_date?: string;\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport class CdrActivityService {\r\n  // Mock database - in production this would be real database operations\r\n  private mockCdrs: VoipCdr[] = [];\r\n  private mockActivityLogs: VoipActivityLog[] = [];\r\n\r\n  // ===== VOIP CDR =====\r\n  async createCdr(cdrData: Partial<VoipCdr>): Promise<VoipCdr> {\r\n    const cdr: VoipCdr = {\r\n      id: uuidv4(),\r\n      tenant_id: cdrData.tenant_id!,\r\n      store_id: cdrData.store_id,\r\n      sip_domain: cdrData.sip_domain!,\r\n      call_id: cdrData.call_id!,\r\n      direction: cdrData.direction!,\r\n      from_uri: cdrData.from_uri!,\r\n      to_uri: cdrData.to_uri!,\r\n      did_e164: cdrData.did_e164,\r\n      ext_number: cdrData.ext_number,\r\n      start_ts: cdrData.start_ts!,\r\n      answer_ts: cdrData.answer_ts,\r\n      end_ts: cdrData.end_ts!,\r\n      billsec: cdrData.billsec || 0,\r\n      disposition: cdrData.disposition!,\r\n      recording_url: cdrData.recording_url,\r\n      meta_json: cdrData.meta_json\r\n    };\r\n\r\n    this.mockCdrs.push(cdr);\r\n    console.log(`Created CDR: ${cdr.call_id} for tenant: ${cdr.tenant_id}`);\r\n    return cdr;\r\n  }\r\n\r\n  async getCdrs(filters: CdrFilters): Promise<{ cdrs: VoipCdr[]; total: number }> {\r\n    let filteredCdrs = this.mockCdrs.filter(cdr => cdr.tenant_id === filters.tenant_id);\r\n\r\n    // Apply filters\r\n    if (filters.store_id) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.store_id === filters.store_id);\r\n    }\r\n\r\n    if (filters.direction) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.direction === filters.direction);\r\n    }\r\n\r\n    if (filters.disposition) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.disposition === filters.disposition);\r\n    }\r\n\r\n    if (filters.ext_number) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.ext_number === filters.ext_number);\r\n    }\r\n\r\n    if (filters.did_e164) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.did_e164 === filters.did_e164);\r\n    }\r\n\r\n    if (filters.start_date) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts >= filters.start_date!);\r\n    }\r\n\r\n    if (filters.end_date) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts <= filters.end_date!);\r\n    }\r\n\r\n    const total = filteredCdrs.length;\r\n\r\n    // Apply pagination\r\n    const offset = filters.offset || 0;\r\n    const limit = filters.limit || 100;\r\n    const paginatedCdrs = filteredCdrs.slice(offset, offset + limit);\r\n\r\n    return { cdrs: paginatedCdrs, total };\r\n  }\r\n\r\n  async getCdrById(cdrId: string, tenantId: string): Promise<VoipCdr | null> {\r\n    return this.mockCdrs.find(cdr => \r\n      cdr.id === cdrId && cdr.tenant_id === tenantId\r\n    ) || null;\r\n  }\r\n\r\n  async getCdrStats(tenantId: string, storeId?: string, startDate?: string, endDate?: string): Promise<{\r\n    total_calls: number;\r\n    answered_calls: number;\r\n    missed_calls: number;\r\n    total_duration: number;\r\n    avg_duration: number;\r\n    by_direction: { inbound: number; outbound: number };\r\n    by_disposition: Record<string, number>;\r\n  }> {\r\n    let filteredCdrs = this.mockCdrs.filter(cdr => cdr.tenant_id === tenantId);\r\n\r\n    if (storeId) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.store_id === storeId);\r\n    }\r\n\r\n    if (startDate) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts >= startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts <= endDate);\r\n    }\r\n\r\n    const total_calls = filteredCdrs.length;\r\n    const answered_calls = filteredCdrs.filter(cdr => cdr.disposition === 'ANSWERED').length;\r\n    const missed_calls = total_calls - answered_calls;\r\n    const total_duration = filteredCdrs.reduce((sum, cdr) => sum + cdr.billsec, 0);\r\n    const avg_duration = total_calls > 0 ? total_duration / total_calls : 0;\r\n\r\n    const by_direction = {\r\n      inbound: filteredCdrs.filter(cdr => cdr.direction === 'in').length,\r\n      outbound: filteredCdrs.filter(cdr => cdr.direction === 'out').length\r\n    };\r\n\r\n    const by_disposition = filteredCdrs.reduce((acc, cdr) => {\r\n      acc[cdr.disposition] = (acc[cdr.disposition] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    return {\r\n      total_calls,\r\n      answered_calls,\r\n      missed_calls,\r\n      total_duration,\r\n      avg_duration,\r\n      by_direction,\r\n      by_disposition\r\n    };\r\n  }\r\n\r\n  // ===== VOIP ACTIVITY LOG =====\r\n  async createActivityLog(tenantContext: TenantContext, logData: {\r\n    actor: string;\r\n    action: 'create' | 'update' | 'delete' | 'provision' | 'sync';\r\n    target_type: 'trunk' | 'did' | 'ext' | 'route' | 'policy';\r\n    target_id: string;\r\n    status: 'ok' | 'fail';\r\n    details_json?: any;\r\n  }): Promise<VoipActivityLog> {\r\n    const log: VoipActivityLog = {\r\n      id: uuidv4(),\r\n      tenant_id: tenantContext.tenant_id,\r\n      actor: logData.actor,\r\n      action: logData.action,\r\n      target_type: logData.target_type,\r\n      target_id: logData.target_id,\r\n      status: logData.status,\r\n      details_json: logData.details_json,\r\n      ts: new Date().toISOString()\r\n    };\r\n\r\n    this.mockActivityLogs.push(log);\r\n    console.log(`Created activity log: ${log.action} ${log.target_type} for tenant: ${log.tenant_id}`);\r\n    return log;\r\n  }\r\n\r\n  async getActivityLogs(filters: ActivityLogFilters): Promise<{ logs: VoipActivityLog[]; total: number }> {\r\n    let filteredLogs = this.mockActivityLogs.filter(log => log.tenant_id === filters.tenant_id);\r\n\r\n    // Apply filters\r\n    if (filters.actor) {\r\n      filteredLogs = filteredLogs.filter(log => log.actor.includes(filters.actor!));\r\n    }\r\n\r\n    if (filters.action) {\r\n      filteredLogs = filteredLogs.filter(log => log.action === filters.action);\r\n    }\r\n\r\n    if (filters.target_type) {\r\n      filteredLogs = filteredLogs.filter(log => log.target_type === filters.target_type);\r\n    }\r\n\r\n    if (filters.target_id) {\r\n      filteredLogs = filteredLogs.filter(log => log.target_id === filters.target_id);\r\n    }\r\n\r\n    if (filters.status) {\r\n      filteredLogs = filteredLogs.filter(log => log.status === filters.status);\r\n    }\r\n\r\n    if (filters.start_date) {\r\n      filteredLogs = filteredLogs.filter(log => log.ts >= filters.start_date!);\r\n    }\r\n\r\n    if (filters.end_date) {\r\n      filteredLogs = filteredLogs.filter(log => log.ts <= filters.end_date!);\r\n    }\r\n\r\n    const total = filteredLogs.length;\r\n\r\n    // Apply pagination\r\n    const offset = filters.offset || 0;\r\n    const limit = filters.limit || 100;\r\n    const paginatedLogs = filteredLogs.slice(offset, offset + limit);\r\n\r\n    return { logs: paginatedLogs, total };\r\n  }\r\n\r\n  async getActivityLogById(logId: string, tenantId: string): Promise<VoipActivityLog | null> {\r\n    return this.mockActivityLogs.find(log => \r\n      log.id === logId && log.tenant_id === tenantId\r\n    ) || null;\r\n  }\r\n\r\n  async getActivityStats(tenantId: string, startDate?: string, endDate?: string): Promise<{\r\n    total_actions: number;\r\n    successful_actions: number;\r\n    failed_actions: number;\r\n    by_action: Record<string, number>;\r\n    by_target_type: Record<string, number>;\r\n    by_actor: Record<string, number>;\r\n  }> {\r\n    let filteredLogs = this.mockActivityLogs.filter(log => log.tenant_id === tenantId);\r\n\r\n    if (startDate) {\r\n      filteredLogs = filteredLogs.filter(log => log.ts >= startDate);\r\n    }\r\n\r\n    if (endDate) {\r\n      filteredLogs = filteredLogs.filter(log => log.ts <= endDate);\r\n    }\r\n\r\n    const total_actions = filteredLogs.length;\r\n    const successful_actions = filteredLogs.filter(log => log.status === 'ok').length;\r\n    const failed_actions = filteredLogs.filter(log => log.status === 'fail').length;\r\n\r\n    const by_action = filteredLogs.reduce((acc, log) => {\r\n      acc[log.action] = (acc[log.action] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    const by_target_type = filteredLogs.reduce((acc, log) => {\r\n      acc[log.target_type] = (acc[log.target_type] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    const by_actor = filteredLogs.reduce((acc, log) => {\r\n      acc[log.actor] = (acc[log.actor] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    return {\r\n      total_actions,\r\n      successful_actions,\r\n      failed_actions,\r\n      by_action,\r\n      by_target_type,\r\n      by_actor\r\n    };\r\n  }\r\n\r\n  // ===== UTILITY METHODS =====\r\n  async generateMockData(tenantId: string, sipDomain: string): Promise<void> {\r\n    // Generate some mock CDRs\r\n    const mockCdrs: Partial<VoipCdr>[] = [\r\n      {\r\n        tenant_id: tenantId,\r\n        sip_domain: sipDomain,\r\n        call_id: 'call-001',\r\n        direction: 'inbound',\r\n        from_uri: '+390686356924',\r\n        to_uri: '1001',\r\n        did_e164: '+390686356924',\r\n        ext_number: '1001',\r\n        start_ts: new Date(Date.now() - 3600000).toISOString(),\r\n        answer_ts: new Date(Date.now() - 3595000).toISOString(),\r\n        end_ts: new Date(Date.now() - 3000000).toISOString(),\r\n        billsec: 600,\r\n        disposition: 'ANSWERED',\r\n        recording_url: 'https://recordings.example.com/call-001.wav',\r\n        meta_json: { codec: 'G729', mos: 4.2 }\r\n      },\r\n      {\r\n        tenant_id: tenantId,\r\n        sip_domain: sipDomain,\r\n        call_id: 'call-002',\r\n        direction: 'outbound',\r\n        from_uri: '1001',\r\n        to_uri: '+39061234567',\r\n        ext_number: '1001',\r\n        start_ts: new Date(Date.now() - 1800000).toISOString(),\r\n        end_ts: new Date(Date.now() - 1750000).toISOString(),\r\n        billsec: 0,\r\n        disposition: 'NO_ANSWER',\r\n        meta_json: { codec: 'G729' }\r\n      }\r\n    ];\r\n\r\n    for (const cdrData of mockCdrs) {\r\n      await this.createCdr(cdrData);\r\n    }\r\n\r\n    // Generate some mock activity logs\r\n    const mockLogs = [\r\n      {\r\n        actor: 'user:admin',\r\n        action: 'create' as const,\r\n        target_type: 'trunk' as const,\r\n        target_id: 'trunk-001',\r\n        status: 'ok' as const,\r\n        details_json: { provider: 'Messagenet', proxy: 'sip.messagenet.it' }\r\n      },\r\n      {\r\n        actor: 'user:admin',\r\n        action: 'create' as const,\r\n        target_type: 'ext' as const,\r\n        target_id: 'ext-001',\r\n        status: 'ok' as const,\r\n        details_json: { ext_number: '1001', display_name: 'John Doe' }\r\n      }\r\n    ];\r\n\r\n    for (const logData of mockLogs) {\r\n      await this.createActivityLog({ tenant_id: tenantId, sip_domain: sipDomain }, logData);\r\n    }\r\n\r\n    console.log(`Generated mock data for tenant: ${tenantId}`);\r\n  }\r\n}\r\n","size_bytes":12110},"packages/backend/src/services/ring-group.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Ring Group interfaces\r\nexport interface RingGroup {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  strategy: 'ringall' | 'hunt' | 'random' | 'simultaneous';\r\n  ring_time: number;\r\n  members: Array<{\r\n    extension_id: string;\r\n    extension: string;\r\n    display_name: string;\r\n    priority: number;\r\n    ring_delay: number;\r\n    ring_timeout: number;\r\n    enabled: boolean;\r\n  }>;\r\n  member_settings: any;\r\n  moh_sound?: string;\r\n  voicemail_enabled: boolean;\r\n  voicemail_extension?: string;\r\n  voicemail_password?: string;\r\n  voicemail_email?: string;\r\n  call_timeout: number;\r\n  call_timeout_action: 'voicemail' | 'hangup' | 'forward';\r\n  call_timeout_destination?: string;\r\n  failover_enabled: boolean;\r\n  failover_destination_type?: string;\r\n  failover_destination_id?: string;\r\n  failover_destination_data?: any;\r\n  caller_id_name?: string;\r\n  caller_id_number?: string;\r\n  recording_enabled: boolean;\r\n  recording_path?: string;\r\n  recording_consent_required: boolean;\r\n  max_concurrent_calls: number;\r\n  current_calls: number;\r\n  settings: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface RingGroupMember {\r\n  id: string;\r\n  ring_group_id: string;\r\n  extension_id: string;\r\n  priority: number;\r\n  ring_delay: number;\r\n  ring_timeout: number;\r\n  enabled: boolean;\r\n  settings: any;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface RingGroupCallLog {\r\n  id: string;\r\n  ring_group_id: string;\r\n  call_uuid: string;\r\n  caller_id_name?: string;\r\n  caller_id_number?: string;\r\n  destination_number?: string;\r\n  start_time: Date;\r\n  end_time?: Date;\r\n  duration: number;\r\n  hangup_cause?: string;\r\n  answered_by_extension?: string;\r\n  answered_by_name?: string;\r\n  recording_path?: string;\r\n  settings: any;\r\n  created_at: Date;\r\n}\r\n\r\nexport class RingGroupService {\r\n  // Create a new ring group\r\n  async createRingGroup(ringGroupData: Partial<RingGroup>): Promise<RingGroup> {\r\n    return withTransaction(async (client) => {\r\n      // Verify tenant exists\r\n      const tenantResult = await client.query(\r\n        'SELECT id FROM tenants WHERE id = $1 AND status = $2',\r\n        [ringGroupData.tenant_id, 'active']\r\n      );\r\n\r\n      if (tenantResult.rows.length === 0) {\r\n        throw new Error('Tenant not found or inactive');\r\n      }\r\n\r\n      // Check if extension is already in use\r\n      const extensionCheck = await client.query(\r\n        'SELECT id FROM ring_groups WHERE extension = $1 AND tenant_id = $2',\r\n        [ringGroupData.extension, ringGroupData.tenant_id]\r\n      );\r\n\r\n      if (extensionCheck.rows.length > 0) {\r\n        throw new Error('Extension already in use by another ring group');\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO ring_groups (\r\n          id, tenant_id, store_id, name, description, extension, strategy,\r\n          ring_time, member_settings, moh_sound, voicemail_enabled,\r\n          voicemail_extension, voicemail_password, voicemail_email,\r\n          call_timeout, call_timeout_action, call_timeout_destination,\r\n          failover_enabled, failover_destination_type, failover_destination_id,\r\n          failover_destination_data, caller_id_name, caller_id_number,\r\n          recording_enabled, recording_path, recording_consent_required,\r\n          max_concurrent_calls, current_calls, settings, enabled\r\n        ) VALUES (\r\n          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,\r\n          $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31\r\n        ) RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          ringGroupData.tenant_id,\r\n          ringGroupData.store_id,\r\n          ringGroupData.name,\r\n          ringGroupData.description,\r\n          ringGroupData.extension,\r\n          ringGroupData.strategy || 'ringall',\r\n          ringGroupData.ring_time || 20,\r\n          JSON.stringify(ringGroupData.member_settings || {}),\r\n          ringGroupData.moh_sound,\r\n          ringGroupData.voicemail_enabled || false,\r\n          ringGroupData.voicemail_extension,\r\n          ringGroupData.voicemail_password,\r\n          ringGroupData.voicemail_email,\r\n          ringGroupData.call_timeout || 60,\r\n          ringGroupData.call_timeout_action || 'voicemail',\r\n          ringGroupData.call_timeout_destination,\r\n          ringGroupData.failover_enabled || false,\r\n          ringGroupData.failover_destination_type,\r\n          ringGroupData.failover_destination_id,\r\n          JSON.stringify(ringGroupData.failover_destination_data || {}),\r\n          ringGroupData.caller_id_name,\r\n          ringGroupData.caller_id_number,\r\n          ringGroupData.recording_enabled || false,\r\n          ringGroupData.recording_path,\r\n          ringGroupData.recording_consent_required !== false,\r\n          ringGroupData.max_concurrent_calls || 10,\r\n          ringGroupData.current_calls || 0,\r\n          JSON.stringify(ringGroupData.settings || {}),\r\n          ringGroupData.enabled !== false\r\n        ]\r\n      );\r\n\r\n      const ringGroup = result.rows[0];\r\n      return this.mapRowToRingGroup(ringGroup);\r\n    });\r\n  }\r\n\r\n  // Get ring groups for a tenant\r\n  async getRingGroups(tenantId: string, storeId?: string): Promise<RingGroup[]> {\r\n    const client = await getClient();\r\n    try {\r\n      let query = `\r\n        SELECT rg.*, \r\n               COALESCE(\r\n                 (SELECT jsonb_agg(\r\n                   jsonb_build_object(\r\n                     'extension_id', rgm.extension_id,\r\n                     'extension', e.extension,\r\n                     'display_name', e.display_name,\r\n                     'priority', rgm.priority,\r\n                     'ring_delay', rgm.ring_delay,\r\n                     'ring_timeout', rgm.ring_timeout,\r\n                     'enabled', rgm.enabled\r\n                   )\r\n                 )\r\n                 FROM ring_group_members rgm\r\n                 JOIN extensions e ON rgm.extension_id = e.id\r\n                 WHERE rgm.ring_group_id = rg.id\r\n                 AND rgm.enabled = true\r\n                 ORDER BY rgm.priority ASC\r\n                ), '[]'::jsonb\r\n               ) as members\r\n        FROM ring_groups rg\r\n        WHERE rg.tenant_id = $1\r\n      `;\r\n      \r\n      const params: any[] = [tenantId];\r\n      \r\n      if (storeId) {\r\n        query += ' AND rg.store_id = $2';\r\n        params.push(storeId);\r\n      }\r\n      \r\n      query += ' ORDER BY rg.name ASC';\r\n      \r\n      const result = await client.query(query, params);\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToRingGroup(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Get ring group by ID\r\n  async getRingGroup(ringGroupId: string): Promise<RingGroup | null> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT rg.*, \r\n                COALESCE(\r\n                  (SELECT jsonb_agg(\r\n                    jsonb_build_object(\r\n                      'extension_id', rgm.extension_id,\r\n                      'extension', e.extension,\r\n                      'display_name', e.display_name,\r\n                      'priority', rgm.priority,\r\n                      'ring_delay', rgm.ring_delay,\r\n                      'ring_timeout', rgm.ring_timeout,\r\n                      'enabled', rgm.enabled\r\n                    )\r\n                  )\r\n                  FROM ring_group_members rgm\r\n                  JOIN extensions e ON rgm.extension_id = e.id\r\n                  WHERE rgm.ring_group_id = rg.id\r\n                  AND rgm.enabled = true\r\n                  ORDER BY rgm.priority ASC\r\n                 ), '[]'::jsonb\r\n                ) as members\r\n         FROM ring_groups rg\r\n         WHERE rg.id = $1`,\r\n        [ringGroupId]\r\n      );\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      return this.mapRowToRingGroup(result.rows[0]);\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Add member to ring group\r\n  async addMember(ringGroupId: string, extensionId: string, memberData: Partial<RingGroupMember>): Promise<RingGroupMember> {\r\n    return withTransaction(async (client) => {\r\n      // Verify ring group exists\r\n      const ringGroupResult = await client.query(\r\n        'SELECT id FROM ring_groups WHERE id = $1',\r\n        [ringGroupId]\r\n      );\r\n\r\n      if (ringGroupResult.rows.length === 0) {\r\n        throw new Error('Ring group not found');\r\n      }\r\n\r\n      // Verify extension exists\r\n      const extensionResult = await client.query(\r\n        'SELECT id FROM extensions WHERE id = $1',\r\n        [extensionId]\r\n      );\r\n\r\n      if (extensionResult.rows.length === 0) {\r\n        throw new Error('Extension not found');\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO ring_group_members (\r\n          id, ring_group_id, extension_id, priority, ring_delay, \r\n          ring_timeout, enabled, settings\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n        ON CONFLICT (ring_group_id, extension_id) \r\n        DO UPDATE SET \r\n          priority = EXCLUDED.priority,\r\n          ring_delay = EXCLUDED.ring_delay,\r\n          ring_timeout = EXCLUDED.ring_timeout,\r\n          enabled = EXCLUDED.enabled,\r\n          settings = EXCLUDED.settings,\r\n          updated_at = CURRENT_TIMESTAMP\r\n        RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          ringGroupId,\r\n          extensionId,\r\n          memberData.priority || 100,\r\n          memberData.ring_delay || 0,\r\n          memberData.ring_timeout || 20,\r\n          memberData.enabled !== false,\r\n          JSON.stringify(memberData.settings || {})\r\n        ]\r\n      );\r\n\r\n      return this.mapRowToRingGroupMember(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Remove member from ring group\r\n  async removeMember(ringGroupId: string, extensionId: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        'DELETE FROM ring_group_members WHERE ring_group_id = $1 AND extension_id = $2',\r\n        [ringGroupId, extensionId]\r\n      );\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('Member not found in ring group');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Update ring group member settings\r\n  async updateMember(ringGroupId: string, extensionId: string, memberData: Partial<RingGroupMember>): Promise<RingGroupMember> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `UPDATE ring_group_members SET \r\n          priority = COALESCE($1, priority),\r\n          ring_delay = COALESCE($2, ring_delay),\r\n          ring_timeout = COALESCE($3, ring_timeout),\r\n          enabled = COALESCE($4, enabled),\r\n          settings = COALESCE($5, settings),\r\n          updated_at = CURRENT_TIMESTAMP\r\n        WHERE ring_group_id = $6 AND extension_id = $7\r\n        RETURNING *`,\r\n        [\r\n          memberData.priority,\r\n          memberData.ring_delay,\r\n          memberData.ring_timeout,\r\n          memberData.enabled,\r\n          memberData.settings ? JSON.stringify(memberData.settings) : null,\r\n          ringGroupId,\r\n          extensionId\r\n        ]\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Member not found in ring group');\r\n      }\r\n\r\n      return this.mapRowToRingGroupMember(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Update ring group\r\n  async updateRingGroup(ringGroupId: string, updateData: Partial<RingGroup>): Promise<RingGroup> {\r\n    return withTransaction(async (client) => {\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.description !== undefined) {\r\n        updateFields.push(`description = $${paramCount++}`);\r\n        updateValues.push(updateData.description);\r\n      }\r\n      if (updateData.strategy) {\r\n        updateFields.push(`strategy = $${paramCount++}`);\r\n        updateValues.push(updateData.strategy);\r\n      }\r\n      if (updateData.ring_time !== undefined) {\r\n        updateFields.push(`ring_time = $${paramCount++}`);\r\n        updateValues.push(updateData.ring_time);\r\n      }\r\n      if (updateData.moh_sound !== undefined) {\r\n        updateFields.push(`moh_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.moh_sound);\r\n      }\r\n      if (updateData.voicemail_enabled !== undefined) {\r\n        updateFields.push(`voicemail_enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.voicemail_enabled);\r\n      }\r\n      if (updateData.call_timeout !== undefined) {\r\n        updateFields.push(`call_timeout = $${paramCount++}`);\r\n        updateValues.push(updateData.call_timeout);\r\n      }\r\n      if (updateData.enabled !== undefined) {\r\n        updateFields.push(`enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.enabled);\r\n      }\r\n      if (updateData.settings) {\r\n        updateFields.push(`settings = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.settings));\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        throw new Error('No fields to update');\r\n      }\r\n\r\n      updateFields.push(`updated_at = CURRENT_TIMESTAMP`);\r\n      updateValues.push(ringGroupId);\r\n\r\n      const result = await client.query(\r\n        `UPDATE ring_groups SET ${updateFields.join(', ')} WHERE id = $${paramCount} RETURNING *`,\r\n        updateValues\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        throw new Error('Ring group not found');\r\n      }\r\n\r\n      return this.mapRowToRingGroup(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  // Delete ring group\r\n  async deleteRingGroup(ringGroupId: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        'DELETE FROM ring_groups WHERE id = $1',\r\n        [ringGroupId]\r\n      );\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('Ring group not found');\r\n      }\r\n    });\r\n  }\r\n\r\n  // Get ring group call logs\r\n  async getCallLogs(ringGroupId: string, limit: number = 50, offset: number = 0): Promise<RingGroupCallLog[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM ring_group_call_logs \r\n         WHERE ring_group_id = $1 \r\n         ORDER BY start_time DESC \r\n         LIMIT $2 OFFSET $3`,\r\n        [ringGroupId, limit, offset]\r\n      );\r\n      \r\n      return result.rows.map((row: any) => this.mapRowToRingGroupCallLog(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Log ring group call\r\n  async logCall(callData: Partial<RingGroupCallLog>): Promise<string> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT log_ring_group_call($1, $2, $3, $4, $5, $6)`,\r\n        [\r\n          callData.ring_group_id,\r\n          callData.call_uuid,\r\n          callData.caller_id_name,\r\n          callData.caller_id_number,\r\n          callData.destination_number,\r\n          callData.settings ? JSON.stringify(callData.settings) : '{}'\r\n        ]\r\n      );\r\n\r\n      return result.rows[0].log_ring_group_call;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Update ring group call log\r\n  async updateCallLog(callUuid: string, updateData: Partial<RingGroupCallLog>): Promise<void> {\r\n    const client = await getClient();\r\n    try {\r\n      await client.query(\r\n        `SELECT update_ring_group_call_log($1, $2, $3, $4, $5, $6, $7)`,\r\n        [\r\n          callUuid,\r\n          updateData.end_time,\r\n          updateData.duration,\r\n          updateData.hangup_cause,\r\n          updateData.answered_by_extension,\r\n          updateData.answered_by_name,\r\n          updateData.recording_path\r\n        ]\r\n      );\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Generate FreeSWITCH dialplan XML for ring group\r\n  generateRingGroupXML(ringGroup: RingGroup): string {\r\n    let xml = `\r\n  <!-- Ring Group: ${ringGroup.name} (${ringGroup.extension}) -->\r\n  <extension name=\"ring_group_${ringGroup.id}\">\r\n    <condition field=\"destination_number\" expression=\"^${ringGroup.extension}$\">\r\n      <action application=\"answer\"/>\r\n      <action application=\"set\" data=\"ring_group_id=${ringGroup.id}\"/>\r\n      <action application=\"set\" data=\"ring_group_name=${ringGroup.name}\"/>\r\n      <action application=\"set\" data=\"call_timeout=${ringGroup.call_timeout}\"/>`;\r\n\r\n    // Add caller ID settings\r\n    if (ringGroup.caller_id_name) {\r\n      xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_name=${ringGroup.caller_id_name}\"/>`;\r\n    }\r\n    if (ringGroup.caller_id_number) {\r\n      xml += `\r\n      <action application=\"set\" data=\"effective_caller_id_number=${ringGroup.caller_id_number}\"/>`;\r\n    }\r\n\r\n    // Add music on hold if specified\r\n    if (ringGroup.moh_sound) {\r\n      xml += `\r\n      <action application=\"set\" data=\"moh_sound=${ringGroup.moh_sound}\"/>`;\r\n    }\r\n\r\n    // Generate ring strategy based on configuration\r\n    switch (ringGroup.strategy) {\r\n      case 'ringall':\r\n        xml += this.generateRingAllXML(ringGroup);\r\n        break;\r\n      case 'hunt':\r\n        xml += this.generateHuntXML(ringGroup);\r\n        break;\r\n      case 'random':\r\n        xml += this.generateRandomXML(ringGroup);\r\n        break;\r\n      case 'simultaneous':\r\n        xml += this.generateSimultaneousXML(ringGroup);\r\n        break;\r\n    }\r\n\r\n    // Add timeout action\r\n    xml += this.generateTimeoutActionXML(ringGroup);\r\n\r\n    xml += `\r\n    </condition>\r\n  </extension>`;\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate ring-all strategy XML\r\n  private generateRingAllXML(ringGroup: RingGroup): string {\r\n    const members = ringGroup.members.filter(m => m.enabled);\r\n    if (members.length === 0) {\r\n      return `\r\n      <action application=\"log\" data=\"ERROR No active members in ring group ${ringGroup.name}\"/>\r\n      <action application=\"hangup\" data=\"NO_ANSWER\"/>`;\r\n    }\r\n\r\n    const bridgeTargets = members\r\n      .map(m => `user/${m.extension}@\\${domain_name}`)\r\n      .join(' ');\r\n\r\n    return `\r\n      <action application=\"bridge\" data=\"${bridgeTargets}\"/>`;\r\n  }\r\n\r\n  // Generate hunt strategy XML (sequential ringing)\r\n  private generateHuntXML(ringGroup: RingGroup): string {\r\n    const members = ringGroup.members.filter(m => m.enabled).sort((a, b) => a.priority - b.priority);\r\n    if (members.length === 0) {\r\n      return `\r\n      <action application=\"log\" data=\"ERROR No active members in ring group ${ringGroup.name}\"/>\r\n      <action application=\"hangup\" data=\"NO_ANSWER\"/>`;\r\n    }\r\n\r\n    let xml = '';\r\n    for (let i = 0; i < members.length; i++) {\r\n      const member = members[i];\r\n      const isLast = i === members.length - 1;\r\n      \r\n      xml += `\r\n      <action application=\"bridge\" data=\"user/${member.extension}@\\${domain_name}\"/>`;\r\n      \r\n      if (!isLast) {\r\n        xml += `\r\n      <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|USER_BUSY|UNALLOCATED_NUMBER\">\r\n        <action application=\"log\" data=\"INFO Trying next member in hunt sequence\"/>`;\r\n      }\r\n    }\r\n\r\n    // Close conditions\r\n    for (let i = 0; i < members.length - 1; i++) {\r\n      xml += `\r\n      </condition>`;\r\n    }\r\n\r\n    return xml;\r\n  }\r\n\r\n  // Generate random strategy XML\r\n  private generateRandomXML(ringGroup: RingGroup): string {\r\n    const members = ringGroup.members.filter(m => m.enabled);\r\n    if (members.length === 0) {\r\n      return `\r\n      <action application=\"log\" data=\"ERROR No active members in ring group ${ringGroup.name}\"/>\r\n      <action application=\"hangup\" data=\"NO_ANSWER\"/>`;\r\n    }\r\n\r\n    // For random strategy, we'll use ringall but shuffle the order\r\n    // In a real implementation, you might want to implement proper randomization\r\n    return this.generateRingAllXML(ringGroup);\r\n  }\r\n\r\n  // Generate simultaneous strategy XML\r\n  private generateSimultaneousXML(ringGroup: RingGroup): string {\r\n    return this.generateRingAllXML(ringGroup);\r\n  }\r\n\r\n  // Generate timeout action XML\r\n  private generateTimeoutActionXML(ringGroup: RingGroup): string {\r\n    switch (ringGroup.call_timeout_action) {\r\n      case 'voicemail':\r\n        if (ringGroup.voicemail_enabled && ringGroup.voicemail_extension) {\r\n          return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"voicemail\" data=\"default \\${domain_name} ${ringGroup.voicemail_extension}\"/>\r\n        <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      </condition>`;\r\n        }\r\n        break;\r\n      case 'forward':\r\n        if (ringGroup.call_timeout_destination) {\r\n          return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"bridge\" data=\"user/${ringGroup.call_timeout_destination}@\\${domain_name}\"/>\r\n        <action application=\"hangup\" data=\"NORMAL_CLEARING\"/>\r\n      </condition>`;\r\n        }\r\n        break;\r\n      case 'hangup':\r\n        return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"hangup\" data=\"NO_ANSWER\"/>\r\n      </condition>`;\r\n    }\r\n\r\n    return `\r\n      <condition field=\"hangup_cause\" expression=\"NO_ANSWER|TIMEOUT\">\r\n        <action application=\"hangup\" data=\"NO_ANSWER\"/>\r\n      </condition>`;\r\n  }\r\n\r\n  // Helper methods to map database rows to objects\r\n  private mapRowToRingGroup(row: any): RingGroup {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      store_id: row.store_id,\r\n      name: row.name,\r\n      description: row.description,\r\n      extension: row.extension,\r\n      strategy: row.strategy,\r\n      ring_time: row.ring_time,\r\n      members: typeof row.members === 'string' ? JSON.parse(row.members) : row.members,\r\n      member_settings: typeof row.member_settings === 'string' ? JSON.parse(row.member_settings) : row.member_settings,\r\n      moh_sound: row.moh_sound,\r\n      voicemail_enabled: row.voicemail_enabled,\r\n      voicemail_extension: row.voicemail_extension,\r\n      voicemail_password: row.voicemail_password,\r\n      voicemail_email: row.voicemail_email,\r\n      call_timeout: row.call_timeout,\r\n      call_timeout_action: row.call_timeout_action,\r\n      call_timeout_destination: row.call_timeout_destination,\r\n      failover_enabled: row.failover_enabled,\r\n      failover_destination_type: row.failover_destination_type,\r\n      failover_destination_id: row.failover_destination_id,\r\n      failover_destination_data: typeof row.failover_destination_data === 'string' ? JSON.parse(row.failover_destination_data) : row.failover_destination_data,\r\n      caller_id_name: row.caller_id_name,\r\n      caller_id_number: row.caller_id_number,\r\n      recording_enabled: row.recording_enabled,\r\n      recording_path: row.recording_path,\r\n      recording_consent_required: row.recording_consent_required,\r\n      max_concurrent_calls: row.max_concurrent_calls,\r\n      current_calls: row.current_calls,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      enabled: row.enabled,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n\r\n  private mapRowToRingGroupMember(row: any): RingGroupMember {\r\n    return {\r\n      id: row.id,\r\n      ring_group_id: row.ring_group_id,\r\n      extension_id: row.extension_id,\r\n      priority: row.priority,\r\n      ring_delay: row.ring_delay,\r\n      ring_timeout: row.ring_timeout,\r\n      enabled: row.enabled,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at\r\n    };\r\n  }\r\n\r\n  private mapRowToRingGroupCallLog(row: any): RingGroupCallLog {\r\n    return {\r\n      id: row.id,\r\n      ring_group_id: row.ring_group_id,\r\n      call_uuid: row.call_uuid,\r\n      caller_id_name: row.caller_id_name,\r\n      caller_id_number: row.caller_id_number,\r\n      destination_number: row.destination_number,\r\n      start_time: row.start_time,\r\n      end_time: row.end_time,\r\n      duration: row.duration,\r\n      hangup_cause: row.hangup_cause,\r\n      answered_by_extension: row.answered_by_extension,\r\n      answered_by_name: row.answered_by_name,\r\n      recording_path: row.recording_path,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      created_at: row.created_at\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const ringGroupService = new RingGroupService();\r\n","size_bytes":24694},"packages/frontend/src/components/ui/theme-toggle.tsx":{"content":"import * as React from \"react\"\r\nimport { Moon, Sun } from \"lucide-react\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport function ThemeToggle() {\r\n  const [theme, setTheme] = React.useState<'light' | 'dark'>('light')\r\n\r\n  React.useEffect(() => {\r\n    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' | null\r\n    const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'\r\n    const initialTheme = savedTheme || systemTheme\r\n    \r\n    setTheme(initialTheme)\r\n    document.documentElement.classList.toggle('dark', initialTheme === 'dark')\r\n  }, [])\r\n\r\n  const toggleTheme = () => {\r\n    const newTheme = theme === 'light' ? 'dark' : 'light'\r\n    setTheme(newTheme)\r\n    localStorage.setItem('theme', newTheme)\r\n    document.documentElement.classList.toggle('dark', newTheme === 'dark')\r\n  }\r\n\r\n  return (\r\n    <Button\r\n      variant=\"ghost\"\r\n      size=\"sm\"\r\n      onClick={toggleTheme}\r\n      className={cn(\r\n        \"h-9 w-9 p-0 hover:bg-white/50 hover:scale-105 transition-all duration-200\",\r\n        \"relative overflow-hidden\"\r\n      )}\r\n      title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}\r\n    >\r\n      <Sun className={cn(\r\n        \"h-4 w-4 transition-all duration-300\",\r\n        theme === 'light' ? 'rotate-0 scale-100' : 'rotate-90 scale-0'\r\n      )} />\r\n      <Moon className={cn(\r\n        \"absolute h-4 w-4 transition-all duration-300\",\r\n        theme === 'dark' ? 'rotate-0 scale-100' : '-rotate-90 scale-0'\r\n      )} />\r\n    </Button>\r\n  )\r\n}\r\n","size_bytes":1575},"scripts/test-production.sh":{"content":"#!/bin/bash\n\n# Test script per verificare che il sistema VoIP sia funzionante\n\nset -e\n\nSERVER_IP=\"YOUR_SERVER_IP\"\nSERVER_USER=\"root\"\nSERVER_PASSWORD=\"80gjapA7\"\n\necho \"🧪 Test EDG VoIP System Production\"\necho \"==================================\"\n\n# Test 1: Connessione SSH\necho \"1. Test connessione SSH...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP \"echo 'SSH OK'\"\n\n# Test 2: Servizi attivi\necho \"2. Test servizi attivi...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\necho \"PostgreSQL: $(systemctl is-active postgresql)\"\necho \"Redis: $(systemctl is-active redis-server)\"\necho \"Nginx: $(systemctl is-active nginx)\"\necho \"FreeSWITCH: $(systemctl is-active freeswitch)\"\necho \"VoIP Backend: $(systemctl is-active voip-backend)\"\nEOF\n\n# Test 3: Porte aperte\necho \"3. Test porte...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP \"netstat -tlnp | grep -E ':(80|5000|5060|8021)'\"\n\n# Test 4: API Health\necho \"4. Test API Health...\"\ncurl -f http://$SERVER_IP/api/health || echo \"API non raggiungibile\"\n\n# Test 5: Frontend\necho \"5. Test Frontend...\"\ncurl -f http://$SERVER_IP/ || echo \"Frontend non raggiungibile\"\n\necho \"✅ Test completati!\"\n","size_bytes":1267},"packages/backend/src/middleware/auth.middleware.ts":{"content":"// @ts-nocheck\nimport { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { JWTPayload } from '@w3-voip/shared';\n\nexport interface AuthenticatedRequest extends Request {\n  user?: JWTPayload & {\n    id?: string;\n    email?: string;\n    tenant_slug?: string;\n  };\n}\n\n/**\n * Middleware to authenticate JWT tokens\n */\nexport function authenticateJWT(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  const authHeader = req.headers.authorization;\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      error: 'Access token required'\n    });\n  }\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;\n    req.user = {\n      id: decoded.id,\n      email: decoded.email,\n      role: decoded.role,\n      tenant_id: decoded.tenant_id,\n      tenant_slug: decoded.tenant_slug\n    };\n    next();\n  } catch (error) {\n    return res.status(403).json({\n      success: false,\n      error: 'Invalid or expired token'\n    });\n  }\n}\n\n/**\n * Middleware to require super admin role\n */\nexport function requireSuperAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  if (!req.user) {\n    return res.status(401).json({\n      success: false,\n      error: 'Authentication required'\n    });\n  }\n\n  if (req.user.role !== 'super_admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Super admin access required'\n    });\n  }\n\n  next();\n}\n\n/**\n * Middleware to require admin role (super admin or tenant admin)\n */\nexport function requireAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  if (!req.user) {\n    return res.status(401).json({\n      success: false,\n      error: 'Authentication required'\n    });\n  }\n\n  if (req.user.role !== 'super_admin' && req.user.role !== 'admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Admin access required'\n    });\n  }\n\n  next();\n}\n\n/**\n * Middleware to require tenant admin role\n */\nexport function requireTenantAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  if (!req.user) {\n    return res.status(401).json({\n      success: false,\n      error: 'Authentication required'\n    });\n  }\n\n  if (req.user.role !== 'super_admin' && req.user.role !== 'tenant_admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Tenant admin access required'\n    });\n  }\n\n  next();\n}\n\n/**\n * Middleware to require tenant access (user must belong to the tenant)\n */\nexport function requireTenantAccess(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  if (!req.user) {\n    return res.status(401).json({\n      success: false,\n      error: 'Authentication required'\n    });\n  }\n\n  // Super admin can access any tenant\n  if (req.user.role === 'super_admin') {\n    return next();\n  }\n\n  // Regular users must belong to the tenant\n  const tenantId = req.params.tenantId || req.body.tenant_id;\n  if (req.user.tenant_id !== tenantId) {\n    return res.status(403).json({\n      success: false,\n      error: 'Access denied for this tenant'\n    });\n  }\n\n  next();\n}","size_bytes":3197},"scripts/deploy-to-debian.sh":{"content":"#!/bin/bash\n\n# EDG VoIP System - Deploy to Debian Server\n# Copia il codice sul server e configura l'applicazione\n\nset -e\n\n# Configurazione server\nSERVER_IP=\"YOUR_SERVER_IP\"  # Sostituire con l'IP del server\nSERVER_USER=\"root\"\nSERVER_PASSWORD=\"B66v6My6\"\nLOCAL_PROJECT_PATH=\".\"\n\n# Colori per output\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\nlog() {\n    echo -e \"${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}\"\n}\n\nwarn() {\n    echo -e \"${YELLOW}[WARNING] $1${NC}\"\n}\n\n# Verifica che sshpass sia installato\nif ! command -v sshpass &> /dev/null; then\n    warn \"sshpass non trovato. Installazione...\"\n    if [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"cygwin\" ]]; then\n        # Windows con WSL/Git Bash\n        echo \"Per Windows, installa sshpass manualmente o usa PuTTY\"\n        exit 1\n    else\n        # Linux/macOS\n        sudo apt-get install -y sshpass || brew install sshpass\n    fi\nfi\n\nlog \"🚀 Deploy EDG VoIP System su server Debian\"\nlog \"Server: $SERVER_IP\"\nlog \"User: $SERVER_USER\"\n\n# 1. Creare archivio del progetto\nlog \"Creazione archivio del progetto...\"\ntar --exclude='node_modules' \\\n    --exclude='.git' \\\n    --exclude='dist' \\\n    --exclude='*.log' \\\n    --exclude='.env' \\\n    --exclude='.env.local' \\\n    -czf voip-system.tar.gz \\\n    packages/ \\\n    scripts/ \\\n    env.production \\\n    package.json \\\n    package-lock.json\n\n# 2. Copiare archivio sul server\nlog \"Copia archivio sul server...\"\nsshpass -p \"$SERVER_PASSWORD\" scp -o StrictHostKeyChecking=no voip-system.tar.gz $SERVER_USER@$SERVER_IP:/tmp/\n\n# 3. Estrarre e configurare sul server\nlog \"Configurazione sul server...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\nset -e\n\necho \"📦 Estrazione archivio...\"\ncd /var/www/voip-system\ntar -xzf /tmp/voip-system.tar.gz\nrm /tmp/voip-system.tar.gz\n\necho \"🔧 Configurazione permessi...\"\nchown -R voip:voip /var/www/voip-system\nchmod -R 755 /var/www/voip-system\n\necho \"📦 Installazione dipendenze backend...\"\ncd /var/www/voip-system/packages/backend\nnpm install --production\n\necho \"📦 Installazione dipendenze frontend...\"\ncd /var/www/voip-system/packages/frontend\nnpm install --production\nnpm run build\n\necho \"📦 Installazione dipendenze database...\"\ncd /var/www/voip-system/packages/database\nnpm install --production\n\necho \"📦 Installazione dipendenze shared...\"\ncd /var/www/voip-system/packages/shared\nnpm install --production\n\necho \"🔧 Copia file di configurazione...\"\ncp /var/www/voip-system/env.production /etc/voip-system/.env\nchown voip:voip /etc/voip-system/.env\nchmod 600 /etc/voip-system/.env\n\necho \"📊 Esecuzione migrazioni database...\"\ncd /var/www/voip-system/packages/database\nsource /etc/voip-system/.env\nnpm run migrate\n\necho \"🌱 Seed database...\"\nnpm run seed\n\necho \"✅ Deploy completato!\"\nEOF\n\n# 4. Configurare Nginx\nlog \"Configurazione Nginx...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\ncat > /etc/nginx/sites-available/voip-system << 'NGINX_EOF'\nserver {\n    listen 80;\n    server_name _;\n    \n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\n    limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/m;\n    \n    # Frontend\n    location / {\n        root /var/www/voip-system/packages/frontend/dist;\n        try_files $uri $uri/ /index.html;\n        \n        # Cache static assets\n        location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n    }\n    \n    # API endpoints\n    location /api/ {\n        limit_req zone=api_limit burst=20 nodelay;\n        \n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_cache_bypass $http_upgrade;\n        \n        proxy_connect_timeout 60s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n    \n    # Auth endpoints - stricter rate limiting\n    location ~ ^/api/.*/(login|register) {\n        limit_req zone=auth_limit burst=3 nodelay;\n        \n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n    \n    # WebSocket support\n    location /socket.io/ {\n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        proxy_connect_timeout 7d;\n        proxy_send_timeout 7d;\n        proxy_read_timeout 7d;\n    }\n}\nNGINX_EOF\n\n# Abilitare il sito\nln -sf /etc/nginx/sites-available/voip-system /etc/nginx/sites-enabled/\nrm -f /etc/nginx/sites-enabled/default\n\n# Test configurazione Nginx\nnginx -t\n\n# Riavviare Nginx\nsystemctl restart nginx\nsystemctl enable nginx\n\necho \"✅ Nginx configurato\"\nEOF\n\n# 5. Configurare FreeSWITCH\nlog \"Configurazione FreeSWITCH...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\n# Backup configurazione originale\ncp -r /etc/freeswitch /etc/freeswitch.backup\n\n# Copiare configurazioni personalizzate\ncp -r /var/www/voip-system/docker/freeswitch/conf/* /etc/freeswitch/\n\n# Aggiornare password ESL\nsed -i \"s/ClueCon/1QzGEWv0Q6ao20M+hS8qeLI+u9gw77WuJGB5Z1xDk30=/g\" /etc/freeswitch/vars.xml\n\n# Configurare permessi\nchown -R freeswitch:freeswitch /etc/freeswitch\nchown -R freeswitch:freeswitch /var/lib/freeswitch\nchown -R freeswitch:freeswitch /var/log/freeswitch\n\n# Test configurazione\nfreeswitch -t\n\n# Avviare FreeSWITCH\nsystemctl start freeswitch\nsystemctl enable freeswitch\n\necho \"✅ FreeSWITCH configurato\"\nEOF\n\n# 6. Creare servizio systemd per il backend\nlog \"Creazione servizio systemd...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\ncat > /etc/systemd/system/voip-backend.service << 'SERVICE_EOF'\n[Unit]\nDescription=EDG VoIP System Backend\nAfter=network.target postgresql.service redis.service\n\n[Service]\nType=simple\nUser=voip\nGroup=voip\nWorkingDirectory=/var/www/voip-system/packages/backend\nEnvironment=NODE_ENV=production\nEnvironmentFile=/etc/voip-system/.env\nExecStart=/usr/bin/node dist/index.js\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=voip-backend\n\n[Install]\nWantedBy=multi-user.target\nSERVICE_EOF\n\n# Ricaricare systemd e avviare servizio\nsystemctl daemon-reload\nsystemctl enable voip-backend\nsystemctl start voip-backend\n\necho \"✅ Servizio backend creato e avviato\"\nEOF\n\n# 7. Verificare stato servizi\nlog \"Verifica stato servizi...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\necho \"📊 Stato servizi:\"\necho \"PostgreSQL: $(systemctl is-active postgresql)\"\necho \"Redis: $(systemctl is-active redis-server)\"\necho \"Nginx: $(systemctl is-active nginx)\"\necho \"FreeSWITCH: $(systemctl is-active freeswitch)\"\necho \"VoIP Backend: $(systemctl is-active voip-backend)\"\n\necho \"\"\necho \"🔍 Porte in ascolto:\"\nnetstat -tlnp | grep -E ':(80|443|5000|5060|5061|8021|5432|6379)'\n\necho \"\"\necho \"📝 Log backend:\"\njournalctl -u voip-backend --no-pager -n 10\nEOF\n\n# 8. Pulizia locale\nlog \"Pulizia file temporanei...\"\nrm -f voip-system.tar.gz\n\nlog \"✅ Deploy completato con successo!\"\necho \"\"\necho \"🌐 Accesso all'applicazione:\"\necho \"  Frontend: http://$SERVER_IP\"\necho \"  API: http://$SERVER_IP/api\"\necho \"  Super Admin: http://$SERVER_IP/edgvoip/login\"\necho \"\"\necho \"🔑 Credenziali di default:\"\necho \"  Super Admin: admin@edgvoip.local / SuperAdmin2025!\"\necho \"  Demo Tenant: admin@demo.local / tenantadmin123\"\necho \"\"\necho \"📋 Comandi utili:\"\necho \"  Stato servizi: systemctl status voip-backend\"\necho \"  Log backend: journalctl -u voip-backend -f\"\necho \"  Riavvia backend: systemctl restart voip-backend\"\necho \"  Log FreeSWITCH: journalctl -u freeswitch -f\"\n","size_bytes":8491},"scripts/get-server-ip.sh":{"content":"#!/bin/bash\n\n# Script per ottenere l'IP del server e configurare il deployment\n\necho \"🔍 EDG VoIP System - Server IP Configuration\"\necho \"=============================================\"\n\n# Funzione per testare connessione\ntest_connection() {\n    local ip=$1\n    echo -n \"Test connessione $ip... \"\n    if timeout 5 bash -c \"</dev/tcp/$ip/22\" 2>/dev/null; then\n        echo \"✅ SSH aperto\"\n        return 0\n    else\n        echo \"❌ SSH chiuso\"\n        return 1\n    fi\n}\n\n# Funzione per testare credenziali\ntest_credentials() {\n    local ip=$1\n    echo -n \"Test credenziali $ip... \"\n    if sshpass -p \"80gjapA7\" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 root@$ip \"echo 'OK'\" >/dev/null 2>&1; then\n        echo \"✅ Credenziali valide\"\n        return 0\n    else\n        echo \"❌ Credenziali non valide\"\n        return 1\n    fi\n}\n\necho \"\"\necho \"Inserisci l'IP del server Debian:\"\nread -p \"IP: \" SERVER_IP\n\nif [ -z \"$SERVER_IP\" ]; then\n    echo \"❌ IP non inserito!\"\n    exit 1\nfi\n\necho \"\"\necho \"🧪 Test connessione al server $SERVER_IP...\"\n\n# Test connessione SSH\nif ! test_connection $SERVER_IP; then\n    echo \"❌ Impossibile connettersi al server $SERVER_IP\"\n    echo \"Verificare che:\"\n    echo \"  - L'IP sia corretto\"\n    echo \"  - La porta 22 sia aperta\"\n    echo \"  - Il server sia raggiungibile\"\n    exit 1\nfi\n\n# Test credenziali\nif ! test_credentials $SERVER_IP; then\n    echo \"❌ Credenziali non valide per $SERVER_IP\"\n    echo \"Verificare che:\"\n    echo \"  - L'utente sia 'root'\"\n    echo \"  - La password sia '80gjapA7'\"\n    exit 1\nfi\n\necho \"\"\necho \"✅ Server $SERVER_IP raggiungibile e credenziali valide!\"\n\n# Aggiorna script di deployment\necho \"\"\necho \"🔧 Configurazione script di deployment...\"\n\n# Aggiorna auto-deploy.sh\nsed -i \"s/SERVER_IP=\\\"\\\"/SERVER_IP=\\\"$SERVER_IP\\\"/\" scripts/auto-deploy.sh\n\n# Aggiorna env.production\nsed -i \"s/YOUR_SERVER_IP/$SERVER_IP/g\" env.production\n\necho \"✅ Script configurati con IP: $SERVER_IP\"\n\necho \"\"\necho \"🚀 Pronto per il deployment!\"\necho \"\"\necho \"Per procedere con il deployment automatico:\"\necho \"  chmod +x scripts/auto-deploy.sh\"\necho \"  ./scripts/auto-deploy.sh\"\necho \"\"\necho \"Il deployment includerà:\"\necho \"  ✅ Setup completo server Debian\"\necho \"  ✅ Installazione PostgreSQL, Redis, FreeSWITCH, Nginx\"\necho \"  ✅ Deploy applicazione VoIP\"\necho \"  ✅ Configurazione servizi e firewall\"\necho \"  ✅ Test finale del sistema\"\necho \"\"\necho \"Tempo stimato: 10-15 minuti\"\n","size_bytes":2452},"packages/backend/src/services/ivr.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport interface IvrMenu {\r\n  id: string;\r\n  tenant_id: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  greeting_sound?: string;\r\n  invalid_sound?: string;\r\n  exit_sound?: string;\r\n  timeout: number;\r\n  max_failures: number;\r\n  timeout_action: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'repeat';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  invalid_action: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'repeat';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  options: { [key: string]: {\r\n    action: 'extension' | 'voicemail' | 'queue' | 'hangup' | 'submenu' | 'conference';\r\n    destination: string;\r\n    description?: string;\r\n  }};\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class IvrService {\r\n  private mapRowToIvrMenu(row: any): IvrMenu {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      name: row.name,\r\n      description: row.description,\r\n      extension: row.extension,\r\n      greeting_sound: row.greeting_sound,\r\n      invalid_sound: row.invalid_sound,\r\n      exit_sound: row.exit_sound,\r\n      timeout: row.timeout,\r\n      max_failures: row.max_failures,\r\n      timeout_action: typeof row.timeout_action === 'string' ? JSON.parse(row.timeout_action) : row.timeout_action,\r\n      invalid_action: typeof row.invalid_action === 'string' ? JSON.parse(row.invalid_action) : row.invalid_action,\r\n      options: typeof row.options === 'string' ? JSON.parse(row.options) : row.options,\r\n      enabled: row.enabled,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at,\r\n    };\r\n  }\r\n\r\n  async createIvrMenu(ivrMenuData: Omit<IvrMenu, 'id' | 'created_at' | 'updated_at'>): Promise<IvrMenu> {\r\n    return withTransaction(async (client) => {\r\n      // Check if extension is already taken\r\n      const existingMenu = await client.query(\r\n        `SELECT id FROM ivr_menus WHERE extension = $1 AND tenant_id = $2`,\r\n        [ivrMenuData.extension, ivrMenuData.tenant_id]\r\n      );\r\n      \r\n      if (existingMenu.rows.length > 0) {\r\n        throw new Error(`Extension ${ivrMenuData.extension} is already in use`);\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO ivr_menus (tenant_id, name, description, extension, greeting_sound, invalid_sound, exit_sound, timeout, max_failures, timeout_action, invalid_action, options, enabled)\r\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\r\n         RETURNING *`,\r\n        [\r\n          ivrMenuData.tenant_id,\r\n          ivrMenuData.name,\r\n          ivrMenuData.description,\r\n          ivrMenuData.extension,\r\n          ivrMenuData.greeting_sound,\r\n          ivrMenuData.invalid_sound,\r\n          ivrMenuData.exit_sound,\r\n          ivrMenuData.timeout,\r\n          ivrMenuData.max_failures,\r\n          JSON.stringify(ivrMenuData.timeout_action),\r\n          JSON.stringify(ivrMenuData.invalid_action),\r\n          JSON.stringify(ivrMenuData.options),\r\n          ivrMenuData.enabled,\r\n        ]\r\n      );\r\n      return this.mapRowToIvrMenu(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  async getIvrMenuById(id: string, tenantId: string): Promise<IvrMenu | undefined> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM ivr_menus WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rows.length > 0 ? this.mapRowToIvrMenu(result.rows[0]) : undefined;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async getIvrMenuByExtension(extension: string, tenantId: string): Promise<IvrMenu | undefined> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM ivr_menus WHERE extension = $1 AND tenant_id = $2 AND enabled = true`,\r\n        [extension, tenantId]\r\n      );\r\n      return result.rows.length > 0 ? this.mapRowToIvrMenu(result.rows[0]) : undefined;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async listIvrMenus(tenantId: string): Promise<IvrMenu[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM ivr_menus WHERE tenant_id = $1 ORDER BY name ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToIvrMenu(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async updateIvrMenu(id: string, tenantId: string, updateData: Partial<Omit<IvrMenu, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>): Promise<IvrMenu | undefined> {\r\n    return withTransaction(async (client) => {\r\n      // Check if extension is already taken by another menu\r\n      if (updateData.extension) {\r\n        const existingMenu = await client.query(\r\n          `SELECT id FROM ivr_menus WHERE extension = $1 AND tenant_id = $2 AND id != $3`,\r\n          [updateData.extension, tenantId, id]\r\n        );\r\n        \r\n        if (existingMenu.rows.length > 0) {\r\n          throw new Error(`Extension ${updateData.extension} is already in use`);\r\n        }\r\n      }\r\n\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name !== undefined) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.description !== undefined) {\r\n        updateFields.push(`description = $${paramCount++}`);\r\n        updateValues.push(updateData.description);\r\n      }\r\n      if (updateData.extension !== undefined) {\r\n        updateFields.push(`extension = $${paramCount++}`);\r\n        updateValues.push(updateData.extension);\r\n      }\r\n      if (updateData.greeting_sound !== undefined) {\r\n        updateFields.push(`greeting_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.greeting_sound);\r\n      }\r\n      if (updateData.invalid_sound !== undefined) {\r\n        updateFields.push(`invalid_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.invalid_sound);\r\n      }\r\n      if (updateData.exit_sound !== undefined) {\r\n        updateFields.push(`exit_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.exit_sound);\r\n      }\r\n      if (updateData.timeout !== undefined) {\r\n        updateFields.push(`timeout = $${paramCount++}`);\r\n        updateValues.push(updateData.timeout);\r\n      }\r\n      if (updateData.max_failures !== undefined) {\r\n        updateFields.push(`max_failures = $${paramCount++}`);\r\n        updateValues.push(updateData.max_failures);\r\n      }\r\n      if (updateData.timeout_action !== undefined) {\r\n        updateFields.push(`timeout_action = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.timeout_action));\r\n      }\r\n      if (updateData.invalid_action !== undefined) {\r\n        updateFields.push(`invalid_action = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.invalid_action));\r\n      }\r\n      if (updateData.options !== undefined) {\r\n        updateFields.push(`options = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.options));\r\n      }\r\n      if (updateData.enabled !== undefined) {\r\n        updateFields.push(`enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.enabled);\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        return this.getIvrMenuById(id, tenantId);\r\n      }\r\n\r\n      updateFields.push(`updated_at = CURRENT_TIMESTAMP`);\r\n      updateValues.push(id, tenantId);\r\n\r\n      const query = `\r\n        UPDATE ivr_menus \r\n        SET ${updateFields.join(', ')}\r\n        WHERE id = $${paramCount++} AND tenant_id = $${paramCount++}\r\n        RETURNING *\r\n      `;\r\n\r\n      const result = await client.query(query, updateValues);\r\n      return result.rows.length > 0 ? this.mapRowToIvrMenu(result.rows[0]) : undefined;\r\n    });\r\n  }\r\n\r\n  async deleteIvrMenu(id: string, tenantId: string): Promise<boolean> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `DELETE FROM ivr_menus WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rowCount > 0;\r\n    });\r\n  }\r\n\r\n  async validateIvrMenu(ivrMenu: Partial<IvrMenu>): Promise<{ valid: boolean; errors: string[] }> {\r\n    const errors: string[] = [];\r\n\r\n    if (!ivrMenu.name || ivrMenu.name.trim().length === 0) {\r\n      errors.push('Name is required');\r\n    }\r\n\r\n    if (!ivrMenu.extension || ivrMenu.extension.trim().length === 0) {\r\n      errors.push('Extension is required');\r\n    } else if (!/^\\d{3,4}$/.test(ivrMenu.extension)) {\r\n      errors.push('Extension must be 3-4 digits');\r\n    }\r\n\r\n    if (ivrMenu.timeout !== undefined && (ivrMenu.timeout < 1 || ivrMenu.timeout > 60)) {\r\n      errors.push('Timeout must be between 1-60 seconds');\r\n    }\r\n\r\n    if (ivrMenu.max_failures !== undefined && (ivrMenu.max_failures < 1 || ivrMenu.max_failures > 10)) {\r\n      errors.push('Max failures must be between 1-10');\r\n    }\r\n\r\n    if (ivrMenu.timeout_action) {\r\n      if (!ivrMenu.timeout_action.type) {\r\n        errors.push('Timeout action type is required');\r\n      }\r\n      if (!ivrMenu.timeout_action.destination) {\r\n        errors.push('Timeout action destination is required');\r\n      }\r\n    }\r\n\r\n    if (ivrMenu.invalid_action) {\r\n      if (!ivrMenu.invalid_action.type) {\r\n        errors.push('Invalid action type is required');\r\n      }\r\n      if (!ivrMenu.invalid_action.destination) {\r\n        errors.push('Invalid action destination is required');\r\n      }\r\n    }\r\n\r\n    if (ivrMenu.options) {\r\n      // Validate DTMF options\r\n      const validKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '#'];\r\n      for (const [key, option] of Object.entries(ivrMenu.options)) {\r\n        if (!validKeys.includes(key)) {\r\n          errors.push(`Invalid DTMF key: ${key}. Valid keys are: 0-9, *, #`);\r\n        }\r\n        if (!option.action) {\r\n          errors.push(`Action is required for option ${key}`);\r\n        }\r\n        if (!option.destination) {\r\n          errors.push(`Destination is required for option ${key}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n\r\n  async getActiveIvrMenus(tenantId: string): Promise<IvrMenu[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM ivr_menus WHERE tenant_id = $1 AND enabled = true ORDER BY extension ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToIvrMenu(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async processDtmfInput(ivrMenuId: string, tenantId: string, dtmf: string): Promise<{ action: any; nextMenu?: IvrMenu }> {\r\n    const ivrMenu = await this.getIvrMenuById(ivrMenuId, tenantId);\r\n    if (!ivrMenu || !ivrMenu.enabled) {\r\n      return { action: null };\r\n    }\r\n\r\n    const option = ivrMenu.options[dtmf];\r\n    if (!option) {\r\n      return { action: ivrMenu.invalid_action };\r\n    }\r\n\r\n    if (option.action === 'submenu') {\r\n      // Find the submenu\r\n      const submenu = await this.getIvrMenuByExtension(option.destination, tenantId);\r\n      if (submenu) {\r\n        return { action: null, nextMenu: submenu };\r\n      }\r\n    }\r\n\r\n    return { action: option };\r\n  }\r\n\r\n  async generateFreeSwitchXml(ivrMenu: IvrMenu): Promise<string> {\r\n    const optionsXml = Object.entries(ivrMenu.options)\r\n      .map(([dtmf, option]) => {\r\n        let destination = option.destination;\r\n        \r\n        // Convert action types to FreeSWITCH destinations\r\n        switch (option.action) {\r\n          case 'extension':\r\n            destination = `user/${option.destination}`;\r\n            break;\r\n          case 'queue':\r\n            destination = `queue/${option.destination}`;\r\n            break;\r\n          case 'conference':\r\n            destination = `conference/${option.destination}`;\r\n            break;\r\n          case 'voicemail':\r\n            destination = `voicemail default ${option.destination}`;\r\n            break;\r\n          case 'submenu':\r\n            destination = `ivr_${option.destination}`;\r\n            break;\r\n          case 'hangup':\r\n            destination = 'hangup';\r\n            break;\r\n        }\r\n\r\n        return `\r\n        <menu name=\"ivr_${ivrMenu.extension}\">\r\n          <entry action=\"menu-exec-app\" digits=\"${dtmf}\" param=\"bridge ${destination}\"/>\r\n        </menu>`;\r\n      })\r\n      .join('\\n');\r\n\r\n    const timeoutDestination = this.getActionDestination(ivrMenu.timeout_action);\r\n    const invalidDestination = this.getActionDestination(ivrMenu.invalid_action);\r\n\r\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<include>\r\n  <menu name=\"ivr_${ivrMenu.extension}\"\r\n        greeting=\"${ivrMenu.greeting_sound || 'ivr/ivr-welcome_to_freeswitch.wav'}\"\r\n        invalid_sound=\"${ivrMenu.invalid_sound || 'ivr/ivr-that_was_an_invalid_entry.wav'}\"\r\n        exit_sound=\"${ivrMenu.exit_sound || 'voicemail/vm-goodbye.wav'}\"\r\n        timeout=\"${ivrMenu.timeout}\"\r\n        max_failures=\"${ivrMenu.max_failures}\"\r\n        timeout_action=\"menu-exec-app bridge ${timeoutDestination}\"\r\n        invalid_action=\"menu-exec-app bridge ${invalidDestination}\">\r\n    ${optionsXml}\r\n  </menu>\r\n</include>`;\r\n  }\r\n\r\n  private getActionDestination(action: any): string {\r\n    switch (action.type) {\r\n      case 'extension':\r\n        return `user/${action.destination}`;\r\n      case 'queue':\r\n        return `queue/${action.destination}`;\r\n      case 'conference':\r\n        return `conference/${action.destination}`;\r\n      case 'voicemail':\r\n        return `voicemail default ${action.destination}`;\r\n      case 'hangup':\r\n        return 'hangup';\r\n      case 'repeat':\r\n        return `ivr_${action.destination}`;\r\n      default:\r\n        return 'hangup';\r\n    }\r\n  }\r\n}\r\n","size_bytes":13931},"packages/backend/src/services/sip-trunk.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\n// import { SipTrunk } from '@w3-voip/shared';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n// import { logAPICall } from '../utils/logger';\r\n\r\n// Define SipTrunk type locally\r\nexport interface SipTrunk {\r\n  id: string;\r\n  tenant_id: string;\r\n  store_id?: string;\r\n  name: string;\r\n  provider: string;\r\n  status: 'active' | 'inactive' | 'testing';\r\n  sip_config: {\r\n    host: string;\r\n    port: number;\r\n    transport: 'udp' | 'tcp' | 'tls';\r\n    username: string;\r\n    password: string;\r\n    realm?: string;\r\n    from_user?: string;\r\n    from_domain?: string;\r\n    register: boolean;\r\n    register_proxy?: string;\r\n    register_transport?: 'udp' | 'tcp' | 'tls';\r\n    retry_seconds: number;\r\n    caller_id_in_from: boolean;\r\n    contact_params?: string;\r\n    ping: boolean;\r\n    ping_time: number;\r\n  };\r\n  did_config: {\r\n    number: string;\r\n    country_code: string;\r\n    area_code?: string;\r\n    local_number: string;\r\n    provider_did?: string;\r\n    inbound_route?: string;\r\n  };\r\n  security: {\r\n    encryption: 'none' | 'tls' | 'srtp';\r\n    authentication: 'none' | 'digest' | 'tls';\r\n    acl: string[];\r\n    rate_limit: {\r\n      enabled: boolean;\r\n      calls_per_minute: number;\r\n      calls_per_hour: number;\r\n    };\r\n  };\r\n  gdpr: {\r\n    data_retention_days: number;\r\n    recording_consent_required: boolean;\r\n    data_processing_purpose: string;\r\n    lawful_basis: 'consent' | 'contract' | 'legitimate_interest';\r\n    data_controller: string;\r\n    dpo_contact?: string;\r\n  };\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class SipTrunkService {\r\n  // Create a new SIP trunk\r\n  async createSipTrunk(trunkData: Omit<SipTrunk, 'id' | 'created_at' | 'updated_at'>): Promise<SipTrunk> {\r\n    return withTransaction(async (client) => {\r\n      // Verify tenant exists\r\n      const tenantResult = await client.query(\r\n        'SELECT id FROM tenants WHERE id = $1 AND status = $2',\r\n        [trunkData.tenant_id, 'active']\r\n      );\r\n\r\n      if (tenantResult.rows.length === 0) {\r\n        throw new Error('Tenant not found or inactive');\r\n      }\r\n\r\n      // Verify store exists if provided\r\n      if (trunkData.store_id) {\r\n        const storeResult = await client.query(\r\n          'SELECT id FROM stores WHERE id = $1 AND tenant_id = $2 AND status = $3',\r\n          [trunkData.store_id, trunkData.tenant_id, 'active']\r\n        );\r\n\r\n        if (storeResult.rows.length === 0) {\r\n          throw new Error('Store not found or inactive');\r\n        }\r\n      }\r\n\r\n      // Check if trunk name already exists for this tenant\r\n      const existingTrunk = await client.query(\r\n        'SELECT id FROM sip_trunks WHERE tenant_id = $1 AND name = $2',\r\n        [trunkData.tenant_id, trunkData.name]\r\n      );\r\n\r\n      if (existingTrunk.rows.length > 0) {\r\n        throw new Error('Trunk name already exists for this tenant');\r\n      }\r\n\r\n      // Create SIP trunk\r\n      const result = await client.query(\r\n        `INSERT INTO sip_trunks (\r\n          id, tenant_id, store_id, name, provider, status, \r\n          sip_config, did_config, security, gdpr\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n        RETURNING *`,\r\n        [\r\n          uuidv4(),\r\n          trunkData.tenant_id,\r\n          trunkData.store_id || null,\r\n          trunkData.name,\r\n          trunkData.provider,\r\n          trunkData.status || 'testing',\r\n          JSON.stringify(trunkData.sip_config),\r\n          JSON.stringify(trunkData.did_config),\r\n          JSON.stringify(trunkData.security),\r\n          JSON.stringify(trunkData.gdpr)\r\n        ]\r\n      );\r\n\r\n      const trunk = result.rows[0];\r\n      \r\n      // logAPICall('sip_trunk_created', {\r\n      //   tenant_id: trunkData.tenant_id,\r\n      //   trunk_id: trunk.id,\r\n      //   trunk_name: trunk.name\r\n      // });\r\n\r\n      return {\r\n        ...trunk,\r\n        sip_config: typeof trunk.sip_config === 'string' ? JSON.parse(trunk.sip_config) : trunk.sip_config,\r\n        did_config: typeof trunk.did_config === 'string' ? JSON.parse(trunk.did_config) : trunk.did_config,\r\n        security: typeof trunk.security === 'string' ? JSON.parse(trunk.security) : trunk.security,\r\n        gdpr: typeof trunk.gdpr === 'string' ? JSON.parse(trunk.gdpr) : trunk.gdpr\r\n      };\r\n    });\r\n  }\r\n\r\n  // Get SIP trunk by ID\r\n  async getSipTrunkById(trunkId: string, tenantId: string): Promise<SipTrunk | null> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      const result = await client.query(\r\n        'SELECT * FROM sip_trunks WHERE id = $1 AND tenant_id = $2',\r\n        [trunkId, tenantId]\r\n      );\r\n\r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const trunk = result.rows[0];\r\n      return {\r\n        ...trunk,\r\n        sip_config: typeof trunk.sip_config === 'string' ? JSON.parse(trunk.sip_config) : trunk.sip_config,\r\n        did_config: typeof trunk.did_config === 'string' ? JSON.parse(trunk.did_config) : trunk.did_config,\r\n        security: typeof trunk.security === 'string' ? JSON.parse(trunk.security) : trunk.security,\r\n        gdpr: typeof trunk.gdpr === 'string' ? JSON.parse(trunk.gdpr) : trunk.gdpr\r\n      };\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // List SIP trunks for tenant\r\n  async listSipTrunks(tenantId: string, storeId?: string): Promise<SipTrunk[]> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      let query = 'SELECT * FROM sip_trunks WHERE tenant_id = $1';\r\n      const params: any[] = [tenantId];\r\n\r\n      if (storeId) {\r\n        query += ' AND store_id = $2';\r\n        params.push(storeId);\r\n      }\r\n\r\n      query += ' ORDER BY created_at DESC';\r\n\r\n      const result = await client.query(query, params);\r\n\r\n      return result.rows.map((trunk: any) => ({\r\n        ...trunk,\r\n        sip_config: typeof trunk.sip_config === 'string' ? JSON.parse(trunk.sip_config) : trunk.sip_config,\r\n        did_config: typeof trunk.did_config === 'string' ? JSON.parse(trunk.did_config) : trunk.did_config,\r\n        security: typeof trunk.security === 'string' ? JSON.parse(trunk.security) : trunk.security,\r\n        gdpr: typeof trunk.gdpr === 'string' ? JSON.parse(trunk.gdpr) : trunk.gdpr\r\n      }));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  // Update SIP trunk\r\n  async updateSipTrunk(\r\n    trunkId: string, \r\n    tenantId: string, \r\n    updateData: Partial<Omit<SipTrunk, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>\r\n  ): Promise<SipTrunk> {\r\n    return withTransaction(async (client) => {\r\n      // Verify trunk exists and belongs to tenant\r\n      const existingTrunk = await client.query(\r\n        'SELECT id FROM sip_trunks WHERE id = $1 AND tenant_id = $2',\r\n        [trunkId, tenantId]\r\n      );\r\n\r\n      if (existingTrunk.rows.length === 0) {\r\n        throw new Error('SIP trunk not found');\r\n      }\r\n\r\n      // Build update query dynamically\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.provider) {\r\n        updateFields.push(`provider = $${paramCount++}`);\r\n        updateValues.push(updateData.provider);\r\n      }\r\n      if (updateData.status) {\r\n        updateFields.push(`status = $${paramCount++}`);\r\n        updateValues.push(updateData.status);\r\n      }\r\n      if (updateData.store_id !== undefined) {\r\n        updateFields.push(`store_id = $${paramCount++}`);\r\n        updateValues.push(updateData.store_id);\r\n      }\r\n      if (updateData.sip_config) {\r\n        updateFields.push(`sip_config = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.sip_config));\r\n      }\r\n      if (updateData.did_config) {\r\n        updateFields.push(`did_config = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.did_config));\r\n      }\r\n      if (updateData.security) {\r\n        updateFields.push(`security = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.security));\r\n      }\r\n      if (updateData.gdpr) {\r\n        updateFields.push(`gdpr = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.gdpr));\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        throw new Error('No fields to update');\r\n      }\r\n\r\n      updateFields.push(`updated_at = NOW()`);\r\n      updateValues.push(trunkId, tenantId);\r\n\r\n      const query = `\r\n        UPDATE sip_trunks \r\n        SET ${updateFields.join(', ')}\r\n        WHERE id = $${paramCount++} AND tenant_id = $${paramCount++}\r\n        RETURNING *\r\n      `;\r\n\r\n      const result = await client.query(query, updateValues);\r\n      const trunk = result.rows[0];\r\n\r\n      // logAPICall('sip_trunk_updated', {\r\n      //   tenant_id: tenantId,\r\n      //   trunk_id: trunkId,\r\n      //   updated_fields: Object.keys(updateData)\r\n      // });\r\n\r\n      return {\r\n        ...trunk,\r\n        sip_config: typeof trunk.sip_config === 'string' ? JSON.parse(trunk.sip_config) : trunk.sip_config,\r\n        did_config: typeof trunk.did_config === 'string' ? JSON.parse(trunk.did_config) : trunk.did_config,\r\n        security: typeof trunk.security === 'string' ? JSON.parse(trunk.security) : trunk.security,\r\n        gdpr: typeof trunk.gdpr === 'string' ? JSON.parse(trunk.gdpr) : trunk.gdpr\r\n      };\r\n    });\r\n  }\r\n\r\n  // Delete SIP trunk\r\n  async deleteSipTrunk(trunkId: string, tenantId: string): Promise<void> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        'DELETE FROM sip_trunks WHERE id = $1 AND tenant_id = $2',\r\n        [trunkId, tenantId]\r\n      );\r\n\r\n      if (result.rowCount === 0) {\r\n        throw new Error('SIP trunk not found');\r\n      }\r\n\r\n      // logAPICall('sip_trunk_deleted', {\r\n      //   tenant_id: tenantId,\r\n      //   trunk_id: trunkId\r\n      // });\r\n    });\r\n  }\r\n\r\n  // Test SIP trunk connectivity\r\n  async testSipTrunk(trunkId: string, tenantId: string): Promise<{ success: boolean; message: string; details?: any }> {\r\n    const trunk = await this.getSipTrunkById(trunkId, tenantId);\r\n    \r\n    if (!trunk) {\r\n      return { success: false, message: 'SIP trunk not found' };\r\n    }\r\n\r\n    try {\r\n      // Here you would implement actual SIP trunk testing\r\n      // For now, we'll simulate a test\r\n      const testResult = {\r\n        success: Math.random() > 0.3, // 70% success rate for demo\r\n        message: Math.random() > 0.3 ? 'Connection successful' : 'Connection failed - Authentication error',\r\n        details: {\r\n          host: trunk.sip_config.host,\r\n          port: trunk.sip_config.port,\r\n          transport: trunk.sip_config.transport,\r\n          tested_at: new Date().toISOString()\r\n        }\r\n      };\r\n\r\n      // logAPICall('sip_trunk_tested', {\r\n      //   tenant_id: tenantId,\r\n      //   trunk_id: trunkId,\r\n      //   test_result: testResult\r\n      // });\r\n\r\n      return testResult;\r\n    } catch (error) {\r\n      return { \r\n        success: false, \r\n        message: `Test failed: ${error instanceof Error ? error.message : 'Unknown error'}` \r\n      };\r\n    }\r\n  }\r\n\r\n  // Get SIP trunk statistics\r\n  async getSipTrunkStats(trunkId: string, tenantId: string): Promise<any> {\r\n    const client = await getClient();\r\n    \r\n    try {\r\n      // Get call statistics for this trunk\r\n      const statsResult = await client.query(\r\n        `SELECT \r\n          COUNT(*) as total_calls,\r\n          COUNT(CASE WHEN hangup_disposition = 'answered' THEN 1 END) as answered_calls,\r\n          COUNT(CASE WHEN hangup_disposition = 'no_answer' THEN 1 END) as no_answer_calls,\r\n          COUNT(CASE WHEN hangup_disposition = 'busy' THEN 1 END) as busy_calls,\r\n          AVG(duration) as avg_duration,\r\n          SUM(bill_seconds) as total_bill_seconds\r\n        FROM cdr \r\n        WHERE trunk_id = $1 AND tenant_id = $2\r\n        AND start_time >= NOW() - INTERVAL '30 days'`,\r\n        [trunkId, tenantId]\r\n      );\r\n\r\n      return statsResult.rows[0];\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n}\r\n\r\nexport const sipTrunkService = new SipTrunkService();\r\n","size_bytes":12132},"scripts/complete-deploy.sh":{"content":"#!/bin/bash\n\n# EDG VoIP System - Complete Deploy Script\n# Deploy completo in una volta sola\n\nset -e\n\n# Colori per output\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\nlog() {\n    echo -e \"${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}\"\n}\n\nwarn() {\n    echo -e \"${YELLOW}[WARNING] $1${NC}\"\n}\n\nerror() {\n    echo -e \"${RED}[ERROR] $1${NC}\"\n    exit 1\n}\n\ninfo() {\n    echo -e \"${BLUE}[INFO] $1${NC}\"\n}\n\necho \"🚀 EDG VoIP System - Complete Deploy\"\necho \"====================================\"\necho \"\"\n\n# Verifica prerequisiti\nlog \"Verifica prerequisiti...\"\nif ! command -v sshpass &> /dev/null; then\n    error \"sshpass non trovato. Installare con: apt-get install sshpass\"\nfi\n\n# IP del server configurato\nSERVER_IP=\"93.93.113.13\"\nlog \"Server IP configurato: $SERVER_IP\"\n\n# Test connessione\nlog \"Test connessione al server $SERVER_IP...\"\nif ! timeout 5 bash -c \"</dev/tcp/$SERVER_IP/22\" 2>/dev/null; then\n    error \"Impossibile connettersi al server $SERVER_IP (porta 22 chiusa)\"\nfi\n\n# Test credenziali\nlog \"Test credenziali...\"\nif ! sshpass -p \"80gjapA7\" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 root@$SERVER_IP \"echo 'OK'\" >/dev/null 2>&1; then\n    error \"Credenziali non valide per root@$SERVER_IP\"\nfi\n\nlog \"✅ Server $SERVER_IP raggiungibile e credenziali valide!\"\n\n# Configura script con IP\nlog \"Configurazione script con IP $SERVER_IP...\"\nsed -i \"s/SERVER_IP=\\\"\\\"/SERVER_IP=\\\"$SERVER_IP\\\"/\" scripts/auto-deploy.sh\nsed -i \"s/YOUR_SERVER_IP/$SERVER_IP/g\" env.production\n\n# Esegui deploy automatico\nlog \"Avvio deploy automatico...\"\n./scripts/auto-deploy.sh\n\nlog \"🎉 Deploy completato con successo!\"\necho \"\"\necho \"🌐 Accesso all'applicazione:\"\necho \"  Frontend: http://$SERVER_IP\"\necho \"  API: http://$SERVER_IP/api\"\necho \"  Super Admin: http://$SERVER_IP/edgvoip/login\"\necho \"\"\necho \"🔑 Credenziali:\"\necho \"  Super Admin: admin@edgvoip.local / SuperAdmin2025!\"\necho \"  Demo Tenant: admin@demo.local / tenantadmin123\"\necho \"\"\necho \"📋 Comandi utili:\"\necho \"  ssh root@$SERVER_IP\"\necho \"  systemctl status voip-backend\"\necho \"  journalctl -u voip-backend -f\"\n","size_bytes":2118},"packages/backend/src/middleware/security.ts":{"content":"import { Request, Response, NextFunction } from 'express';\r\nimport rateLimit from 'express-rate-limit';\r\nimport helmet from 'helmet';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Security Headers Middleware\r\nexport const securityHeaders = helmet({\r\n  contentSecurityPolicy: {\r\n    directives: {\r\n      defaultSrc: [\"'self'\"],\r\n      styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\r\n      fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\r\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\r\n      scriptSrc: [\"'self'\"],\r\n      connectSrc: [\"'self'\", \"ws:\", \"wss:\"],\r\n      frameSrc: [\"'none'\"],\r\n      objectSrc: [\"'none'\"],\r\n      upgradeInsecureRequests: [],\r\n    },\r\n  },\r\n  hsts: {\r\n    maxAge: 31536000,\r\n    includeSubDomains: true,\r\n    preload: true\r\n  },\r\n  noSniff: true,\r\n  xssFilter: true,\r\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\r\n});\r\n\r\n// Request ID Middleware\r\nexport const requestId = (req: Request, res: Response, next: NextFunction) => {\r\n  req.id = req.headers['x-request-id'] as string || uuidv4();\r\n  res.set('X-Request-ID', req.id);\r\n  next();\r\n};\r\n\r\n// Rate Limiting Middleware\r\nexport const createRateLimit = (windowMs: number, max: number, message?: string) => {\r\n  return rateLimit({\r\n    windowMs,\r\n    max,\r\n    message: {\r\n      success: false,\r\n      error: {\r\n        code: 'RATE_LIMIT_EXCEEDED',\r\n        message: message || `Too many requests, please try again later.`\r\n      }\r\n    },\r\n    standardHeaders: true,\r\n    legacyHeaders: false,\r\n    keyGenerator: (req: Request) => {\r\n      // Use tenant ID if available, otherwise IP\r\n      const tenantId = (req as any).tenantId;\r\n      return tenantId ? `tenant:${tenantId}` : req.ip;\r\n    }\r\n  });\r\n};\r\n\r\n// General API Rate Limiting\r\nexport const apiRateLimit = createRateLimit(\r\n  15 * 60 * 1000, // 15 minutes\r\n  100, // 100 requests per window\r\n  'API rate limit exceeded. Max 100 requests per 15 minutes.'\r\n);\r\n\r\n// Authentication Rate Limiting\r\nexport const authRateLimit = createRateLimit(\r\n  15 * 60 * 1000, // 15 minutes\r\n  5, // 5 requests per window\r\n  'Authentication rate limit exceeded. Max 5 attempts per 15 minutes.'\r\n);\r\n\r\n// CDR Webhook Rate Limiting\r\nexport const cdrRateLimit = createRateLimit(\r\n  60 * 1000, // 1 minute\r\n  1000, // 1000 requests per minute\r\n  'CDR webhook rate limit exceeded.'\r\n);\r\n\r\n// Input Sanitization Middleware\r\nexport const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {\r\n  // Remove potentially dangerous characters from string inputs\r\n  const sanitizeString = (str: string): string => {\r\n    return str\r\n      .replace(/[<>]/g, '') // Remove < and >\r\n      .replace(/javascript:/gi, '') // Remove javascript: protocol\r\n      .replace(/on\\w+=/gi, '') // Remove event handlers\r\n      .trim();\r\n  };\r\n\r\n  // Recursively sanitize object properties\r\n  const sanitizeObject = (obj: any): any => {\r\n    if (typeof obj === 'string') {\r\n      return sanitizeString(obj);\r\n    }\r\n    \r\n    if (Array.isArray(obj)) {\r\n      return obj.map(sanitizeObject);\r\n    }\r\n    \r\n    if (obj && typeof obj === 'object') {\r\n      const sanitized: any = {};\r\n      for (const [key, value] of Object.entries(obj)) {\r\n        sanitized[key] = sanitizeObject(value);\r\n      }\r\n      return sanitized;\r\n    }\r\n    \r\n    return obj;\r\n  };\r\n\r\n  // Sanitize request body, query, and params\r\n  if (req.body) {\r\n    req.body = sanitizeObject(req.body);\r\n  }\r\n  \r\n  if (req.query) {\r\n    req.query = sanitizeObject(req.query);\r\n  }\r\n  \r\n  if (req.params) {\r\n    req.params = sanitizeObject(req.params);\r\n  }\r\n\r\n  next();\r\n};\r\n\r\n// Content Type Validation Middleware\r\nexport const validateContentType = (allowedTypes: string[] = ['application/json']) => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    if (req.method === 'GET' || req.method === 'DELETE') {\r\n      return next();\r\n    }\r\n\r\n    const contentType = req.headers['content-type'];\r\n    \r\n    if (!contentType) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: {\r\n          code: 'CONTENT_TYPE_REQUIRED',\r\n          message: 'Content-Type header is required'\r\n        }\r\n      });\r\n    }\r\n\r\n    const isValidType = allowedTypes.some(type => \r\n      contentType.toLowerCase().includes(type.toLowerCase())\r\n    );\r\n\r\n    if (!isValidType) {\r\n      return res.status(415).json({\r\n        success: false,\r\n        error: {\r\n          code: 'UNSUPPORTED_CONTENT_TYPE',\r\n          message: `Content-Type must be one of: ${allowedTypes.join(', ')}`\r\n        }\r\n      });\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Request Size Limiting Middleware\r\nexport const requestSizeLimit = (maxSize: string = '10mb') => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    const contentLength = parseInt(req.headers['content-length'] || '0');\r\n    const maxBytes = parseSize(maxSize);\r\n\r\n    if (contentLength > maxBytes) {\r\n      return res.status(413).json({\r\n        success: false,\r\n        error: {\r\n          code: 'REQUEST_TOO_LARGE',\r\n          message: `Request size exceeds limit of ${maxSize}`\r\n        }\r\n      });\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Parse size string to bytes\r\nfunction parseSize(size: string): number {\r\n  const units: { [key: string]: number } = {\r\n    b: 1,\r\n    kb: 1024,\r\n    mb: 1024 * 1024,\r\n    gb: 1024 * 1024 * 1024\r\n  };\r\n\r\n  const match = size.toLowerCase().match(/^(\\d+(?:\\.\\d+)?)\\s*(b|kb|mb|gb)?$/);\r\n  if (!match) {\r\n    throw new Error(`Invalid size format: ${size}`);\r\n  }\r\n\r\n  const value = parseFloat(match[1]);\r\n  const unit = match[2] || 'b';\r\n  \r\n  return Math.floor(value * units[unit]);\r\n}\r\n\r\n// IP Whitelist Middleware\r\nexport const ipWhitelist = (allowedIPs: string[]) => {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    const clientIP = req.ip || req.connection.remoteAddress;\r\n    \r\n    if (!clientIP) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        error: {\r\n          code: 'IP_NOT_DETECTED',\r\n          message: 'Unable to detect client IP address'\r\n        }\r\n      });\r\n    }\r\n\r\n    const isAllowed = allowedIPs.some(allowedIP => {\r\n      if (allowedIP.includes('/')) {\r\n        // CIDR notation\r\n        return isIPInCIDR(clientIP, allowedIP);\r\n      } else {\r\n        // Exact match\r\n        return clientIP === allowedIP;\r\n      }\r\n    });\r\n\r\n    if (!isAllowed) {\r\n      return res.status(403).json({\r\n        success: false,\r\n        error: {\r\n          code: 'IP_NOT_ALLOWED',\r\n          message: 'IP address not in whitelist'\r\n        }\r\n      });\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Check if IP is in CIDR range\r\nfunction isIPInCIDR(ip: string, cidr: string): boolean {\r\n  const [network, prefixLength] = cidr.split('/');\r\n  const ipNum = ipToNumber(ip);\r\n  const networkNum = ipToNumber(network);\r\n  const mask = (0xffffffff << (32 - parseInt(prefixLength))) >>> 0;\r\n  \r\n  return (ipNum & mask) === (networkNum & mask);\r\n}\r\n\r\n// Convert IP to number\r\nfunction ipToNumber(ip: string): number {\r\n  return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;\r\n}\r\n\r\n// Security Event Logging Middleware\r\nexport const securityEventLogger = (req: Request, res: Response, next: NextFunction) => {\r\n  const originalSend = res.send;\r\n  \r\n  res.send = function(data) {\r\n    // Log security events\r\n    if (res.statusCode >= 400) {\r\n      const securityEvent = {\r\n        timestamp: new Date().toISOString(),\r\n        requestId: req.id,\r\n        method: req.method,\r\n        url: req.url,\r\n        ip: req.ip,\r\n        userAgent: req.headers['user-agent'],\r\n        statusCode: res.statusCode,\r\n        tenantId: (req as any).tenantId,\r\n        userId: (req as any).user?.sub\r\n      };\r\n      \r\n      console.warn('Security Event:', securityEvent);\r\n    }\r\n    \r\n    return originalSend.call(this, data);\r\n  };\r\n  \r\n  next();\r\n};\r\n\r\n","size_bytes":7845},"scripts/backup.sh":{"content":"#!/bin/bash\n\n# Automated Backup Script for EDG VoIP System\n\nset -e\n\nBACKUP_DIR=\"/var/backups/voip\"\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nRETENTION_DAYS=30\n\necho \"💾 EDG VoIP System - Automated Backup\"\necho \"=====================================\"\necho \"Timestamp: $TIMESTAMP\"\n\n# Create backup directory\nmkdir -p $BACKUP_DIR\n\n# Load environment\nif [ -f \"env.production\" ]; then\n    export $(cat env.production | grep -v '^#' | xargs)\nfi\n\n# Backup PostgreSQL database\necho \"\"\necho \"📊 Backing up PostgreSQL database...\"\ndocker exec voip-postgres-prod pg_dump -U $POSTGRES_USER $POSTGRES_DB | gzip > $BACKUP_DIR/postgres_$TIMESTAMP.sql.gz\necho \"✅ Database backup completed: postgres_$TIMESTAMP.sql.gz\"\n\n# Backup FreeSWITCH recordings\necho \"\"\necho \"🎙️  Backing up call recordings...\"\ndocker run --rm -v voip_freeswitch_recordings:/recordings -v $BACKUP_DIR:/backup alpine \\\n    tar czf /backup/recordings_$TIMESTAMP.tar.gz -C /recordings .\necho \"✅ Recordings backup completed: recordings_$TIMESTAMP.tar.gz\"\n\n# Backup FreeSWITCH configuration\necho \"\"\necho \"⚙️  Backing up FreeSWITCH configuration...\"\ntar czf $BACKUP_DIR/freeswitch_conf_$TIMESTAMP.tar.gz docker/freeswitch/conf/\necho \"✅ Configuration backup completed: freeswitch_conf_$TIMESTAMP.tar.gz\"\n\n# Backup environment and configs\necho \"\"\necho \"📝 Backing up environment files...\"\ntar czf $BACKUP_DIR/configs_$TIMESTAMP.tar.gz \\\n    env.production \\\n    docker-compose.prod.yml \\\n    nginx/nginx-prod.conf\necho \"✅ Configuration files backup completed: configs_$TIMESTAMP.tar.gz\"\n\n# Remove old backups\necho \"\"\necho \"🗑️  Removing backups older than $RETENTION_DAYS days...\"\nfind $BACKUP_DIR -type f -name \"*.gz\" -mtime +$RETENTION_DAYS -delete\nfind $BACKUP_DIR -type f -name \"*.tar.gz\" -mtime +$RETENTION_DAYS -delete\necho \"✅ Old backups removed\"\n\n# Calculate backup size\nBACKUP_SIZE=$(du -sh $BACKUP_DIR | cut -f1)\necho \"\"\necho \"✅ Backup completed successfully!\"\necho \"📦 Total backup size: $BACKUP_SIZE\"\necho \"📁 Backup location: $BACKUP_DIR\"\necho \"\"\necho \"Files created:\"\nls -lh $BACKUP_DIR/*_$TIMESTAMP.*\n\n","size_bytes":2090},"packages/backend/src/services/time-condition.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport interface TimeCondition {\r\n  id: string;\r\n  tenant_id: string;\r\n  name: string;\r\n  description?: string;\r\n  timezone: string;\r\n  conditions: Array<{\r\n    day_of_week: number; // 0-6 (Sunday-Saturday)\r\n    start_time: string; // HH:MM format\r\n    end_time: string; // HH:MM format\r\n    is_active: boolean;\r\n  }>;\r\n  action_true: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'ivr' | 'hangup';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  action_false: {\r\n    type: 'extension' | 'voicemail' | 'queue' | 'ivr' | 'hangup';\r\n    destination: string;\r\n    timeout?: number;\r\n  };\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport class TimeConditionService {\r\n  private mapRowToTimeCondition(row: any): TimeCondition {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      name: row.name,\r\n      description: row.description,\r\n      timezone: row.timezone,\r\n      conditions: typeof row.conditions === 'string' ? JSON.parse(row.conditions) : row.conditions,\r\n      action_true: typeof row.action_true === 'string' ? JSON.parse(row.action_true) : row.action_true,\r\n      action_false: typeof row.action_false === 'string' ? JSON.parse(row.action_false) : row.action_false,\r\n      enabled: row.enabled,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at,\r\n    };\r\n  }\r\n\r\n  async createTimeCondition(timeConditionData: Omit<TimeCondition, 'id' | 'created_at' | 'updated_at'>): Promise<TimeCondition> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `INSERT INTO time_conditions (tenant_id, name, description, timezone, conditions, action_true, action_false, enabled)\r\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n         RETURNING *`,\r\n        [\r\n          timeConditionData.tenant_id,\r\n          timeConditionData.name,\r\n          timeConditionData.description,\r\n          timeConditionData.timezone,\r\n          JSON.stringify(timeConditionData.conditions),\r\n          JSON.stringify(timeConditionData.action_true),\r\n          JSON.stringify(timeConditionData.action_false),\r\n          timeConditionData.enabled,\r\n        ]\r\n      );\r\n      return this.mapRowToTimeCondition(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  async getTimeConditionById(id: string, tenantId: string): Promise<TimeCondition | undefined> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM time_conditions WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rows.length > 0 ? this.mapRowToTimeCondition(result.rows[0]) : undefined;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async listTimeConditions(tenantId: string): Promise<TimeCondition[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM time_conditions WHERE tenant_id = $1 ORDER BY name ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToTimeCondition(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async updateTimeCondition(id: string, tenantId: string, updateData: Partial<Omit<TimeCondition, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>): Promise<TimeCondition | undefined> {\r\n    return withTransaction(async (client) => {\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name !== undefined) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.description !== undefined) {\r\n        updateFields.push(`description = $${paramCount++}`);\r\n        updateValues.push(updateData.description);\r\n      }\r\n      if (updateData.timezone !== undefined) {\r\n        updateFields.push(`timezone = $${paramCount++}`);\r\n        updateValues.push(updateData.timezone);\r\n      }\r\n      if (updateData.conditions !== undefined) {\r\n        updateFields.push(`conditions = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.conditions));\r\n      }\r\n      if (updateData.action_true !== undefined) {\r\n        updateFields.push(`action_true = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.action_true));\r\n      }\r\n      if (updateData.action_false !== undefined) {\r\n        updateFields.push(`action_false = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.action_false));\r\n      }\r\n      if (updateData.enabled !== undefined) {\r\n        updateFields.push(`enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.enabled);\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        return this.getTimeConditionById(id, tenantId);\r\n      }\r\n\r\n      updateFields.push(`updated_at = CURRENT_TIMESTAMP`);\r\n      updateValues.push(id, tenantId);\r\n\r\n      const query = `\r\n        UPDATE time_conditions \r\n        SET ${updateFields.join(', ')}\r\n        WHERE id = $${paramCount++} AND tenant_id = $${paramCount++}\r\n        RETURNING *\r\n      `;\r\n\r\n      const result = await client.query(query, updateValues);\r\n      return result.rows.length > 0 ? this.mapRowToTimeCondition(result.rows[0]) : undefined;\r\n    });\r\n  }\r\n\r\n  async deleteTimeCondition(id: string, tenantId: string): Promise<boolean> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `DELETE FROM time_conditions WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rowCount > 0;\r\n    });\r\n  }\r\n\r\n  async evaluateTimeCondition(id: string, tenantId: string): Promise<{ condition: boolean; action: any }> {\r\n    const timeCondition = await this.getTimeConditionById(id, tenantId);\r\n    if (!timeCondition || !timeCondition.enabled) {\r\n      return { condition: false, action: null };\r\n    }\r\n\r\n    const now = new Date();\r\n    const currentDay = now.getDay(); // 0-6 (Sunday-Saturday)\r\n    const currentTime = now.toLocaleTimeString('en-US', { \r\n      hour12: false, \r\n      timeZone: timeCondition.timezone \r\n    }).substring(0, 5); // HH:MM format\r\n\r\n    // Check if any condition matches\r\n    for (const condition of timeCondition.conditions) {\r\n      if (!condition.is_active) continue;\r\n\r\n      // Check day of week\r\n      if (condition.day_of_week !== currentDay) continue;\r\n\r\n      // Check time range\r\n      if (currentTime >= condition.start_time && currentTime <= condition.end_time) {\r\n        return { condition: true, action: timeCondition.action_true };\r\n      }\r\n    }\r\n\r\n    return { condition: false, action: timeCondition.action_false };\r\n  }\r\n\r\n  async validateTimeCondition(timeCondition: Partial<TimeCondition>): Promise<{ valid: boolean; errors: string[] }> {\r\n    const errors: string[] = [];\r\n\r\n    if (!timeCondition.name || timeCondition.name.trim().length === 0) {\r\n      errors.push('Name is required');\r\n    }\r\n\r\n    if (!timeCondition.timezone) {\r\n      errors.push('Timezone is required');\r\n    }\r\n\r\n    if (!timeCondition.conditions || timeCondition.conditions.length === 0) {\r\n      errors.push('At least one time condition is required');\r\n    } else {\r\n      timeCondition.conditions.forEach((condition, index) => {\r\n        if (condition.day_of_week < 0 || condition.day_of_week > 6) {\r\n          errors.push(`Condition ${index + 1}: Day of week must be between 0-6`);\r\n        }\r\n\r\n        if (!condition.start_time || !condition.end_time) {\r\n          errors.push(`Condition ${index + 1}: Start time and end time are required`);\r\n        } else {\r\n          const startTime = condition.start_time;\r\n          const endTime = condition.end_time;\r\n          \r\n          if (!/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(startTime)) {\r\n            errors.push(`Condition ${index + 1}: Invalid start time format (use HH:MM)`);\r\n          }\r\n          \r\n          if (!/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(endTime)) {\r\n            errors.push(`Condition ${index + 1}: Invalid end time format (use HH:MM)`);\r\n          }\r\n\r\n          if (startTime >= endTime) {\r\n            errors.push(`Condition ${index + 1}: Start time must be before end time`);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!timeCondition.action_true || !timeCondition.action_true.type) {\r\n      errors.push('True action is required');\r\n    }\r\n\r\n    if (!timeCondition.action_false || !timeCondition.action_false.type) {\r\n      errors.push('False action is required');\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n\r\n  async getActiveTimeConditions(tenantId: string): Promise<TimeCondition[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM time_conditions WHERE tenant_id = $1 AND enabled = true ORDER BY name ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToTimeCondition(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n}\r\n","size_bytes":9099},"packages/frontend/src/pages/Dashboard.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Phone, Users, Building, Activity, TrendingUp, Clock, UserPlus } from 'lucide-react';\nimport apiClient from '@/lib/api';\nimport { useAuth } from '@/hooks/use-auth';\n\ninterface DashboardStats {\n  totalCalls: number;\n  activeCalls: number;\n  totalExtensions: number;\n  totalStores: number;\n  callVolume: number;\n  averageCallDuration: number;\n}\n\nexport default function Dashboard() {\n  const [stats, setStats] = useState<DashboardStats>({\n    totalCalls: 0,\n    activeCalls: 0,\n    totalExtensions: 0,\n    totalStores: 0,\n    callVolume: 0,\n    averageCallDuration: 0,\n  });\n  const [isLoading, setIsLoading] = useState(true);\n  const { user } = useAuth();\n  const navigate = useNavigate();\n  const { tenantSlug } = useParams<{ tenantSlug: string }>();\n\n  useEffect(() => {\n    loadDashboardData();\n  }, []);\n\n  const loadDashboardData = async () => {\n    try {\n      setIsLoading(true);\n      \n      // Load CDR statistics\n      const cdrStats = await apiClient.getCDRStats({\n        start_date: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // Last 24 hours\n      });\n\n      // Load extensions count\n      const extensions = await apiClient.getExtensions({ limit: 1 });\n      \n      // Load stores count\n      const stores = await apiClient.getStores({ limit: 1 });\n\n      // Load call status\n      const callStatus = await apiClient.getCallStatus();\n\n      setStats({\n        totalCalls: (cdrStats.data as any)?.total_calls || 0,\n        activeCalls: (callStatus.data as any)?.freeswitch?.connected ? Math.floor(Math.random() * 10) : 0, // Mock active calls\n        totalExtensions: (extensions.data as any)?.pagination?.total || 0,\n        totalStores: (stores.data as any)?.pagination?.total || 0,\n        callVolume: (cdrStats.data as any)?.total_duration || 0,\n        averageCallDuration: (cdrStats.data as any)?.average_duration || 0,\n      });\n    } catch (error) {\n      console.error('Failed to load dashboard data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    return `${hours}h ${minutes}m`;\n  };\n\n  const formatTime = (seconds: number) => {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div>\n        <h1 className=\"text-3xl font-bold tracking-tight\">Dashboard</h1>\n        <p className=\"text-muted-foreground\">\n          Welcome back, {user?.role === 'super_admin' ? 'Administrator' : 'User'}! Here's your VoIP system overview.\n        </p>\n      </div>\n\n      {/* Stats Grid */}\n      <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-4\">\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Total Calls (24h)</CardTitle>\n            <div className=\"p-2 rounded-lg bg-gradient-to-br from-blue-500/10 to-blue-600/10 \n                        group-hover:from-blue-500/20 group-hover:to-blue-600/20\n                        transition-colors duration-200\">\n              <Phone className=\"h-4 w-4 text-blue-600 group-hover:scale-110 transition-transform\" />\n            </div>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.totalCalls}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              <TrendingUp className=\"inline h-3 w-3 mr-1\" />\n              +12% from yesterday\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Active Calls</CardTitle>\n            <div className=\"p-2 rounded-lg bg-gradient-to-br from-green-500/10 to-green-600/10 \n                        group-hover:from-green-500/20 group-hover:to-green-600/20\n                        transition-colors duration-200\">\n              <Activity className=\"h-4 w-4 text-green-600 group-hover:scale-110 transition-transform\" />\n            </div>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.activeCalls}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Currently in progress\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Extensions</CardTitle>\n            <div className=\"p-2 rounded-lg bg-gradient-to-br from-purple-500/10 to-purple-600/10 \n                        group-hover:from-purple-500/20 group-hover:to-purple-600/20\n                        transition-colors duration-200\">\n              <Users className=\"h-4 w-4 text-purple-600 group-hover:scale-110 transition-transform\" />\n            </div>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.totalExtensions}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Total registered extensions\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Stores</CardTitle>\n            <div className=\"p-2 rounded-lg bg-gradient-to-br from-orange-500/10 to-orange-600/10 \n                        group-hover:from-orange-500/20 group-hover:to-orange-600/20\n                        transition-colors duration-200\">\n              <Building className=\"h-4 w-4 text-orange-600 group-hover:scale-110 transition-transform\" />\n            </div>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{stats.totalStores}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Active store locations\n            </p>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Additional Stats */}\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader>\n            <CardTitle>Call Volume (24h)</CardTitle>\n            <CardDescription>\n              Total call duration in the last 24 hours\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-3xl font-bold\">{formatDuration(stats.callVolume)}</div>\n            <div className=\"flex items-center space-x-2 mt-2\">\n              <Badge variant=\"secondary\" className=\"hover:scale-105 transition-transform\">Voice Calls</Badge>\n              <Badge variant=\"outline\" className=\"hover:scale-105 transition-transform\">Video Calls</Badge>\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card variant=\"glass\" className=\"group\">\n          <CardHeader>\n            <CardTitle>Average Call Duration</CardTitle>\n            <CardDescription>\n              Mean duration of completed calls\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-3xl font-bold\">{formatTime(stats.averageCallDuration)}</div>\n            <div className=\"flex items-center space-x-2 mt-2\">\n              <Clock className=\"h-4 w-4 text-muted-foreground\" />\n              <span className=\"text-sm text-muted-foreground\">\n                Per call average\n              </span>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Quick Actions */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Quick Actions</CardTitle>\n          <CardDescription>\n            Common tasks and system management\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid gap-4 md:grid-cols-3\">\n            <Button \n              variant=\"outline\" \n              className=\"h-20 flex flex-col items-center justify-center hover:bg-blue-50 transition-colors\"\n              onClick={() => navigate(`/${tenantSlug}/ring-groups`)}\n            >\n              <UserPlus className=\"h-6 w-6 mb-2\" />\n              <span>Ring Groups</span>\n            </Button>\n            <Button \n              variant=\"outline\" \n              className=\"h-20 flex flex-col items-center justify-center hover:bg-purple-50 transition-colors\"\n              onClick={() => navigate(`/${tenantSlug}/extensions`)}\n            >\n              <Users className=\"h-6 w-6 mb-2\" />\n              <span>Manage Extensions</span>\n            </Button>\n            <Button \n              variant=\"outline\" \n              className=\"h-20 flex flex-col items-center justify-center hover:bg-orange-50 transition-colors\"\n              onClick={() => navigate(`/${tenantSlug}/stores`)}\n            >\n              <Building className=\"h-6 w-6 mb-2\" />\n              <span>Store Settings</span>\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* System Status */}\n      <Card>\n        <CardHeader>\n          <CardTitle>System Status</CardTitle>\n          <CardDescription>\n            Current system health and connectivity\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"h-2 w-2 bg-green-500 rounded-full\"></div>\n                <span>FreeSWITCH Connection</span>\n              </div>\n              <Badge variant=\"secondary\">Connected</Badge>\n            </div>\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"h-2 w-2 bg-green-500 rounded-full\"></div>\n                <span>Database</span>\n              </div>\n              <Badge variant=\"secondary\">Healthy</Badge>\n            </div>\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"h-2 w-2 bg-green-500 rounded-full\"></div>\n                <span>API Services</span>\n              </div>\n              <Badge variant=\"secondary\">Running</Badge>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n      \n    </div>\n  );\n}","size_bytes":11174},"packages/frontend/src/components/layout/Header.tsx":{"content":"import { Bell, Search, Shield, Users, User, RefreshCw } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { ThemeToggle } from '@/components/ui/theme-toggle';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useState, useEffect } from 'react';\nimport { cn } from '@/lib/utils';\n\nexport default function Header() {\n  const { user } = useAuth();\n  const [freeSwitchConnected, setFreeSwitchConnected] = useState(false);\n  const [freeSwitchLoading, setFreeSwitchLoading] = useState(false);\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n\n  const checkFreeSwitchStatus = async () => {\n    try {\n      setFreeSwitchLoading(true);\n      const response = await fetch('/api/freeswitch/status');\n      const data = await response.json();\n      const connected = Boolean((data?.data && data.data.connected) ?? data.connected);\n      setFreeSwitchConnected(connected);\n    } catch (error) {\n      console.error('Error checking FreeSWITCH status:', error);\n      setFreeSwitchConnected(false);\n    } finally {\n      setFreeSwitchLoading(false);\n    }\n  };\n\n  const refreshFreeSwitchStatus = async () => {\n    await checkFreeSwitchStatus();\n  };\n\n  useEffect(() => {\n    checkFreeSwitchStatus();\n    // Check status every 30 seconds\n    const interval = setInterval(checkFreeSwitchStatus, 30000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // Listen for sidebar state changes\n  useEffect(() => {\n    const handleSidebarStateChange = (event: CustomEvent) => {\n      setSidebarCollapsed(event.detail.collapsed);\n    };\n\n    window.addEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\n    return () => {\n      window.removeEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\n    };\n  }, []);\n\n  return (\n    <header className=\"glass-light sticky top-0 z-30 px-6 py-4 border-b border-white/20\">\n      <div className=\"max-w-7xl mx-auto\">\n        <div className=\"flex justify-between items-center h-16\">\n          <div className=\"flex items-center space-x-3\">\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              EDG VoIP System\n              <span className={cn(\n                \"ml-2 text-xs px-2 py-1 rounded-full transition-all duration-200\",\n                sidebarCollapsed \n                  ? \"bg-blue-100 text-blue-700\" \n                  : \"bg-green-100 text-green-700\"\n              )}>\n                {sidebarCollapsed ? \"Compact\" : \"Full\"}\n              </span>\n            </h1>\n            {user && (\n              <div className=\"flex items-center space-x-2 text-sm text-gray-600\">\n                {user.role === 'super_admin' && (\n                  <>\n                    <Shield className=\"h-4 w-4 text-red-500\" />\n                    <span className=\"font-medium\">Super Admin</span>\n                  </>\n                )}\n                {user.role === 'tenant_admin' && (\n                  <>\n                    <Users className=\"h-4 w-4 text-blue-500\" />\n                    <span className=\"font-medium\">Tenant Admin</span>\n                    {user.tenant_id && (\n                      <span className=\"text-gray-500\">• Tenant: {user.tenant_id.slice(0, 8)}...</span>\n                    )}\n                  </>\n                )}\n                {user.role === 'tenant_user' && (\n                  <>\n                    <User className=\"h-4 w-4 text-green-500\" />\n                    <span className=\"font-medium\">User</span>\n                    {user.tenant_id && (\n                      <span className=\"text-gray-500\">• Tenant: {user.tenant_id.slice(0, 8)}...</span>\n                    )}\n                  </>\n                )}\n              </div>\n            )}\n          </div>\n\n          <div className=\"flex items-center space-x-4\">\n            {/* Search */}\n            <div className=\"relative\">\n              <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n              <Input\n                type=\"text\"\n                placeholder=\"Search...\"\n                className=\"glass-input pl-10 w-64 focus:ring-2 focus:ring-blue-500/50 transition-all duration-200\"\n              />\n            </div>\n\n            {/* Theme Toggle */}\n            <ThemeToggle />\n\n            {/* Notifications */}\n            <Button \n              variant=\"ghost\" \n              size=\"sm\" \n              className=\"relative hover:bg-white/50 hover:scale-105 transition-all duration-200\"\n            >\n              <Bell className=\"h-5 w-5\" />\n              <Badge \n                variant=\"destructive\" \n                className=\"absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center p-0 text-xs animate-bounce-smooth\"\n              >\n                3\n              </Badge>\n            </Button>\n\n            {/* Status Indicators */}\n            <div className=\"flex items-center space-x-4\">\n              {/* System Online */}\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"h-2 w-2 bg-green-500 rounded-full animate-pulse\"></div>\n                <span className=\"text-sm text-gray-600\">System Online</span>\n              </div>\n              \n              {/* FreeSWITCH Status */}\n              <div className=\"flex items-center space-x-2\">\n                <div className={cn(\n                  \"h-2 w-2 rounded-full transition-colors duration-200\",\n                  freeSwitchConnected ? 'bg-green-500 animate-pulse' : 'bg-red-500'\n                )}></div>\n                <span className={cn(\n                  \"text-sm transition-colors duration-200\",\n                  freeSwitchConnected ? 'text-gray-600' : 'text-red-600'\n                )}>\n                  FreeSWITCH {freeSwitchConnected ? '' : '(ESL Disabled)'}\n                </span>\n                <button \n                  onClick={refreshFreeSwitchStatus}\n                  disabled={freeSwitchLoading}\n                  className=\"p-1 hover:bg-white/50 hover:scale-105 rounded transition-all duration-200\"\n                  title={freeSwitchConnected ? \"Refresh FreeSWITCH Status\" : \"FreeSWITCH ESL not configured\"}\n                >\n                  <RefreshCw className={cn(\n                    \"h-3 w-3 text-gray-500 transition-transform duration-200\",\n                    freeSwitchLoading ? 'animate-spin' : 'hover:rotate-180'\n                  )} />\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </header>\n  );\n}","size_bytes":6632},"packages/backend/src/routes/logs.ts":{"content":"// @ts-nocheck\r\nimport express from 'express';\r\nimport { Request, Response } from 'express';\r\nimport { exec } from 'child_process';\r\nimport { promisify } from 'util';\r\nimport path from 'path';\r\n\r\nconst execAsync = promisify(exec);\r\nconst router = express.Router();\r\n\r\ninterface LogEntry {\r\n  id: string;\r\n  timestamp: string;\r\n  level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';\r\n  component: string;\r\n  message: string;\r\n  tenant_id?: string;\r\n  source: 'freeswitch' | 'backend' | 'frontend';\r\n}\r\n\r\n// Get FreeSWITCH logs\r\nrouter.get('/freeswitch', async (req: Request, res: Response) => {\r\n  try {\r\n    const { lines = '100', level = 'all', component = 'all' } = req.query;\r\n    \r\n    // Check if FreeSWITCH container is running\r\n    try {\r\n      await execAsync('docker ps --filter name=voip_freeswitch --format \"{{.Names}}\"');\r\n    } catch (error) {\r\n      return res.status(503).json({\r\n        error: 'FreeSWITCH container is not running',\r\n        message: 'Please start FreeSWITCH container first'\r\n      });\r\n    }\r\n\r\n    // Get FreeSWITCH logs from Docker container\r\n    const logCommand = `docker logs voip_freeswitch --tail ${lines}`;\r\n    const { stdout } = await execAsync(logCommand);\r\n    \r\n    // Parse logs and convert to structured format\r\n    const logLines = stdout.split('\\n').filter(line => line.trim());\r\n    const parsedLogs: LogEntry[] = [];\r\n    \r\n    logLines.forEach((line, index) => {\r\n      // Parse FreeSWITCH log format: [timestamp] level component message\r\n      const match = line.match(/^\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\] (\\w+)\\s+(.+)/);\r\n      \r\n      if (match) {\r\n        const [, timestamp, level, rest] = match;\r\n        const componentMatch = rest.match(/^([a-zA-Z_]+)\\s+(.+)/);\r\n        \r\n        if (componentMatch) {\r\n          const [, component, message] = componentMatch;\r\n          \r\n          const logEntry: LogEntry = {\r\n            id: `fs-${Date.now()}-${index}`,\r\n            timestamp: new Date(timestamp).toISOString(),\r\n            level: (level.toUpperCase() as any) || 'INFO',\r\n            component: component || 'unknown',\r\n            message: message || rest,\r\n            source: 'freeswitch'\r\n          };\r\n          \r\n          // Apply filters\r\n          if (level === 'all' || logEntry.level === level.toUpperCase()) {\r\n            if (component === 'all' || logEntry.component === component) {\r\n              parsedLogs.push(logEntry);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n    \r\n    res.json({\r\n      success: true,\r\n      logs: parsedLogs,\r\n      total: parsedLogs.length,\r\n      source: 'freeswitch',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching FreeSWITCH logs:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to fetch FreeSWITCH logs',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Get backend logs\r\nrouter.get('/backend', async (req: Request, res: Response) => {\r\n  try {\r\n    const { lines = '100', level = 'all' } = req.query;\r\n    \r\n    // For now, return sample backend logs\r\n    // In production, this would read from actual log files\r\n    const sampleLogs: LogEntry[] = [\r\n      {\r\n        id: `be-${Date.now()}-1`,\r\n        timestamp: new Date().toISOString(),\r\n        level: 'INFO',\r\n        component: 'api',\r\n        message: 'Server started successfully on port 3000',\r\n        source: 'backend'\r\n      },\r\n      {\r\n        id: `be-${Date.now()}-2`,\r\n        timestamp: new Date(Date.now() - 1000).toISOString(),\r\n        level: 'INFO',\r\n        component: 'auth',\r\n        message: 'User authentication successful',\r\n        source: 'backend'\r\n      },\r\n      {\r\n        id: `be-${Date.now()}-3`,\r\n        timestamp: new Date(Date.now() - 2000).toISOString(),\r\n        level: 'DEBUG',\r\n        component: 'database',\r\n        message: 'Database connection established',\r\n        source: 'backend'\r\n      }\r\n    ];\r\n    \r\n    // Apply level filter\r\n    const filteredLogs = level === 'all' \r\n      ? sampleLogs \r\n      : sampleLogs.filter(log => log.level === level.toUpperCase());\r\n    \r\n    res.json({\r\n      success: true,\r\n      logs: filteredLogs,\r\n      total: filteredLogs.length,\r\n      source: 'backend',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching backend logs:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to fetch backend logs',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Get system logs (combined)\r\nrouter.get('/system', async (req: Request, res: Response) => {\r\n  try {\r\n    const { lines = '50' } = req.query;\r\n    \r\n    // Get logs from multiple sources\r\n    const [freeswitchResponse, backendResponse] = await Promise.allSettled([\r\n      fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/freeswitch?lines=${lines}`),\r\n      fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/backend?lines=${lines}`)\r\n    ]);\r\n    \r\n    const allLogs: LogEntry[] = [];\r\n    \r\n    if (freeswitchResponse.status === 'fulfilled' && freeswitchResponse.value.ok) {\r\n      const fsData = await freeswitchResponse.value.json();\r\n      if (fsData.success) {\r\n        allLogs.push(...fsData.logs);\r\n      }\r\n    }\r\n    \r\n    if (backendResponse.status === 'fulfilled' && backendResponse.value.ok) {\r\n      const beData = await backendResponse.value.json();\r\n      if (beData.success) {\r\n        allLogs.push(...beData.logs);\r\n      }\r\n    }\r\n    \r\n    // Sort by timestamp (newest first)\r\n    allLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n    \r\n    res.json({\r\n      success: true,\r\n      logs: allLogs,\r\n      total: allLogs.length,\r\n      sources: ['freeswitch', 'backend'],\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching system logs:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to fetch system logs',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Get log statistics\r\nrouter.get('/stats', async (req: Request, res: Response) => {\r\n  try {\r\n    // Get recent logs to calculate stats\r\n    const { lines = '1000' } = req.query;\r\n    \r\n    const [freeswitchResponse, backendResponse] = await Promise.allSettled([\r\n      fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/freeswitch?lines=${lines}`),\r\n      fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/backend?lines=${lines}`)\r\n    ]);\r\n    \r\n    let totalLogs = 0;\r\n    let errorCount = 0;\r\n    let warningCount = 0;\r\n    \r\n    if (freeswitchResponse.status === 'fulfilled' && freeswitchResponse.value.ok) {\r\n      const fsData = await freeswitchResponse.value.json();\r\n      if (fsData.success) {\r\n        totalLogs += fsData.logs.length;\r\n        errorCount += fsData.logs.filter((log: LogEntry) => \r\n          log.level === 'ERROR' || log.level === 'CRITICAL'\r\n        ).length;\r\n        warningCount += fsData.logs.filter((log: LogEntry) => \r\n          log.level === 'WARN'\r\n        ).length;\r\n      }\r\n    }\r\n    \r\n    if (backendResponse.status === 'fulfilled' && backendResponse.value.ok) {\r\n      const beData = await backendResponse.value.json();\r\n      if (beData.success) {\r\n        totalLogs += beData.logs.length;\r\n        errorCount += beData.logs.filter((log: LogEntry) => \r\n          log.level === 'ERROR' || log.level === 'CRITICAL'\r\n        ).length;\r\n        warningCount += beData.logs.filter((log: LogEntry) => \r\n          log.level === 'WARN'\r\n        ).length;\r\n      }\r\n    }\r\n    \r\n    res.json({\r\n      success: true,\r\n      stats: {\r\n        total: totalLogs,\r\n        errors: errorCount,\r\n        warnings: warningCount,\r\n        last_update: new Date().toISOString()\r\n      },\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching log statistics:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to fetch log statistics',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Set FreeSWITCH log level\r\nrouter.post('/freeswitch/level', async (req: Request, res: Response) => {\r\n  try {\r\n    const { level } = req.body;\r\n    \r\n    if (!level || !['debug', 'info', 'notice', 'warning', 'error'].includes(level)) {\r\n      return res.status(400).json({\r\n        error: 'Invalid log level',\r\n        message: 'Level must be one of: debug, info, notice, warning, error'\r\n      });\r\n    }\r\n    \r\n    // Execute FreeSWITCH command to set log level\r\n    const command = `docker exec voip_freeswitch fs_cli -x \"console loglevel ${level}\"`;\r\n    await execAsync(command);\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: `FreeSWITCH log level set to ${level}`,\r\n      level: level,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error setting FreeSWITCH log level:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to set FreeSWITCH log level',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Enable/disable SIP tracing\r\nrouter.post('/freeswitch/tracing', async (req: Request, res: Response) => {\r\n  try {\r\n    const { enabled } = req.body;\r\n    \r\n    if (typeof enabled !== 'boolean') {\r\n      return res.status(400).json({\r\n        error: 'Invalid parameter',\r\n        message: 'enabled must be a boolean value'\r\n      });\r\n    }\r\n    \r\n    // Execute FreeSWITCH command to enable/disable SIP tracing\r\n    const command = `docker exec voip_freeswitch fs_cli -x \"sofia loglevel ${enabled ? 'all' : 'info'}\"`;\r\n    await execAsync(command);\r\n    \r\n    res.json({\r\n      success: true,\r\n      message: `SIP tracing ${enabled ? 'enabled' : 'disabled'}`,\r\n      enabled: enabled,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error('Error setting SIP tracing:', error);\r\n    res.status(500).json({\r\n      error: 'Failed to set SIP tracing',\r\n      message: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":10253},"packages/backend/src/routes/sip-test-routes.ts":{"content":"import { Router } from 'express';\r\nimport { SipTestService, SipTestConfig } from '../services/sip-test-service';\r\n\r\nconst router = Router();\r\nconst sipTestService = new SipTestService();\r\n\r\n// Test SIP registration\r\nrouter.post('/test-registration', async (req, res) => {\r\n  try {\r\n    const config: SipTestConfig = req.body;\r\n    \r\n    // Validate required fields\r\n    if (!config.provider || !config.proxy || !config.auth_username || !config.auth_password) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Missing required fields: provider, proxy, auth_username, auth_password'\r\n      });\r\n    }\r\n\r\n    const result = await sipTestService.testSipRegistration(config);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: result\r\n    });\r\n  } catch (error) {\r\n    console.error('Error testing SIP registration:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to test SIP registration',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Test SIP trunk connectivity\r\nrouter.post('/test-connectivity', async (req, res) => {\r\n  try {\r\n    const config: SipTestConfig = req.body;\r\n    \r\n    // Validate required fields\r\n    if (!config.proxy || !config.port) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Missing required fields: proxy, port'\r\n      });\r\n    }\r\n\r\n    const result = await sipTestService.testSipTrunkConnectivity(config);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: result\r\n    });\r\n  } catch (error) {\r\n    console.error('Error testing SIP connectivity:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to test SIP connectivity',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Test Messagenet connection specifically\r\nrouter.post('/test-messagenet', async (req, res) => {\r\n  try {\r\n    const result = await sipTestService.testMessagenetConnection();\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: result\r\n    });\r\n  } catch (error) {\r\n    console.error('Error testing Messagenet connection:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to test Messagenet connection',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// Test multiple configurations\r\nrouter.post('/test-multiple', async (req, res) => {\r\n  try {\r\n    const configs: SipTestConfig[] = req.body.configs;\r\n    \r\n    if (!Array.isArray(configs) || configs.length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'configs must be a non-empty array'\r\n      });\r\n    }\r\n\r\n    const results = await sipTestService.testMultipleConfigurations(configs);\r\n    \r\n    res.json({\r\n      success: true,\r\n      data: results\r\n    });\r\n  } catch (error) {\r\n    console.error('Error testing multiple SIP configurations:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to test SIP configurations',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":3200},"packages/frontend/src/vite-env.d.ts":{"content":"/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_API_BASE_URL: string\n  readonly VITE_FRONTEND_PORT: number\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n\ndeclare global {\n  interface ImportMeta {\n    readonly env: ImportMetaEnv\n  }\n}\n","size_bytes":306},"packages/frontend/src/pages/Tenants.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Badge } from '@/components/ui/badge';\nimport { Plus, Search, Edit, Trash2, Eye } from 'lucide-react';\nimport apiClient from '@/lib/api';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface Tenant {\n  id: string;\n  name: string;\n  domain: string;\n  sip_domain: string;\n  edg_suite_id: string;\n  created_at: string;\n  updated_at: string;\n  stores_count?: number;\n  extensions_count?: number;\n  trunks_count?: number;\n}\n\nexport default function Tenants() {\n  const navigate = useNavigate();\n  const [tenants, setTenants] = useState<Tenant[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [searchTerm, setSearchTerm] = useState('');\n  const { toast } = useToast();\n\n  useEffect(() => {\n    loadTenants();\n  }, []);\n\n  const loadTenants = async () => {\n    try {\n      setIsLoading(true);\n      const response = await apiClient.getTenants();\n      setTenants((response.data as any)?.tenants || []);\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load tenants\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const filteredTenants = tenants.filter(tenant =>\n    tenant.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    tenant.domain.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    tenant.sip_domain.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Tenants</h1>\n          <p className=\"text-muted-foreground\">\n            Manage multi-tenant VoIP configurations\n          </p>\n        </div>\n        <Button onClick={() => navigate('/edgvoip/tenants/create')}>\n          <Plus className=\"h-4 w-4 mr-2\" />\n          Add Tenant\n        </Button>\n      </div>\n\n      {/* Search */}\n      <div className=\"flex items-center space-x-2\">\n        <div className=\"relative flex-1 max-w-sm\">\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n          <Input\n            placeholder=\"Search tenants...\"\n            value={searchTerm}\n            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchTerm(e.target.value)}\n            className=\"pl-10\"\n          />\n        </div>\n      </div>\n\n      {/* Tenants Grid */}\n      <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n        {filteredTenants.map((tenant) => (\n          <Card key={tenant.id}>\n            <CardHeader>\n              <div className=\"flex items-center justify-between\">\n                <CardTitle className=\"text-lg\">{tenant.name}</CardTitle>\n                <Badge variant=\"secondary\">Active</Badge>\n              </div>\n              <CardDescription>\n                <div className=\"space-y-1\">\n                  <div>Domain: {tenant.domain}</div>\n                  <div className=\"text-blue-600 font-medium\">SIP Domain: {tenant.sip_domain}</div>\n                </div>\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-2\">\n                <div className=\"text-sm\">\n                  <span className=\"font-medium\">EDG Suite ID:</span>\n                  <span className=\"ml-2 text-muted-foreground\">\n                    {tenant.edg_suite_id}\n                  </span>\n                </div>\n                <div className=\"text-sm\">\n                  <span className=\"font-medium\">Created:</span>\n                  <span className=\"ml-2 text-muted-foreground\">\n                    {new Date(tenant.created_at).toLocaleDateString()}\n                  </span>\n                </div>\n              </div>\n              \n              <div className=\"flex space-x-2 mt-4\">\n                <Button variant=\"outline\" size=\"sm\">\n                  <Eye className=\"h-4 w-4 mr-1\" />\n                  View\n                </Button>\n                <Button variant=\"outline\" size=\"sm\">\n                  <Edit className=\"h-4 w-4 mr-1\" />\n                  Edit\n                </Button>\n                <Button variant=\"outline\" size=\"sm\">\n                  <Trash2 className=\"h-4 w-4 mr-1\" />\n                  Delete\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {filteredTenants.length === 0 && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <div className=\"text-center\">\n              <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                No tenants found\n              </h3>\n              <p className=\"text-gray-500 mb-4\">\n                {searchTerm ? 'Try adjusting your search terms.' : 'Get started by creating your first tenant.'}\n              </p>\n              <Button>\n                <Plus className=\"h-4 w-4 mr-2\" />\n                Add Tenant\n              </Button>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}","size_bytes":5557},"packages/backend/src/services/conference.service.ts":{"content":"import { getClient, withTransaction } from '@w3-voip/database';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport interface ConferenceRoom {\r\n  id: string;\r\n  tenant_id: string;\r\n  name: string;\r\n  description?: string;\r\n  extension: string;\r\n  pin?: string;\r\n  moderator_pin?: string;\r\n  max_members: number;\r\n  record: boolean;\r\n  record_path?: string;\r\n  moh_sound?: string;\r\n  announce_sound?: string;\r\n  settings: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\nexport interface ConferenceMember {\r\n  id: string;\r\n  conference_id: string;\r\n  extension: string;\r\n  caller_id_name?: string;\r\n  caller_id_number?: string;\r\n  join_time: Date;\r\n  leave_time?: Date;\r\n  is_moderator: boolean;\r\n  is_muted: boolean;\r\n  is_deaf: boolean;\r\n  member_flags?: string;\r\n  created_at: Date;\r\n}\r\n\r\nexport class ConferenceService {\r\n  private mapRowToConferenceRoom(row: any): ConferenceRoom {\r\n    return {\r\n      id: row.id,\r\n      tenant_id: row.tenant_id,\r\n      name: row.name,\r\n      description: row.description,\r\n      extension: row.extension,\r\n      pin: row.pin,\r\n      moderator_pin: row.moderator_pin,\r\n      max_members: row.max_members,\r\n      record: row.record,\r\n      record_path: row.record_path,\r\n      moh_sound: row.moh_sound,\r\n      announce_sound: row.announce_sound,\r\n      settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings,\r\n      enabled: row.enabled,\r\n      created_at: row.created_at,\r\n      updated_at: row.updated_at,\r\n    };\r\n  }\r\n\r\n  private mapRowToConferenceMember(row: any): ConferenceMember {\r\n    return {\r\n      id: row.id,\r\n      conference_id: row.conference_id,\r\n      extension: row.extension,\r\n      caller_id_name: row.caller_id_name,\r\n      caller_id_number: row.caller_id_number,\r\n      join_time: row.join_time,\r\n      leave_time: row.leave_time,\r\n      is_moderator: row.is_moderator,\r\n      is_muted: row.is_muted,\r\n      is_deaf: row.is_deaf,\r\n      member_flags: row.member_flags,\r\n      created_at: row.created_at,\r\n    };\r\n  }\r\n\r\n  async createConferenceRoom(conferenceRoomData: Omit<ConferenceRoom, 'id' | 'created_at' | 'updated_at'>): Promise<ConferenceRoom> {\r\n    return withTransaction(async (client) => {\r\n      // Check if extension is already taken\r\n      const existingRoom = await client.query(\r\n        `SELECT id FROM conference_rooms WHERE extension = $1 AND tenant_id = $2`,\r\n        [conferenceRoomData.extension, conferenceRoomData.tenant_id]\r\n      );\r\n      \r\n      if (existingRoom.rows.length > 0) {\r\n        throw new Error(`Extension ${conferenceRoomData.extension} is already in use`);\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO conference_rooms (tenant_id, name, description, extension, pin, moderator_pin, max_members, record, record_path, moh_sound, announce_sound, settings, enabled)\r\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\r\n         RETURNING *`,\r\n        [\r\n          conferenceRoomData.tenant_id,\r\n          conferenceRoomData.name,\r\n          conferenceRoomData.description,\r\n          conferenceRoomData.extension,\r\n          conferenceRoomData.pin,\r\n          conferenceRoomData.moderator_pin,\r\n          conferenceRoomData.max_members,\r\n          conferenceRoomData.record,\r\n          conferenceRoomData.record_path,\r\n          conferenceRoomData.moh_sound,\r\n          conferenceRoomData.announce_sound,\r\n          JSON.stringify(conferenceRoomData.settings),\r\n          conferenceRoomData.enabled,\r\n        ]\r\n      );\r\n      return this.mapRowToConferenceRoom(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  async getConferenceRoomById(id: string, tenantId: string): Promise<ConferenceRoom | undefined> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM conference_rooms WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rows.length > 0 ? this.mapRowToConferenceRoom(result.rows[0]) : undefined;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async getConferenceRoomByExtension(extension: string, tenantId: string): Promise<ConferenceRoom | undefined> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM conference_rooms WHERE extension = $1 AND tenant_id = $2 AND enabled = true`,\r\n        [extension, tenantId]\r\n      );\r\n      return result.rows.length > 0 ? this.mapRowToConferenceRoom(result.rows[0]) : undefined;\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async listConferenceRooms(tenantId: string): Promise<ConferenceRoom[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM conference_rooms WHERE tenant_id = $1 ORDER BY name ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToConferenceRoom(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async updateConferenceRoom(id: string, tenantId: string, updateData: Partial<Omit<ConferenceRoom, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>): Promise<ConferenceRoom | undefined> {\r\n    return withTransaction(async (client) => {\r\n      // Check if extension is already taken by another room\r\n      if (updateData.extension) {\r\n        const existingRoom = await client.query(\r\n          `SELECT id FROM conference_rooms WHERE extension = $1 AND tenant_id = $2 AND id != $3`,\r\n          [updateData.extension, tenantId, id]\r\n        );\r\n        \r\n        if (existingRoom.rows.length > 0) {\r\n          throw new Error(`Extension ${updateData.extension} is already in use`);\r\n        }\r\n      }\r\n\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updateData.name !== undefined) {\r\n        updateFields.push(`name = $${paramCount++}`);\r\n        updateValues.push(updateData.name);\r\n      }\r\n      if (updateData.description !== undefined) {\r\n        updateFields.push(`description = $${paramCount++}`);\r\n        updateValues.push(updateData.description);\r\n      }\r\n      if (updateData.extension !== undefined) {\r\n        updateFields.push(`extension = $${paramCount++}`);\r\n        updateValues.push(updateData.extension);\r\n      }\r\n      if (updateData.pin !== undefined) {\r\n        updateFields.push(`pin = $${paramCount++}`);\r\n        updateValues.push(updateData.pin);\r\n      }\r\n      if (updateData.moderator_pin !== undefined) {\r\n        updateFields.push(`moderator_pin = $${paramCount++}`);\r\n        updateValues.push(updateData.moderator_pin);\r\n      }\r\n      if (updateData.max_members !== undefined) {\r\n        updateFields.push(`max_members = $${paramCount++}`);\r\n        updateValues.push(updateData.max_members);\r\n      }\r\n      if (updateData.record !== undefined) {\r\n        updateFields.push(`record = $${paramCount++}`);\r\n        updateValues.push(updateData.record);\r\n      }\r\n      if (updateData.record_path !== undefined) {\r\n        updateFields.push(`record_path = $${paramCount++}`);\r\n        updateValues.push(updateData.record_path);\r\n      }\r\n      if (updateData.moh_sound !== undefined) {\r\n        updateFields.push(`moh_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.moh_sound);\r\n      }\r\n      if (updateData.announce_sound !== undefined) {\r\n        updateFields.push(`announce_sound = $${paramCount++}`);\r\n        updateValues.push(updateData.announce_sound);\r\n      }\r\n      if (updateData.settings !== undefined) {\r\n        updateFields.push(`settings = $${paramCount++}`);\r\n        updateValues.push(JSON.stringify(updateData.settings));\r\n      }\r\n      if (updateData.enabled !== undefined) {\r\n        updateFields.push(`enabled = $${paramCount++}`);\r\n        updateValues.push(updateData.enabled);\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        return this.getConferenceRoomById(id, tenantId);\r\n      }\r\n\r\n      updateFields.push(`updated_at = CURRENT_TIMESTAMP`);\r\n      updateValues.push(id, tenantId);\r\n\r\n      const query = `\r\n        UPDATE conference_rooms \r\n        SET ${updateFields.join(', ')}\r\n        WHERE id = $${paramCount++} AND tenant_id = $${paramCount++}\r\n        RETURNING *\r\n      `;\r\n\r\n      const result = await client.query(query, updateValues);\r\n      return result.rows.length > 0 ? this.mapRowToConferenceRoom(result.rows[0]) : undefined;\r\n    });\r\n  }\r\n\r\n  async deleteConferenceRoom(id: string, tenantId: string): Promise<boolean> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `DELETE FROM conference_rooms WHERE id = $1 AND tenant_id = $2`,\r\n        [id, tenantId]\r\n      );\r\n      return result.rowCount > 0;\r\n    });\r\n  }\r\n\r\n  async getConferenceMembers(conferenceId: string, tenantId: string): Promise<ConferenceMember[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT cm.* FROM conference_members cm\r\n         JOIN conference_rooms cr ON cm.conference_id = cr.id\r\n         WHERE cm.conference_id = $1 AND cr.tenant_id = $2 AND cm.leave_time IS NULL\r\n         ORDER BY cm.join_time ASC`,\r\n        [conferenceId, tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToConferenceMember(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async addConferenceMember(conferenceId: string, tenantId: string, memberData: {\r\n    extension: string;\r\n    caller_id_name?: string;\r\n    caller_id_number?: string;\r\n    is_moderator?: boolean;\r\n  }): Promise<ConferenceMember> {\r\n    return withTransaction(async (client) => {\r\n      // Verify conference exists and belongs to tenant\r\n      const conference = await client.query(\r\n        `SELECT id FROM conference_rooms WHERE id = $1 AND tenant_id = $2`,\r\n        [conferenceId, tenantId]\r\n      );\r\n      \r\n      if (conference.rows.length === 0) {\r\n        throw new Error('Conference room not found');\r\n      }\r\n\r\n      const result = await client.query(\r\n        `INSERT INTO conference_members (conference_id, extension, caller_id_name, caller_id_number, is_moderator)\r\n         VALUES ($1, $2, $3, $4, $5)\r\n         RETURNING *`,\r\n        [\r\n          conferenceId,\r\n          memberData.extension,\r\n          memberData.caller_id_name,\r\n          memberData.caller_id_number,\r\n          memberData.is_moderator || false,\r\n        ]\r\n      );\r\n      return this.mapRowToConferenceMember(result.rows[0]);\r\n    });\r\n  }\r\n\r\n  async removeConferenceMember(conferenceId: string, tenantId: string, memberId: string): Promise<boolean> {\r\n    return withTransaction(async (client) => {\r\n      const result = await client.query(\r\n        `UPDATE conference_members \r\n         SET leave_time = CURRENT_TIMESTAMP\r\n         WHERE id = $1 AND conference_id = $2 AND conference_id IN (\r\n           SELECT id FROM conference_rooms WHERE tenant_id = $3\r\n         )`,\r\n        [memberId, conferenceId, tenantId]\r\n      );\r\n      return result.rowCount > 0;\r\n    });\r\n  }\r\n\r\n  async updateMemberStatus(conferenceId: string, tenantId: string, memberId: string, updates: {\r\n    is_muted?: boolean;\r\n    is_deaf?: boolean;\r\n    is_moderator?: boolean;\r\n  }): Promise<boolean> {\r\n    return withTransaction(async (client) => {\r\n      const updateFields: string[] = [];\r\n      const updateValues: any[] = [];\r\n      let paramCount = 1;\r\n\r\n      if (updates.is_muted !== undefined) {\r\n        updateFields.push(`is_muted = $${paramCount++}`);\r\n        updateValues.push(updates.is_muted);\r\n      }\r\n      if (updates.is_deaf !== undefined) {\r\n        updateFields.push(`is_deaf = $${paramCount++}`);\r\n        updateValues.push(updates.is_deaf);\r\n      }\r\n      if (updates.is_moderator !== undefined) {\r\n        updateFields.push(`is_moderator = $${paramCount++}`);\r\n        updateValues.push(updates.is_moderator);\r\n      }\r\n\r\n      if (updateFields.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      updateValues.push(memberId, conferenceId, tenantId);\r\n\r\n      const query = `\r\n        UPDATE conference_members \r\n        SET ${updateFields.join(', ')}\r\n        WHERE id = $${paramCount++} AND conference_id = $${paramCount++} AND conference_id IN (\r\n          SELECT id FROM conference_rooms WHERE tenant_id = $${paramCount++}\r\n        )\r\n      `;\r\n\r\n      const result = await client.query(query, updateValues);\r\n      return result.rowCount > 0;\r\n    });\r\n  }\r\n\r\n  async validateConferenceRoom(conferenceRoom: Partial<ConferenceRoom>): Promise<{ valid: boolean; errors: string[] }> {\r\n    const errors: string[] = [];\r\n\r\n    if (!conferenceRoom.name || conferenceRoom.name.trim().length === 0) {\r\n      errors.push('Name is required');\r\n    }\r\n\r\n    if (!conferenceRoom.extension || conferenceRoom.extension.trim().length === 0) {\r\n      errors.push('Extension is required');\r\n    } else if (!/^\\d{3,4}$/.test(conferenceRoom.extension)) {\r\n      errors.push('Extension must be 3-4 digits');\r\n    }\r\n\r\n    if (conferenceRoom.max_members !== undefined && (conferenceRoom.max_members < 2 || conferenceRoom.max_members > 1000)) {\r\n      errors.push('Max members must be between 2-1000');\r\n    }\r\n\r\n    if (conferenceRoom.pin && !/^\\d{4,8}$/.test(conferenceRoom.pin)) {\r\n      errors.push('PIN must be 4-8 digits');\r\n    }\r\n\r\n    if (conferenceRoom.moderator_pin && !/^\\d{4,8}$/.test(conferenceRoom.moderator_pin)) {\r\n      errors.push('Moderator PIN must be 4-8 digits');\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n\r\n  async getActiveConferenceRooms(tenantId: string): Promise<ConferenceRoom[]> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT * FROM conference_rooms WHERE tenant_id = $1 AND enabled = true ORDER BY extension ASC`,\r\n        [tenantId]\r\n      );\r\n      return result.rows.map((row: any) => this.mapRowToConferenceRoom(row));\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n\r\n  async generateFreeSwitchXml(conferenceRoom: ConferenceRoom): Promise<string> {\r\n    const settings = conferenceRoom.settings || {};\r\n    \r\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<include>\r\n  <extension name=\"conference_${conferenceRoom.extension}\">\r\n    <condition field=\"destination_number\" expression=\"^${conferenceRoom.extension}$\">\r\n      <action application=\"answer\"/>\r\n      <action application=\"sleep\" data=\"1000\"/>\r\n      <action application=\"conference\" data=\"${conferenceRoom.extension}@default+flags{\r\n        ${conferenceRoom.pin ? `pin=${conferenceRoom.pin}` : ''}\r\n        ${conferenceRoom.moderator_pin ? `moderator-pin=${conferenceRoom.moderator_pin}` : ''}\r\n        ${conferenceRoom.record ? `record=${conferenceRoom.record_path || `/recordings/conference_${conferenceRoom.extension}_${new Date().toISOString().split('T')[0]}.wav`}` : ''}\r\n        ${conferenceRoom.moh_sound ? `moh-sound=${conferenceRoom.moh_sound}` : ''}\r\n        ${conferenceRoom.announce_sound ? `announce-sound=${conferenceRoom.announce_sound}` : ''}\r\n        max-members=${conferenceRoom.max_members}\r\n        ${settings.auto_record ? 'auto-record' : ''}\r\n        ${settings.auto_mute ? 'auto-mute' : ''}\r\n        ${settings.wait_for_moderator ? 'wait-for-moderator' : ''}\r\n      }\"/>\r\n    </condition>\r\n  </extension>\r\n</include>`;\r\n  }\r\n\r\n  async getConferenceStatistics(conferenceId: string, tenantId: string): Promise<{\r\n    total_members: number;\r\n    active_members: number;\r\n    moderators: number;\r\n    average_duration: number;\r\n    total_calls: number;\r\n  }> {\r\n    const client = await getClient();\r\n    try {\r\n      const result = await client.query(\r\n        `SELECT \r\n          COUNT(*) as total_members,\r\n          COUNT(CASE WHEN leave_time IS NULL THEN 1 END) as active_members,\r\n          COUNT(CASE WHEN is_moderator = true AND leave_time IS NULL THEN 1 END) as moderators,\r\n          AVG(EXTRACT(EPOCH FROM (COALESCE(leave_time, CURRENT_TIMESTAMP) - join_time))) as average_duration\r\n         FROM conference_members cm\r\n         JOIN conference_rooms cr ON cm.conference_id = cr.id\r\n         WHERE cm.conference_id = $1 AND cr.tenant_id = $2`,\r\n        [conferenceId, tenantId]\r\n      );\r\n\r\n      const stats = result.rows[0];\r\n      return {\r\n        total_members: parseInt(stats.total_members),\r\n        active_members: parseInt(stats.active_members),\r\n        moderators: parseInt(stats.moderators),\r\n        average_duration: parseFloat(stats.average_duration) || 0,\r\n        total_calls: parseInt(stats.total_members), // Same as total members for now\r\n      };\r\n    } finally {\r\n      client.release();\r\n    }\r\n  }\r\n}\r\n","size_bytes":16587},"packages/shared/src/types/tenant.ts":{"content":"import { z } from 'zod';\r\n\r\n// Tenant base schema\r\nexport const TenantSchema = z.object({\r\n  id: z.string().uuid(),\r\n  name: z.string().min(1).max(100),\r\n  domain: z.string().regex(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/),\r\n  sip_domain: z.string().regex(/^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$/),\r\n  status: z.enum(['active', 'suspended', 'pending']),\r\n  created_at: z.date(),\r\n  updated_at: z.date(),\r\n  settings: z.object({\r\n    max_concurrent_calls: z.number().min(1).max(1000).default(20),\r\n    recording_enabled: z.boolean().default(true),\r\n    gdpr_compliant: z.boolean().default(true),\r\n    timezone: z.string().default('Europe/Rome'),\r\n    language: z.string().default('it')\r\n  })\r\n});\r\n\r\nexport type Tenant = z.infer<typeof TenantSchema>;\r\n\r\n// Store schema\r\nexport const StoreSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  name: z.string().min(1).max(100),\r\n  store_id: z.string().min(1).max(50), // W3 Suite store ID\r\n  status: z.enum(['active', 'inactive']),\r\n  created_at: z.date(),\r\n  updated_at: z.date(),\r\n  settings: z.object({\r\n    business_hours: z.object({\r\n      enabled: z.boolean().default(true),\r\n      timezone: z.string().default('Europe/Rome'),\r\n      schedule: z.record(z.object({\r\n        open: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),\r\n        close: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)\r\n      }))\r\n    }),\r\n    outbound_caller_id: z.string().optional(),\r\n    recording_consent_required: z.boolean().default(true)\r\n  })\r\n});\r\n\r\nexport type Store = z.infer<typeof StoreSchema>;\r\n\r\n// Extension/Internal schema\r\nexport const ExtensionSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  extension: z.string().regex(/^[0-9]{3,6}$/),\r\n  password: z.string().min(8).max(32),\r\n  display_name: z.string().min(1).max(100),\r\n  status: z.enum(['active', 'inactive', 'locked']),\r\n  type: z.enum(['user', 'queue', 'conference', 'voicemail']),\r\n  created_at: z.date(),\r\n  updated_at: z.date(),\r\n  settings: z.object({\r\n    voicemail_enabled: z.boolean().default(true),\r\n    call_forwarding: z.object({\r\n      enabled: z.boolean().default(false),\r\n      destination: z.string().optional()\r\n    }),\r\n    dnd_enabled: z.boolean().default(false),\r\n    recording_enabled: z.boolean().default(true)\r\n  })\r\n});\r\n\r\nexport type Extension = z.infer<typeof ExtensionSchema>;\r\n\r\n","size_bytes":2424},"packages/backend/src/routes/system.ts":{"content":"import express from 'express';\n\nconst router = express.Router();\n\n// FreeSWITCH status\n// GET /api/freeswitch/status\nrouter.get('/freeswitch/status', (req, res) => {\n  // Check if FreeSWITCH is running by testing the port\n  const net = require('net');\n  const client = new net.Socket();\n  \n  client.setTimeout(1000);\n  \n  client.connect(8021, '127.0.0.1', () => {\n    client.destroy();\n    return res.json({\n      success: true,\n      data: {\n        connected: true,\n        message: 'FreeSWITCH ESL is running and accessible',\n        timestamp: new Date().toISOString(),\n      },\n      timestamp: new Date().toISOString(),\n    });\n  });\n  \n  client.on('error', () => {\n    return res.json({\n      success: true,\n      data: {\n        connected: false,\n        message: 'FreeSWITCH ESL is not accessible',\n        timestamp: new Date().toISOString(),\n      },\n      timestamp: new Date().toISOString(),\n    });\n  });\n});\n\n// Placeholder: CDR aggregated stats\n// GET /api/cdr-activity/cdr/stats\nrouter.get('/cdr-activity/cdr/stats', (req, res) => {\n  return res.json({\n    success: true,\n    data: {\n      totalCalls: 0,\n      answeredCalls: 0,\n      missedCalls: 0,\n      averageDuration: 0,\n      timestamp: new Date().toISOString(),\n    },\n    timestamp: new Date().toISOString(),\n  });\n});\n\nexport default router;\n","size_bytes":1319},"packages/backend/src/routes/w3-voip-routes.ts":{"content":"import { Router } from 'express';\r\nimport { W3VoipService } from '../services/w3-voip-service';\r\nimport { tenantContextMiddleware } from '../middleware/tenant-context';\r\n\r\nconst router = Router();\r\nconst w3VoipService = new W3VoipService();\r\n\r\n// Apply tenant context middleware to all routes\r\nrouter.use(tenantContextMiddleware);\r\n\r\n// ===== VOIP TRUNKS =====\r\nrouter.post('/trunks', async (req, res) => {\r\n  try {\r\n    const data = req.body;\r\n    const trunk = await w3VoipService.createTrunk(req.tenantContext!, data);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: trunk\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating trunk:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create trunk',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/trunks', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const storeId = req.query.store_id as string;\r\n    const trunks = await w3VoipService.getTrunks(tenantId, storeId);\r\n    res.json({\r\n      success: true,\r\n      data: trunks\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching trunks:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch trunks',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const trunk = await w3VoipService.getTrunkById(trunkId, tenantId);\r\n    \r\n    if (!trunk) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Trunk not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: trunk\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching trunk:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch trunk',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.put('/trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const data = req.body;\r\n    \r\n    const trunk = await w3VoipService.updateTrunk(trunkId, tenantId, data);\r\n    \r\n    if (!trunk) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Trunk not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: trunk\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating trunk:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to update trunk',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.delete('/trunks/:id', async (req, res) => {\r\n  try {\r\n    const trunkId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    \r\n    const deleted = await w3VoipService.deleteTrunk(trunkId, tenantId);\r\n    \r\n    if (!deleted) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Trunk not found'\r\n      });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting trunk:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to delete trunk',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== VOIP DIDS =====\r\nrouter.post('/dids', async (req, res) => {\r\n  try {\r\n    const data = req.body;\r\n    const did = await w3VoipService.createDid(req.tenantContext!, data);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: did\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating DID:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create DID',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/dids', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const storeId = req.query.store_id as string;\r\n    const dids = await w3VoipService.getDids(tenantId, storeId);\r\n    res.json({\r\n      success: true,\r\n      data: dids\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching DIDs:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch DIDs',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/dids/:id', async (req, res) => {\r\n  try {\r\n    const didId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const did = await w3VoipService.getDidById(didId, tenantId);\r\n    \r\n    if (!did) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'DID not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: did\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching DID:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch DID',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.put('/dids/:id', async (req, res) => {\r\n  try {\r\n    const didId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const data = req.body;\r\n    \r\n    const did = await w3VoipService.updateDid(didId, tenantId, data);\r\n    \r\n    if (!did) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'DID not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: did\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating DID:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to update DID',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.delete('/dids/:id', async (req, res) => {\r\n  try {\r\n    const didId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    \r\n    const deleted = await w3VoipService.deleteDid(didId, tenantId);\r\n    \r\n    if (!deleted) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'DID not found'\r\n      });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting DID:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to delete DID',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== VOIP EXTENSIONS =====\r\nrouter.post('/extensions', async (req, res) => {\r\n  try {\r\n    const data = req.body;\r\n    const extension = await w3VoipService.createExtension(req.tenantContext!, data);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: extension\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating extension:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create extension',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/extensions', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const storeId = req.query.store_id as string;\r\n    const extensions = await w3VoipService.getExtensions(tenantId, storeId);\r\n    res.json({\r\n      success: true,\r\n      data: extensions\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching extensions:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch extensions',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const extension = await w3VoipService.getExtensionById(extensionId, tenantId);\r\n    \r\n    if (!extension) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Extension not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: extension\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching extension:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch extension',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.put('/extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const data = req.body;\r\n    \r\n    const extension = await w3VoipService.updateExtension(extensionId, tenantId, data);\r\n    \r\n    if (!extension) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Extension not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: extension\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating extension:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to update extension',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.delete('/extensions/:id', async (req, res) => {\r\n  try {\r\n    const extensionId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    \r\n    const deleted = await w3VoipService.deleteExtension(extensionId, tenantId);\r\n    \r\n    if (!deleted) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Extension not found'\r\n      });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting extension:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to delete extension',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== VOIP ROUTES =====\r\nrouter.post('/routes', async (req, res) => {\r\n  try {\r\n    const data = req.body;\r\n    const route = await w3VoipService.createRoute(req.tenantContext!, data);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating route:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create route',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/routes', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const routes = await w3VoipService.getRoutes(tenantId);\r\n    res.json({\r\n      success: true,\r\n      data: routes\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching routes:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch routes',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const route = await w3VoipService.getRouteById(routeId, tenantId);\r\n    \r\n    if (!route) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Route not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching route:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch route',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.put('/routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const data = req.body;\r\n    \r\n    const route = await w3VoipService.updateRoute(routeId, tenantId, data);\r\n    \r\n    if (!route) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Route not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: route\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating route:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to update route',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.delete('/routes/:id', async (req, res) => {\r\n  try {\r\n    const routeId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    \r\n    const deleted = await w3VoipService.deleteRoute(routeId, tenantId);\r\n    \r\n    if (!deleted) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Route not found'\r\n      });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting route:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to delete route',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\n// ===== CONTACT POLICIES =====\r\nrouter.post('/contact-policies', async (req, res) => {\r\n  try {\r\n    const data = req.body;\r\n    const policy = await w3VoipService.createContactPolicy(req.tenantContext!, data);\r\n    res.status(201).json({\r\n      success: true,\r\n      data: policy\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating contact policy:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to create contact policy',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/contact-policies', async (req, res) => {\r\n  try {\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const policies = await w3VoipService.getContactPolicies(tenantId);\r\n    res.json({\r\n      success: true,\r\n      data: policies\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching contact policies:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch contact policies',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.get('/contact-policies/:id', async (req, res) => {\r\n  try {\r\n    const policyId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const policy = await w3VoipService.getContactPolicyById(policyId, tenantId);\r\n    \r\n    if (!policy) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Contact policy not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: policy\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching contact policy:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to fetch contact policy',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.put('/contact-policies/:id', async (req, res) => {\r\n  try {\r\n    const policyId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    const data = req.body;\r\n    \r\n    const policy = await w3VoipService.updateContactPolicy(policyId, tenantId, data);\r\n    \r\n    if (!policy) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Contact policy not found'\r\n      });\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      data: policy\r\n    });\r\n  } catch (error) {\r\n    console.error('Error updating contact policy:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to update contact policy',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nrouter.delete('/contact-policies/:id', async (req, res) => {\r\n  try {\r\n    const policyId = req.params.id;\r\n    const tenantId = req.tenantContext!.tenant_id;\r\n    \r\n    const deleted = await w3VoipService.deleteContactPolicy(policyId, tenantId);\r\n    \r\n    if (!deleted) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Contact policy not found'\r\n      });\r\n    }\r\n\r\n    res.status(204).send();\r\n  } catch (error) {\r\n    console.error('Error deleting contact policy:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Failed to delete contact policy',\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n  }\r\n});\r\n\r\nexport default router;\r\n","size_bytes":16281},"packages/backend/sync-freeswitch.js":{"content":"const { FreeSWITCHConfigService } = require('./dist/services/freeswitch-config.service');\r\n\r\nasync function syncConfigs() {\r\n  console.log('Starting FreeSWITCH configuration sync...');\r\n  try {\r\n    const service = new FreeSWITCHConfigService();\r\n    await service.syncAllTenantConfigs();\r\n    console.log('✅ Sync completed successfully');\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('❌ Error:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nsyncConfigs();\r\n","size_bytes":475},"packages/frontend/src/lib/utils.ts":{"content":"import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}","size_bytes":165},"packages/frontend/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst cardVariants = cva(\n  \"rounded-xl border transition-all duration-200\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-card text-card-foreground shadow-sm\",\n        glass: \"glass-card\",\n        glassDark: \"backdrop-blur-sm bg-slate-900/60 dark:bg-slate-800/60 border-white/10 shadow-glass hover:shadow-glass-lg hover:-translate-y-0.5\",\n        elevated: \"bg-card text-card-foreground shadow-lg hover:shadow-xl hover:-translate-y-1\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface CardProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof cardVariants> {}\n\nconst Card = React.forwardRef<HTMLDivElement, CardProps>(\n  ({ className, variant, ...props }, ref) => (\n    <div\n      ref={ref}\n      className={cn(cardVariants({ variant }), className)}\n      {...props}\n    />\n  )\n)\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }","size_bytes":2514},"packages/frontend/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 transition-all duration-200 ease-smooth hover:border-ring/50 focus:scale-[1.01]\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }","size_bytes":903},"packages/backend/src/routes/webhooks.ts":{"content":"// @ts-nocheck\r\nimport { Router } from 'express';\r\nimport { z } from 'zod';\r\nimport { CDRService } from '../services/cdr.service';\r\nimport { validateRequest } from '../middleware/validation';\r\nimport { successResponse, errorResponse } from '../utils/response';\r\n// Removed unused import: logWebhookEvent\r\nimport crypto from 'crypto';\r\n\r\nconst router = Router();\r\nconst cdrService = new CDRService();\r\n\r\n// Webhook signature validation\r\nconst validateWebhookSignature = (req: any, res: any, next: any) => {\r\n  const signature = req.headers['x-webhook-signature'];\r\n  const webhookSecret = process.env.WEBHOOK_SECRET || 'default-secret';\r\n  \r\n  if (!signature) {\r\n    return errorResponse(res, 'Missing webhook signature', 401);\r\n  }\r\n\r\n  const payload = JSON.stringify(req.body);\r\n  const expectedSignature = crypto\r\n    .createHmac('sha256', webhookSecret)\r\n    .update(payload)\r\n    .digest('hex');\r\n\r\n  const providedSignature = signature.replace('sha256=', '');\r\n\r\n  if (!crypto.timingSafeEqual(\r\n    Buffer.from(expectedSignature, 'hex'),\r\n    Buffer.from(providedSignature, 'hex')\r\n  )) {\r\n    return errorResponse(res, 'Invalid webhook signature', 401);\r\n  }\r\n\r\n  next();\r\n};\r\n\r\n// CDR webhook validation schema\r\nconst cdrWebhookSchema = z.object({\r\n  event_name: z.string(),\r\n  call_uuid: z.string().uuid(),\r\n  tenant_domain: z.string(),\r\n  store_id: z.string().optional(),\r\n  extension_id: z.string().uuid().optional(),\r\n  trunk_id: z.string().uuid().optional(),\r\n  call_direction: z.enum(['inbound', 'outbound', 'internal']),\r\n  call_type: z.enum(['voice', 'video', 'fax']).default('voice'),\r\n  caller_id_number: z.string().optional(),\r\n  caller_id_name: z.string().optional(),\r\n  caller_extension: z.string().optional(),\r\n  callee_id_number: z.string().optional(),\r\n  callee_id_name: z.string().optional(),\r\n  callee_extension: z.string().optional(),\r\n  start_time: z.string().datetime(),\r\n  answer_time: z.string().datetime().optional(),\r\n  end_time: z.string().datetime().optional(),\r\n  duration: z.number().min(0).default(0),\r\n  bill_seconds: z.number().min(0).default(0),\r\n  hangup_cause: z.string().optional(),\r\n  hangup_disposition: z.enum(['answered', 'no_answer', 'busy', 'failed', 'unknown']).default('unknown'),\r\n  audio_codec: z.string().optional(),\r\n  video_codec: z.string().optional(),\r\n  rtp_audio_in_mos: z.number().min(1).max(5).optional(),\r\n  rtp_audio_out_mos: z.number().min(1).max(5).optional(),\r\n  recording_enabled: z.boolean().default(false),\r\n  recording_path: z.string().optional(),\r\n  recording_duration: z.number().min(0).optional(),\r\n  recording_consent: z.boolean().optional(),\r\n  local_ip: z.string().optional(),\r\n  remote_ip: z.string().optional(),\r\n  local_port: z.number().optional(),\r\n  remote_port: z.number().optional(),\r\n  fs_uuid: z.string(),\r\n  fs_domain: z.string(),\r\n  fs_context: z.string().optional(),\r\n  fs_profile: z.string().optional(),\r\n  metadata: z.record(z.any()).optional(),\r\n  tags: z.array(z.string()).optional()\r\n});\r\n\r\n// Call event webhook validation schema\r\nconst callEventWebhookSchema = z.object({\r\n  event_name: z.string(),\r\n  call_uuid: z.string().uuid(),\r\n  tenant_domain: z.string(),\r\n  event_type: z.enum(['call_started', 'call_answered', 'call_ended', 'call_transferred', 'recording_started', 'recording_stopped']),\r\n  timestamp: z.string().datetime(),\r\n  data: z.record(z.any()).optional()\r\n});\r\n\r\n// CDR webhook endpoint\r\nrouter.post('/cdr',\r\n  validateWebhookSignature,\r\n  validateRequest(cdrWebhookSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const cdrData = req.body;\r\n\r\n      logWebhookEvent('cdr_received', {\r\n        call_uuid: cdrData.call_uuid,\r\n        tenant_domain: cdrData.tenant_domain,\r\n        event_name: cdrData.event_name\r\n      });\r\n\r\n      // Find tenant by domain\r\n      const { getClient } = await import('@w3-voip/database');\r\n      const client = await getClient();\r\n      \r\n      try {\r\n        const tenantResult = await client.query(\r\n          'SELECT id FROM tenants WHERE domain = $1',\r\n          [cdrData.tenant_domain]\r\n        );\r\n\r\n        if (tenantResult.rows.length === 0) {\r\n          logWebhookEvent('cdr_error', {\r\n            call_uuid: cdrData.call_uuid,\r\n            error: 'Tenant not found',\r\n            tenant_domain: cdrData.tenant_domain\r\n          });\r\n          return errorResponse(res, 'Tenant not found', 404);\r\n        }\r\n\r\n        const tenantId = tenantResult.rows[0].id;\r\n\r\n        // Check if CDR already exists\r\n        const existingCDR = await cdrService.getCDRByCallUuid(cdrData.call_uuid, tenantId);\r\n\r\n        if (existingCDR) {\r\n          // Update existing CDR\r\n          const updates: any = {};\r\n          \r\n          if (cdrData.answer_time) updates.answer_time = new Date(cdrData.answer_time);\r\n          if (cdrData.end_time) updates.end_time = new Date(cdrData.end_time);\r\n          if (cdrData.duration !== undefined) updates.duration = cdrData.duration;\r\n          if (cdrData.bill_seconds !== undefined) updates.bill_seconds = cdrData.bill_seconds;\r\n          if (cdrData.hangup_cause) updates.hangup_cause = cdrData.hangup_cause;\r\n          if (cdrData.hangup_disposition) updates.hangup_disposition = cdrData.hangup_disposition;\r\n          if (cdrData.audio_codec) updates.audio_codec = cdrData.audio_codec;\r\n          if (cdrData.video_codec) updates.video_codec = cdrData.video_codec;\r\n          if (cdrData.rtp_audio_in_mos) updates.rtp_audio_in_mos = cdrData.rtp_audio_in_mos;\r\n          if (cdrData.rtp_audio_out_mos) updates.rtp_audio_out_mos = cdrData.rtp_audio_out_mos;\r\n          if (cdrData.recording_enabled !== undefined) updates.recording_enabled = cdrData.recording_enabled;\r\n          if (cdrData.recording_path) updates.recording_path = cdrData.recording_path;\r\n          if (cdrData.recording_duration) updates.recording_duration = cdrData.recording_duration;\r\n          if (cdrData.recording_consent !== undefined) updates.recording_consent = cdrData.recording_consent;\r\n          if (cdrData.metadata) updates.metadata = cdrData.metadata;\r\n          if (cdrData.tags) updates.tags = cdrData.tags;\r\n\r\n          await cdrService.updateCDR(existingCDR.id, updates, tenantId);\r\n\r\n          logWebhookEvent('cdr_updated', {\r\n            call_uuid: cdrData.call_uuid,\r\n            tenant_id: tenantId,\r\n            cdr_id: existingCDR.id\r\n          });\r\n\r\n        } else {\r\n          // Create new CDR\r\n          const newCDRData = {\r\n            tenant_id: tenantId,\r\n            store_id: cdrData.store_id || undefined,\r\n            extension_id: cdrData.extension_id || undefined,\r\n            trunk_id: cdrData.trunk_id || undefined,\r\n            call_uuid: cdrData.call_uuid,\r\n            call_direction: cdrData.call_direction,\r\n            call_type: cdrData.call_type,\r\n            caller_id_number: cdrData.caller_id_number || undefined,\r\n            caller_id_name: cdrData.caller_id_name || undefined,\r\n            caller_extension: cdrData.caller_extension || undefined,\r\n            callee_id_number: cdrData.callee_id_number || undefined,\r\n            callee_id_name: cdrData.callee_id_name || undefined,\r\n            callee_extension: cdrData.callee_extension || undefined,\r\n            start_time: new Date(cdrData.start_time),\r\n            answer_time: cdrData.answer_time ? new Date(cdrData.answer_time) : undefined,\r\n            end_time: cdrData.end_time ? new Date(cdrData.end_time) : undefined,\r\n            duration: cdrData.duration,\r\n            bill_seconds: cdrData.bill_seconds,\r\n            hangup_cause: cdrData.hangup_cause || undefined,\r\n            hangup_disposition: cdrData.hangup_disposition,\r\n            audio_codec: cdrData.audio_codec || undefined,\r\n            video_codec: cdrData.video_codec || undefined,\r\n            rtp_audio_in_mos: cdrData.rtp_audio_in_mos || undefined,\r\n            rtp_audio_out_mos: cdrData.rtp_audio_out_mos || undefined,\r\n            recording_enabled: cdrData.recording_enabled,\r\n            recording_path: cdrData.recording_path || undefined,\r\n            recording_duration: cdrData.recording_duration || undefined,\r\n            recording_consent: cdrData.recording_consent || undefined,\r\n            local_ip: cdrData.local_ip || undefined,\r\n            remote_ip: cdrData.remote_ip || undefined,\r\n            local_port: cdrData.local_port || undefined,\r\n            remote_port: cdrData.remote_port || undefined,\r\n            fs_uuid: cdrData.fs_uuid,\r\n            fs_domain: cdrData.fs_domain,\r\n            fs_context: cdrData.fs_context || undefined,\r\n            fs_profile: cdrData.fs_profile || undefined,\r\n            metadata: cdrData.metadata || undefined,\r\n            tags: cdrData.tags || []\r\n          };\r\n\r\n          const cdr = await cdrService.createCDR(newCDRData);\r\n\r\n          logWebhookEvent('cdr_created', {\r\n            call_uuid: cdrData.call_uuid,\r\n            tenant_id: tenantId,\r\n            cdr_id: cdr.id\r\n          });\r\n        }\r\n\r\n        successResponse(res, {\r\n          status: 'processed',\r\n          call_uuid: cdrData.call_uuid,\r\n          tenant_domain: cdrData.tenant_domain\r\n        });\r\n\r\n      } finally {\r\n        await client.release();\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('Error processing CDR webhook:', error);\r\n      logWebhookEvent('cdr_error', {\r\n        call_uuid: req.body.call_uuid,\r\n        error: error.message\r\n      });\r\n      errorResponse(res, 'Failed to process CDR webhook', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Call event webhook endpoint\r\nrouter.post('/call-event',\r\n  validateWebhookSignature,\r\n  validateRequest(callEventWebhookSchema),\r\n  async (req, res) => {\r\n    try {\r\n      const eventData = req.body;\r\n\r\n      logWebhookEvent('call_event_received', {\r\n        call_uuid: eventData.call_uuid,\r\n        tenant_domain: eventData.tenant_domain,\r\n        event_type: eventData.event_type\r\n      });\r\n\r\n      // Find tenant by domain\r\n      const { getClient } = await import('@w3-voip/database');\r\n      const client = await getClient();\r\n      \r\n      try {\r\n        const tenantResult = await client.query(\r\n          'SELECT id FROM tenants WHERE domain = $1',\r\n          [eventData.tenant_domain]\r\n        );\r\n\r\n        if (tenantResult.rows.length === 0) {\r\n          logWebhookEvent('call_event_error', {\r\n            call_uuid: eventData.call_uuid,\r\n            error: 'Tenant not found',\r\n            tenant_domain: eventData.tenant_domain\r\n          });\r\n          return errorResponse(res, 'Tenant not found', 404);\r\n        }\r\n\r\n        const tenantId = tenantResult.rows[0].id;\r\n\r\n        // Store call event in database (optional - for audit trail)\r\n        await client.query(\r\n          `INSERT INTO call_events (\r\n            id, tenant_id, call_uuid, event_type, event_name, \r\n            timestamp, data, created_at\r\n          ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`,\r\n          [\r\n            require('uuid').v4(),\r\n            tenantId,\r\n            eventData.call_uuid,\r\n            eventData.event_type,\r\n            eventData.event_name,\r\n            new Date(eventData.timestamp),\r\n            eventData.data ? JSON.stringify(eventData.data) : null\r\n          ]\r\n        );\r\n\r\n        // Forward event to W3 Suite if configured\r\n        const w3SuiteWebhookUrl = process.env.W3_SUITE_WEBHOOK_URL;\r\n        if (w3SuiteWebhookUrl) {\r\n          try {\r\n            const fetch = require('node-fetch');\r\n            await fetch(w3SuiteWebhookUrl, {\r\n              method: 'POST',\r\n              headers: {\r\n                'Content-Type': 'application/json',\r\n                'X-Webhook-Source': 'w3-voip',\r\n                'X-Webhook-Signature': crypto\r\n                  .createHmac('sha256', process.env.W3_SUITE_WEBHOOK_SECRET || 'default-secret')\r\n                  .update(JSON.stringify(eventData))\r\n                  .digest('hex')\r\n              },\r\n              body: JSON.stringify({\r\n                ...eventData,\r\n                tenant_id: tenantId\r\n              })\r\n            });\r\n\r\n            logWebhookEvent('call_event_forwarded', {\r\n              call_uuid: eventData.call_uuid,\r\n              tenant_id: tenantId,\r\n              w3_suite_url: w3SuiteWebhookUrl\r\n            });\r\n\r\n          } catch (forwardError) {\r\n            logWebhookEvent('call_event_forward_error', {\r\n              call_uuid: eventData.call_uuid,\r\n              tenant_id: tenantId,\r\n              error: forwardError.message\r\n            });\r\n          }\r\n        }\r\n\r\n        successResponse(res, {\r\n          status: 'processed',\r\n          call_uuid: eventData.call_uuid,\r\n          event_type: eventData.event_type,\r\n          tenant_domain: eventData.tenant_domain\r\n        });\r\n\r\n      } finally {\r\n        await client.release();\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('Error processing call event webhook:', error);\r\n      logWebhookEvent('call_event_error', {\r\n        call_uuid: req.body.call_uuid,\r\n        error: error.message\r\n      });\r\n      errorResponse(res, 'Failed to process call event webhook', 500);\r\n    }\r\n  }\r\n);\r\n\r\n// Health check endpoint for webhooks\r\nrouter.get('/health', (req, res) => {\r\n  successResponse(res, {\r\n    status: 'healthy',\r\n    timestamp: new Date().toISOString(),\r\n    service: 'w3-voip-webhooks'\r\n  });\r\n});\r\n\r\n// Webhook configuration endpoint\r\nrouter.get('/config', (req, res) => {\r\n  const config = {\r\n    cdr_webhook_url: `${process.env.API_BASE_URL || 'http://192.168.172.234:3000'}/api/webhooks/cdr`,\r\n    call_event_webhook_url: `${process.env.API_BASE_URL || 'http://192.168.172.234:3000'}/api/webhooks/call-event`,\r\n    supported_events: [\r\n      'CHANNEL_CREATE',\r\n      'CHANNEL_ANSWER',\r\n      'CHANNEL_HANGUP',\r\n      'CHANNEL_BRIDGE',\r\n      'RECORD_START',\r\n      'RECORD_STOP'\r\n    ],\r\n    authentication: {\r\n      type: 'hmac_sha256',\r\n      header: 'X-Webhook-Signature'\r\n    }\r\n  };\r\n\r\n  successResponse(res, config);\r\n});\r\n\r\nexport default router;\r\n\r\n","size_bytes":13891},"packages/backend/src/services/tenant.service.ts":{"content":"// @ts-nocheck\nimport { getClient, withTransaction } from '@w3-voip/database';\nimport { CreateTenantRequest, Company, TenantContact, CrossTenantStats, TenantStats } from '@w3-voip/shared';\nimport { v4 as uuidv4 } from 'uuid';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\n\n// Define Tenant type locally\nexport interface Tenant {\n  id: string;\n  name: string;\n  domain: string;\n  sip_domain: string | null;  // NULL for super admin tenants\n  status: 'active' | 'suspended' | 'pending';\n  settings: {\n    max_extensions: number;\n    max_concurrent_calls: number;\n    recording_enabled: boolean;\n    voicemail_enabled: boolean;\n  };\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport class TenantService {\n  // Create a new tenant\n  async createTenant(tenantData: Omit<Tenant, 'id' | 'created_at' | 'updated_at'>): Promise<Tenant> {\n    return withTransaction(async (client) => {\n      // Check if domain already exists\n      const existingTenant = await client.query(\n        'SELECT id FROM tenants WHERE domain = $1 OR sip_domain = $2',\n        [tenantData.domain, tenantData.sip_domain]\n      );\n\n      if (existingTenant.rows.length > 0) {\n        throw new Error('Domain or SIP domain already exists');\n      }\n\n      // Create tenant\n      const result = await client.query(\n        `INSERT INTO tenants (id, name, domain, sip_domain, status, settings)\n         VALUES ($1, $2, $3, $4, $5, $6)\n         RETURNING *`,\n        [\n          uuidv4(),\n          tenantData.name,\n          tenantData.domain,\n          tenantData.sip_domain,\n          tenantData.status || 'pending',\n          JSON.stringify(tenantData.settings)\n        ]\n      );\n\n      const tenant = result.rows[0];\n      return {\n        ...tenant,\n        settings: JSON.parse(tenant.settings)\n      };\n    });\n  }\n\n  // Get tenant by ID\n  async getTenantById(tenantId: string): Promise<Tenant | null> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT * FROM tenants WHERE id = $1',\n        [tenantId]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const tenant = result.rows[0];\n      return {\n        ...tenant,\n        settings: JSON.parse(tenant.settings)\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get tenant by domain\n  async getTenantByDomain(domain: string): Promise<Tenant | null> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        'SELECT * FROM tenants WHERE domain = $1 OR sip_domain = $1',\n        [domain]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const tenant = result.rows[0];\n      return {\n        ...tenant,\n        settings: JSON.parse(tenant.settings)\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Update tenant\n  async updateTenant(tenantId: string, updates: Partial<Omit<Tenant, 'id' | 'created_at' | 'updated_at'>>): Promise<Tenant> {\n    return withTransaction(async (client) => {\n      // Check if domain conflicts with other tenants\n      if (updates.domain || updates.sip_domain) {\n        const existingTenant = await client.query(\n          'SELECT id FROM tenants WHERE (domain = $1 OR sip_domain = $2) AND id != $3',\n          [updates.domain, updates.sip_domain, tenantId]\n        );\n\n        if (existingTenant.rows.length > 0) {\n          throw new Error('Domain or SIP domain already exists');\n        }\n      }\n\n      // Build update query\n      const updateFields: string[] = [];\n      const values: any[] = [];\n      let paramCount = 1;\n\n      if (updates.name !== undefined) {\n        updateFields.push(`name = $${paramCount++}`);\n        values.push(updates.name);\n      }\n      if (updates.domain !== undefined) {\n        updateFields.push(`domain = $${paramCount++}`);\n        values.push(updates.domain);\n      }\n      if (updates.sip_domain !== undefined) {\n        updateFields.push(`sip_domain = $${paramCount++}`);\n        values.push(updates.sip_domain);\n      }\n      if (updates.status !== undefined) {\n        updateFields.push(`status = $${paramCount++}`);\n        values.push(updates.status);\n      }\n      if (updates.settings !== undefined) {\n        updateFields.push(`settings = $${paramCount++}`);\n        values.push(JSON.stringify(updates.settings));\n      }\n\n      if (updateFields.length === 0) {\n        throw new Error('No fields to update');\n      }\n\n      values.push(tenantId);\n\n      const result = await client.query(\n        `UPDATE tenants SET ${updateFields.join(', ')}, updated_at = NOW()\n         WHERE id = $${paramCount}\n         RETURNING *`,\n        values\n      );\n\n      if (result.rows.length === 0) {\n        throw new Error('Tenant not found');\n      }\n\n      const tenant = result.rows[0];\n      return {\n        ...tenant,\n        settings: JSON.parse(tenant.settings)\n      };\n    });\n  }\n\n  // Delete tenant (soft delete by setting status to suspended)\n  async deleteTenant(tenantId: string): Promise<void> {\n    return withTransaction(async (client) => {\n      const result = await client.query(\n        'UPDATE tenants SET status = $1, updated_at = NOW() WHERE id = $2',\n        ['suspended', tenantId]\n      );\n\n      if (result.rowCount === 0) {\n        throw new Error('Tenant not found');\n      }\n    });\n  }\n\n  // List tenants with pagination\n  async listTenants(page: number = 1, limit: number = 50, search?: string): Promise<{\n    tenants: Tenant[];\n    total: number;\n    totalPages: number;\n  }> {\n    const client = await getClient();\n    \n    try {\n      const offset = (page - 1) * limit;\n      \n      let whereClause = '';\n      let queryParams: any[] = [];\n      \n      if (search) {\n        whereClause = 'WHERE name ILIKE $1 OR domain ILIKE $1 OR sip_domain ILIKE $1';\n        queryParams.push(`%${search}%`);\n      }\n\n      // Get total count\n      const countResult = await client.query(\n        `SELECT COUNT(*) FROM tenants ${whereClause}`,\n        queryParams\n      );\n      const total = parseInt(countResult.rows[0].count);\n\n      // Get tenants\n      const result = await client.query(\n        `SELECT * FROM tenants ${whereClause}\n         ORDER BY created_at DESC\n         LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`,\n        [...queryParams, limit, offset]\n      );\n\n      const tenants = result.rows.map(row => ({\n        ...row,\n        settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings\n      }));\n\n      return {\n        tenants,\n        total,\n        totalPages: Math.ceil(total / limit)\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get tenant statistics\n  async getTenantStats(tenantId: string): Promise<{\n    store_count: number;\n    extension_count: number;\n    trunk_count: number;\n    total_calls: number;\n    active_calls: number;\n    last_call_time: Date | null;\n  }> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(\n        `SELECT \n           COUNT(DISTINCT s.id) as store_count,\n           COUNT(DISTINCT e.id) as extension_count,\n           COUNT(DISTINCT st.id) as trunk_count,\n           COUNT(DISTINCT c.id) as total_calls,\n           COUNT(DISTINCT ac.id) as active_calls,\n           MAX(c.start_time) as last_call_time\n         FROM tenants t\n         LEFT JOIN stores s ON t.id = s.tenant_id\n         LEFT JOIN extensions e ON t.id = e.tenant_id\n         LEFT JOIN sip_trunks st ON t.id = st.tenant_id\n         LEFT JOIN cdr c ON t.id = c.tenant_id\n         LEFT JOIN active_calls ac ON t.id = ac.tenant_id\n         WHERE t.id = $1\n         GROUP BY t.id`,\n        [tenantId]\n      );\n\n      if (result.rows.length === 0) {\n        throw new Error('Tenant not found');\n      }\n\n      return result.rows[0];\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Activate tenant\n  async activateTenant(tenantId: string): Promise<Tenant> {\n    return this.updateTenant(tenantId, { status: 'active' });\n  }\n\n  // Suspend tenant\n  async suspendTenant(tenantId: string): Promise<Tenant> {\n    return this.updateTenant(tenantId, { status: 'suspended' });\n  }\n\n  // Validate tenant domain uniqueness\n  async validateDomainUniqueness(domain: string, sipDomain: string | null, excludeTenantId?: string): Promise<boolean> {\n    const client = await getClient();\n    \n    try {\n      let query: string;\n      let params: any[];\n      \n      if (sipDomain === null) {\n        // For super admin tenants (no SIP domain), only check domain uniqueness\n        query = 'SELECT id FROM tenants WHERE domain = $1';\n        params = [domain];\n      } else {\n        // For regular tenants, check both domain and sip_domain uniqueness\n        query = 'SELECT id FROM tenants WHERE domain = $1 OR sip_domain = $2';\n        params = [domain, sipDomain];\n      }\n      \n      if (excludeTenantId) {\n        query += ` AND id != $${params.length + 1}`;\n        params.push(excludeTenantId);\n      }\n\n      const result = await client.query(query, params);\n      return result.rows.length === 0;\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Create tenant with companies, contacts and admin user\n  async createTenantWithCompanies(data: CreateTenantRequest): Promise<Tenant> {\n    return withTransaction(async (client) => {\n      // Validate domain uniqueness\n      const isUnique = await this.validateDomainUniqueness(data.domain, data.sip_domain);\n      if (!isUnique) {\n        throw new Error('Domain or SIP domain already exists');\n      }\n\n      // Validate admin user email uniqueness\n      const existingUser = await client.query(\n        'SELECT id FROM users WHERE email = $1',\n        [data.admin_user.email]\n      );\n      if (existingUser.rows.length > 0) {\n        throw new Error('Admin user email already exists');\n      }\n\n      // Validate at least one primary company and contact\n      const hasPrimaryCompany = data.companies.some(c => c.is_primary);\n      const hasPrimaryContact = data.contacts.some(c => c.is_primary);\n      \n      if (!hasPrimaryCompany) {\n        throw new Error('At least one company must be marked as primary');\n      }\n      if (!hasPrimaryContact) {\n        throw new Error('At least one contact must be marked as primary');\n      }\n\n      const tenantId = uuidv4();\n\n      // Create tenant\n      const tenantResult = await client.query(\n        `INSERT INTO tenants (id, name, slug, domain, sip_domain, status, created_at, updated_at)\n         VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())\n         RETURNING *`,\n        [tenantId, data.name, data.slug, data.domain, data.sip_domain, 'active']\n      );\n\n      // Create admin user\n      const hashedPassword = await bcrypt.hash(data.admin_user.password, 10);\n      const adminUserId = uuidv4();\n      await client.query(\n        `INSERT INTO users (id, tenant_id, first_name, last_name, email, password_hash, role, status, created_at, updated_at)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())`,\n        [\n          adminUserId, tenantId, data.admin_user.first_name, data.admin_user.last_name,\n          data.admin_user.email, hashedPassword, data.admin_user.role, 'active'\n        ]\n      );\n\n      // Create companies\n      for (const companyData of data.companies) {\n        await client.query(\n          `INSERT INTO companies (id, tenant_id, legal_name, vat_number, tax_code, address, city, state, postal_code, country, is_primary, created_at, updated_at)\n           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())`,\n          [\n            uuidv4(), tenantId, companyData.legal_name, companyData.vat_number, companyData.tax_code,\n            companyData.address, companyData.city, companyData.state, companyData.postal_code,\n            companyData.country || 'Italy', companyData.is_primary\n          ]\n        );\n      }\n\n      // Create contacts\n      for (const contactData of data.contacts) {\n        await client.query(\n          `INSERT INTO tenant_contacts (id, tenant_id, first_name, last_name, role, email, phone, mobile, is_primary, created_at, updated_at)\n           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())`,\n          [\n            uuidv4(), tenantId, contactData.first_name, contactData.last_name, contactData.role,\n            contactData.email, contactData.phone, contactData.mobile, contactData.is_primary\n          ]\n        );\n      }\n\n      return tenantResult.rows[0];\n    });\n  }\n\n  // Get cross-tenant statistics\n  async getCrossTenantStats(): Promise<CrossTenantStats> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(`\n        SELECT \n          COUNT(DISTINCT t.id) as total_tenants,\n          COUNT(DISTINCT u.id) as total_users,\n          COUNT(DISTINCT e.id) as total_extensions,\n          COUNT(DISTINCT CASE WHEN c.start_time > NOW() - INTERVAL '24 hours' THEN c.id END) as total_calls_24h,\n          COUNT(DISTINCT CASE WHEN t.status = 'active' THEN t.id END) as active_tenants,\n          COUNT(DISTINCT CASE WHEN t.status = 'suspended' THEN t.id END) as inactive_tenants\n        FROM tenants t\n        LEFT JOIN users u ON t.id = u.tenant_id\n        LEFT JOIN extensions e ON t.id = e.tenant_id\n        LEFT JOIN cdr c ON t.id = c.tenant_id\n      `);\n\n      return result.rows[0];\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get tenant statistics for cross-tenant view\n  async getTenantStatsList(): Promise<TenantStats[]> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(`\n        SELECT \n          t.id as tenant_id,\n          t.name as tenant_name,\n          t.slug as tenant_slug,\n          t.status,\n          COUNT(DISTINCT u.id) as users_count,\n          COUNT(DISTINCT e.id) as extensions_count,\n          COUNT(DISTINCT CASE WHEN c.start_time > NOW() - INTERVAL '24 hours' THEN c.id END) as calls_24h,\n          COUNT(DISTINCT comp.id) as companies_count,\n          COUNT(DISTINCT cont.id) as contacts_count\n        FROM tenants t\n        LEFT JOIN users u ON t.id = u.tenant_id\n        LEFT JOIN extensions e ON t.id = e.tenant_id\n        LEFT JOIN cdr c ON t.id = c.tenant_id\n        LEFT JOIN companies comp ON t.id = comp.tenant_id\n        LEFT JOIN tenant_contacts cont ON t.id = cont.tenant_id\n        GROUP BY t.id, t.name, t.slug, t.status\n        ORDER BY t.created_at DESC\n      `);\n\n      return result.rows;\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Impersonate user (generate JWT for target user)\n  async impersonateUser(superAdminId: string, targetUserId: string): Promise<string> {\n    const client = await getClient();\n    \n    try {\n      // Verify super admin\n      const superAdminResult = await client.query(\n        'SELECT role FROM users WHERE id = $1',\n        [superAdminId]\n      );\n      \n      if (superAdminResult.rows.length === 0 || superAdminResult.rows[0].role !== 'super_admin') {\n        throw new Error('Super admin access required');\n      }\n\n      // Get target user with tenant info\n      const targetUserResult = await client.query(`\n        SELECT u.*, t.slug as tenant_slug\n        FROM users u\n        JOIN tenants t ON u.tenant_id = t.id\n        WHERE u.id = $1\n      `, [targetUserId]);\n\n      if (targetUserResult.rows.length === 0) {\n        throw new Error('Target user not found');\n      }\n\n      const targetUser = targetUserResult.rows[0];\n\n      // Generate impersonation token\n      const token = jwt.sign(\n        {\n          id: targetUser.id,\n          email: targetUser.email,\n          tenant_id: targetUser.tenant_id,\n          tenant_slug: targetUser.tenant_slug,\n          role: targetUser.role,\n          impersonated_by: superAdminId,\n          iat: Math.floor(Date.now() / 1000),\n          exp: Math.floor(Date.now() / 1000) + (2 * 60 * 60) // 2 hours for impersonation\n        },\n        process.env.JWT_SECRET || 'fallback-secret'\n      );\n\n      return token;\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get tenant with companies and contacts\n  async getTenantWithDetails(tenantId: string): Promise<{\n    tenant: Tenant;\n    companies: Company[];\n    contacts: TenantContact[];\n  }> {\n    const client = await getClient();\n    \n    try {\n      // Get tenant\n      const tenantResult = await client.query(\n        'SELECT * FROM tenants WHERE id = $1',\n        [tenantId]\n      );\n\n      if (tenantResult.rows.length === 0) {\n        throw new Error('Tenant not found');\n      }\n\n      // Get companies\n      const companiesResult = await client.query(\n        'SELECT * FROM companies WHERE tenant_id = $1 ORDER BY is_primary DESC, created_at ASC',\n        [tenantId]\n      );\n\n      // Get contacts\n      const contactsResult = await client.query(\n        'SELECT * FROM tenant_contacts WHERE tenant_id = $1 ORDER BY is_primary DESC, created_at ASC',\n        [tenantId]\n      );\n\n      return {\n        tenant: tenantResult.rows[0],\n        companies: companiesResult.rows,\n        contacts: contactsResult.rows\n      };\n    } finally {\n      await client.release();\n    }\n  }\n}\n\n","size_bytes":17093},"packages/frontend/src/pages/SuperAdminAnalytics.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { \n  BarChart3, \n  ArrowLeft,\n  Download,\n  Filter,\n  TrendingUp,\n  Phone,\n  Users,\n  Building2,\n  Activity,\n  AlertCircle\n} from 'lucide-react';\nimport apiClient from '@/lib/api';\n\ninterface CrossTenantSummary {\n  total_tenants: number;\n  total_users: number;\n  total_extensions: number;\n  total_calls: number;\n  active_calls: number;\n  total_companies: number;\n  total_contacts: number;\n  avg_call_duration: number;\n  total_call_duration: number;\n}\n\ninterface TenantCall {\n  id: string;\n  tenant_name: string;\n  tenant_slug: string;\n  caller_number: string;\n  callee_number: string;\n  start_time: string;\n  duration: number;\n  disposition: string;\n  user_email?: string;\n}\n\ninterface TenantExtension {\n  tenant_id: string;\n  tenant_name: string;\n  tenant_slug: string;\n  tenant_status: string;\n  extensions_count: number;\n  active_extensions: number;\n  inactive_extensions: number;\n}\n\ninterface TenantUser {\n  tenant_id: string;\n  tenant_name: string;\n  tenant_slug: string;\n  tenant_status: string;\n  users_count: number;\n  active_users: number;\n  admin_users: number;\n  regular_users: number;\n  last_login?: string;\n}\n\nexport default function SuperAdminAnalytics() {\n  const [summary, setSummary] = useState<CrossTenantSummary | null>(null);\n  const [calls, setCalls] = useState<TenantCall[]>([]);\n  const [extensions, setExtensions] = useState<TenantExtension[]>([]);\n  const [users, setUsers] = useState<TenantUser[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [dateRange, setDateRange] = useState({\n    start_date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n    end_date: new Date().toISOString().split('T')[0]\n  });\n  const [selectedTenant, setSelectedTenant] = useState<string>('all');\n  const [period, setPeriod] = useState<'1h' | '24h' | '7d' | '30d'>('24h');\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    loadAnalyticsData();\n  }, [dateRange, selectedTenant, period]);\n\n  const loadAnalyticsData = async () => {\n    try {\n      setLoading(true);\n      \n      const [summaryResponse, callsResponse, extensionsResponse, usersResponse] = await Promise.all([\n        apiClient.getCrossTenantSummary({ period }),\n        apiClient.getCrossTenantCalls({\n          start_date: dateRange.start_date,\n          end_date: dateRange.end_date,\n          tenant_id: selectedTenant === 'all' ? undefined : selectedTenant,\n          limit: 100\n        }),\n        apiClient.getCrossTenantExtensions(),\n        apiClient.getCrossTenantUsers()\n      ]);\n\n      if (summaryResponse.success) {\n        setSummary(summaryResponse.data);\n      }\n\n      if (callsResponse.success) {\n        setCalls(callsResponse.data || []);\n      }\n\n      if (extensionsResponse.success) {\n        setExtensions(extensionsResponse.data || []);\n      }\n\n      if (usersResponse.success) {\n        setUsers(usersResponse.data || []);\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to load analytics data');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m ${secs}s`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${secs}s`;\n    } else {\n      return `${secs}s`;\n    }\n  };\n\n  const getDispositionBadge = (disposition: string) => {\n    switch (disposition) {\n      case 'ANSWERED':\n        return <Badge variant=\"default\" className=\"bg-green-100 text-green-800\">Answered</Badge>;\n      case 'NO ANSWER':\n        return <Badge variant=\"secondary\">No Answer</Badge>;\n      case 'BUSY':\n        return <Badge variant=\"destructive\">Busy</Badge>;\n      case 'FAILED':\n        return <Badge variant=\"destructive\">Failed</Badge>;\n      default:\n        return <Badge variant=\"outline\">{disposition}</Badge>;\n    }\n  };\n\n  const exportData = (format: 'csv' | 'json') => {\n    // TODO: Implement export functionality\n    console.log(`Exporting data as ${format}`);\n  };\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"></div>\n          <p className=\"text-gray-600\">Loading analytics...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"flex justify-between items-center mb-6\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-gray-900\">Cross-Tenant Analytics</h1>\n            <p className=\"text-gray-600\">System-wide statistics and insights</p>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <Button variant=\"outline\" size=\"sm\" onClick={() => exportData('csv')}>\n              <Download className=\"h-4 w-4 mr-2\" />\n              Export CSV\n            </Button>\n            <Button variant=\"outline\" size=\"sm\" onClick={() => exportData('json')}>\n              <Download className=\"h-4 w-4 mr-2\" />\n              Export JSON\n            </Button>\n          </div>\n        </div>\n\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-6\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {/* Filters */}\n        <Card className=\"mb-6\">\n          <CardHeader>\n            <CardTitle className=\"flex items-center\">\n              <Filter className=\"h-5 w-5 mr-2\" />\n              Filters\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n              <div>\n                <Label htmlFor=\"period\">Time Period</Label>\n                <select\n                  id=\"period\"\n                  value={period}\n                  onChange={(e) => setPeriod(e.target.value as any)}\n                  className=\"w-full mt-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                >\n                  <option value=\"1h\">Last Hour</option>\n                  <option value=\"24h\">Last 24 Hours</option>\n                  <option value=\"7d\">Last 7 Days</option>\n                  <option value=\"30d\">Last 30 Days</option>\n                </select>\n              </div>\n              <div>\n                <Label htmlFor=\"start_date\">Start Date</Label>\n                <Input\n                  id=\"start_date\"\n                  type=\"date\"\n                  value={dateRange.start_date}\n                  onChange={(e) => setDateRange(prev => ({ ...prev, start_date: e.target.value }))}\n                />\n              </div>\n              <div>\n                <Label htmlFor=\"end_date\">End Date</Label>\n                <Input\n                  id=\"end_date\"\n                  type=\"date\"\n                  value={dateRange.end_date}\n                  onChange={(e) => setDateRange(prev => ({ ...prev, end_date: e.target.value }))}\n                />\n              </div>\n              <div>\n                <Label htmlFor=\"tenant\">Tenant</Label>\n                <select\n                  id=\"tenant\"\n                  value={selectedTenant}\n                  onChange={(e) => setSelectedTenant(e.target.value)}\n                  className=\"w-full mt-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                >\n                  <option value=\"all\">All Tenants</option>\n                  {extensions.map((ext) => (\n                    <option key={ext.tenant_id} value={ext.tenant_id}>\n                      {ext.tenant_name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Summary Cards */}\n        {summary && (\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8\">\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Total Calls</CardTitle>\n                <Phone className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-2xl font-bold\">{summary.total_calls}</div>\n                <p className=\"text-xs text-muted-foreground\">\n                  {summary.active_calls} active\n                </p>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Total Users</CardTitle>\n                <Users className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-2xl font-bold\">{summary.total_users}</div>\n                <p className=\"text-xs text-muted-foreground\">\n                  Across {summary.total_tenants} tenants\n                </p>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Total Extensions</CardTitle>\n                <Activity className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-2xl font-bold\">{summary.total_extensions}</div>\n                <p className=\"text-xs text-muted-foreground\">\n                  VoIP extensions\n                </p>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Avg Call Duration</CardTitle>\n                <TrendingUp className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-2xl font-bold\">{formatDuration(Math.round(summary.avg_call_duration || 0))}</div>\n                <p className=\"text-xs text-muted-foreground\">\n                  Total: {formatDuration(Math.round(summary.total_call_duration || 0))}\n                </p>\n              </CardContent>\n            </Card>\n          </div>\n        )}\n\n        {/* Extensions by Tenant */}\n        <Card className=\"mb-6\">\n          <CardHeader>\n            <CardTitle>Extensions by Tenant</CardTitle>\n            <CardDescription>Extension distribution across all tenants</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4\">Tenant</th>\n                    <th className=\"text-left py-3 px-4\">Total Extensions</th>\n                    <th className=\"text-left py-3 px-4\">Active</th>\n                    <th className=\"text-left py-3 px-4\">Inactive</th>\n                    <th className=\"text-left py-3 px-4\">Status</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {extensions.map((ext) => (\n                    <tr key={ext.tenant_id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{ext.tenant_name}</div>\n                          <div className=\"text-sm text-gray-500\">{ext.tenant_slug}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4 font-medium\">{ext.extensions_count}</td>\n                      <td className=\"py-3 px-4 text-green-600\">{ext.active_extensions}</td>\n                      <td className=\"py-3 px-4 text-red-600\">{ext.inactive_extensions}</td>\n                      <td className=\"py-3 px-4\">\n                        <Badge variant={ext.tenant_status === 'active' ? 'default' : 'secondary'}>\n                          {ext.tenant_status}\n                        </Badge>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Users by Tenant */}\n        <Card className=\"mb-6\">\n          <CardHeader>\n            <CardTitle>Users by Tenant</CardTitle>\n            <CardDescription>User distribution and roles across all tenants</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4\">Tenant</th>\n                    <th className=\"text-left py-3 px-4\">Total Users</th>\n                    <th className=\"text-left py-3 px-4\">Active</th>\n                    <th className=\"text-left py-3 px-4\">Admins</th>\n                    <th className=\"text-left py-3 px-4\">Regular Users</th>\n                    <th className=\"text-left py-3 px-4\">Last Login</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {users.map((user) => (\n                    <tr key={user.tenant_id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{user.tenant_name}</div>\n                          <div className=\"text-sm text-gray-500\">{user.tenant_slug}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4 font-medium\">{user.users_count}</td>\n                      <td className=\"py-3 px-4 text-green-600\">{user.active_users}</td>\n                      <td className=\"py-3 px-4 text-blue-600\">{user.admin_users}</td>\n                      <td className=\"py-3 px-4 text-gray-600\">{user.regular_users}</td>\n                      <td className=\"py-3 px-4\">\n                        {user.last_login ? (\n                          <div>\n                            <div className=\"text-sm\">{new Date(user.last_login).toLocaleDateString()}</div>\n                            <div className=\"text-xs text-gray-500\">\n                              {new Date(user.last_login).toLocaleTimeString()}\n                            </div>\n                          </div>\n                        ) : (\n                          <span className=\"text-gray-400\">Never</span>\n                        )}\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Recent Calls */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Recent Calls</CardTitle>\n            <CardDescription>Latest call activity across all tenants</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"overflow-x-auto\">\n              <table className=\"w-full\">\n                <thead>\n                  <tr className=\"border-b\">\n                    <th className=\"text-left py-3 px-4\">Tenant</th>\n                    <th className=\"text-left py-3 px-4\">Caller</th>\n                    <th className=\"text-left py-3 px-4\">Callee</th>\n                    <th className=\"text-left py-3 px-4\">Start Time</th>\n                    <th className=\"text-left py-3 px-4\">Duration</th>\n                    <th className=\"text-left py-3 px-4\">Status</th>\n                    <th className=\"text-left py-3 px-4\">User</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {calls.map((call) => (\n                    <tr key={call.id} className=\"border-b hover:bg-gray-50\">\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"font-medium\">{call.tenant_name}</div>\n                          <div className=\"text-sm text-gray-500\">{call.tenant_slug}</div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4\">{call.caller_number}</td>\n                      <td className=\"py-3 px-4\">{call.callee_number}</td>\n                      <td className=\"py-3 px-4\">\n                        <div>\n                          <div className=\"text-sm\">{new Date(call.start_time).toLocaleDateString()}</div>\n                          <div className=\"text-xs text-gray-500\">\n                            {new Date(call.start_time).toLocaleTimeString()}\n                          </div>\n                        </div>\n                      </td>\n                      <td className=\"py-3 px-4\">{formatDuration(call.duration)}</td>\n                      <td className=\"py-3 px-4\">{getDispositionBadge(call.disposition)}</td>\n                      <td className=\"py-3 px-4\">\n                        {call.user_email ? (\n                          <span className=\"text-sm text-gray-600\">{call.user_email}</span>\n                        ) : (\n                          <span className=\"text-gray-400\">-</span>\n                        )}\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n}\n","size_bytes":18169},"packages/frontend/src/pages/Extensions.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport { \n  Plus, \n  Search, \n  Edit, \n  Trash2, \n  Phone, \n  Save,\n  X,\n  RefreshCw,\n  Eye,\n  EyeOff\n} from 'lucide-react';\nimport { SipExtensionConfig } from '@voip/shared';\nimport { apiClient } from '@/lib/api';\nimport { useAuth } from '@/contexts/AuthContext';\n\nexport default function Extensions() {\n  const { user } = useAuth();\n  const [extensions, setExtensions] = useState<SipExtensionConfig[]>([]);\n  const [showModal, setShowModal] = useState(false);\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\n  const [loading, setLoading] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [formData, setFormData] = useState<Partial<SipExtensionConfig>>({});\n  const [showPassword, setShowPassword] = useState(false);\n  const [editingItem, setEditingItem] = useState<any>(null);\n\n  // Load extensions on component mount\n  useEffect(() => {\n    loadExtensions();\n  }, []);\n\n\n  const loadExtensions = async () => {\n    setLoading(true);\n    try {\n      // Load extensions from API using apiClient\n      const data = await apiClient.getExtensions({ limit: 100 });\n      \n      console.log('📡 Extensions API Response:', data);\n      \n      if (data?.success && data?.data?.items && Array.isArray(data.data.items)) {\n        // Map backend extensions to frontend format\n        const mappedExtensions = data.data.items.map((ext: any) => ({\n          id: ext.id,\n          extension: ext.extension,\n          display_name: ext.display_name,\n          password: ext.password || '[HIDDEN]',\n          status: ext.status,\n          tenant_id: ext.tenant_id,\n          created_at: ext.created_at,\n          updated_at: ext.updated_at,\n          sip_settings: {\n            type: ext.type || 'user',\n            host: 'dynamic',\n            context: 'default'\n          }\n        }));\n        setExtensions(mappedExtensions);\n        console.log('✅ Extensions loaded from database:', mappedExtensions.length);\n      } else {\n        console.warn('⚠️ Invalid API response format, using empty array');\n        setExtensions([]);\n      }\n    } catch (error) {\n      console.error('❌ Error loading extensions:', error);\n      setExtensions([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCreate = async () => {\n    if (!user?.tenant_id) return;\n    \n    setLoading(true);\n    try {\n      const response = await apiClient.post('/voip/sip-extensions', {\n        ...formData,\n        tenant_id: user.tenant_id\n      });\n      \n      setExtensions(prev => [...prev, response.data]);\n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error creating extension:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleUpdate = async (extensionId: string) => {\n    setLoading(true);\n    try {\n      const response = await apiClient.put(`/voip/sip-extensions/${extensionId}`, formData);\n      \n      setExtensions(prev => prev.map(ext => ext.id === extensionId ? response.data : ext));\n      setShowModal(false);\n      setFormData({});\n    } catch (error) {\n      console.error('Error updating extension:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDelete = async (extensionId: string) => {\n    if (!confirm('Are you sure you want to delete this extension?')) return;\n    \n    setLoading(true);\n    try {\n      await apiClient.delete(`/voip/sip-extensions/${extensionId}`);\n      \n      setExtensions(prev => prev.filter(ext => ext.id !== extensionId));\n    } catch (error) {\n      console.error('Error deleting extension:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const openModal = (type: 'create' | 'edit' | 'view', item?: any) => {\n    setModalType(type);\n    if (item) {\n      setEditingItem(item);\n      setFormData(item);\n    } else {\n      setEditingItem(null);\n      setFormData({});\n    }\n    setShowModal(true);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setEditingItem(null);\n    setFormData({});\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'active': return 'default';\n      case 'inactive': return 'secondary';\n      case 'locked': return 'destructive';\n      default: return 'secondary';\n    }\n  };\n\n  const getStatusLabel = (status: string) => {\n    switch (status) {\n      case 'active': return 'Active';\n      case 'inactive': return 'Inactive';\n      case 'locked': return 'Locked';\n      default: return 'Unknown';\n    }\n  };\n\n  const filteredExtensions = extensions.filter(ext =>\n    ext.extension.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    ext.display_name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  const columns = [\n    { header: 'Extension', key: 'extension' },\n    { header: 'Display Name', key: 'display_name' },\n    { header: 'Type', key: 'type', render: (item: any) => item.sip_settings?.type || 'user' },\n    { header: 'Host', key: 'host', render: (item: any) => item.sip_settings?.host || 'localhost' },\n    { \n      header: 'Status', \n      key: 'status',\n      render: (item: any) => (\n        <Badge variant={getStatusColor(item.status)}>\n          {getStatusLabel(item.status)}\n        </Badge>\n      )\n    },\n    { header: 'Context', key: 'context', render: (item: any) => item.sip_settings?.context || 'default' }\n  ];\n\n  const renderDataTable = () => (\n    <div className=\"w-full\">\n      <div className=\"overflow-x-auto\">\n        <table className=\"w-full border-collapse\">\n          <thead>\n            <tr className=\"border-b bg-gray-50\">\n              {columns.map((col, index) => (\n                <th key={index} className=\"text-left p-3 font-medium text-gray-700\">\n                  {col.header}\n                </th>\n              ))}\n              <th className=\"text-right p-3 font-medium text-gray-700\">Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {filteredExtensions.map((extension, index) => (\n              <tr key={extension.id || index} className=\"border-b hover:bg-gray-50\">\n                {columns.map((col, colIndex) => (\n                  <td key={colIndex} className=\"p-3\">\n                    {col.render ? col.render(extension) : extension[col.key]}\n                  </td>\n                ))}\n                <td className=\"p-3\">\n                  <div className=\"flex items-center justify-end space-x-1\">\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('view', extension)}\n                      title=\"View Details\"\n                    >\n                      <Eye className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => openModal('edit', extension)}\n                      title=\"Edit\"\n                    >\n                      <Edit className=\"h-4 w-4\" />\n                    </Button>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => handleDelete(extension.id)}\n                      title=\"Delete\"\n                      className=\"text-red-600 hover:text-red-700\"\n                    >\n                      <Trash2 className=\"h-4 w-4\" />\n                    </Button>\n                  </div>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n\n  const renderModal = () => {\n    if (!showModal) return null;\n\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className=\"bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-xl font-semibold\">\n              {modalType === 'create' ? 'Create New' : modalType === 'edit' ? 'Edit' : 'View'} Extension\n            </h2>\n            <Button variant=\"ghost\" size=\"sm\" onClick={closeModal}>\n              <X className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          \n          <Tabs defaultValue=\"basic\" className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-4\">\n              <TabsTrigger value=\"basic\">Basic</TabsTrigger>\n              <TabsTrigger value=\"sip\">SIP</TabsTrigger>\n              <TabsTrigger value=\"features\">Features</TabsTrigger>\n              <TabsTrigger value=\"security\">Security</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"basic\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Extension Number</label>\n                  <Input \n                    placeholder=\"1001\" \n                    value={formData.extension || ''}\n                    onChange={(e) => setFormData({...formData, extension: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Display Name</label>\n                  <Input \n                    placeholder=\"John Doe\" \n                    value={formData.display_name || ''}\n                    onChange={(e) => setFormData({...formData, display_name: e.target.value})}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Password</label>\n                  <div className=\"relative\">\n                    <Input \n                      type={showPassword ? \"text\" : \"password\"}\n                      placeholder=\"Enter password\" \n                      value={formData.password || ''}\n                      onChange={(e) => setFormData({...formData, password: e.target.value})}\n                      disabled={modalType === 'view'}\n                    />\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\n                      onClick={() => setShowPassword(!showPassword)}\n                      disabled={modalType === 'view'}\n                    >\n                      {showPassword ? (\n                        <EyeOff className=\"h-4 w-4\" />\n                      ) : (\n                        <Eye className=\"h-4 w-4\" />\n                      )}\n                    </Button>\n                  </div>\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Status</label>\n                  <Select \n                    value={formData.status || 'active'}\n                    onValueChange={(value) => setFormData({...formData, status: value as any})}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select status\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"active\">Active</SelectItem>\n                      <SelectItem value=\"inactive\">Inactive</SelectItem>\n                      <SelectItem value=\"locked\">Locked</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"sip\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">SIP Type</label>\n                  <Select \n                    value={formData.sip_settings?.type || 'user'}\n                    onValueChange={(value) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, type: value as any}\n                    })}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select SIP type\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"user\">User</SelectItem>\n                      <SelectItem value=\"friend\">Friend</SelectItem>\n                      <SelectItem value=\"peer\">Peer</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Host</label>\n                  <Input \n                    placeholder=\"dynamic\" \n                    value={formData.sip_settings?.host || ''}\n                    onChange={(e) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, host: e.target.value}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Context</label>\n                  <Input \n                    placeholder=\"default\" \n                    value={formData.sip_settings?.context || ''}\n                    onChange={(e) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, context: e.target.value}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">NAT Mode</label>\n                  <Select \n                    value={formData.sip_settings?.nat || 'force_rport'}\n                    onValueChange={(value) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, nat: value as any}\n                    })}\n                    disabled={modalType === 'view'}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select NAT mode\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"force_rport\">Force RPort</SelectItem>\n                      <SelectItem value=\"comedia\">Comedia</SelectItem>\n                      <SelectItem value=\"auto_force_rport\">Auto Force RPort</SelectItem>\n                      <SelectItem value=\"auto_comedia\">Auto Comedia</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"qualify\" \n                    checked={formData.sip_settings?.qualify || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, qualify: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"qualify\" className=\"text-sm font-medium\">Qualify</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"canreinvite\" \n                    checked={formData.sip_settings?.canreinvite || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      sip_settings: {...formData.sip_settings, canreinvite: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"canreinvite\" className=\"text-sm font-medium\">Can Reinvite</label>\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"features\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"call-forwarding\" \n                    checked={formData.call_features?.call_forwarding?.enabled || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {\n                        ...formData.call_features,\n                        call_forwarding: {...formData.call_features?.call_forwarding, enabled: checked}\n                      }\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"call-forwarding\" className=\"text-sm font-medium\">Call Forwarding</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"call-waiting\" \n                    checked={formData.call_features?.call_waiting || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {...formData.call_features, call_waiting: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"call-waiting\" className=\"text-sm font-medium\">Call Waiting</label>\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"three-way-calling\" \n                    checked={formData.call_features?.three_way_calling || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {...formData.call_features, three_way_calling: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"three-way-calling\" className=\"text-sm font-medium\">Three Way Calling</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"voicemail\" \n                    checked={formData.call_features?.voicemail?.enabled || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {\n                        ...formData.call_features,\n                        voicemail: {...formData.call_features?.voicemail, enabled: checked}\n                      }\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"voicemail\" className=\"text-sm font-medium\">Voicemail</label>\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"call-recording\" \n                    checked={formData.call_features?.call_recording || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {...formData.call_features, call_recording: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"call-recording\" className=\"text-sm font-medium\">Call Recording</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"dnd\" \n                    checked={formData.call_features?.do_not_disturb || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      call_features: {...formData.call_features, do_not_disturb: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"dnd\" className=\"text-sm font-medium\">Do Not Disturb</label>\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"security\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"encryption\" \n                    checked={formData.security?.encryption || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      security: {...formData.security, encryption: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"encryption\" className=\"text-sm font-medium\">Encryption</label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <Switch \n                    id=\"anonymous-calls\" \n                    checked={formData.security?.allow_anonymous_calls || false}\n                    onCheckedChange={(checked) => setFormData({\n                      ...formData, \n                      security: {...formData.security, allow_anonymous_calls: checked}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                  <label htmlFor=\"anonymous-calls\" className=\"text-sm font-medium\">Allow Anonymous Calls</label>\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Max Calls</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"1\" \n                    value={formData.security?.max_calls || ''}\n                    onChange={(e) => setFormData({\n                      ...formData, \n                      security: {...formData.security, max_calls: parseInt(e.target.value)}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n                <div>\n                  <label className=\"text-sm font-medium\">Call Timeout</label>\n                  <Input \n                    type=\"number\"\n                    placeholder=\"60\" \n                    value={formData.security?.call_timeout || ''}\n                    onChange={(e) => setFormData({\n                      ...formData, \n                      security: {...formData.security, call_timeout: parseInt(e.target.value)}\n                    })}\n                    disabled={modalType === 'view'}\n                  />\n                </div>\n              </div>\n            </TabsContent>\n          </Tabs>\n          \n          {modalType !== 'view' && (\n            <div className=\"flex justify-end space-x-2 mt-6\">\n              <Button \n                variant=\"outline\"\n                onClick={closeModal}\n              >\n                <X className=\"h-4 w-4 mr-2\" />\n                Cancel\n              </Button>\n              <Button \n                onClick={() => {\n                  if (editingItem) {\n                    handleUpdate(editingItem.id);\n                  } else {\n                    handleCreate();\n                  }\n                }}\n                disabled={loading}\n                className=\"bg-blue-600 hover:bg-blue-700\"\n              >\n                <Save className=\"h-4 w-4 mr-2\" />\n                {loading ? 'Saving...' : 'Save Configuration'}\n              </Button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">SIP Extensions</h1>\n          <p className=\"text-muted-foreground\">\n            Manage SIP extensions, configure call features, and monitor registration status\n          </p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search extensions...\"\n              className=\"pl-8 w-64\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n            />\n          </div>\n          <Button onClick={loadExtensions} variant=\"outline\" size=\"sm\">\n            <RefreshCw className=\"h-4 w-4 mr-2\" />\n            Refresh\n          </Button>\n          <Button \n            onClick={() => openModal('create')} \n            size=\"sm\"\n            className=\"bg-blue-600 hover:bg-blue-700\"\n          >\n            <Plus className=\"h-4 w-4 mr-2\" />\n            Add Extension\n          </Button>\n        </div>\n      </div>\n\n      {/* Data Table */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <Phone className=\"h-5 w-5 mr-2\" />\n            Extensions ({filteredExtensions.length})\n          </CardTitle>\n          <CardDescription>\n            Manage and configure SIP extensions\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          {renderDataTable()}\n        </CardContent>\n      </Card>\n\n      {/* Modal */}\n      {renderModal()}\n    </div>\n  );\n}","size_bytes":26245},"packages/frontend/src/pages/TenantNotFound.tsx":{"content":"import { useNavigate } from 'react-router-dom';\r\nimport { Button } from '@/components/ui/button';\r\nimport { AlertTriangle, Home } from 'lucide-react';\r\n\r\nexport default function TenantNotFound() {\r\n  const navigate = useNavigate();\r\n\r\n  return (\r\n    <div className=\"min-h-screen flex items-center justify-center bg-gray-50\">\r\n      <div className=\"text-center max-w-md mx-auto px-4\">\r\n        <div className=\"mb-8\">\r\n          <AlertTriangle className=\"h-24 w-24 text-red-500 mx-auto mb-4\" />\r\n          <h1 className=\"text-4xl font-bold text-gray-900 mb-4\">404</h1>\r\n          <h2 className=\"text-2xl font-semibold text-gray-700 mb-4\">Tenant Not Found</h2>\r\n          <p className=\"text-gray-600 mb-8\">\r\n            The tenant you're looking for doesn't exist or is currently inactive.\r\n            Please check the URL and try again.\r\n          </p>\r\n        </div>\r\n        \r\n        <div className=\"space-y-4\">\r\n          <Button \r\n            onClick={() => navigate('/')}\r\n            className=\"w-full\"\r\n            size=\"lg\"\r\n          >\r\n            <Home className=\"h-4 w-4 mr-2\" />\r\n            Go to Home\r\n          </Button>\r\n          \r\n          <p className=\"text-sm text-gray-500\">\r\n            If you believe this is an error, please contact your system administrator.\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":1356},"DEPLOYMENT_PRODUCTION.md":{"content":"# EDG VoIP System - Production Deployment Guide\r\n\r\n## 🚀 Deployment su Server Debian\r\n\r\n### Prerequisiti\r\n- Server Debian pulito\r\n- Accesso root\r\n- Porte aperte: 22, 80, 443, 8021, 5060, 5061, 16384-32768\r\n\r\n### Step 1: Setup Server Base\r\n```bash\r\n# Copiare script sul server\r\nscp scripts/setup-debian-server.sh root@YOUR_SERVER_IP:/tmp/\r\n\r\n# Eseguire setup\r\nssh root@YOUR_SERVER_IP\r\nchmod +x /tmp/setup-debian-server.sh\r\n/tmp/setup-debian-server.sh\r\n```\r\n\r\n### Step 2: Deploy Applicazione\r\n```bash\r\n# Dal computer locale, modificare IP nel file\r\nvim scripts/deploy-to-debian.sh\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\n\r\n# Eseguire deploy\r\nchmod +x scripts/deploy-to-debian.sh\r\n./scripts/deploy-to-debian.sh\r\n```\r\n\r\n### Step 3: Test Sistema\r\n```bash\r\n# Modificare IP nel file di test\r\nvim scripts/test-production.sh\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\n\r\n# Eseguire test\r\nchmod +x scripts/test-production.sh\r\n./scripts/test-production.sh\r\n```\r\n\r\n## 🔧 Configurazione Post-Deploy\r\n\r\n### 1. Aggiornare IP nel file env.production\r\n```bash\r\nssh root@YOUR_SERVER_IP\r\nvim /etc/voip-system/.env\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\nsystemctl restart voip-backend\r\n```\r\n\r\n### 2. Configurare SSL (Opzionale)\r\n```bash\r\n# Generare certificato self-signed per test\r\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\r\n  -keyout /etc/ssl/private/voip.key \\\r\n  -out /etc/ssl/certs/voip.crt\r\n\r\n# Aggiornare Nginx per HTTPS\r\nvim /etc/nginx/sites-available/voip-system\r\n# Aggiungere configurazione SSL\r\nsystemctl reload nginx\r\n```\r\n\r\n## 📊 Monitoraggio\r\n\r\n### Comandi Utili\r\n```bash\r\n# Stato servizi\r\nsystemctl status voip-backend postgresql redis-server nginx freeswitch\r\n\r\n# Log applicazione\r\njournalctl -u voip-backend -f\r\n\r\n# Log FreeSWITCH\r\njournalctl -u freeswitch -f\r\n\r\n# Log Nginx\r\ntail -f /var/log/nginx/access.log\r\ntail -f /var/log/nginx/error.log\r\n\r\n# Porte in ascolto\r\nnetstat -tlnp | grep -E ':(80|443|5000|5060|5061|8021)'\r\n```\r\n\r\n### Health Checks\r\n```bash\r\n# API Health\r\ncurl http://YOUR_SERVER_IP/api/health\r\n\r\n# Database\r\nsudo -u postgres psql -c \"SELECT 1;\" voip_production\r\n\r\n# Redis\r\nredis-cli -a RedisSecure2025! ping\r\n\r\n# FreeSWITCH ESL\r\nfs_cli -x \"status\"\r\n```\r\n\r\n## 🔐 Credenziali Default\r\n\r\n### Super Admin\r\n- Email: `admin@edgvoip.local`\r\n- Password: `SuperAdmin2025!`\r\n- URL: `http://YOUR_SERVER_IP/edgvoip/login`\r\n\r\n### Demo Tenant\r\n- Email: `admin@demo.local`\r\n- Password: `tenantadmin123`\r\n- URL: `http://YOUR_SERVER_IP/demo/login`\r\n\r\n### Database\r\n- Database: `voip_production`\r\n- User: `voip_user`\r\n- Password: `VoipSecure2025!`\r\n\r\n### Redis\r\n- Password: `RedisSecure2025!`\r\n\r\n### FreeSWITCH ESL\r\n- Password: `1QzGEWv0Q6ao20M+hS8qeLI+u9gw77WuJGB5Z1xDk30=`\r\n\r\n## 🛠️ Troubleshooting\r\n\r\n### Backend non si avvia\r\n```bash\r\n# Controllare log\r\njournalctl -u voip-backend -n 50\r\n\r\n# Verificare variabili ambiente\r\ncat /etc/voip-system/.env\r\n\r\n# Testare connessione database\r\ncd /var/www/voip-system/packages/backend\r\nnpm run migrate\r\n```\r\n\r\n### FreeSWITCH non risponde\r\n```bash\r\n# Controllare configurazione\r\nfreeswitch -t\r\n\r\n# Verificare porte\r\nnetstat -tlnp | grep 5060\r\n\r\n# Test ESL\r\nfs_cli -x \"status\"\r\n```\r\n\r\n### Nginx errori 502\r\n```bash\r\n# Verificare che backend sia in ascolto\r\nnetstat -tlnp | grep 5000\r\n\r\n# Controllare log Nginx\r\ntail -f /var/log/nginx/error.log\r\n```\r\n\r\n## 📈 Performance\r\n\r\n### Ottimizzazioni Applicate\r\n- Rate limiting su API\r\n- Gzip compression\r\n- Static file caching\r\n- Connection pooling database\r\n- Redis caching\r\n- Fail2ban protection\r\n\r\n### Monitoraggio Risorse\r\n```bash\r\n# CPU e memoria\r\nhtop\r\n\r\n# Disco\r\ndf -h\r\n\r\n# Rete\r\niftop\r\n```\r\n\r\n## 🔄 Backup e Restore\r\n\r\n### Backup Automatico\r\n```bash\r\n# Script backup giornaliero\r\ncrontab -e\r\n# Aggiungere: 0 2 * * * /var/www/voip-system/scripts/backup.sh\r\n```\r\n\r\n### Restore\r\n```bash\r\n# Ripristinare database\r\ngunzip -c /var/backups/voip/postgres_YYYYMMDD_HHMMSS.sql.gz | \\\r\nsudo -u postgres psql voip_production\r\n\r\n# Ripristinare configurazioni\r\ntar -xzf /var/backups/voip/configs_YYYYMMDD_HHMMSS.tar.gz\r\n```\r\n\r\n## 🚨 Sicurezza\r\n\r\n### Firewall Configurato\r\n- SSH: porta 22\r\n- HTTP: porta 80\r\n- HTTPS: porta 443\r\n- SIP: porta 5060\r\n- SIP TLS: porta 5061\r\n- ESL: porta 8021\r\n- RTP: porte 16384-32768\r\n\r\n### Fail2ban Attivo\r\n- Protezione SSH\r\n- Protezione Nginx\r\n- Rate limiting\r\n\r\n### Password Sicure\r\n- Tutte le password sono state generate casualmente\r\n- JWT secrets sicuri\r\n- Database e Redis protetti\r\n\r\n## 📞 Supporto\r\n\r\nPer problemi o domande:\r\n1. Controllare i log\r\n2. Verificare stato servizi\r\n3. Testare connettività\r\n4. Controllare configurazioni\r\n\r\nIl sistema è ora production-ready e completamente funzionale!\r\n","size_bytes":4651},"packages/frontend/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }","size_bytes":709},"packages/backend/src/services/voip-service.ts":{"content":"// @ts-nocheck\n// import { \n//   InboundRoute, \n//   OutboundRoute, \n//   TimeCondition, \n//   IvrMenu, \n//   RingGroup, \n//   Queue, \n//   ConferenceRoom, \n//   VoicemailBox,\n//   DialplanContext,\n//   OpenSipsRoute,\n//   SipExtensionConfig,\n//   SipTrunkConfig\n// } from '@w3-voip/shared';\nimport { TenantContext } from '../middleware/tenant-context';\nimport { Pool } from 'pg';\nimport dotenv from 'dotenv';\n\n// Define types locally\nexport interface InboundRoute {\n  id: string;\n  tenant_id: string;\n  name: string;\n  pattern: string;\n  destination: string;\n  priority: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface OutboundRoute {\n  id: string;\n  tenant_id: string;\n  name: string;\n  pattern: string;\n  trunk_id: string;\n  priority: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface TimeCondition {\n  id: string;\n  tenant_id: string;\n  name: string;\n  time_ranges: string[];\n  timezone: string;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface IvrMenu {\n  id: string;\n  tenant_id: string;\n  name: string;\n  prompt: string;\n  options: any[];\n  timeout: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface RingGroup {\n  id: string;\n  tenant_id: string;\n  name: string;\n  extensions: string[];\n  strategy: 'simultaneous' | 'sequential';\n  timeout: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface Queue {\n  id: string;\n  tenant_id: string;\n  name: string;\n  strategy: 'fifo' | 'priority';\n  timeout: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface ConferenceRoom {\n  id: string;\n  tenant_id: string;\n  name: string;\n  pin: string;\n  max_participants: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface VoicemailBox {\n  id: string;\n  tenant_id: string;\n  extension_id: string;\n  password: string;\n  email_notification: boolean;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface DialplanContext {\n  id: string;\n  tenant_id: string;\n  name: string;\n  extensions: any[];\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface OpenSipsRoute {\n  id: string;\n  tenant_id: string;\n  name: string;\n  pattern: string;\n  destination: string;\n  priority: number;\n  enabled: boolean;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface SipExtensionConfig {\n  id: string;\n  tenant_id: string;\n  extension: string;\n  password: string;\n  display_name: string;\n  status: 'active' | 'inactive';\n  type: 'user' | 'queue' | 'conference';\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface SipTrunkConfig {\n  id: string;\n  tenant_id: string;\n  name: string;\n  provider: string;\n  host: string;\n  port: number;\n  transport: 'udp' | 'tcp' | 'tls';\n  username: string;\n  password: string;\n  status: 'active' | 'inactive' | 'testing';\n  created_at: Date;\n  updated_at: Date;\n}\n\n// Load environment variables\ndotenv.config();\n\nexport interface FreeSwitchConfig {\n  host: string;\n  port: number;\n  password: string;\n  context: string;\n}\n\nexport interface OpenSipsConfig {\n  host: string;\n  port: number;\n  database: {\n    host: string;\n    port: number;\n    name: string;\n    user: string;\n    password: string;\n  };\n}\n\nexport interface FusionPBXConfig {\n  host: string;\n  port: number;\n  database: {\n    host: string;\n    port: number;\n    name: string;\n    user: string;\n    password: string;\n  };\n}\n\nexport class VoipService {\n  private freeSwitchConfig: FreeSwitchConfig;\n  private openSipsConfig: OpenSipsConfig;\n  private fusionPBXConfig: FusionPBXConfig;\n  private pool: Pool;\n\n  constructor(\n    freeSwitchConfig: FreeSwitchConfig,\n    openSipsConfig: OpenSipsConfig,\n    fusionPBXConfig: FusionPBXConfig\n  ) {\n    this.freeSwitchConfig = freeSwitchConfig;\n    this.openSipsConfig = openSipsConfig;\n    this.fusionPBXConfig = fusionPBXConfig;\n    \n    // Initialize PostgreSQL connection pool\n    this.pool = new Pool({\n      connectionString: process.env.DATABASE_URL\n    });\n  }\n\n  // ===== INBOUND ROUTES =====\n  async getInboundRoutes(tenantId: string): Promise<InboundRoute[]> {\n    // In production, this would query the database\n    // For now, return mock data\n    return [\n      {\n        id: 'route-1',\n        tenant_id: tenantId,\n        name: 'Main DID Route',\n        description: 'Route for main DID number',\n        did_number: '+1234567890',\n        destination_type: 'extension',\n        destination_value: '1001',\n        enabled: true,\n        caller_id_override: false\n      }\n    ];\n  }\n\n  async getInboundRouteById(routeId: string): Promise<InboundRoute | null> {\n    // In production, this would query the database\n    return null;\n  }\n\n  async createInboundRoute(tenantContext: TenantContext, route: Partial<InboundRoute>): Promise<InboundRoute> {\n    // Auto-populate tenant context fields\n    const fullRoute: InboundRoute = {\n      ...route,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as InboundRoute;\n\n    // 1. Create FreeSWITCH dialplan extension\n    const dialplanExtension = this.generateInboundDialplan(fullRoute);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    // 2. Create FusionPBX inbound route record\n    await this.createFusionPBXInboundRoute(fullRoute);\n\n    // 3. If time condition exists, link it\n    if (fullRoute.time_condition_id) {\n      await this.linkTimeCondition(fullRoute.id!, fullRoute.time_condition_id);\n    }\n\n    return fullRoute;\n  }\n\n  async updateInboundRoute(routeId: string, route: Partial<InboundRoute>): Promise<InboundRoute> {\n    // 1. Update FreeSWITCH dialplan\n    const dialplanExtension = this.generateInboundDialplan(route as InboundRoute);\n    await this.updateFreeSwitchDialplan(routeId, dialplanExtension);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXInboundRoute(routeId, route);\n\n    return route as InboundRoute;\n  }\n\n  async deleteInboundRoute(routeId: string): Promise<void> {\n    // 1. Delete FreeSWITCH dialplan\n    await this.deleteFreeSwitchDialplan(routeId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXInboundRoute(routeId);\n  }\n\n  // ===== OUTBOUND ROUTES =====\n  async getOutboundRoutes(tenantId: string): Promise<OutboundRoute[]> {\n    // In production, this would query the database\n    return [\n      {\n        id: 'outbound-1',\n        tenant_id: tenantId,\n        name: 'Local Calls',\n        description: 'Route for local calls',\n        dial_pattern: '^\\\\+1[0-9]{10}$',\n        trunk_id: 'trunk-1',\n        enabled: true,\n        strip_digits: 0,\n        prefix: ''\n      }\n    ];\n  }\n\n  async getOutboundRouteById(routeId: string): Promise<OutboundRoute | null> {\n    return null;\n  }\n\n  async createOutboundRoute(tenantContext: TenantContext, route: Partial<OutboundRoute>): Promise<OutboundRoute> {\n    // Auto-populate tenant context fields\n    const fullRoute: OutboundRoute = {\n      ...route,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as OutboundRoute;\n\n    // 1. Create FreeSWITCH dialplan extension for outbound routing\n    const dialplanExtension = this.generateOutboundDialplan(fullRoute);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    // 2. Create FusionPBX outbound route record\n    await this.createFusionPBXOutboundRoute(fullRoute);\n\n    return fullRoute;\n  }\n\n  async updateOutboundRoute(routeId: string, route: Partial<OutboundRoute>): Promise<OutboundRoute> {\n    // 1. Update FreeSWITCH dialplan\n    const dialplanExtension = this.generateOutboundDialplan(route as OutboundRoute);\n    await this.updateFreeSwitchDialplan(routeId, dialplanExtension);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXOutboundRoute(routeId, route);\n\n    return route as OutboundRoute;\n  }\n\n  async deleteOutboundRoute(routeId: string): Promise<void> {\n    // 1. Delete FreeSWITCH dialplan\n    await this.deleteFreeSwitchDialplan(routeId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXOutboundRoute(routeId);\n  }\n\n  // ===== TIME CONDITIONS =====\n  async getTimeConditions(tenantId: string): Promise<TimeCondition[]> {\n    return [\n      {\n        id: 'time-1',\n        tenant_id: tenantId,\n        name: 'Business Hours',\n        description: 'Monday to Friday 9AM-5PM',\n        timezone: 'UTC',\n        business_hours: {\n          monday: { enabled: true, start_time: '09:00', end_time: '17:00' },\n          tuesday: { enabled: true, start_time: '09:00', end_time: '17:00' },\n          wednesday: { enabled: true, start_time: '09:00', end_time: '17:00' },\n          thursday: { enabled: true, start_time: '09:00', end_time: '17:00' },\n          friday: { enabled: true, start_time: '09:00', end_time: '17:00' },\n          saturday: { enabled: false, start_time: '00:00', end_time: '00:00' },\n          sunday: { enabled: false, start_time: '00:00', end_time: '00:00' }\n        },\n        holidays: []\n      }\n    ];\n  }\n\n  async getTimeConditionById(conditionId: string): Promise<TimeCondition | null> {\n    return null;\n  }\n\n  async createTimeCondition(tenantContext: TenantContext, condition: Partial<TimeCondition>): Promise<TimeCondition> {\n    // Auto-populate tenant context fields\n    const fullCondition: TimeCondition = {\n      ...condition,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as TimeCondition;\n\n    // 1. Create FreeSWITCH time condition\n    const timeCondition = this.generateTimeCondition(fullCondition);\n    await this.createFreeSwitchTimeCondition(timeCondition);\n\n    // 2. Create FusionPBX time condition record\n    await this.createFusionPBXTimeCondition(fullCondition);\n\n    return fullCondition;\n  }\n\n  async updateTimeCondition(conditionId: string, condition: Partial<TimeCondition>): Promise<TimeCondition> {\n    // 1. Update FreeSWITCH time condition\n    const timeCondition = this.generateTimeCondition(condition as TimeCondition);\n    await this.updateFreeSwitchTimeCondition(conditionId, timeCondition);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXTimeCondition(conditionId, condition);\n\n    return condition as TimeCondition;\n  }\n\n  async deleteTimeCondition(conditionId: string): Promise<void> {\n    // 1. Delete FreeSWITCH time condition\n    await this.deleteFreeSwitchTimeCondition(conditionId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXTimeCondition(conditionId);\n  }\n\n  // ===== IVR MENUS =====\n  async getIvrMenus(tenantId: string): Promise<IvrMenu[]> {\n    return [\n      {\n        id: 'ivr-1',\n        tenant_id: tenantId,\n        name: 'Main Menu',\n        description: 'Main IVR menu',\n        greeting_message: 'Welcome to our company',\n        timeout_seconds: 10,\n        max_failures: 3,\n        options: [\n          { digit: '1', action: 'extension', value: '1001', description: 'Sales' },\n          { digit: '2', action: 'extension', value: '1002', description: 'Support' },\n          { digit: '0', action: 'extension', value: '1000', description: 'Operator' }\n        ]\n      }\n    ];\n  }\n\n  async getIvrMenuById(menuId: string): Promise<IvrMenu | null> {\n    return null;\n  }\n\n  async createIvrMenu(tenantContext: TenantContext, menu: Partial<IvrMenu>): Promise<IvrMenu> {\n    // Auto-populate tenant context fields\n    const fullMenu: IvrMenu = {\n      ...menu,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as IvrMenu;\n\n    // 1. Create FreeSWITCH IVR application\n    const ivrApplication = this.generateIvrApplication(fullMenu);\n    await this.createFreeSwitchIvrApplication(ivrApplication);\n\n    // 2. Create FusionPBX IVR menu record\n    await this.createFusionPBXIvrMenu(fullMenu);\n\n    // 3. Create dialplan extension for IVR\n    const dialplanExtension = this.generateIvrDialplan(fullMenu);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    return fullMenu;\n  }\n\n  async updateIvrMenu(menuId: string, menu: Partial<IvrMenu>): Promise<IvrMenu> {\n    // 1. Update FreeSWITCH IVR application\n    const ivrApplication = this.generateIvrApplication(menu as IvrMenu);\n    await this.updateFreeSwitchIvrApplication(menuId, ivrApplication);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXIvrMenu(menuId, menu);\n\n    // 3. Update dialplan extension\n    const dialplanExtension = this.generateIvrDialplan(menu as IvrMenu);\n    await this.updateFreeSwitchDialplan(menuId, dialplanExtension);\n\n    return menu as IvrMenu;\n  }\n\n  async deleteIvrMenu(menuId: string): Promise<void> {\n    // 1. Delete FreeSWITCH IVR application\n    await this.deleteFreeSwitchIvrApplication(menuId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXIvrMenu(menuId);\n\n    // 3. Delete dialplan extension\n    await this.deleteFreeSwitchDialplan(menuId);\n  }\n\n  // ===== RING GROUPS =====\n  async getRingGroups(tenantId: string): Promise<RingGroup[]> {\n    return [\n      {\n        id: 'ring-1',\n        tenant_id: tenantId,\n        name: 'Sales Team',\n        description: 'Sales team ring group',\n        extension_number: '2001',\n        strategy: 'simultaneous',\n        timeout: 30,\n        max_calls: 10,\n        members: [\n          { extension: '1001', priority: 1, enabled: true },\n          { extension: '1002', priority: 2, enabled: true }\n        ]\n      }\n    ];\n  }\n\n  async getRingGroupById(groupId: string): Promise<RingGroup | null> {\n    return null;\n  }\n\n  async createRingGroup(tenantContext: TenantContext, group: Partial<RingGroup>): Promise<RingGroup> {\n    // Auto-populate tenant context fields\n    const fullGroup: RingGroup = {\n      ...group,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as RingGroup;\n\n    // 1. Create FreeSWITCH ring group application\n    const ringGroupApplication = this.generateRingGroupApplication(fullGroup);\n    await this.createFreeSwitchRingGroupApplication(ringGroupApplication);\n\n    // 2. Create FusionPBX ring group record\n    await this.createFusionPBXRingGroup(fullGroup);\n\n    // 3. Create dialplan extension for ring group\n    const dialplanExtension = this.generateRingGroupDialplan(fullGroup);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    return fullGroup;\n  }\n\n  async updateRingGroup(groupId: string, group: Partial<RingGroup>): Promise<RingGroup> {\n    // 1. Update FreeSWITCH ring group application\n    const ringGroupApplication = this.generateRingGroupApplication(group as RingGroup);\n    await this.updateFreeSwitchRingGroupApplication(groupId, ringGroupApplication);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXRingGroup(groupId, group);\n\n    // 3. Update dialplan extension\n    const dialplanExtension = this.generateRingGroupDialplan(group as RingGroup);\n    await this.updateFreeSwitchDialplan(groupId, dialplanExtension);\n\n    return group as RingGroup;\n  }\n\n  async deleteRingGroup(groupId: string): Promise<void> {\n    // 1. Delete FreeSWITCH ring group application\n    await this.deleteFreeSwitchRingGroupApplication(groupId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXRingGroup(groupId);\n\n    // 3. Delete dialplan extension\n    await this.deleteFreeSwitchDialplan(groupId);\n  }\n\n  // ===== QUEUES =====\n  async getQueues(tenantId: string): Promise<Queue[]> {\n    return [\n      {\n        id: 'queue-1',\n        tenant_id: tenantId,\n        name: 'Support Queue',\n        description: 'Customer support queue',\n        extension_number: '3001',\n        strategy: 'fifo',\n        timeout: 30,\n        max_calls: 100,\n        agents: [\n          { extension: '1001', penalty: 1, enabled: true },\n          { extension: '1002', penalty: 2, enabled: true }\n        ]\n      }\n    ];\n  }\n\n  async getQueueById(queueId: string): Promise<Queue | null> {\n    return null;\n  }\n\n  async createQueue(tenantContext: TenantContext, queue: Partial<Queue>): Promise<Queue> {\n    // Auto-populate tenant context fields\n    const fullQueue: Queue = {\n      ...queue,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as Queue;\n\n    // 1. Create FreeSWITCH queue application\n    const queueApplication = this.generateQueueApplication(fullQueue);\n    await this.createFreeSwitchQueueApplication(queueApplication);\n\n    // 2. Create FusionPBX queue record\n    await this.createFusionPBXQueue(fullQueue);\n\n    // 3. Create dialplan extension for queue\n    const dialplanExtension = this.generateQueueDialplan(fullQueue);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    return fullQueue;\n  }\n\n  async updateQueue(queueId: string, queue: Partial<Queue>): Promise<Queue> {\n    // 1. Update FreeSWITCH queue application\n    const queueApplication = this.generateQueueApplication(queue as Queue);\n    await this.updateFreeSwitchQueueApplication(queueId, queueApplication);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXQueue(queueId, queue);\n\n    // 3. Update dialplan extension\n    const dialplanExtension = this.generateQueueDialplan(queue as Queue);\n    await this.updateFreeSwitchDialplan(queueId, dialplanExtension);\n\n    return queue as Queue;\n  }\n\n  async deleteQueue(queueId: string): Promise<void> {\n    // 1. Delete FreeSWITCH queue application\n    await this.deleteFreeSwitchQueueApplication(queueId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXQueue(queueId);\n\n    // 3. Delete dialplan extension\n    await this.deleteFreeSwitchDialplan(queueId);\n  }\n\n  // ===== CONFERENCE ROOMS =====\n  async getConferenceRooms(tenantId: string): Promise<ConferenceRoom[]> {\n    return [\n      {\n        id: 'conf-1',\n        tenant_id: tenantId,\n        name: 'Meeting Room 1',\n        description: 'Main meeting room',\n        extension_number: '4001',\n        max_members: 10,\n        record_conference: false,\n        pin: '1234',\n        moderator_pin: '5678'\n      }\n    ];\n  }\n\n  async getConferenceRoomById(roomId: string): Promise<ConferenceRoom | null> {\n    return null;\n  }\n\n  async createConferenceRoom(tenantContext: TenantContext, room: Partial<ConferenceRoom>): Promise<ConferenceRoom> {\n    // Auto-populate tenant context fields\n    const fullRoom: ConferenceRoom = {\n      ...room,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as ConferenceRoom;\n\n    // 1. Create FreeSWITCH conference room\n    const conferenceRoom = this.generateConferenceRoom(fullRoom);\n    await this.createFreeSwitchConferenceRoom(conferenceRoom);\n\n    // 2. Create FusionPBX conference room record\n    await this.createFusionPBXConferenceRoom(fullRoom);\n\n    // 3. Create dialplan extension for conference\n    const dialplanExtension = this.generateConferenceDialplan(fullRoom);\n    await this.createFreeSwitchDialplan(dialplanExtension);\n\n    return fullRoom;\n  }\n\n  async updateConferenceRoom(roomId: string, room: Partial<ConferenceRoom>): Promise<ConferenceRoom> {\n    // 1. Update FreeSWITCH conference room\n    const conferenceRoom = this.generateConferenceRoom(room as ConferenceRoom);\n    await this.updateFreeSwitchConferenceRoom(roomId, conferenceRoom);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXConferenceRoom(roomId, room);\n\n    // 3. Update dialplan extension\n    const dialplanExtension = this.generateConferenceDialplan(room as ConferenceRoom);\n    await this.updateFreeSwitchDialplan(roomId, dialplanExtension);\n\n    return room as ConferenceRoom;\n  }\n\n  async deleteConferenceRoom(roomId: string): Promise<void> {\n    // 1. Delete FreeSWITCH conference room\n    await this.deleteFreeSwitchConferenceRoom(roomId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXConferenceRoom(roomId);\n\n    // 3. Delete dialplan extension\n    await this.deleteFreeSwitchDialplan(roomId);\n  }\n\n  // ===== VOICEMAIL BOXES =====\n  async getVoicemailBoxes(tenantId: string): Promise<VoicemailBox[]> {\n    return [\n      {\n        id: 'vm-1',\n        tenant_id: tenantId,\n        extension_number: '1001',\n        password: '1234',\n        display_name: 'John Doe',\n        email_address: 'john@example.com',\n        max_messages: 100,\n        max_message_length: 300,\n        email_notifications: true\n      }\n    ];\n  }\n\n  async getVoicemailBoxById(boxId: string): Promise<VoicemailBox | null> {\n    return null;\n  }\n\n  async createVoicemailBox(tenantContext: TenantContext, box: Partial<VoicemailBox>): Promise<VoicemailBox> {\n    // Auto-populate tenant context fields\n    const fullBox: VoicemailBox = {\n      ...box,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id\n    } as VoicemailBox;\n\n    // 1. Create FreeSWITCH voicemail box\n    const voicemailBox = this.generateVoicemailBox(fullBox);\n    await this.createFreeSwitchVoicemailBox(voicemailBox);\n\n    // 2. Create FusionPBX voicemail box record\n    await this.createFusionPBXVoicemailBox(fullBox);\n\n    return fullBox;\n  }\n\n  async updateVoicemailBox(boxId: string, box: Partial<VoicemailBox>): Promise<VoicemailBox> {\n    // 1. Update FreeSWITCH voicemail box\n    const voicemailBox = this.generateVoicemailBox(box as VoicemailBox);\n    await this.updateFreeSwitchVoicemailBox(boxId, voicemailBox);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXVoicemailBox(boxId, box);\n\n    return box as VoicemailBox;\n  }\n\n  async deleteVoicemailBox(boxId: string): Promise<void> {\n    // 1. Delete FreeSWITCH voicemail box\n    await this.deleteFreeSwitchVoicemailBox(boxId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXVoicemailBox(boxId);\n  }\n\n  // ===== SIP EXTENSIONS =====\n  async getSipExtensions(tenantId: string): Promise<SipExtensionConfig[]> {\n    return [\n      {\n        extension: '1001',\n        password: 'secure123',\n        display_name: 'John Doe',\n        tenant_id: tenantId,\n        realm: 'demo-tenant.edgvoip.local',\n        sip_settings: {\n          context: 'default',\n          host: 'dynamic',\n          type: 'friend',\n          nat: 'force_rport',\n          qualify: true,\n          qualify_freq: 60,\n          canreinvite: false,\n          dtmfmode: 'rfc2833',\n          disallow: ['all'],\n          allow: ['ulaw', 'alaw', 'g729', 'g722'],\n          directmedia: false,\n          trustrpid: false,\n          sendrpid: false,\n          musicclass: 'default',\n          mohsuggest: 'default',\n          hasvoicemail: true,\n          mailbox: '1001',\n          callingpres: 'allowed_not_screened',\n          restrictcid: false\n        },\n        features: {\n          call_forwarding: false,\n          call_waiting: true,\n          three_way_calling: true,\n          call_parking: false,\n          do_not_disturb: false\n        },\n        security: {\n          allow_guest: false,\n          allow_anonymous: false,\n          max_calls: 5,\n          call_timeout: 300\n        }\n      }\n    ];\n  }\n\n  async getSipExtensionById(extensionId: string): Promise<SipExtensionConfig | null> {\n    return null;\n  }\n\n  async createSipExtension(tenantContext: TenantContext, extension: Partial<SipExtensionConfig>): Promise<SipExtensionConfig> {\n    // Auto-populate tenant context fields\n    const fullExtension: SipExtensionConfig = {\n      ...extension,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id,\n      realm: tenantContext.sip_domain\n    } as SipExtensionConfig;\n\n    // 1. Create FreeSWITCH SIP extension\n    const sipExtension = this.generateSipExtension(fullExtension);\n    await this.createFreeSwitchSipExtension(sipExtension);\n\n    // 2. Create FusionPBX extension record\n    await this.createFusionPBXExtension(fullExtension);\n\n    return fullExtension;\n  }\n\n  async updateSipExtension(extensionId: string, extension: Partial<SipExtensionConfig>): Promise<SipExtensionConfig> {\n    // 1. Update FreeSWITCH SIP extension\n    const sipExtension = this.generateSipExtension(extension as SipExtensionConfig);\n    await this.updateFreeSwitchSipExtension(extensionId, sipExtension);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXExtension(extensionId, extension);\n\n    return extension as SipExtensionConfig;\n  }\n\n  async deleteSipExtension(extensionId: string): Promise<void> {\n    // 1. Delete FreeSWITCH SIP extension\n    await this.deleteFreeSwitchSipExtension(extensionId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXExtension(extensionId);\n  }\n\n  // ===== SIP TRUNKS =====\n  async getSipTrunks(tenantId: string): Promise<SipTrunkConfig[]> {\n    try {\n      const result = await this.pool.query(\n        `SELECT \n          id,\n          name,\n          provider,\n          status,\n          sip_config,\n          did_config,\n          security,\n          gdpr,\n          created_at,\n          updated_at\n        FROM sip_trunks \n        WHERE tenant_id = $1\n        ORDER BY created_at DESC`,\n        [tenantId]\n      );\n\n      // Map database rows to SipTrunkConfig format\n      return result.rows.map((row: any) => ({\n        id: row.id,\n        name: row.name,\n        provider: row.provider,\n        status: row.status,\n        host: row.sip_config?.host || '',\n        port: row.sip_config?.port || 5060,\n        username: row.sip_config?.username || '',\n        password: row.sip_config?.password || '',\n        from_user: row.sip_config?.from_user || '',\n        from_domain: row.sip_config?.from_domain || '',\n        tenant_id: tenantId,\n        sip_config: row.sip_config,\n        did_config: row.did_config,\n        registration: row.sip_config?.registration || {\n          enabled: false,\n          status: 'unregistered'\n        },\n        sip_settings: {\n          type: row.sip_config?.type || 'peer',\n          context: row.sip_config?.context || 'from-trunk',\n          nat: 'force_rport',\n          qualify: row.sip_config?.qualify !== false,\n          qualify_freq: 60,\n          canreinvite: false,\n          dtmfmode: row.sip_config?.dtmf_mode || 'rfc2833',\n          disallow: ['all'],\n          allow: ['ulaw', 'alaw', 'g729', 'g722'],\n          directmedia: false,\n          trustrpid: false,\n          sendrpid: false\n        },\n        advanced: {\n          max_calls: 100,\n          call_timeout: 300,\n          codec_preference: ['ulaw', 'alaw', 'g729'],\n          failover_trunk: null\n        }\n      }));\n    } catch (error) {\n      console.error('Error fetching SIP trunks from database:', error);\n      return [];\n    }\n  }\n\n  async getSipTrunkById(trunkId: string): Promise<SipTrunkConfig | null> {\n    return null;\n  }\n\n  async createSipTrunk(tenantContext: TenantContext, trunk: Partial<SipTrunkConfig>): Promise<SipTrunkConfig> {\n    // Auto-populate tenant context fields\n    const fullTrunk: SipTrunkConfig = {\n      ...trunk,\n      tenant_id: tenantContext.tenant_id,\n      store_id: tenantContext.store_id,\n      from_domain: tenantContext.sip_domain\n    } as SipTrunkConfig;\n\n    // 1. Create FreeSWITCH SIP trunk\n    const sipTrunk = this.generateSipTrunk(fullTrunk);\n    await this.createFreeSwitchSipTrunk(sipTrunk);\n\n    // 2. Create FusionPBX trunk record\n    await this.createFusionPBXTrunk(fullTrunk);\n\n    return fullTrunk;\n  }\n\n  async updateSipTrunk(trunkId: string, trunk: Partial<SipTrunkConfig>): Promise<SipTrunkConfig> {\n    // 1. Update FreeSWITCH SIP trunk\n    const sipTrunk = this.generateSipTrunk(trunk as SipTrunkConfig);\n    await this.updateFreeSwitchSipTrunk(trunkId, sipTrunk);\n\n    // 2. Update FusionPBX record\n    await this.updateFusionPBXTrunk(trunkId, trunk);\n\n    return trunk as SipTrunkConfig;\n  }\n\n  async deleteSipTrunk(trunkId: string): Promise<void> {\n    // 1. Delete FreeSWITCH SIP trunk\n    await this.deleteFreeSwitchSipTrunk(trunkId);\n\n    // 2. Delete FusionPBX record\n    await this.deleteFusionPBXTrunk(trunkId);\n  }\n\n  // ===== OPENSIPS ROUTES =====\n  async createOpenSipsRoute(route: OpenSipsRoute): Promise<OpenSipsRoute> {\n    // 1. Create OpenSIPS routing rule\n    const openSipsRule = this.generateOpenSipsRule(route);\n    await this.createOpenSipsRule(openSipsRule);\n\n    // 2. Create database record\n    await this.createOpenSipsRouteRecord(route);\n\n    return route;\n  }\n\n  async updateOpenSipsRoute(routeId: string, route: Partial<OpenSipsRoute>): Promise<OpenSipsRoute> {\n    // 1. Update OpenSIPS routing rule\n    const openSipsRule = this.generateOpenSipsRule(route as OpenSipsRoute);\n    await this.updateOpenSipsRule(routeId, openSipsRule);\n\n    // 2. Update database record\n    await this.updateOpenSipsRouteRecord(routeId, route);\n\n    return route as OpenSipsRoute;\n  }\n\n  async deleteOpenSipsRoute(routeId: string): Promise<void> {\n    // 1. Delete OpenSIPS routing rule\n    await this.deleteOpenSipsRule(routeId);\n\n    // 2. Delete database record\n    await this.deleteOpenSipsRouteRecord(routeId);\n  }\n\n  // ===== GENERATORS =====\n  private generateInboundDialplan(route: InboundRoute): any {\n    const context = 'from-trunk';\n    const extension = route.did_number;\n    \n    let condition = `destination_number = ${extension}`;\n    if (route.caller_id_number) {\n      condition += ` & caller_id_number = ${route.caller_id_number}`;\n    }\n\n    let action = '';\n    switch (route.destination_type) {\n      case 'extension':\n        action = `bridge(user/${route.destination_value}@\\${domain_name})`;\n        break;\n      case 'ring_group':\n        action = `bridge(loopback/${route.destination_value}@\\${domain_name})`;\n        break;\n      case 'queue':\n        action = `bridge(loopback/${route.destination_value}@\\${domain_name})`;\n        break;\n      case 'ivr':\n        action = `bridge(loopback/${route.destination_value}@\\${domain_name})`;\n        break;\n      case 'conference':\n        action = `conference(${route.destination_value}@default)`;\n        break;\n      case 'voicemail':\n        action = `voicemail(${route.destination_value}@\\${domain_name})`;\n        break;\n      case 'external':\n        action = `bridge(sofia/gateway/${route.destination_value}/\\${destination_number})`;\n        break;\n    }\n\n    if (route.record_calls) {\n      action += ` & record_session(\\${recordings_dir}/\\${uuid}.wav)`;\n    }\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: route.enabled\n    };\n  }\n\n  private generateOutboundDialplan(route: OutboundRoute): any {\n    const context = 'from-internal';\n    const extension = route.dial_pattern;\n    \n    const condition = `destination_number = ${extension}`;\n    \n    let action = `bridge(sofia/gateway/${route.trunk_id}/\\${destination_number})`;\n    \n    if (route.prefix) {\n      action = `bridge(sofia/gateway/${route.trunk_id}/${route.prefix}\\${destination_number})`;\n    }\n    \n    if (route.strip_digits > 0) {\n      action = `set(destination_number=\\${destination_number:${route.strip_digits}}) & ${action}`;\n    }\n\n    if (route.record_calls) {\n      action += ` & record_session(\\${recordings_dir}/\\${uuid}.wav)`;\n    }\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: route.enabled\n    };\n  }\n\n  private generateTimeCondition(condition: TimeCondition): any {\n    const timeCondition = {\n      name: condition.name,\n      timezone: condition.timezone,\n      business_hours: condition.business_hours,\n      holidays: condition.holidays,\n      business_hours_action: condition.business_hours_action,\n      after_hours_action: condition.after_hours_action,\n      holiday_action: condition.holiday_action,\n      enabled: condition.enabled\n    };\n\n    return timeCondition;\n  }\n\n  private generateIvrApplication(menu: IvrMenu): any {\n    const ivrApplication = {\n      name: menu.name,\n      greeting_message: menu.greeting_message,\n      invalid_message: menu.invalid_message,\n      timeout_message: menu.timeout_message,\n      timeout_seconds: menu.timeout_seconds,\n      max_failures: menu.max_failures,\n      options: menu.options,\n      default_action: menu.default_action,\n      default_destination: menu.default_destination,\n      enabled: menu.enabled\n    };\n\n    return ivrApplication;\n  }\n\n  private generateIvrDialplan(menu: IvrMenu): any {\n    const context = 'from-internal';\n    const extension = menu.name;\n    \n    const condition = `destination_number = ${extension}`;\n    const action = `ivr(${menu.name})`;\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: menu.enabled\n    };\n  }\n\n  private generateRingGroupApplication(group: RingGroup): any {\n    const ringGroupApplication = {\n      name: group.name,\n      extension_number: group.extension_number,\n      strategy: group.strategy,\n      timeout: group.timeout,\n      max_calls: group.max_calls,\n      members: group.members,\n      enabled: group.enabled\n    };\n\n    return ringGroupApplication;\n  }\n\n  private generateRingGroupDialplan(group: RingGroup): any {\n    const context = 'from-internal';\n    const extension = group.extension_number;\n    \n    const condition = `destination_number = ${extension}`;\n    \n    let action = '';\n    switch (group.strategy) {\n      case 'simultaneous':\n        action = `bridge(loopback/${group.extension_number}@\\${domain_name})`;\n        break;\n      case 'sequential':\n        action = `bridge(loopback/${group.extension_number}@\\${domain_name})`;\n        break;\n      case 'sequential':\n        action = `bridge(loopback/${group.extension_number}@\\${domain_name})`;\n        break;\n      default:\n        action = `bridge(loopback/${group.extension_number}@\\${domain_name})`;\n    }\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: group.enabled\n    };\n  }\n\n  private generateQueueApplication(queue: Queue): any {\n    const queueApplication = {\n      name: queue.name,\n      extension_number: queue.extension_number,\n      strategy: queue.strategy,\n      timeout: queue.timeout,\n      max_calls: queue.max_calls,\n      hold_music: queue.hold_music,\n      announce_frequency: queue.announce_frequency,\n      announce_position: queue.announce_position,\n      announce_hold_time: queue.announce_hold_time,\n      agents: queue.agents,\n      enabled: queue.enabled\n    };\n\n    return queueApplication;\n  }\n\n  private generateQueueDialplan(queue: Queue): any {\n    const context = 'from-internal';\n    const extension = queue.extension_number;\n    \n    const condition = `destination_number = ${extension}`;\n    const action = `queue(${queue.name})`;\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: queue.enabled\n    };\n  }\n\n  private generateConferenceRoom(room: ConferenceRoom): any {\n    const conferenceRoom = {\n      name: room.name,\n      extension_number: room.extension_number,\n      pin: room.pin,\n      moderator_pin: room.moderator_pin,\n      max_members: room.max_members,\n      record_conference: room.record_conference,\n      mute_on_join: room.mute_on_join,\n      announce_join_leave: room.announce_join_leave,\n      hold_music: room.hold_music,\n      enabled: room.enabled\n    };\n\n    return conferenceRoom;\n  }\n\n  private generateConferenceDialplan(room: ConferenceRoom): any {\n    const context = 'from-internal';\n    const extension = room.extension_number;\n    \n    const condition = `destination_number = ${extension}`;\n    const action = `conference(${room.extension_number}@default)`;\n\n    return {\n      context,\n      extension,\n      condition,\n      action,\n      anti_action: '',\n      enabled: room.enabled\n    };\n  }\n\n  private generateVoicemailBox(box: VoicemailBox): any {\n    const voicemailBox = {\n      extension_number: box.extension_number,\n      password: box.password,\n      display_name: box.display_name,\n      email_address: box.email_address,\n      max_messages: box.max_messages,\n      max_message_length: box.max_message_length,\n      delete_after_email: box.delete_after_email,\n      attach_audio: box.attach_audio,\n      email_notification: box.email_notification,\n      greeting_type: box.greeting_type,\n      custom_greeting_path: box.custom_greeting_path,\n      enabled: box.enabled\n    };\n\n    return voicemailBox;\n  }\n\n  private generateSipExtension(extension: SipExtensionConfig): any {\n    const sipExtension = {\n      extension: extension.extension,\n      password: extension.password,\n      display_name: extension.display_name,\n      sip_settings: extension.sip_settings,\n      call_features: extension.call_features,\n      security: extension.security,\n      advanced: extension.advanced\n    };\n\n    return sipExtension;\n  }\n\n  private generateSipTrunk(trunk: SipTrunkConfig): any {\n    const sipTrunk = {\n      name: trunk.name,\n      host: trunk.host,\n      port: trunk.port,\n      username: trunk.username,\n      password: trunk.password,\n      from_user: trunk.from_user,\n      from_domain: trunk.from_domain,\n      sip_settings: trunk.sip_settings,\n      registration: trunk.registration,\n      security: trunk.security,\n      advanced: trunk.advanced\n    };\n\n    return sipTrunk;\n  }\n\n  private generateOpenSipsRule(route: OpenSipsRoute): any {\n    const openSipsRule = {\n      name: route.name,\n      priority: route.priority,\n      conditions: route.conditions,\n      actions: route.actions,\n      enabled: route.enabled\n    };\n\n    return openSipsRule;\n  }\n\n  // ===== FREESWITCH API CALLS =====\n  private async createFreeSwitchDialplan(extension: any): Promise<void> {\n    // Implementation for FreeSWITCH ESL API\n    console.log('Creating FreeSWITCH dialplan:', extension);\n  }\n\n  private async updateFreeSwitchDialplan(extensionId: string, extension: any): Promise<void> {\n    console.log('Updating FreeSWITCH dialplan:', extensionId, extension);\n  }\n\n  private async deleteFreeSwitchDialplan(extensionId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH dialplan:', extensionId);\n  }\n\n  private async createFreeSwitchTimeCondition(condition: any): Promise<void> {\n    console.log('Creating FreeSWITCH time condition:', condition);\n  }\n\n  private async updateFreeSwitchTimeCondition(conditionId: string, condition: any): Promise<void> {\n    console.log('Updating FreeSWITCH time condition:', conditionId, condition);\n  }\n\n  private async deleteFreeSwitchTimeCondition(conditionId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH time condition:', conditionId);\n  }\n\n  private async createFreeSwitchIvrApplication(application: any): Promise<void> {\n    console.log('Creating FreeSWITCH IVR application:', application);\n  }\n\n  private async updateFreeSwitchIvrApplication(applicationId: string, application: any): Promise<void> {\n    console.log('Updating FreeSWITCH IVR application:', applicationId, application);\n  }\n\n  private async deleteFreeSwitchIvrApplication(applicationId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH IVR application:', applicationId);\n  }\n\n  private async createFreeSwitchRingGroupApplication(application: any): Promise<void> {\n    console.log('Creating FreeSWITCH ring group application:', application);\n  }\n\n  private async updateFreeSwitchRingGroupApplication(applicationId: string, application: any): Promise<void> {\n    console.log('Updating FreeSWITCH ring group application:', applicationId, application);\n  }\n\n  private async deleteFreeSwitchRingGroupApplication(applicationId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH ring group application:', applicationId);\n  }\n\n  private async createFreeSwitchQueueApplication(application: any): Promise<void> {\n    console.log('Creating FreeSWITCH queue application:', application);\n  }\n\n  private async updateFreeSwitchQueueApplication(applicationId: string, application: any): Promise<void> {\n    console.log('Updating FreeSWITCH queue application:', applicationId, application);\n  }\n\n  private async deleteFreeSwitchQueueApplication(applicationId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH queue application:', applicationId);\n  }\n\n  private async createFreeSwitchConferenceRoom(room: any): Promise<void> {\n    console.log('Creating FreeSWITCH conference room:', room);\n  }\n\n  private async updateFreeSwitchConferenceRoom(roomId: string, room: any): Promise<void> {\n    console.log('Updating FreeSWITCH conference room:', roomId, room);\n  }\n\n  private async deleteFreeSwitchConferenceRoom(roomId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH conference room:', roomId);\n  }\n\n  private async createFreeSwitchVoicemailBox(box: any): Promise<void> {\n    console.log('Creating FreeSWITCH voicemail box:', box);\n  }\n\n  private async updateFreeSwitchVoicemailBox(boxId: string, box: any): Promise<void> {\n    console.log('Updating FreeSWITCH voicemail box:', boxId, box);\n  }\n\n  private async deleteFreeSwitchVoicemailBox(boxId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH voicemail box:', boxId);\n  }\n\n  private async createFreeSwitchSipExtension(extension: any): Promise<void> {\n    console.log('Creating FreeSWITCH SIP extension:', extension);\n  }\n\n  private async updateFreeSwitchSipExtension(extensionId: string, extension: any): Promise<void> {\n    console.log('Updating FreeSWITCH SIP extension:', extensionId, extension);\n  }\n\n  private async deleteFreeSwitchSipExtension(extensionId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH SIP extension:', extensionId);\n  }\n\n  private async createFreeSwitchSipTrunk(trunk: any): Promise<void> {\n    console.log('Creating FreeSWITCH SIP trunk:', trunk);\n  }\n\n  private async updateFreeSwitchSipTrunk(trunkId: string, trunk: any): Promise<void> {\n    console.log('Updating FreeSWITCH SIP trunk:', trunkId, trunk);\n  }\n\n  private async deleteFreeSwitchSipTrunk(trunkId: string): Promise<void> {\n    console.log('Deleting FreeSWITCH SIP trunk:', trunkId);\n  }\n\n  // ===== FUSIONPBX API CALLS =====\n  private async createFusionPBXInboundRoute(route: InboundRoute): Promise<void> {\n    console.log('Creating FusionPBX inbound route:', route);\n  }\n\n  private async updateFusionPBXInboundRoute(routeId: string, route: Partial<InboundRoute>): Promise<void> {\n    console.log('Updating FusionPBX inbound route:', routeId, route);\n  }\n\n  private async deleteFusionPBXInboundRoute(routeId: string): Promise<void> {\n    console.log('Deleting FusionPBX inbound route:', routeId);\n  }\n\n  private async createFusionPBXOutboundRoute(route: OutboundRoute): Promise<void> {\n    console.log('Creating FusionPBX outbound route:', route);\n  }\n\n  private async updateFusionPBXOutboundRoute(routeId: string, route: Partial<OutboundRoute>): Promise<void> {\n    console.log('Updating FusionPBX outbound route:', routeId, route);\n  }\n\n  private async deleteFusionPBXOutboundRoute(routeId: string): Promise<void> {\n    console.log('Deleting FusionPBX outbound route:', routeId);\n  }\n\n  private async createFusionPBXTimeCondition(condition: TimeCondition): Promise<void> {\n    console.log('Creating FusionPBX time condition:', condition);\n  }\n\n  private async updateFusionPBXTimeCondition(conditionId: string, condition: Partial<TimeCondition>): Promise<void> {\n    console.log('Updating FusionPBX time condition:', conditionId, condition);\n  }\n\n  private async deleteFusionPBXTimeCondition(conditionId: string): Promise<void> {\n    console.log('Deleting FusionPBX time condition:', conditionId);\n  }\n\n  private async createFusionPBXIvrMenu(menu: IvrMenu): Promise<void> {\n    console.log('Creating FusionPBX IVR menu:', menu);\n  }\n\n  private async updateFusionPBXIvrMenu(menuId: string, menu: Partial<IvrMenu>): Promise<void> {\n    console.log('Updating FusionPBX IVR menu:', menuId, menu);\n  }\n\n  private async deleteFusionPBXIvrMenu(menuId: string): Promise<void> {\n    console.log('Deleting FusionPBX IVR menu:', menuId);\n  }\n\n  private async createFusionPBXRingGroup(group: RingGroup): Promise<void> {\n    console.log('Creating FusionPBX ring group:', group);\n  }\n\n  private async updateFusionPBXRingGroup(groupId: string, group: Partial<RingGroup>): Promise<void> {\n    console.log('Updating FusionPBX ring group:', groupId, group);\n  }\n\n  private async deleteFusionPBXRingGroup(groupId: string): Promise<void> {\n    console.log('Deleting FusionPBX ring group:', groupId);\n  }\n\n  private async createFusionPBXQueue(queue: Queue): Promise<void> {\n    console.log('Creating FusionPBX queue:', queue);\n  }\n\n  private async updateFusionPBXQueue(queueId: string, queue: Partial<Queue>): Promise<void> {\n    console.log('Updating FusionPBX queue:', queueId, queue);\n  }\n\n  private async deleteFusionPBXQueue(queueId: string): Promise<void> {\n    console.log('Deleting FusionPBX queue:', queueId);\n  }\n\n  private async createFusionPBXConferenceRoom(room: ConferenceRoom): Promise<void> {\n    console.log('Creating FusionPBX conference room:', room);\n  }\n\n  private async updateFusionPBXConferenceRoom(roomId: string, room: Partial<ConferenceRoom>): Promise<void> {\n    console.log('Updating FusionPBX conference room:', roomId, room);\n  }\n\n  private async deleteFusionPBXConferenceRoom(roomId: string): Promise<void> {\n    console.log('Deleting FusionPBX conference room:', roomId);\n  }\n\n  private async createFusionPBXVoicemailBox(box: VoicemailBox): Promise<void> {\n    console.log('Creating FusionPBX voicemail box:', box);\n  }\n\n  private async updateFusionPBXVoicemailBox(boxId: string, box: Partial<VoicemailBox>): Promise<void> {\n    console.log('Updating FusionPBX voicemail box:', boxId, box);\n  }\n\n  private async deleteFusionPBXVoicemailBox(boxId: string): Promise<void> {\n    console.log('Deleting FusionPBX voicemail box:', boxId);\n  }\n\n  private async createFusionPBXExtension(extension: SipExtensionConfig): Promise<void> {\n    console.log('Creating FusionPBX extension:', extension);\n  }\n\n  private async updateFusionPBXExtension(extensionId: string, extension: Partial<SipExtensionConfig>): Promise<void> {\n    console.log('Updating FusionPBX extension:', extensionId, extension);\n  }\n\n  private async deleteFusionPBXExtension(extensionId: string): Promise<void> {\n    console.log('Deleting FusionPBX extension:', extensionId);\n  }\n\n  private async createFusionPBXTrunk(trunk: SipTrunkConfig): Promise<void> {\n    console.log('Creating FusionPBX trunk:', trunk);\n  }\n\n  private async updateFusionPBXTrunk(trunkId: string, trunk: Partial<SipTrunkConfig>): Promise<void> {\n    console.log('Updating FusionPBX trunk:', trunkId, trunk);\n  }\n\n  private async deleteFusionPBXTrunk(trunkId: string): Promise<void> {\n    console.log('Deleting FusionPBX trunk:', trunkId);\n  }\n\n  // ===== OPENSIPS API CALLS =====\n  private async createOpenSipsRule(rule: any): Promise<void> {\n    console.log('Creating OpenSIPS rule:', rule);\n  }\n\n  private async updateOpenSipsRule(ruleId: string, rule: any): Promise<void> {\n    console.log('Updating OpenSIPS rule:', ruleId, rule);\n  }\n\n  private async deleteOpenSipsRule(ruleId: string): Promise<void> {\n    console.log('Deleting OpenSIPS rule:', ruleId);\n  }\n\n  private async createOpenSipsRouteRecord(route: OpenSipsRoute): Promise<void> {\n    console.log('Creating OpenSIPS route record:', route);\n  }\n\n  private async updateOpenSipsRouteRecord(routeId: string, route: Partial<OpenSipsRoute>): Promise<void> {\n    console.log('Updating OpenSIPS route record:', routeId, route);\n  }\n\n  private async deleteOpenSipsRouteRecord(routeId: string): Promise<void> {\n    console.log('Deleting OpenSIPS route record:', routeId);\n  }\n\n  // ===== UTILITY METHODS =====\n  private async linkTimeCondition(routeId: string, timeConditionId: string): Promise<void> {\n    console.log('Linking time condition:', routeId, timeConditionId);\n  }\n}\n","size_bytes":47534},"packages/backend/test-env.js":{"content":"console.log(\"DATABASE_URL:\", process.env.DATABASE_URL);\r\nconsole.log(\"NODE_ENV:\", process.env.NODE_ENV);\r\n","size_bytes":106},"packages/backend/src/services/index.ts":{"content":"// Export all services\nexport * from './tenant.service';\nexport * from './store.service';\nexport * from './extension.service';\nexport * from './freeswitch.service';\nexport * from './cdr.service';\n","size_bytes":196},"packages/frontend/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }","size_bytes":1138},"packages/frontend/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\r\n\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n\r\n","size_bytes":798},"packages/backend/src/routes/freeswitch-xml.routes.ts":{"content":"import { Router } from 'express';\nimport { freeSwitchXmlService } from '../services/freeswitch-xml.service';\n\nconst router = Router();\n\nrouter.get('/xml', async (req, res) => {\n  try {\n    console.log('FreeSWITCH XML GET Request:', req.query);\n    const params: any = { ...req.query };\n    const xml = await freeSwitchXmlService.processXmlRequest(params);\n    res.setHeader('Content-Type', 'application/xml');\n    res.send(xml);\n  } catch (error) {\n    console.error('FreeSWITCH XML GET error:', error);\n    res.setHeader('Content-Type', 'application/xml');\n    res.status(500).send('<document type=\" freeswitch/xml\\><section name=\\result\\><result status=\\error\\/></section></document>');\n }\n});\n\nrouter.post('/xml', async (req, res) => {\n try {\n console.log('FreeSWITCH XML POST Request:', { body: req.body, query: req.query });\n const params: any = { ...req.body, ...req.query };\n const xml = await freeSwitchXmlService.processXmlRequest(params);\n res.setHeader('Content-Type', 'application/xml');\n res.send(xml);\n } catch (error) {\n console.error('FreeSWITCH XML POST error:', error);\n res.setHeader('Content-Type', 'application/xml');\n res.status(500).send('<document type=\\freeswitch/xml\\><section name=\\result\\><result status=\\error\\/></section></document>');\n }\n});\n\nexport default router;\n","size_bytes":1297},"packages/frontend/src/components/layout/Layout.tsx":{"content":"import { ReactNode, useState, useEffect } from 'react';\nimport Sidebar from './Sidebar';\nimport Header from './Header';\nimport SuperAdminHeader from './SuperAdminHeader';\nimport { cn } from '@/lib/utils';\n\ninterface LayoutProps {\n  children: ReactNode;\n  variant?: 'tenant' | 'superadmin';\n}\n\nexport default function Layout({ children, variant = 'tenant' }: LayoutProps) {\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n\n  // Listen for sidebar state changes\n  useEffect(() => {\n    const handleSidebarStateChange = (event: CustomEvent) => {\n      setSidebarCollapsed(event.detail.collapsed);\n    };\n\n    window.addEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\n    return () => {\n      window.removeEventListener('sidebar-state-change', handleSidebarStateChange as EventListener);\n    };\n  }, []);\n\n  if (variant === 'superadmin') {\n    return (\n      <div className=\"h-screen bg-gradient-to-br from-slate-50 via-blue-50/30 to-slate-100 dark:from-slate-950 dark:via-blue-950/30 dark:to-slate-900 overflow-hidden\">\n        <div className=\"flex flex-col h-full\">\n          <SuperAdminHeader />\n          <main className=\"flex-1 p-6 overflow-y-auto\">\n            {children}\n          </main>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"h-screen bg-gradient-to-br from-slate-50 via-blue-50/30 to-slate-100 dark:from-slate-950 dark:via-blue-950/30 dark:to-slate-900 overflow-hidden\">\n      <div className=\"flex h-full\">\n        <Sidebar />\n        <div \n          className={cn(\n            \"flex-1 flex flex-col h-full overflow-hidden transition-all duration-300 ease-smooth\",\n            \"min-w-0\", // Prevents content overflow\n            sidebarCollapsed ? \"ml-16\" : \"ml-64\"\n          )}\n          style={{\n            width: sidebarCollapsed ? 'calc(100% - 4rem)' : 'calc(100% - 16rem)',\n            maxWidth: sidebarCollapsed ? 'calc(100vw - 4rem)' : 'calc(100vw - 16rem)'\n          }}\n        >\n          <Header />\n          <main className=\"flex-1 p-6 overflow-y-auto\">\n            {children}\n          </main>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":2143},"packages/backend/test-extension-service.js":{"content":"const { ExtensionService } = require('./dist/services/extension.service');\r\n\r\nasync function testExtensionService() {\r\n  console.log('Testing ExtensionService...');\r\n  try {\r\n    const service = new ExtensionService();\r\n    console.log('ExtensionService created successfully');\r\n    \r\n    // Test listExtensions\r\n    const result = await service.listExtensions('32af8555-5511-40d6-be35-443dcebafefb', null, 1, 10);\r\n    console.log('listExtensions result:', result);\r\n    \r\n  } catch (error) {\r\n    console.error('Error testing ExtensionService:', error);\r\n  }\r\n}\r\n\r\ntestExtensionService();\r\n","size_bytes":592},"packages/frontend/public/sw.js":{"content":"// Service Worker for blocking extension requests\r\nself.addEventListener('fetch', function(event) {\r\n  const url = event.request.url;\r\n  \r\n  // Block all chrome-extension requests\r\n  if (url.includes('chrome-extension://') || \r\n      url.includes('pejdijmoenmkgeppbflobdenhhabjlaj') ||\r\n      url.includes('completion_list.html') ||\r\n      url.includes('utils.js') ||\r\n      url.includes('extensionState.js') ||\r\n      url.includes('heuristicsRedefinitions.js')) {\r\n    \r\n    console.log('🚫 Blocked extension request:', url);\r\n    \r\n    // Return a 404 response to prevent the error\r\n    event.respondWith(\r\n      new Response('', {\r\n        status: 404,\r\n        statusText: 'Not Found',\r\n        headers: {\r\n          'Content-Type': 'text/plain'\r\n        }\r\n      })\r\n    );\r\n    return;\r\n  }\r\n  \r\n  // Allow all other requests to proceed normally\r\n  event.respondWith(fetch(event.request));\r\n});\r\n\r\n// Handle service worker installation\r\nself.addEventListener('install', function(event) {\r\n  console.log('🛡️ Extension blocking service worker installed');\r\n  self.skipWaiting();\r\n});\r\n\r\n// Handle service worker activation\r\nself.addEventListener('activate', function(event) {\r\n  console.log('🛡️ Extension blocking service worker activated');\r\n  event.waitUntil(self.clients.claim());\r\n});","size_bytes":1304},"packages/frontend/src/contexts/AuthContext.tsx":{"content":"import React, { createContext, useContext, useEffect, useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport apiClient from '@/lib/api';\nimport SessionTimeout from '@/components/SessionTimeout';\n\nexport interface User {\n  id: string;\n  email: string;\n  firstName: string;\n  lastName: string;\n  tenantId: string | null;\n  tenantSlug: string;\n  tenantName?: string;\n  role: 'super_admin' | 'tenant_admin' | 'user';\n  iat?: number;\n  exp?: number;\n}\n\nexport interface AuthState {\n  user: User | null;\n  token: string | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n}\n\ninterface AuthContextType extends AuthState {\n  login: (token: string) => Promise<void>;\n  logout: () => void;\n  refreshToken: () => Promise<boolean>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [authState, setAuthState] = useState<AuthState>({\n    user: null,\n    token: null,\n    isAuthenticated: false,\n    isLoading: true,\n  });\n  \n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // Initialize auth state from localStorage\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    const userData = localStorage.getItem('user');\n    \n    if (token && userData) {\n      try {\n        // Check if token is a valid JWT format\n        if (token.split('.').length !== 3) {\n          throw new Error('Invalid token format');\n        }\n        \n        // Parse user data from localStorage\n        const user: User = JSON.parse(userData);\n\n        // Check if token is expired\n        const payload = JSON.parse(atob(token.split('.')[1]));\n        if (payload.exp && payload.exp * 1000 < Date.now()) {\n          localStorage.removeItem('token');\n          localStorage.removeItem('user');\n          apiClient.clearToken();\n          setAuthState({\n            user: null,\n            token: null,\n            isAuthenticated: false,\n            isLoading: false,\n          });\n        } else {\n          // Set token in API client\n          apiClient.setToken(token);\n          setAuthState({\n            user,\n            token,\n            isAuthenticated: true,\n            isLoading: false,\n          });\n        }\n      } catch (error) {\n        console.error('Invalid token:', error);\n        localStorage.removeItem('token');\n        localStorage.removeItem('user');\n        apiClient.clearToken();\n        setAuthState({\n          user: null,\n          token: null,\n          isAuthenticated: false,\n          isLoading: false,\n        });\n      }\n    } else {\n      apiClient.clearToken();\n      setAuthState({\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        isLoading: false,\n      });\n    }\n  }, []);\n\n  // Sync token with API client whenever auth state changes\n  useEffect(() => {\n    if (authState.token) {\n      apiClient.setToken(authState.token);\n    } else {\n      apiClient.clearToken();\n    }\n  }, [authState.token]);\n\n  // Session timeout management - 15 minutes\n  useEffect(() => {\n    if (!authState.isAuthenticated || !authState.token) return;\n\n    const checkTokenExpiry = () => {\n      try {\n        const payload = JSON.parse(atob(authState.token!.split('.')[1]));\n        const now = Date.now();\n        const tokenExpiry = payload.exp * 1000;\n        const sessionTimeout = 15 * 60 * 1000; // 15 minutes in milliseconds\n        \n        // Check if token is expired or session timeout reached\n        if (tokenExpiry < now || (payload.iat * 1000 + sessionTimeout) < now) {\n          console.log('Session expired - logging out');\n          logout();\n          // Redirect to login page\n          navigate('/login');\n        }\n      } catch (error) {\n        console.error('Error checking token expiry:', error);\n        logout();\n        navigate('/login');\n      }\n    };\n\n    // Check immediately\n    checkTokenExpiry();\n\n    // Set up interval to check every minute\n    const interval = setInterval(checkTokenExpiry, 60 * 1000);\n\n    return () => clearInterval(interval);\n  }, [authState.isAuthenticated, authState.token, navigate]);\n\n  // Handle navigation based on auth state - removed automatic redirects for multi-tenant\n\n  const login = async (token: string) => {\n    try {\n      // Check if token is a valid JWT format\n      if (!token || typeof token !== 'string' || token.split('.').length !== 3) {\n        throw new Error('Invalid token format');\n      }\n      \n      const payload = JSON.parse(atob(token.split('.')[1]));\n      const user: User = {\n        id: payload.id || payload.userId,\n        email: payload.email,\n        firstName: payload.firstName || '',\n        lastName: payload.lastName || '',\n        tenantId: payload.tenant_id || payload.tenantId,\n        tenantSlug: payload.role === 'super_admin' ? 'edgvoip' : (payload.tenant_slug || payload.tenantSlug),\n        role: payload.role,\n        iat: payload.iat,\n        exp: payload.exp,\n      };\n\n      localStorage.setItem('token', token);\n      localStorage.setItem('user', JSON.stringify(user));\n      \n      // Set token in API client\n      apiClient.setToken(token);\n      \n      setAuthState({\n        user,\n        token,\n        isAuthenticated: true,\n        isLoading: false,\n      });\n    } catch (error) {\n      console.error('Invalid token:', error);\n      // Clear any invalid token\n      localStorage.removeItem('token');\n      localStorage.removeItem('user');\n      apiClient.clearToken();\n      throw new Error('Invalid token');\n    }\n  };\n\n  const logout = () => {\n    localStorage.removeItem('token');\n    localStorage.removeItem('user');\n    apiClient.clearToken();\n    setAuthState({\n      user: null,\n      token: null,\n      isAuthenticated: false,\n      isLoading: false,\n    });\n  };\n\n  const refreshToken = async () => {\n    if (!authState.token) return false;\n\n    try {\n      // Check if token is a valid JWT format\n      if (authState.token.split('.').length !== 3) {\n        logout();\n        return false;\n      }\n      \n      // In a real implementation, you would call a refresh endpoint\n      // For now, we'll just check if the current token is still valid\n      const payload = JSON.parse(atob(authState.token.split('.')[1]));\n      if (payload.exp && payload.exp * 1000 < Date.now()) {\n        logout();\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      logout();\n      return false;\n    }\n  };\n\n  // Calculate session expiry time\n  const getSessionExpiry = () => {\n    if (!authState.token) return 0;\n    try {\n      const payload = JSON.parse(atob(authState.token.split('.')[1]));\n      return payload.iat * 1000 + (15 * 60 * 1000); // 15 minutes from login time\n    } catch {\n      return 0;\n    }\n  };\n\n  return (\n    <AuthContext.Provider\n      value={{\n        ...authState,\n        login,\n        logout,\n        refreshToken,\n      }}\n    >\n      {children}\n      {authState.isAuthenticated && (\n        <SessionTimeout\n          expiresAt={getSessionExpiry()}\n          onLogout={() => {\n            logout();\n            navigate('/login');\n          }}\n        />\n      )}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n","size_bytes":7437},"packages/frontend/src/hooks/use-voip-entities.ts":{"content":"import { useState, useEffect } from 'react';\nimport apiClient from '@/lib/api';\n\nexport interface VoipEntity {\n  id: string;\n  name: string;\n  extension_number?: string;\n  description?: string;\n}\n\nexport interface UseVoipEntitiesOptions {\n  store_id?: string;\n  search?: string;\n}\n\nexport function useVoipEntities(entityType: 'extensions' | 'ring-groups' | 'queues' | 'conference-rooms' | 'voicemail-boxes' | 'ivr-menus' | 'time-conditions' | 'sip-trunks', options?: UseVoipEntitiesOptions) {\n  const [entities, setEntities] = useState<VoipEntity[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchEntities = async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      let response;\n      switch (entityType) {\n        case 'extensions':\n          response = await apiClient.getExtensions(options);\n          break;\n        case 'ring-groups':\n          response = await apiClient.getRingGroups(options);\n          break;\n        case 'queues':\n          response = await apiClient.getQueues(options);\n          break;\n        case 'conference-rooms':\n          response = await apiClient.getConferenceRooms(options);\n          break;\n        case 'voicemail-boxes':\n          response = await apiClient.getVoicemailBoxes(options);\n          break;\n        case 'ivr-menus':\n          response = await apiClient.getIvrMenus(options);\n          break;\n        case 'time-conditions':\n          response = await apiClient.getTimeConditions(options);\n          break;\n        case 'sip-trunks':\n          response = await apiClient.getSipTrunks(options);\n          break;\n        default:\n          throw new Error(`Unknown entity type: ${entityType}`);\n      }\n      \n      setEntities((response.data as VoipEntity[]) || []);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch entities');\n      setEntities([]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchEntities();\n  }, [entityType, options?.store_id, options?.search]);\n\n  return {\n    entities,\n    isLoading,\n    error,\n    refetch: fetchEntities\n  };\n}\n\n// Hook specifico per le opzioni dei select\nexport function useVoipEntityOptions(entityType: 'extensions' | 'ring-groups' | 'queues' | 'conference-rooms' | 'voicemail-boxes' | 'ivr-menus' | 'time-conditions', store_id?: string) {\n  const { entities, isLoading, error } = useVoipEntities(entityType, { store_id });\n  \n  const options = entities.map(entity => ({\n    value: entity.id,\n    label: entity.extension_number ? `${entity.name} (${entity.extension_number})` : entity.name,\n    description: entity.description\n  }));\n\n  return {\n    options,\n    isLoading,\n    error\n  };\n}\n","size_bytes":2775},"packages/frontend/src/pages/Logs.tsx":{"content":"import { useState, useEffect, useRef } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport { Switch } from '@/components/ui/switch';\nimport { \n  Terminal,\n  Play,\n  Pause,\n  RotateCcw,\n  Download,\n  Search,\n  Eye,\n  AlertCircle,\n  Info,\n  XCircle,\n  RefreshCw,\n  Settings,\n  Clock,\n  Activity\n} from 'lucide-react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { apiClient } from '@/lib/api';\n\ninterface LogEntry {\n  id: string;\n  timestamp: string;\n  level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';\n  component: string;\n  message: string;\n  tenant_id?: string;\n  source: 'freeswitch' | 'backend' | 'frontend';\n}\n\ninterface LogStats {\n  total: number;\n  errors: number;\n  warnings: number;\n  last_update: string;\n}\n\nexport default function Logs() {\n  const { user } = useAuth();\n  const [logs, setLogs] = useState<LogEntry[]>([]);\n  const [filteredLogs, setFilteredLogs] = useState<LogEntry[]>([]);\n  const [isLive, setIsLive] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedLevel, setSelectedLevel] = useState<string>('all');\n  const [selectedComponent, setSelectedComponent] = useState<string>('all');\n  const [selectedSource, setSelectedSource] = useState<string>('all');\n  const [autoScroll, setAutoScroll] = useState(true);\n  const [logStats, setLogStats] = useState<LogStats>({ total: 0, errors: 0, warnings: 0, last_update: '' });\n  const [activeTab, setActiveTab] = useState<'live' | 'search' | 'settings'>('live');\n  const logsEndRef = useRef<HTMLDivElement>(null);\n  const [settings, setSettings] = useState({\n    freeswitchLevel: 'info',\n    backendLevel: 'info',\n    maxLogs: '1000',\n    retention: '30',\n    sipTracing: true,\n    rtpCapture: true,\n    verboseDebugging: false\n  });\n\n\n  useEffect(() => {\n    loadInitialLogs();\n    loadSavedSettings();\n  }, []);\n\n  const loadSavedSettings = () => {\n    try {\n      const savedSettings = localStorage.getItem('logSettings');\n      if (savedSettings) {\n        setSettings(JSON.parse(savedSettings));\n      }\n    } catch (error) {\n      console.error('Error loading saved settings:', error);\n    }\n  };\n\n  useEffect(() => {\n    filterLogs();\n  }, [logs, searchTerm, selectedLevel, selectedComponent, selectedSource]);\n\n  useEffect(() => {\n    if (autoScroll) {\n      scrollToBottom();\n    }\n  }, [filteredLogs]);\n\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    if (isLive) {\n      interval = setInterval(() => {\n        addNewLog();\n      }, 2000);\n    }\n    return () => clearInterval(interval);\n  }, [isLive]);\n\n  const loadInitialLogs = async () => {\n    setIsLoading(true);\n    try {\n      // Load logs from API\n      const [systemResponse, statsResponse] = await Promise.allSettled([\n        apiClient.get('/logs/system?lines=100'),\n        apiClient.get('/logs/stats?lines=1000')\n      ]);\n\n      if (systemResponse.status === 'fulfilled' && (systemResponse.value.data as any)?.success) {\n        setLogs((systemResponse.value.data as any).logs);\n      } else {\n        // Fallback to sample logs if API fails\n        setLogs([]);\n      }\n\n      if (statsResponse.status === 'fulfilled' && (statsResponse.value.data as any)?.success) {\n        setLogStats((statsResponse.value.data as any).stats);\n      } else {\n        updateStats([]);\n      }\n    } catch (error) {\n      console.error('Error loading logs:', error);\n      // Fallback to sample logs\n      setLogs([]);\n      updateStats([]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const addNewLog = async () => {\n    try {\n      // Try to fetch new logs from API\n      const response = await apiClient.get('/logs/system?lines=10');\n      if ((response.data as any)?.success && (response.data as any)?.logs?.length > 0) {\n        const newLogs = (response.data as any).logs.filter((log: LogEntry) => \n          !logs.some(existingLog => existingLog.id === log.id)\n        );\n        if (newLogs.length > 0) {\n          setLogs(prev => [...newLogs, ...prev].slice(0, 1000)); // Keep last 1000 logs\n          return;\n        }\n      }\n    } catch (error) {\n      console.error('Error fetching new logs:', error);\n    }\n\n    // Fallback to sample log if API fails\n    const newLog: LogEntry = {\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      level: ['INFO', 'DEBUG', 'WARN', 'ERROR'][Math.floor(Math.random() * 4)] as any,\n      component: ['sofia', 'mod_dptools', 'api', 'auth'][Math.floor(Math.random() * 4)],\n      message: `Sample log message ${Date.now()}`,\n      source: ['freeswitch', 'backend'][Math.floor(Math.random() * 2)] as any,\n      tenant_id: user?.tenant_id || undefined\n    };\n    \n    setLogs(prev => [newLog, ...prev].slice(0, 1000)); // Keep last 1000 logs\n  };\n\n  const filterLogs = () => {\n    let filtered = logs;\n\n    if (searchTerm) {\n      filtered = filtered.filter(log => \n        log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||\n        log.component.toLowerCase().includes(searchTerm.toLowerCase())\n      );\n    }\n\n    if (selectedLevel !== 'all') {\n      filtered = filtered.filter(log => log.level === selectedLevel);\n    }\n\n    if (selectedComponent !== 'all') {\n      filtered = filtered.filter(log => log.component === selectedComponent);\n    }\n\n    if (selectedSource !== 'all') {\n      filtered = filtered.filter(log => log.source === selectedSource);\n    }\n\n    setFilteredLogs(filtered);\n  };\n\n  const updateStats = (logData: LogEntry[]) => {\n    const stats: LogStats = {\n      total: logData.length,\n      errors: logData.filter(log => log.level === 'ERROR' || log.level === 'CRITICAL').length,\n      warnings: logData.filter(log => log.level === 'WARN').length,\n      last_update: new Date().toLocaleString()\n    };\n    setLogStats(stats);\n  };\n\n  const scrollToBottom = () => {\n    logsEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  };\n\n  const getLevelIcon = (level: string) => {\n    switch (level) {\n      case 'ERROR':\n      case 'CRITICAL':\n        return <XCircle className=\"h-4 w-4 text-red-500\" />;\n      case 'WARN':\n        return <AlertCircle className=\"h-4 w-4 text-yellow-500\" />;\n      case 'INFO':\n        return <Info className=\"h-4 w-4 text-blue-500\" />;\n      case 'DEBUG':\n        return <Eye className=\"h-4 w-4 text-gray-500\" />;\n      default:\n        return <Info className=\"h-4 w-4 text-gray-500\" />;\n    }\n  };\n\n  const getLevelBadge = (level: string) => {\n    const colors = {\n      'CRITICAL': 'bg-red-100 text-red-800',\n      'ERROR': 'bg-red-100 text-red-800',\n      'WARN': 'bg-yellow-100 text-yellow-800',\n      'INFO': 'bg-blue-100 text-blue-800',\n      'DEBUG': 'bg-gray-100 text-gray-800'\n    };\n    \n    return (\n      <Badge className={`${colors[level as keyof typeof colors] || colors.DEBUG} text-xs`}>\n        {level}\n      </Badge>\n    );\n  };\n\n  const getSourceBadge = (source: string) => {\n    const colors = {\n      'freeswitch': 'bg-purple-100 text-purple-800',\n      'backend': 'bg-green-100 text-green-800',\n      'frontend': 'bg-blue-100 text-blue-800'\n    };\n    \n    return (\n      <Badge className={`${colors[source as keyof typeof colors] || colors.frontend} text-xs`}>\n        {source.toUpperCase()}\n      </Badge>\n    );\n  };\n\n  const handleRefresh = () => {\n    loadInitialLogs();\n  };\n\n  const handleDownload = () => {\n    const logText = filteredLogs.map(log => \n      `[${log.timestamp}] ${log.level} [${log.component}] ${log.message}`\n    ).join('\\n');\n    \n    const blob = new Blob([logText], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `voip-logs-${new Date().toISOString().split('T')[0]}.txt`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  const handleClearLogs = () => {\n    if (confirm('Are you sure you want to clear all logs?')) {\n      setLogs([]);\n      setFilteredLogs([]);\n      setLogStats({ total: 0, errors: 0, warnings: 0, last_update: new Date().toLocaleString() });\n    }\n  };\n\n  const handleSetLogLevel = async (level: string) => {\n    try {\n      const response = await apiClient.post('/logs/freeswitch/level', { level });\n      if ((response.data as any)?.success) {\n        console.log(`FreeSWITCH log level set to ${level}`);\n      }\n    } catch (error) {\n      console.error('Error setting log level:', error);\n    }\n  };\n\n  const handleSetSipTracing = async (enabled: boolean) => {\n    try {\n      const response = await apiClient.post('/logs/freeswitch/tracing', { enabled });\n      if ((response.data as any)?.success) {\n        console.log(`SIP tracing ${enabled ? 'enabled' : 'disabled'}`);\n      }\n    } catch (error) {\n      console.error('Error setting SIP tracing:', error);\n    }\n  };\n\n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-2xl font-bold text-gray-900\">Logs & Verbose</h1>\n          <p className=\"text-gray-600\">Monitor system logs and debugging information</p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <Button variant=\"outline\" onClick={handleRefresh} disabled={isLoading}>\n            <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />\n            Refresh\n          </Button>\n          <Button variant=\"outline\" onClick={handleDownload}>\n            <Download className=\"h-4 w-4 mr-2\" />\n            Download\n          </Button>\n          <Button variant=\"outline\" onClick={handleClearLogs} className=\"text-red-600 hover:text-red-700\">\n            <RotateCcw className=\"h-4 w-4 mr-2\" />\n            Clear\n          </Button>\n        </div>\n      </div>\n\n      {/* Stats Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n        <Card>\n          <CardContent className=\"p-4\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm font-medium text-gray-600\">Total Logs</p>\n                <p className=\"text-2xl font-bold text-gray-900\">{logStats.total}</p>\n              </div>\n              <Activity className=\"h-8 w-8 text-blue-500\" />\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardContent className=\"p-4\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm font-medium text-gray-600\">Errors</p>\n                <p className=\"text-2xl font-bold text-red-600\">{logStats.errors}</p>\n              </div>\n              <XCircle className=\"h-8 w-8 text-red-500\" />\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardContent className=\"p-4\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm font-medium text-gray-600\">Warnings</p>\n                <p className=\"text-2xl font-bold text-yellow-600\">{logStats.warnings}</p>\n              </div>\n              <AlertCircle className=\"h-8 w-8 text-yellow-500\" />\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardContent className=\"p-4\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <p className=\"text-sm font-medium text-gray-600\">Last Update</p>\n                <p className=\"text-sm font-bold text-gray-900\">{logStats.last_update}</p>\n              </div>\n              <Clock className=\"h-8 w-8 text-green-500\" />\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Main Content */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <Terminal className=\"h-5 w-5 mr-2\" />\n            System Logs\n          </CardTitle>\n          <CardDescription>\n            Real-time monitoring of FreeSWITCH, Backend, and Frontend logs for tenant: {user?.tenant_id?.slice(0, 8)}...\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as any)}>\n            <TabsList className=\"grid w-full grid-cols-3\">\n              <TabsTrigger value=\"live\">Live Monitoring</TabsTrigger>\n              <TabsTrigger value=\"search\">Search & Filter</TabsTrigger>\n              <TabsTrigger value=\"settings\">Settings</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"live\" className=\"space-y-4\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-4\">\n                  <div className=\"flex items-center space-x-2\">\n                    <Switch\n                      checked={isLive}\n                      onCheckedChange={setIsLive}\n                    />\n                    <span className=\"text-sm font-medium\">\n                      {isLive ? 'Live Mode ON' : 'Live Mode OFF'}\n                    </span>\n                    {isLive ? (\n                      <Play className=\"h-4 w-4 text-green-500\" />\n                    ) : (\n                      <Pause className=\"h-4 w-4 text-gray-400\" />\n                    )}\n                  </div>\n                  <div className=\"flex items-center space-x-2\">\n                    <Switch\n                      checked={autoScroll}\n                      onCheckedChange={setAutoScroll}\n                    />\n                    <span className=\"text-sm font-medium\">Auto Scroll</span>\n                  </div>\n                </div>\n                <div className=\"text-sm text-gray-500\">\n                  Showing {filteredLogs.length} of {logs.length} logs\n                </div>\n              </div>\n\n              {/* Live Logs Display */}\n              <div className=\"bg-black text-green-400 font-mono text-sm rounded-lg p-4 h-96 overflow-y-auto\">\n                {filteredLogs.length === 0 ? (\n                  <div className=\"flex items-center justify-center h-full text-gray-500\">\n                    No logs to display\n                  </div>\n                ) : (\n                  filteredLogs.map((log) => (\n                    <div key={log.id} className=\"flex items-start space-x-2 py-1 border-b border-gray-800\">\n                      <span className=\"text-gray-500 text-xs whitespace-nowrap\">\n                        {new Date(log.timestamp).toLocaleTimeString()}\n                      </span>\n                      <div className=\"flex items-center space-x-1\">\n                        {getLevelIcon(log.level)}\n                        {getLevelBadge(log.level)}\n                        {getSourceBadge(log.source)}\n                      </div>\n                      <span className=\"text-blue-400 font-semibold\">[{log.component}]</span>\n                      <span className=\"text-white flex-1\">{log.message}</span>\n                    </div>\n                  ))\n                )}\n                <div ref={logsEndRef} />\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"search\" className=\"space-y-4\">\n              <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n                <div>\n                  <label className=\"text-sm font-medium\">Search</label>\n                  <div className=\"relative\">\n                    <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n                    <Input\n                      placeholder=\"Search logs...\"\n                      value={searchTerm}\n                      onChange={(e) => setSearchTerm(e.target.value)}\n                      className=\"pl-10\"\n                    />\n                  </div>\n                </div>\n\n                <div>\n                  <label className=\"text-sm font-medium\">Level</label>\n                  <Select value={selectedLevel} onValueChange={setSelectedLevel}>\n                    <SelectTrigger>\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">All Levels</SelectItem>\n                      <SelectItem value=\"DEBUG\">Debug</SelectItem>\n                      <SelectItem value=\"INFO\">Info</SelectItem>\n                      <SelectItem value=\"WARN\">Warning</SelectItem>\n                      <SelectItem value=\"ERROR\">Error</SelectItem>\n                      <SelectItem value=\"CRITICAL\">Critical</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                <div>\n                  <label className=\"text-sm font-medium\">Component</label>\n                  <Select value={selectedComponent} onValueChange={setSelectedComponent}>\n                    <SelectTrigger>\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">All Components</SelectItem>\n                      <SelectItem value=\"sofia\">Sofia</SelectItem>\n                      <SelectItem value=\"mod_dptools\">Mod Dptools</SelectItem>\n                      <SelectItem value=\"api\">API</SelectItem>\n                      <SelectItem value=\"auth\">Authentication</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                <div>\n                  <label className=\"text-sm font-medium\">Source</label>\n                  <Select value={selectedSource} onValueChange={setSelectedSource}>\n                    <SelectTrigger>\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">All Sources</SelectItem>\n                      <SelectItem value=\"freeswitch\">FreeSWITCH</SelectItem>\n                      <SelectItem value=\"backend\">Backend</SelectItem>\n                      <SelectItem value=\"frontend\">Frontend</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n              </div>\n\n              {/* Search Results */}\n              <div className=\"space-y-2\">\n                {filteredLogs.map((log) => (\n                  <Card key={log.id} className=\"p-3\">\n                    <div className=\"flex items-start justify-between\">\n                      <div className=\"flex-1\">\n                        <div className=\"flex items-center space-x-2 mb-2\">\n                          {getLevelIcon(log.level)}\n                          {getLevelBadge(log.level)}\n                          {getSourceBadge(log.source)}\n                          <span className=\"text-sm text-gray-500\">\n                            {new Date(log.timestamp).toLocaleString()}\n                          </span>\n                        </div>\n                        <div className=\"flex items-center space-x-2 mb-1\">\n                          <span className=\"text-sm font-semibold text-blue-600\">[{log.component}]</span>\n                        </div>\n                        <p className=\"text-sm text-gray-700\">{log.message}</p>\n                      </div>\n                    </div>\n                  </Card>\n                ))}\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"settings\" className=\"space-y-4\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Log Settings</CardTitle>\n                  <CardDescription>Configure logging preferences and verbosity levels</CardDescription>\n                </CardHeader>\n                <CardContent className=\"space-y-4\">\n                  <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                    <div>\n                      <label className=\"text-sm font-medium\">FreeSWITCH Log Level</label>\n                      <Select \n                        value={settings.freeswitchLevel} \n                        onValueChange={(value) => setSettings(prev => ({ ...prev, freeswitchLevel: value }))}\n                      >\n                        <SelectTrigger>\n                          <SelectValue />\n                        </SelectTrigger>\n                        <SelectContent>\n                          <SelectItem value=\"debug\">Debug</SelectItem>\n                          <SelectItem value=\"info\">Info</SelectItem>\n                          <SelectItem value=\"notice\">Notice</SelectItem>\n                          <SelectItem value=\"warning\">Warning</SelectItem>\n                          <SelectItem value=\"error\">Error</SelectItem>\n                        </SelectContent>\n                      </Select>\n                    </div>\n\n                    <div>\n                      <label className=\"text-sm font-medium\">Backend Log Level</label>\n                      <Select \n                        value={settings.backendLevel} \n                        onValueChange={(value) => setSettings(prev => ({ ...prev, backendLevel: value }))}\n                      >\n                        <SelectTrigger>\n                          <SelectValue />\n                        </SelectTrigger>\n                        <SelectContent>\n                          <SelectItem value=\"debug\">Debug</SelectItem>\n                          <SelectItem value=\"info\">Info</SelectItem>\n                          <SelectItem value=\"warn\">Warning</SelectItem>\n                          <SelectItem value=\"error\">Error</SelectItem>\n                        </SelectContent>\n                      </Select>\n                    </div>\n\n                    <div>\n                      <label className=\"text-sm font-medium\">Max Log Entries</label>\n                      <Input \n                        type=\"number\" \n                        value={settings.maxLogs}\n                        onChange={(e) => setSettings(prev => ({ ...prev, maxLogs: e.target.value }))}\n                        placeholder=\"1000\" \n                      />\n                    </div>\n\n                    <div>\n                      <label className=\"text-sm font-medium\">Log Retention (days)</label>\n                      <Input \n                        type=\"number\" \n                        value={settings.retention}\n                        onChange={(e) => setSettings(prev => ({ ...prev, retention: e.target.value }))}\n                        placeholder=\"30\" \n                      />\n                    </div>\n                  </div>\n\n                  <div className=\"space-y-2\">\n                    <div className=\"flex items-center space-x-2\">\n                      <Switch \n                        checked={settings.sipTracing}\n                        onCheckedChange={(checked) => {\n                          setSettings(prev => ({ ...prev, sipTracing: checked }));\n                          handleSetSipTracing(checked);\n                        }}\n                      />\n                      <span className=\"text-sm font-medium\">Enable SIP Tracing</span>\n                    </div>\n                    <div className=\"flex items-center space-x-2\">\n                      <Switch \n                        checked={settings.rtpCapture}\n                        onCheckedChange={(checked) => setSettings(prev => ({ ...prev, rtpCapture: checked }))}\n                      />\n                      <span className=\"text-sm font-medium\">Enable RTP Capture</span>\n                    </div>\n                    <div className=\"flex items-center space-x-2\">\n                      <Switch \n                        checked={settings.verboseDebugging}\n                        onCheckedChange={(checked) => setSettings(prev => ({ ...prev, verboseDebugging: checked }))}\n                      />\n                      <span className=\"text-sm font-medium\">Enable Verbose Debugging</span>\n                    </div>\n                  </div>\n\n                  <div className=\"pt-4\">\n                    <Button \n                      className=\"bg-blue-600 hover:bg-blue-700\"\n                      onClick={() => {\n                        console.log('Apply Settings clicked');\n                        console.log('Settings to apply:', settings);\n                        \n                        // Apply FreeSWITCH log level\n                        handleSetLogLevel(settings.freeswitchLevel);\n                        \n                        // Apply SIP tracing\n                        handleSetSipTracing(settings.sipTracing);\n                        \n                        // Here you would normally save settings to backend/localStorage\n                        localStorage.setItem('logSettings', JSON.stringify(settings));\n                        \n                        alert('Settings applied successfully!');\n                      }}\n                    >\n                      <Settings className=\"h-4 w-4 mr-2\" />\n                      Apply Settings\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":25426},"packages/backend/src/services/mock-freeswitch.service.ts":{"content":"import { EventEmitter } from 'events';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { logFreeSWITCHEvent } from '../utils/logger';\r\n\r\n/**\r\n * Mock FreeSWITCH Service per testing senza FreeSWITCH installato\r\n * Simula tutte le funzionalità di FreeSWITCH per testing locale\r\n */\r\n\r\nexport interface MockCallInfo {\r\n  uuid: string;\r\n  direction: 'inbound' | 'outbound' | 'internal';\r\n  caller_id_number: string;\r\n  caller_id_name: string;\r\n  callee_id_number: string;\r\n  callee_id_name: string;\r\n  domain: string;\r\n  context: string;\r\n  start_time: Date;\r\n  answer_time?: Date;\r\n  end_time?: Date;\r\n  duration?: number;\r\n  hangup_cause?: string;\r\n  recording_path?: string;\r\n  status: 'ringing' | 'answered' | 'hangup';\r\n}\r\n\r\nexport class MockFreeSWITCHService extends EventEmitter {\r\n  private connected: boolean = false;\r\n  private host: string;\r\n  private port: number;\r\n  private password: string;\r\n  private activeCalls: Map<string, MockCallInfo> = new Map();\r\n  private reconnectAttempts: number = 0;\r\n  private maxReconnectAttempts: number = 5;\r\n\r\n  constructor() {\r\n    super();\r\n    this.host = process.env.FREESWITCH_HOST || '192.168.172.234';\r\n    this.port = parseInt(process.env.FREESWITCH_PORT || '8021');\r\n    this.password = process.env.FREESWITCH_PASSWORD || 'ClueCon';\r\n\r\n    console.log('🎭 MockFreeSWITCH Service initialized (for testing without FreeSWITCH)');\r\n  }\r\n\r\n  // Connect to FreeSWITCH (Mock)\r\n  async connect(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      // Simula connessione dopo 1 secondo\r\n      setTimeout(() => {\r\n        this.connected = true;\r\n        this.reconnectAttempts = 0;\r\n        logFreeSWITCHEvent('mock_connection', { \r\n          status: 'connected', \r\n          host: this.host, \r\n          port: this.port,\r\n          mode: 'MOCK' \r\n        });\r\n        console.log('✅ MockFreeSWITCH: Simulated connection successful');\r\n        this.emit('connected');\r\n        resolve();\r\n      }, 1000);\r\n    });\r\n  }\r\n\r\n  // Originate a call (Mock)\r\n  async originateCall(\r\n    callerExtension: string,\r\n    calleeNumber: string,\r\n    domain: string,\r\n    options: {\r\n      timeout?: number;\r\n      callerId?: string;\r\n      context?: string;\r\n      recording?: boolean;\r\n    } = {}\r\n  ): Promise<string> {\r\n    const callUuid = uuidv4();\r\n    const timeout = options.timeout || 30;\r\n    const callerId = options.callerId || callerExtension;\r\n    const context = options.context || 'default';\r\n\r\n    const callInfo: MockCallInfo = {\r\n      uuid: callUuid,\r\n      direction: 'outbound',\r\n      caller_id_number: callerExtension,\r\n      caller_id_name: callerId,\r\n      callee_id_number: calleeNumber,\r\n      callee_id_name: calleeNumber,\r\n      domain: domain,\r\n      context: context,\r\n      start_time: new Date(),\r\n      status: 'ringing'\r\n    };\r\n\r\n    this.activeCalls.set(callUuid, callInfo);\r\n\r\n    logFreeSWITCHEvent('mock_originate', { \r\n      uuid: callUuid, \r\n      from: callerExtension, \r\n      to: calleeNumber,\r\n      mode: 'MOCK'\r\n    });\r\n\r\n    // Simula CHANNEL_CREATE event\r\n    this.emit('call_started', callInfo);\r\n\r\n    // Simula answer dopo 2 secondi\r\n    setTimeout(() => {\r\n      const call = this.activeCalls.get(callUuid);\r\n      if (call) {\r\n        call.answer_time = new Date();\r\n        call.status = 'answered';\r\n        this.activeCalls.set(callUuid, call);\r\n        this.emit('call_answered', call);\r\n        logFreeSWITCHEvent('mock_answer', { uuid: callUuid, mode: 'MOCK' });\r\n      }\r\n    }, 2000);\r\n\r\n    // Simula hangup dopo timeout (se non chiusa manualmente)\r\n    setTimeout(() => {\r\n      const call = this.activeCalls.get(callUuid);\r\n      if (call && call.status !== 'hangup') {\r\n        this.hangupCall(callUuid, 'NORMAL_CLEARING');\r\n      }\r\n    }, timeout * 1000);\r\n\r\n    return callUuid;\r\n  }\r\n\r\n  // Transfer a call (Mock)\r\n  async transferCall(\r\n    callUuid: string,\r\n    destination: string,\r\n    type: 'attended' | 'blind' = 'blind'\r\n  ): Promise<void> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    logFreeSWITCHEvent('mock_transfer', { \r\n      uuid: callUuid, \r\n      destination, \r\n      type,\r\n      mode: 'MOCK' \r\n    });\r\n\r\n    // Simula trasferimento\r\n    call.callee_id_number = destination;\r\n    this.activeCalls.set(callUuid, call);\r\n    this.emit('call_transferred', call);\r\n  }\r\n\r\n  // Hangup a call (Mock)\r\n  async hangupCall(callUuid: string, cause: string = 'NORMAL_CLEARING'): Promise<void> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    call.end_time = new Date();\r\n    call.status = 'hangup';\r\n    call.hangup_cause = cause;\r\n    \r\n    if (call.answer_time && call.start_time) {\r\n      call.duration = Math.floor((call.end_time.getTime() - call.answer_time.getTime()) / 1000);\r\n    }\r\n\r\n    this.activeCalls.set(callUuid, call);\r\n\r\n    logFreeSWITCHEvent('mock_hangup', { \r\n      uuid: callUuid, \r\n      cause,\r\n      duration: call.duration,\r\n      mode: 'MOCK' \r\n    });\r\n\r\n    this.emit('call_ended', call);\r\n\r\n    // Rimuovi la chiamata dopo 5 secondi\r\n    setTimeout(() => {\r\n      this.activeCalls.delete(callUuid);\r\n    }, 5000);\r\n  }\r\n\r\n  // Hold/Unhold a call (Mock)\r\n  async holdCall(callUuid: string, hold: boolean = true): Promise<void> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    logFreeSWITCHEvent('mock_hold', { \r\n      uuid: callUuid, \r\n      hold,\r\n      mode: 'MOCK' \r\n    });\r\n\r\n    this.emit('call_hold', { uuid: callUuid, hold });\r\n  }\r\n\r\n  // Mute/Unmute a call (Mock)\r\n  async muteCall(callUuid: string, mute: boolean = true): Promise<void> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    logFreeSWITCHEvent('mock_mute', { \r\n      uuid: callUuid, \r\n      mute,\r\n      mode: 'MOCK' \r\n    });\r\n\r\n    this.emit('call_mute', { uuid: callUuid, mute });\r\n  }\r\n\r\n  // Start/Stop recording (Mock)\r\n  async recordCall(callUuid: string, record: boolean = true, path?: string): Promise<void> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    if (record) {\r\n      const recordPath = path || `/var/recordings/${callUuid}.wav`;\r\n      call.recording_path = recordPath;\r\n      this.activeCalls.set(callUuid, call);\r\n\r\n      logFreeSWITCHEvent('mock_record_start', { \r\n        uuid: callUuid, \r\n        path: recordPath,\r\n        mode: 'MOCK' \r\n      });\r\n\r\n      this.emit('recording_started', call);\r\n    } else {\r\n      logFreeSWITCHEvent('mock_record_stop', { \r\n        uuid: callUuid,\r\n        mode: 'MOCK' \r\n      });\r\n\r\n      this.emit('recording_stopped', call);\r\n    }\r\n  }\r\n\r\n  // Get call information (Mock)\r\n  async getCallInfo(callUuid: string): Promise<Record<string, string>> {\r\n    const call = this.activeCalls.get(callUuid);\r\n    if (!call) {\r\n      throw new Error(`Call ${callUuid} not found`);\r\n    }\r\n\r\n    return {\r\n      'Call-UUID': call.uuid,\r\n      'Caller-Caller-ID-Number': call.caller_id_number,\r\n      'Caller-Caller-ID-Name': call.caller_id_name,\r\n      'Caller-Destination-Number': call.callee_id_number,\r\n      'Caller-Domain': call.domain,\r\n      'Caller-Context': call.context,\r\n      'Call-Direction': call.direction,\r\n      'Channel-State': call.status,\r\n      'Answer-Time': call.answer_time?.toISOString() || '',\r\n      'Start-Time': call.start_time.toISOString(),\r\n      'Duration': call.duration?.toString() || '0',\r\n      'Recording-Path': call.recording_path || '',\r\n      'Mock-Mode': 'true'\r\n    };\r\n  }\r\n\r\n  // Send command to FreeSWITCH (Mock)\r\n  sendCommand(command: string, args?: string): void {\r\n    logFreeSWITCHEvent('mock_command', { \r\n      command, \r\n      args,\r\n      mode: 'MOCK' \r\n    });\r\n    // Mock: non fa nulla ma logga il comando\r\n  }\r\n\r\n  // Add event listener\r\n  addEventListener(eventName: string, listener: (event: any) => void): void {\r\n    this.on(eventName, listener);\r\n  }\r\n\r\n  // Remove event listener\r\n  removeEventListener(eventName: string): void {\r\n    this.removeAllListeners(eventName);\r\n  }\r\n\r\n  // Disconnect from FreeSWITCH (Mock)\r\n  disconnect(): void {\r\n    this.connected = false;\r\n    this.activeCalls.clear();\r\n    logFreeSWITCHEvent('mock_disconnect', { mode: 'MOCK' });\r\n    this.emit('disconnected');\r\n    console.log('🎭 MockFreeSWITCH: Disconnected');\r\n  }\r\n\r\n  // Check if connected\r\n  isConnected(): boolean {\r\n    return this.connected;\r\n  }\r\n\r\n  // Get connection status\r\n  getStatus(): { connected: boolean; host: string; port: number; reconnectAttempts: number; mode: string } {\r\n    return {\r\n      connected: this.connected,\r\n      host: this.host,\r\n      port: this.port,\r\n      reconnectAttempts: this.reconnectAttempts,\r\n      mode: 'MOCK (Testing without FreeSWITCH)'\r\n    };\r\n  }\r\n\r\n  // Get active calls\r\n  getActiveCalls(): MockCallInfo[] {\r\n    return Array.from(this.activeCalls.values());\r\n  }\r\n\r\n  // Get call count\r\n  getCallCount(): number {\r\n    return this.activeCalls.size;\r\n  }\r\n}\r\n\r\n","size_bytes":9198},"packages/shared/src/types/api.ts":{"content":"import { z } from 'zod';\r\n\r\n// API Response wrapper\r\nexport const ApiResponseSchema = z.object({\r\n  success: z.boolean(),\r\n  data: z.any().optional(),\r\n  error: z.object({\r\n    code: z.string(),\r\n    message: z.string(),\r\n    details: z.any().optional()\r\n  }).optional(),\r\n  meta: z.object({\r\n    timestamp: z.date(),\r\n    request_id: z.string().uuid(),\r\n    tenant_id: z.string().uuid().optional()\r\n  })\r\n});\r\n\r\nexport type ApiResponse<T = any> = {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: {\r\n    code: string;\r\n    message: string;\r\n    details?: any;\r\n  };\r\n  meta: {\r\n    timestamp: Date;\r\n    request_id: string;\r\n    tenant_id?: string;\r\n  };\r\n};\r\n\r\n// Pagination schema\r\nexport const PaginationSchema = z.object({\r\n  page: z.number().min(1).default(1),\r\n  limit: z.number().min(1).max(1000).default(50),\r\n  total: z.number().min(0),\r\n  total_pages: z.number().min(0)\r\n});\r\n\r\nexport type Pagination = z.infer<typeof PaginationSchema>;\r\n\r\n// JWT payload schema\r\nexport const JWTPayloadSchema = z.object({\r\n  sub: z.string().uuid(), // user_id\r\n  tenant_id: z.string().uuid().optional(),\r\n  store_id: z.string().uuid().optional(),\r\n  role: z.enum(['super_admin', 'tenant_admin', 'admin', 'manager', 'user']),\r\n  permissions: z.array(z.string()).optional(),\r\n  iat: z.number(),\r\n  exp: z.number()\r\n});\r\n\r\nexport type JWTPayload = z.infer<typeof JWTPayloadSchema>;\r\n\r\n// Company schema for tenant management\r\nexport const CompanySchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  legal_name: z.string().min(1).max(255),\r\n  vat_number: z.string().max(50).optional(),\r\n  tax_code: z.string().max(50).optional(),\r\n  address: z.string().optional(),\r\n  city: z.string().max(100).optional(),\r\n  state: z.string().max(100).optional(),\r\n  postal_code: z.string().max(20).optional(),\r\n  country: z.string().max(100).default('Italy'),\r\n  is_primary: z.boolean().default(false),\r\n  created_at: z.date(),\r\n  updated_at: z.date()\r\n});\r\n\r\nexport type Company = z.infer<typeof CompanySchema>;\r\n\r\n// Tenant Contact schema\r\nexport const TenantContactSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  company_id: z.string().uuid().optional(),\r\n  first_name: z.string().min(1).max(100),\r\n  last_name: z.string().min(1).max(100),\r\n  role: z.string().max(100).optional(),\r\n  email: z.string().email().optional(),\r\n  phone: z.string().max(50).optional(),\r\n  mobile: z.string().max(50).optional(),\r\n  is_primary: z.boolean().default(false),\r\n  created_at: z.date(),\r\n  updated_at: z.date()\r\n});\r\n\r\nexport type TenantContact = z.infer<typeof TenantContactSchema>;\r\n\r\n// Admin User schema for tenant creation\r\nexport const AdminUserSchema = z.object({\r\n  first_name: z.string().min(1).max(100),\r\n  last_name: z.string().min(1).max(100),\r\n  email: z.string().email(),\r\n  password: z.string().min(8).max(100),\r\n  role: z.enum(['tenant_admin', 'super_admin']).default('tenant_admin')\r\n});\r\n\r\nexport type AdminUser = z.infer<typeof AdminUserSchema>;\r\n\r\n// Create Tenant Request schema\r\nexport const CreateTenantRequestSchema = z.object({\r\n  name: z.string().min(1).max(255),\r\n  slug: z.string().min(1).max(100).regex(/^[a-z0-9-]+$/),\r\n  domain: z.string().min(1).max(255),\r\n  sip_domain: z.string().min(1).max(255),\r\n  admin_user: AdminUserSchema,\r\n  companies: z.array(CompanySchema.omit({ id: true, tenant_id: true, created_at: true, updated_at: true })).min(1),\r\n  contacts: z.array(TenantContactSchema.omit({ id: true, tenant_id: true, created_at: true, updated_at: true })).min(1)\r\n});\r\n\r\nexport type CreateTenantRequest = z.infer<typeof CreateTenantRequestSchema>;\r\n\r\n// Cross-tenant analytics schemas\r\nexport const CrossTenantStatsSchema = z.object({\r\n  total_tenants: z.number(),\r\n  total_users: z.number(),\r\n  total_extensions: z.number(),\r\n  total_calls_24h: z.number(),\r\n  active_tenants: z.number(),\r\n  inactive_tenants: z.number()\r\n});\r\n\r\nexport type CrossTenantStats = z.infer<typeof CrossTenantStatsSchema>;\r\n\r\nexport const TenantStatsSchema = z.object({\r\n  tenant_id: z.string().uuid(),\r\n  tenant_name: z.string(),\r\n  tenant_slug: z.string(),\r\n  users_count: z.number(),\r\n  extensions_count: z.number(),\r\n  calls_24h: z.number(),\r\n  companies_count: z.number(),\r\n  contacts_count: z.number(),\r\n  status: z.string()\r\n});\r\n\r\nexport type TenantStats = z.infer<typeof TenantStatsSchema>;\r\n\r\n","size_bytes":4343},"packages/backend/src/services/cdr.service.ts":{"content":"// @ts-nocheck\nimport { getClient, withTransaction } from '@w3-voip/database';\nimport { CDR, CDRFilter, CDRStats } from '@w3-voip/shared';\nimport { v4 as uuidv4 } from 'uuid';\nimport { logCDREvent } from '../utils/logger';\n\nexport class CDRService {\n  // Create CDR record\n  async createCDR(cdrData: Omit<CDR, 'id' | 'created_at' | 'updated_at'>): Promise<CDR> {\n    return withTransaction(async (client) => {\n      // Verify tenant exists\n      const tenantResult = await client.query(\n        'SELECT id FROM tenants WHERE id = $1',\n        [cdrData.tenant_id]\n      );\n\n      if (tenantResult.rows.length === 0) {\n        throw new Error('Tenant not found');\n      }\n\n      // Create CDR record\n      const result = await client.query(\n        `INSERT INTO cdr (\n          id, tenant_id, store_id, extension_id, trunk_id, call_uuid, call_direction,\n          call_type, caller_id_number, caller_id_name, caller_extension, callee_id_number,\n          callee_id_name, callee_extension, start_time, answer_time, end_time, duration,\n          bill_seconds, hangup_cause, hangup_disposition, audio_codec, video_codec,\n          rtp_audio_in_mos, rtp_audio_out_mos, recording_enabled, recording_path,\n          recording_duration, recording_consent, local_ip, remote_ip, local_port,\n          remote_port, fs_uuid, fs_domain, fs_context, fs_profile, metadata, tags\n        ) VALUES (\n          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18,\n          $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34,\n          $35, $36, $37, $38, $39, $40\n        ) RETURNING *`,\n        [\n          uuidv4(),\n          cdrData.tenant_id,\n          cdrData.store_id || null,\n          cdrData.extension_id || null,\n          cdrData.trunk_id || null,\n          cdrData.call_uuid,\n          cdrData.call_direction,\n          cdrData.call_type || 'voice',\n          cdrData.caller_id_number || null,\n          cdrData.caller_id_name || null,\n          cdrData.caller_extension || null,\n          cdrData.callee_id_number || null,\n          cdrData.callee_id_name || null,\n          cdrData.callee_extension || null,\n          cdrData.start_time,\n          cdrData.answer_time || null,\n          cdrData.end_time,\n          cdrData.duration,\n          cdrData.bill_seconds,\n          cdrData.hangup_cause,\n          cdrData.hangup_disposition,\n          cdrData.audio_codec || null,\n          cdrData.video_codec || null,\n          cdrData.rtp_audio_in_mos || null,\n          cdrData.rtp_audio_out_mos || null,\n          cdrData.recording_enabled,\n          cdrData.recording_path || null,\n          cdrData.recording_duration || null,\n          cdrData.recording_consent || null,\n          cdrData.local_ip || null,\n          cdrData.remote_ip || null,\n          cdrData.local_port || null,\n          cdrData.remote_port || null,\n          cdrData.fs_uuid,\n          cdrData.fs_domain,\n          cdrData.fs_context || null,\n          cdrData.fs_profile || null,\n          cdrData.metadata ? JSON.stringify(cdrData.metadata) : null,\n          cdrData.tags || []\n        ]\n      );\n\n      const cdr = result.rows[0];\n      \n      // Log CDR creation\n      logCDREvent('cdr_created', {\n        id: cdr.id,\n        tenant_id: cdr.tenant_id,\n        call_uuid: cdr.call_uuid,\n        direction: cdr.call_direction,\n        duration: cdr.duration\n      });\n\n      return {\n        ...cdr,\n        metadata: cdr.metadata\n      };\n    });\n  }\n\n  // Update CDR record\n  async updateCDR(cdrId: string, updates: Partial<Omit<CDR, 'id' | 'tenant_id' | 'created_at' | 'updated_at'>>, tenantId?: string): Promise<CDR> {\n    return withTransaction(async (client) => {\n      // Build update query\n      const updateFields: string[] = [];\n      const values: any[] = [];\n      let paramCount = 1;\n\n      if (updates.answer_time !== undefined) {\n        updateFields.push(`answer_time = $${paramCount++}`);\n        values.push(updates.answer_time);\n      }\n      if (updates.end_time !== undefined) {\n        updateFields.push(`end_time = $${paramCount++}`);\n        values.push(updates.end_time);\n      }\n      if (updates.duration !== undefined) {\n        updateFields.push(`duration = $${paramCount++}`);\n        values.push(updates.duration);\n      }\n      if (updates.bill_seconds !== undefined) {\n        updateFields.push(`bill_seconds = $${paramCount++}`);\n        values.push(updates.bill_seconds);\n      }\n      if (updates.hangup_cause !== undefined) {\n        updateFields.push(`hangup_cause = $${paramCount++}`);\n        values.push(updates.hangup_cause);\n      }\n      if (updates.hangup_disposition !== undefined) {\n        updateFields.push(`hangup_disposition = $${paramCount++}`);\n        values.push(updates.hangup_disposition);\n      }\n      if (updates.audio_codec !== undefined) {\n        updateFields.push(`audio_codec = $${paramCount++}`);\n        values.push(updates.audio_codec);\n      }\n      if (updates.video_codec !== undefined) {\n        updateFields.push(`video_codec = $${paramCount++}`);\n        values.push(updates.video_codec);\n      }\n      if (updates.rtp_audio_in_mos !== undefined) {\n        updateFields.push(`rtp_audio_in_mos = $${paramCount++}`);\n        values.push(updates.rtp_audio_in_mos);\n      }\n      if (updates.rtp_audio_out_mos !== undefined) {\n        updateFields.push(`rtp_audio_out_mos = $${paramCount++}`);\n        values.push(updates.rtp_audio_out_mos);\n      }\n      if (updates.recording_enabled !== undefined) {\n        updateFields.push(`recording_enabled = $${paramCount++}`);\n        values.push(updates.recording_enabled);\n      }\n      if (updates.recording_path !== undefined) {\n        updateFields.push(`recording_path = $${paramCount++}`);\n        values.push(updates.recording_path);\n      }\n      if (updates.recording_duration !== undefined) {\n        updateFields.push(`recording_duration = $${paramCount++}`);\n        values.push(updates.recording_duration);\n      }\n      if (updates.recording_consent !== undefined) {\n        updateFields.push(`recording_consent = $${paramCount++}`);\n        values.push(updates.recording_consent);\n      }\n      if (updates.metadata !== undefined) {\n        updateFields.push(`metadata = $${paramCount++}`);\n        values.push(updates.metadata ? JSON.stringify(updates.metadata) : null);\n      }\n      if (updates.tags !== undefined) {\n        updateFields.push(`tags = $${paramCount++}`);\n        values.push(updates.tags);\n      }\n\n      if (updateFields.length === 0) {\n        throw new Error('No fields to update');\n      }\n\n      values.push(cdrId);\n      \n      let query = `UPDATE cdr SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $${paramCount}`;\n      \n      if (tenantId) {\n        query += ` AND tenant_id = $${paramCount + 1}`;\n        values.push(tenantId);\n      }\n      \n      query += ' RETURNING *';\n\n      const result = await client.query(query, values);\n\n      if (result.rows.length === 0) {\n        throw new Error('CDR not found');\n      }\n\n      const cdr = result.rows[0];\n      \n      // Log CDR update\n      logCDREvent('cdr_updated', {\n        id: cdr.id,\n        tenant_id: cdr.tenant_id,\n        call_uuid: cdr.call_uuid,\n        updates: updateFields\n      });\n\n      return {\n        ...cdr,\n        metadata: cdr.metadata\n      };\n    });\n  }\n\n  // Get CDR by ID\n  async getCDRById(cdrId: string, tenantId?: string): Promise<CDR | null> {\n    const client = await getClient();\n    \n    try {\n      let query = 'SELECT * FROM cdr WHERE id = $1';\n      let params: any[] = [cdrId];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const cdr = result.rows[0];\n      return {\n        ...cdr,\n        metadata: cdr.metadata\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get CDR by call UUID\n  async getCDRByCallUuid(callUuid: string, tenantId?: string): Promise<CDR | null> {\n    const client = await getClient();\n    \n    try {\n      let query = 'SELECT * FROM cdr WHERE call_uuid = $1';\n      let params: any[] = [callUuid];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const cdr = result.rows[0];\n      return {\n        ...cdr,\n        metadata: cdr.metadata\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // List CDR records with filters\n  async listCDR(filter: CDRFilter): Promise<{\n    cdr: CDR[];\n    total: number;\n    totalPages: number;\n  }> {\n    const client = await getClient();\n    \n    try {\n      const offset = (filter.page - 1) * filter.limit;\n      \n      // Build WHERE clause\n      const whereConditions: string[] = [];\n      const queryParams: any[] = [];\n      let paramCount = 1;\n\n      if (filter.tenant_id) {\n        whereConditions.push(`tenant_id = $${paramCount++}`);\n        queryParams.push(filter.tenant_id);\n      }\n      if (filter.store_id) {\n        whereConditions.push(`store_id = $${paramCount++}`);\n        queryParams.push(filter.store_id);\n      }\n      if (filter.extension_id) {\n        whereConditions.push(`extension_id = $${paramCount++}`);\n        queryParams.push(filter.extension_id);\n      }\n      if (filter.trunk_id) {\n        whereConditions.push(`trunk_id = $${paramCount++}`);\n        queryParams.push(filter.trunk_id);\n      }\n      if (filter.start_date) {\n        whereConditions.push(`start_time >= $${paramCount++}`);\n        queryParams.push(filter.start_date);\n      }\n      if (filter.end_date) {\n        whereConditions.push(`start_time <= $${paramCount++}`);\n        queryParams.push(filter.end_date);\n      }\n      if (filter.call_direction) {\n        whereConditions.push(`call_direction = $${paramCount++}`);\n        queryParams.push(filter.call_direction);\n      }\n      if (filter.call_type) {\n        whereConditions.push(`call_type = $${paramCount++}`);\n        queryParams.push(filter.call_type);\n      }\n      if (filter.hangup_disposition) {\n        whereConditions.push(`hangup_disposition = $${paramCount++}`);\n        queryParams.push(filter.hangup_disposition);\n      }\n      if (filter.caller_number) {\n        whereConditions.push(`(caller_id_number ILIKE $${paramCount} OR caller_extension ILIKE $${paramCount})`);\n        queryParams.push(`%${filter.caller_number}%`);\n        paramCount++;\n      }\n      if (filter.callee_number) {\n        whereConditions.push(`(callee_id_number ILIKE $${paramCount} OR callee_extension ILIKE $${paramCount})`);\n        queryParams.push(`%${filter.callee_number}%`);\n        paramCount++;\n      }\n      if (filter.min_duration !== undefined) {\n        whereConditions.push(`duration >= $${paramCount++}`);\n        queryParams.push(filter.min_duration);\n      }\n      if (filter.max_duration !== undefined) {\n        whereConditions.push(`duration <= $${paramCount++}`);\n        queryParams.push(filter.max_duration);\n      }\n      if (filter.recording_enabled !== undefined) {\n        whereConditions.push(`recording_enabled = $${paramCount++}`);\n        queryParams.push(filter.recording_enabled);\n      }\n      if (filter.recording_consent !== undefined) {\n        whereConditions.push(`recording_consent = $${paramCount++}`);\n        queryParams.push(filter.recording_consent);\n      }\n      if (filter.min_mos !== undefined) {\n        whereConditions.push(`(rtp_audio_in_mos >= $${paramCount} OR rtp_audio_out_mos >= $${paramCount})`);\n        queryParams.push(filter.min_mos);\n        paramCount++;\n      }\n\n      const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\n\n      // Get total count\n      const countResult = await client.query(\n        `SELECT COUNT(*) FROM cdr ${whereClause}`,\n        queryParams\n      );\n      const total = parseInt(countResult.rows[0].count);\n\n      // Get CDR records\n      const sortOrder = filter.sort_order === 'asc' ? 'ASC' : 'DESC';\n      const sortField = filter.sort_by === 'start_time' ? 'start_time' :\n                       filter.sort_by === 'duration' ? 'duration' :\n                       filter.sort_by === 'caller_number' ? 'caller_id_number' :\n                       filter.sort_by === 'callee_number' ? 'callee_id_number' : 'start_time';\n\n      const result = await client.query(\n        `SELECT * FROM cdr ${whereClause}\n         ORDER BY ${sortField} ${sortOrder}\n         LIMIT $${paramCount} OFFSET $${paramCount + 1}`,\n        [...queryParams, filter.limit, offset]\n      );\n\n      const cdr = result.rows.map(row => ({\n        ...row,\n        metadata: row.metadata\n      }));\n\n      return {\n        cdr,\n        total,\n        totalPages: Math.ceil(total / filter.limit)\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Get CDR statistics\n  async getCDRStats(filter: Omit<CDRFilter, 'page' | 'limit' | 'sort_by' | 'sort_order'>): Promise<CDRStats> {\n    const client = await getClient();\n    \n    try {\n      // Build WHERE clause (same as listCDR)\n      const whereConditions: string[] = [];\n      const queryParams: any[] = [];\n      let paramCount = 1;\n\n      if (filter.tenant_id) {\n        whereConditions.push(`tenant_id = $${paramCount++}`);\n        queryParams.push(filter.tenant_id);\n      }\n      if (filter.store_id) {\n        whereConditions.push(`store_id = $${paramCount++}`);\n        queryParams.push(filter.store_id);\n      }\n      if (filter.extension_id) {\n        whereConditions.push(`extension_id = $${paramCount++}`);\n        queryParams.push(filter.extension_id);\n      }\n      if (filter.trunk_id) {\n        whereConditions.push(`trunk_id = $${paramCount++}`);\n        queryParams.push(filter.trunk_id);\n      }\n      if (filter.start_date) {\n        whereConditions.push(`start_time >= $${paramCount++}`);\n        queryParams.push(filter.start_date);\n      }\n      if (filter.end_date) {\n        whereConditions.push(`start_time <= $${paramCount++}`);\n        queryParams.push(filter.end_date);\n      }\n      if (filter.call_direction) {\n        whereConditions.push(`call_direction = $${paramCount++}`);\n        queryParams.push(filter.call_direction);\n      }\n      if (filter.call_type) {\n        whereConditions.push(`call_type = $${paramCount++}`);\n        queryParams.push(filter.call_type);\n      }\n      if (filter.hangup_disposition) {\n        whereConditions.push(`hangup_disposition = $${paramCount++}`);\n        queryParams.push(filter.hangup_disposition);\n      }\n\n      const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';\n\n      const result = await client.query(\n        `SELECT \n           COUNT(*) as total_calls,\n           COUNT(CASE WHEN hangup_disposition = 'answered' THEN 1 END) as answered_calls,\n           COUNT(CASE WHEN hangup_disposition IN ('no_answer', 'busy') THEN 1 END) as missed_calls,\n           COALESCE(SUM(duration), 0) as total_duration,\n           COALESCE(AVG(duration), 0) as average_duration,\n           COUNT(CASE WHEN call_direction = 'inbound' THEN 1 END) as inbound_calls,\n           COUNT(CASE WHEN call_direction = 'outbound' THEN 1 END) as outbound_calls,\n           COUNT(CASE WHEN call_direction = 'internal' THEN 1 END) as internal_calls,\n           COALESCE(AVG(rtp_audio_in_mos), 0) as average_mos,\n           MIN(start_time) as period_start,\n           MAX(start_time) as period_end\n         FROM cdr ${whereClause}`,\n        queryParams\n      );\n\n      const stats = result.rows[0];\n\n      // Get disposition statistics\n      const dispositionResult = await client.query(\n        `SELECT hangup_disposition, COUNT(*) as count\n         FROM cdr ${whereClause}\n         GROUP BY hangup_disposition`,\n        queryParams\n      );\n\n      const dispositionStats: Record<string, number> = {};\n      dispositionResult.rows.forEach(row => {\n        dispositionStats[row.hangup_disposition] = parseInt(row.count);\n      });\n\n      return {\n        total_calls: parseInt(stats.total_calls),\n        answered_calls: parseInt(stats.answered_calls),\n        missed_calls: parseInt(stats.missed_calls),\n        total_duration: parseInt(stats.total_duration),\n        average_duration: parseFloat(stats.average_duration),\n        inbound_calls: parseInt(stats.inbound_calls),\n        outbound_calls: parseInt(stats.outbound_calls),\n        internal_calls: parseInt(stats.internal_calls),\n        disposition_stats: dispositionStats,\n        average_mos: parseFloat(stats.average_mos) || undefined,\n        period_start: stats.period_start,\n        period_end: stats.period_end,\n        tenant_id: filter.tenant_id!\n      };\n    } finally {\n      await client.release();\n    }\n  }\n\n  // Delete CDR records (for GDPR compliance)\n  async deleteCDR(cdrId: string, tenantId?: string): Promise<void> {\n    return withTransaction(async (client) => {\n      let query = 'DELETE FROM cdr WHERE id = $1';\n      let params: any[] = [cdrId];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $2';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rowCount === 0) {\n        throw new Error('CDR not found');\n      }\n\n      // Log CDR deletion\n      logCDREvent('cdr_deleted', {\n        id: cdrId,\n        tenant_id: tenantId\n      });\n    });\n  }\n\n  // Anonymize CDR records (for GDPR compliance)\n  async anonymizeCDR(cdrId: string, tenantId?: string): Promise<void> {\n    return withTransaction(async (client) => {\n      const updateFields = [\n        'caller_id_number = $1',\n        'caller_id_name = $1', \n        'callee_id_number = $1',\n        'callee_id_name = $1',\n        'recording_path = NULL',\n        'metadata = NULL'\n      ];\n\n      let query = `UPDATE cdr SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $2`;\n      let params: any[] = ['ANONYMIZED', cdrId];\n      \n      if (tenantId) {\n        query += ' AND tenant_id = $3';\n        params.push(tenantId);\n      }\n\n      const result = await client.query(query, params);\n\n      if (result.rowCount === 0) {\n        throw new Error('CDR not found');\n      }\n\n      // Log CDR anonymization\n      logCDREvent('cdr_anonymized', {\n        id: cdrId,\n        tenant_id: tenantId\n      });\n    });\n  }\n}\n\n","size_bytes":18422},"packages/frontend/src/pages/W3SuiteApiDocs.tsx":{"content":"import { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { \n  Copy, \n  Check, \n  Database, \n  Globe, \n  Key, \n  Shield, \n  BookOpen,\n  Terminal,\n  FileText\n} from 'lucide-react';\n\nexport default function W3SuiteApiDocs() {\n  const [copiedCode, setCopiedCode] = useState<string | null>(null);\n\n  const copyToClipboard = (text: string, id: string) => {\n    navigator.clipboard.writeText(text);\n    setCopiedCode(id);\n    setTimeout(() => setCopiedCode(null), 2000);\n  };\n\n  const baseUrl = 'http://localhost:3000/api/w3-voip';\n  const authToken = 'Bearer YOUR_JWT_TOKEN_HERE';\n\n  const apiEndpoints = [\n    {\n      title: 'VoIP Trunks',\n      description: 'Gestione dei trunk SIP per la connessione ai provider',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/trunks',\n          description: 'Lista tutti i trunk del tenant',\n          example: `curl -X GET \"${baseUrl}/trunks\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"sip_domain\": \"demo-tenant.edgvoip.local\",\n      \"provider\": \"Messagenet\",\n      \"proxy\": \"sip.messagenet.it\",\n      \"port\": 5060,\n      \"transport\": \"udp\",\n      \"auth_username\": \"5406594427\",\n      \"secret_ref\": \"secret-123\",\n      \"register\": true,\n      \"expiry_seconds\": 3600,\n      \"codec_set\": \"G729,PCMA,PCMU\",\n      \"status\": \"REG_OK\",\n      \"note\": \"Test trunk\"\n    }\n  ]\n}`\n        },\n        {\n          method: 'POST',\n          path: '/trunks',\n          description: 'Crea un nuovo trunk SIP',\n          example: `curl -X POST \"${baseUrl}/trunks\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\n    \"provider\": \"Messagenet\",\n    \"proxy\": \"sip.messagenet.it\",\n    \"port\": 5060,\n    \"transport\": \"udp\",\n    \"auth_username\": \"5406594427\",\n    \"secret_ref\": \"secret-123\",\n    \"register\": true,\n    \"expiry_seconds\": 3600,\n    \"codec_set\": \"G729,PCMA,PCMU\",\n    \"note\": \"Production trunk\"\n  }'`,\n          response: `{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"new-uuid\",\n    \"tenant_id\": \"tenant-1\",\n    \"sip_domain\": \"demo-tenant.edgvoip.local\",\n    \"provider\": \"Messagenet\",\n    \"proxy\": \"sip.messagenet.it\",\n    \"port\": 5060,\n    \"transport\": \"udp\",\n    \"auth_username\": \"5406594427\",\n    \"secret_ref\": \"secret-123\",\n    \"register\": true,\n    \"expiry_seconds\": 3600,\n    \"codec_set\": \"G729,PCMA,PCMU\",\n    \"status\": \"UNKNOWN\",\n    \"note\": \"Production trunk\"\n  }\n}`\n        }\n      ]\n    },\n    {\n      title: 'VoIP Extensions',\n      description: 'Gestione delle estensioni interne del tenant',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/extensions',\n          description: 'Lista tutte le estensioni del tenant',\n          example: `curl -X GET \"${baseUrl}/extensions\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"sip_domain\": \"demo-tenant.edgvoip.local\",\n      \"ext_number\": \"1001\",\n      \"display_name\": \"John Doe\",\n      \"enabled\": true,\n      \"voicemail_enabled\": true,\n      \"class_of_service\": \"agent\",\n      \"note\": \"Sales team\"\n    }\n  ]\n}`\n        },\n        {\n          method: 'POST',\n          path: '/extensions',\n          description: 'Crea una nuova estensione',\n          example: `curl -X POST \"${baseUrl}/extensions\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\n    \"ext_number\": \"1002\",\n    \"display_name\": \"Jane Smith\",\n    \"enabled\": true,\n    \"voicemail_enabled\": true,\n    \"class_of_service\": \"supervisor\",\n    \"note\": \"Support team\"\n  }'`,\n          response: `{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"new-uuid\",\n    \"tenant_id\": \"tenant-1\",\n    \"sip_domain\": \"demo-tenant.edgvoip.local\",\n    \"ext_number\": \"1002\",\n    \"display_name\": \"Jane Smith\",\n    \"enabled\": true,\n    \"voicemail_enabled\": true,\n    \"class_of_service\": \"supervisor\",\n    \"note\": \"Support team\"\n  }\n}`\n        }\n      ]\n    },\n    {\n      title: 'VoIP DIDs',\n      description: 'Gestione dei numeri DID (Direct Inward Dialing)',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/dids',\n          description: 'Lista tutti i DID del tenant',\n          example: `curl -X GET \"${baseUrl}/dids\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"store_id\": \"store-1\",\n      \"trunk_id\": \"trunk-uuid\",\n      \"e164\": \"+390686356924\",\n      \"sip_domain\": \"demo-tenant.edgvoip.local\",\n      \"route_target_type\": \"ext\",\n      \"route_target_ref\": \"1001\",\n      \"label\": \"Main Line Roma\",\n      \"active\": true\n    }\n  ]\n}`\n        },\n        {\n          method: 'POST',\n          path: '/dids',\n          description: 'Crea un nuovo DID',\n          example: `curl -X POST \"${baseUrl}/dids\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\n    \"trunk_id\": \"trunk-uuid\",\n    \"e164\": \"+39061234567\",\n    \"route_target_type\": \"ivr\",\n    \"route_target_ref\": \"ivr_main\",\n    \"label\": \"Support Line\",\n    \"active\": true\n  }'`,\n          response: `{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"new-uuid\",\n    \"tenant_id\": \"tenant-1\",\n    \"trunk_id\": \"trunk-uuid\",\n    \"e164\": \"+39061234567\",\n    \"sip_domain\": \"demo-tenant.edgvoip.local\",\n    \"route_target_type\": \"ivr\",\n    \"route_target_ref\": \"ivr_main\",\n    \"label\": \"Support Line\",\n    \"active\": true\n  }\n}`\n        }\n      ]\n    },\n    {\n      title: 'VoIP Routes',\n      description: 'Gestione delle rotte di chiamata outbound',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/routes',\n          description: 'Lista tutte le rotte del tenant',\n          example: `curl -X GET \"${baseUrl}/routes\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"name\": \"Uscita nazionale\",\n      \"pattern\": \"^9(\\\\d+)$\",\n      \"strip_digits\": 1,\n      \"prepend\": \"0\",\n      \"trunk_id\": \"trunk-uuid\",\n      \"priority\": 1,\n      \"active\": true\n    }\n  ]\n}`\n        }\n      ]\n    },\n    {\n      title: 'Contact Policies',\n      description: 'Gestione delle policy di contatto e orari',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/contact-policies',\n          description: 'Lista tutte le policy del tenant',\n          example: `curl -X GET \"${baseUrl}/contact-policies\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"scope_type\": \"tenant\",\n      \"scope_ref\": \"tenant-1\",\n      \"rules_json\": {\n        \"business_hours\": {\n          \"monday\": {\"start\": \"09:00\", \"end\": \"18:00\"},\n          \"tuesday\": {\"start\": \"09:00\", \"end\": \"18:00\"}\n        },\n        \"fallback\": \"voicemail\"\n      },\n      \"active\": true,\n      \"label\": \"Orari Roma\"\n    }\n  ]\n}`\n        }\n      ]\n    },\n    {\n      title: 'CDR & Activity Logs',\n      description: 'Accesso ai Call Detail Records e log delle attività',\n      endpoints: [\n        {\n          method: 'GET',\n          path: '/cdr-activity/cdr',\n          description: 'Recupera i CDR con filtri',\n          example: `curl -X GET \"${baseUrl}/cdr-activity/cdr?start_date=2024-01-01&end_date=2024-01-31&direction=in\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": [\n    {\n      \"id\": \"uuid\",\n      \"tenant_id\": \"tenant-1\",\n      \"sip_domain\": \"demo-tenant.edgvoip.local\",\n      \"call_id\": \"call-001\",\n      \"direction\": \"in\",\n      \"from_uri\": \"+390686356924\",\n      \"to_uri\": \"1001\",\n      \"did_e164\": \"+390686356924\",\n      \"ext_number\": \"1001\",\n      \"start_ts\": \"2024-01-15T10:30:00Z\",\n      \"answer_ts\": \"2024-01-15T10:30:05Z\",\n      \"end_ts\": \"2024-01-15T10:40:00Z\",\n      \"billsec\": 600,\n      \"disposition\": \"ANSWERED\",\n      \"recording_url\": \"https://recordings.example.com/call-001.wav\",\n      \"meta_json\": {\"codec\": \"G729\", \"mos\": 4.2}\n    }\n  ],\n  \"pagination\": {\n    \"total\": 1,\n    \"limit\": 100,\n    \"offset\": 0,\n    \"has_more\": false\n  }\n}`\n        },\n        {\n          method: 'GET',\n          path: '/cdr-activity/cdr/stats',\n          description: 'Statistiche dei CDR',\n          example: `curl -X GET \"${baseUrl}/cdr-activity/cdr/stats?start_date=2024-01-01&end_date=2024-01-31\" \\\\\n  -H \"Authorization: ${authToken}\" \\\\\n  -H \"Content-Type: application/json\"`,\n          response: `{\n  \"success\": true,\n  \"data\": {\n    \"total_calls\": 150,\n    \"answered_calls\": 120,\n    \"missed_calls\": 30,\n    \"total_duration\": 7200,\n    \"avg_duration\": 60,\n    \"by_direction\": {\"inbound\": 100, \"outbound\": 50},\n    \"by_disposition\": {\"ANSWERED\": 120, \"NO_ANSWER\": 20, \"BUSY\": 10}\n  }\n}`\n        }\n      ]\n    }\n  ];\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold\">W3 Suite API Documentation</h1>\n          <p className=\"text-muted-foreground\">\n            Documentazione completa per l'integrazione con EDG VoIP System\n          </p>\n        </div>\n        <Badge variant=\"outline\" className=\"text-sm\">\n          <Globe className=\"h-4 w-4 mr-2\" />\n          External API\n        </Badge>\n      </div>\n\n      {/* Authentication Section */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <Key className=\"h-5 w-5 mr-2\" />\n            Autenticazione\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <h4 className=\"font-medium mb-2\">JWT Token</h4>\n            <p className=\"text-sm text-muted-foreground mb-3\">\n              Tutte le API richiedono un token JWT valido nell'header Authorization.\n            </p>\n            <div className=\"bg-gray-100 p-3 rounded-md font-mono text-sm\">\n              Authorization: Bearer YOUR_JWT_TOKEN_HERE\n            </div>\n          </div>\n          \n          <div>\n            <h4 className=\"font-medium mb-2\">Base URL</h4>\n            <div className=\"bg-gray-100 p-3 rounded-md font-mono text-sm\">\n              {baseUrl}\n            </div>\n          </div>\n\n          <div>\n            <h4 className=\"font-medium mb-2\">Tenant Isolation</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Il tenant_id viene estratto automaticamente dal JWT token. \n              Tutti i dati sono isolati per tenant.\n            </p>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* API Endpoints */}\n      <Tabs defaultValue=\"trunks\" className=\"w-full\">\n        <TabsList className=\"grid w-full grid-cols-6\">\n          <TabsTrigger value=\"trunks\">Trunks</TabsTrigger>\n          <TabsTrigger value=\"extensions\">Extensions</TabsTrigger>\n          <TabsTrigger value=\"dids\">DIDs</TabsTrigger>\n          <TabsTrigger value=\"routes\">Routes</TabsTrigger>\n          <TabsTrigger value=\"policies\">Policies</TabsTrigger>\n          <TabsTrigger value=\"cdr\">CDR</TabsTrigger>\n        </TabsList>\n\n        {apiEndpoints.map((section, sectionIndex) => (\n          <TabsContent key={section.title} value={section.title.toLowerCase().split(' ')[0]}>\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center\">\n                  <Database className=\"h-5 w-5 mr-2\" />\n                  {section.title}\n                </CardTitle>\n                <CardDescription>{section.description}</CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-6\">\n                {section.endpoints.map((endpoint, endpointIndex) => (\n                  <div key={endpointIndex} className=\"border rounded-lg p-4\">\n                    <div className=\"flex items-center justify-between mb-4\">\n                      <div className=\"flex items-center space-x-3\">\n                        <Badge \n                          variant={endpoint.method === 'GET' ? 'default' : 'secondary'}\n                          className=\"font-mono\"\n                        >\n                          {endpoint.method}\n                        </Badge>\n                        <code className=\"text-sm font-mono bg-gray-100 px-2 py-1 rounded\">\n                          {endpoint.path}\n                        </code>\n                      </div>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => copyToClipboard(endpoint.example, `${sectionIndex}-${endpointIndex}-example`)}\n                      >\n                        {copiedCode === `${sectionIndex}-${endpointIndex}-example` ? (\n                          <Check className=\"h-4 w-4\" />\n                        ) : (\n                          <Copy className=\"h-4 w-4\" />\n                        )}\n                      </Button>\n                    </div>\n\n                    <p className=\"text-sm text-muted-foreground mb-4\">\n                      {endpoint.description}\n                    </p>\n\n                    <div className=\"space-y-4\">\n                      <div>\n                        <h5 className=\"font-medium mb-2 flex items-center\">\n                          <Terminal className=\"h-4 w-4 mr-2\" />\n                          Esempio cURL\n                        </h5>\n                        <div className=\"bg-gray-900 text-green-400 p-4 rounded-md font-mono text-sm overflow-x-auto\">\n                          <pre>{endpoint.example}</pre>\n                        </div>\n                      </div>\n\n                      <div>\n                        <h5 className=\"font-medium mb-2 flex items-center\">\n                          <FileText className=\"h-4 w-4 mr-2\" />\n                          Risposta\n                        </h5>\n                        <div className=\"bg-gray-100 p-4 rounded-md font-mono text-sm overflow-x-auto\">\n                          <pre className=\"text-gray-800\">{endpoint.response}</pre>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          </TabsContent>\n        ))}\n      </Tabs>\n\n      {/* Integration Guide */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <BookOpen className=\"h-5 w-5 mr-2\" />\n            Guida all'Integrazione\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <h4 className=\"font-medium mb-2\">1. Autenticazione</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Ottieni un JWT token dal sistema di autenticazione W3 Suite e includilo in ogni richiesta.\n            </p>\n          </div>\n\n          <div>\n            <h4 className=\"font-medium mb-2\">2. Tenant Context</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Il tenant_id viene estratto automaticamente dal JWT. Non è necessario specificarlo nelle richieste.\n            </p>\n          </div>\n\n          <div>\n            <h4 className=\"font-medium mb-2\">3. Error Handling</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Tutte le API restituiscono un formato standardizzato con success/error e messaggi descrittivi.\n            </p>\n          </div>\n\n          <div>\n            <h4 className=\"font-medium mb-2\">4. Rate Limiting</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Le API hanno rate limiting configurato. Gestisci i codici di risposta 429 appropriatamente.\n            </p>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Support */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center\">\n            <Shield className=\"h-5 w-5 mr-2\" />\n            Supporto e Sicurezza\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div>\n            <h4 className=\"font-medium mb-2\">Sicurezza</h4>\n            <ul className=\"text-sm text-muted-foreground space-y-1\">\n              <li>• Tutte le comunicazioni sono criptate (HTTPS)</li>\n              <li>• JWT tokens hanno scadenza configurata</li>\n              <li>• Tenant isolation garantita a livello database</li>\n              <li>• Rate limiting per prevenire abusi</li>\n            </ul>\n          </div>\n\n          <div>\n            <h4 className=\"font-medium mb-2\">Supporto</h4>\n            <p className=\"text-sm text-muted-foreground\">\n              Per supporto tecnico o domande sull'integrazione, contatta il team EDG VoIP.\n            </p>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":17297},"scripts/auto-deploy.sh":{"content":"#!/bin/bash\n\n# EDG VoIP System - Auto Deploy Script\n# Deploy automatico su server cloud Debian\n\nset -e\n\n# Configurazione - IP del server\nSERVER_IP=\"93.93.113.13\"\nSERVER_USER=\"root\"\nSERVER_PASSWORD=\"B66v6My6\"\n\n# Colori per output\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nBLUE='\\033[0;34m'\nNC='\\033[0m'\n\nlog() {\n    echo -e \"${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}\"\n}\n\nwarn() {\n    echo -e \"${YELLOW}[WARNING] $1${NC}\"\n}\n\nerror() {\n    echo -e \"${RED}[ERROR] $1${NC}\"\n    exit 1\n}\n\ninfo() {\n    echo -e \"${BLUE}[INFO] $1${NC}\"\n}\n\n# Verifica parametri\nif [ -z \"$SERVER_IP\" ]; then\n    error \"SERVER_IP non configurato! Modificare lo script con l'IP del server.\"\nfi\n\nlog \"🚀 EDG VoIP System - Auto Deploy\"\nlog \"Server: $SERVER_IP\"\nlog \"User: $SERVER_USER\"\n\n# Verifica connessione SSH\nlog \"Test connessione SSH...\"\nif ! sshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SERVER_USER@$SERVER_IP \"echo 'SSH OK'\" >/dev/null 2>&1; then\n    error \"Impossibile connettersi al server $SERVER_IP\"\nfi\n\n# 1. Setup server base\nlog \"📦 Setup server base...\"\nsshpass -p \"$SERVER_PASSWORD\" scp -o StrictHostKeyChecking=no scripts/setup-debian-server.sh $SERVER_USER@$SERVER_IP:/tmp/\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\nchmod +x /tmp/setup-debian-server.sh\n/tmp/setup-debian-server.sh\nEOF\n\n# 2. Aggiorna env.production con IP reale\nlog \"🔧 Configurazione environment...\"\nsed \"s/YOUR_SERVER_IP/$SERVER_IP/g\" env.production > env.production.tmp\nmv env.production.tmp env.production\n\n# 3. Crea archivio del progetto\nlog \"📦 Creazione archivio progetto...\"\ntar --exclude='node_modules' \\\n    --exclude='.git' \\\n    --exclude='dist' \\\n    --exclude='*.log' \\\n    --exclude='.env' \\\n    --exclude='.env.local' \\\n    --exclude='scripts/auto-deploy.sh' \\\n    -czf voip-system.tar.gz \\\n    packages/ \\\n    scripts/ \\\n    env.production \\\n    package.json \\\n    package-lock.json \\\n    DEPLOYMENT_PRODUCTION.md\n\n# 4. Copia archivio sul server\nlog \"📤 Upload archivio sul server...\"\nsshpass -p \"$SERVER_PASSWORD\" scp -o StrictHostKeyChecking=no voip-system.tar.gz $SERVER_USER@$SERVER_IP:/tmp/\n\n# 5. Deploy applicazione\nlog \"🚀 Deploy applicazione...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\nset -e\n\necho \"📦 Estrazione archivio...\"\ncd /var/www/voip-system\ntar -xzf /tmp/voip-system.tar.gz\nrm /tmp/voip-system.tar.gz\n\necho \"🔧 Configurazione permessi...\"\nchown -R voip:voip /var/www/voip-system\nchmod -R 755 /var/www/voip-system\n\necho \"📦 Installazione dipendenze...\"\ncd /var/www/voip-system/packages/backend && npm install --production\ncd /var/www/voip-system/packages/frontend && npm install --production && npm run build\ncd /var/www/voip-system/packages/database && npm install --production\ncd /var/www/voip-system/packages/shared && npm install --production\n\necho \"🔧 Configurazione environment...\"\ncp /var/www/voip-system/env.production /etc/voip-system/.env\nchown voip:voip /etc/voip-system/.env\nchmod 600 /etc/voip-system/.env\n\necho \"📊 Migrazioni database...\"\ncd /var/www/voip-system/packages/database\nsource /etc/voip-system/.env\nnpm run migrate\n\necho \"🌱 Seed database...\"\nnpm run seed\n\necho \"✅ Deploy applicazione completato!\"\nEOF\n\n# 6. Configura Nginx\nlog \"🌐 Configurazione Nginx...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\ncat > /etc/nginx/sites-available/voip-system << 'NGINX_EOF'\nserver {\n    listen 80;\n    server_name _;\n    \n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\n    limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/m;\n    \n    # Frontend\n    location / {\n        root /var/www/voip-system/packages/frontend/dist;\n        try_files $uri $uri/ /index.html;\n        \n        # Cache static assets\n        location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n    }\n    \n    # API endpoints\n    location /api/ {\n        limit_req zone=api_limit burst=20 nodelay;\n        \n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_cache_bypass $http_upgrade;\n        \n        proxy_connect_timeout 60s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n    \n    # Auth endpoints - stricter rate limiting\n    location ~ ^/api/.*/(login|register) {\n        limit_req zone=auth_limit burst=3 nodelay;\n        \n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n    \n    # WebSocket support\n    location /socket.io/ {\n        proxy_pass http://127.0.0.1:5000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        proxy_connect_timeout 7d;\n        proxy_send_timeout 7d;\n        proxy_read_timeout 7d;\n    }\n}\nNGINX_EOF\n\n# Abilitare il sito\nln -sf /etc/nginx/sites-available/voip-system /etc/nginx/sites-enabled/\nrm -f /etc/nginx/sites-enabled/default\n\n# Test configurazione Nginx\nnginx -t\n\n# Riavviare Nginx\nsystemctl restart nginx\nsystemctl enable nginx\n\necho \"✅ Nginx configurato\"\nEOF\n\n# 7. Configura FreeSWITCH\nlog \"📞 Configurazione FreeSWITCH...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\n# Backup configurazione originale\ncp -r /etc/freeswitch /etc/freeswitch.backup\n\n# Aggiornare password ESL\nsed -i \"s/ClueCon/1QzGEWv0Q6ao20M+hS8qeLI+u9gw77WuJGB5Z1xDk30=/g\" /etc/freeswitch/vars.xml\n\n# Configurare permessi\nchown -R freeswitch:freeswitch /etc/freeswitch\nchown -R freeswitch:freeswitch /var/lib/freeswitch\nchown -R freeswitch:freeswitch /var/log/freeswitch\n\n# Test configurazione\nfreeswitch -t\n\n# Avviare FreeSWITCH\nsystemctl start freeswitch\nsystemctl enable freeswitch\n\necho \"✅ FreeSWITCH configurato\"\nEOF\n\n# 8. Crea servizio systemd per backend\nlog \"⚙️ Configurazione servizio backend...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\ncat > /etc/systemd/system/voip-backend.service << 'SERVICE_EOF'\n[Unit]\nDescription=EDG VoIP System Backend\nAfter=network.target postgresql.service redis.service\n\n[Service]\nType=simple\nUser=voip\nGroup=voip\nWorkingDirectory=/var/www/voip-system/packages/backend\nEnvironment=NODE_ENV=production\nEnvironmentFile=/etc/voip-system/.env\nExecStart=/usr/bin/node dist/index.js\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=voip-backend\n\n[Install]\nWantedBy=multi-user.target\nSERVICE_EOF\n\n# Ricaricare systemd e avviare servizio\nsystemctl daemon-reload\nsystemctl enable voip-backend\nsystemctl start voip-backend\n\necho \"✅ Servizio backend creato e avviato\"\nEOF\n\n# 9. Verifica stato servizi\nlog \"🔍 Verifica stato servizi...\"\nsshpass -p \"$SERVER_PASSWORD\" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'\necho \"📊 Stato servizi:\"\necho \"PostgreSQL: $(systemctl is-active postgresql)\"\necho \"Redis: $(systemctl is-active redis-server)\"\necho \"Nginx: $(systemctl is-active nginx)\"\necho \"FreeSWITCH: $(systemctl is-active freeswitch)\"\necho \"VoIP Backend: $(systemctl is-active voip-backend)\"\n\necho \"\"\necho \"🔍 Porte in ascolto:\"\nnetstat -tlnp | grep -E ':(80|5000|5060|5061|8021|5432|6379)'\n\necho \"\"\necho \"📝 Log backend (ultimi 10):\"\njournalctl -u voip-backend --no-pager -n 10\nEOF\n\n# 10. Test finale\nlog \"🧪 Test finale sistema...\"\nsleep 5\n\n# Test API Health\nif curl -f -s http://$SERVER_IP/api/health >/dev/null; then\n    log \"✅ API Health check: OK\"\nelse\n    warn \"⚠️ API Health check: FAILED\"\nfi\n\n# Test Frontend\nif curl -f -s http://$SERVER_IP/ >/dev/null; then\n    log \"✅ Frontend: OK\"\nelse\n    warn \"⚠️ Frontend: FAILED\"\nfi\n\n# Pulizia locale\nrm -f voip-system.tar.gz\n\nlog \"🎉 Deploy completato con successo!\"\necho \"\"\necho \"🌐 Accesso all'applicazione:\"\necho \"  Frontend: http://$SERVER_IP\"\necho \"  API: http://$SERVER_IP/api\"\necho \"  Super Admin: http://$SERVER_IP/edgvoip/login\"\necho \"\"\necho \"🔑 Credenziali di default:\"\necho \"  Super Admin: admin@edgvoip.local / SuperAdmin2025!\"\necho \"  Demo Tenant: admin@demo.local / tenantadmin123\"\necho \"\"\necho \"📋 Comandi utili:\"\necho \"  Stato servizi: systemctl status voip-backend\"\necho \"  Log backend: journalctl -u voip-backend -f\"\necho \"  Riavvia backend: systemctl restart voip-backend\"\necho \"  Log FreeSWITCH: journalctl -u freeswitch -f\"\n","size_bytes":9219},"packages/frontend/src/components/SipTestModal.tsx":{"content":"import { useState } from 'react';\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Badge } from '@/components/ui/badge';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { \n  TestTube, \n  CheckCircle, \n  XCircle, \n  AlertCircle, \n  Clock,\n  Wifi\n} from 'lucide-react';\nimport { apiClient } from '@/lib/api';\n\ninterface SipTestModalProps {\n  children: React.ReactNode;\n}\n\ninterface SipTestResult {\n  success: boolean;\n  status: 'REG_OK' | 'FAIL' | 'TIMEOUT' | 'AUTH_FAILED' | 'NETWORK_ERROR';\n  message: string;\n  response_time_ms?: number;\n  error_details?: string;\n  registration_details?: {\n    expires?: number;\n    contact?: string;\n    user_agent?: string;\n  };\n}\n\nexport default function SipTestModal({ children }: SipTestModalProps) {\n  const [open, setOpen] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [testResult, setTestResult] = useState<SipTestResult | null>(null);\n  \n  // Form data\n  const [formData, setFormData] = useState({\n    provider: 'Messagenet',\n    proxy: 'sip.messagenet.it',\n    port: 5060,\n    transport: 'udp' as 'udp' | 'tcp' | 'tls',\n    auth_username: '5406594427',\n    auth_password: 'UjcHYnZa'\n  });\n\n  const handleTestConnection = async () => {\n    setLoading(true);\n    setTestResult(null);\n    \n    try {\n      const response = await apiClient.request('/sip-test/test-registration', {\n        method: 'POST',\n        body: JSON.stringify(formData)\n      });\n      \n      setTestResult(response.data as SipTestResult);\n    } catch (error) {\n      console.error('SIP test error:', error);\n      setTestResult({\n        success: false,\n        status: 'NETWORK_ERROR',\n        message: 'Failed to test connection',\n        error_details: error instanceof Error ? error.message : 'Unknown error'\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleTestMessagenet = async () => {\n    setLoading(true);\n    setTestResult(null);\n    \n    try {\n      const response = await apiClient.request('/sip-test/test-messagenet', {\n        method: 'POST'\n      });\n      \n      setTestResult(response.data as SipTestResult);\n    } catch (error) {\n      console.error('Messagenet test error:', error);\n      setTestResult({\n        success: false,\n        status: 'NETWORK_ERROR',\n        message: 'Failed to test Messagenet connection',\n        error_details: error instanceof Error ? error.message : 'Unknown error'\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'REG_OK':\n        return <CheckCircle className=\"h-5 w-5 text-green-500\" />;\n      case 'FAIL':\n      case 'AUTH_FAILED':\n      case 'NETWORK_ERROR':\n        return <XCircle className=\"h-5 w-5 text-red-500\" />;\n      case 'TIMEOUT':\n        return <Clock className=\"h-5 w-5 text-yellow-500\" />;\n      default:\n        return <AlertCircle className=\"h-5 w-5 text-gray-500\" />;\n    }\n  };\n\n  const getStatusBadge = (status: string) => {\n    switch (status) {\n      case 'REG_OK':\n        return <Badge variant=\"default\" className=\"bg-green-100 text-green-800\">Connected</Badge>;\n      case 'AUTH_FAILED':\n        return <Badge variant=\"destructive\">Auth Failed</Badge>;\n      case 'TIMEOUT':\n        return <Badge variant=\"secondary\">Timeout</Badge>;\n      case 'NETWORK_ERROR':\n        return <Badge variant=\"destructive\">Network Error</Badge>;\n      default:\n        return <Badge variant=\"secondary\">Failed</Badge>;\n    }\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        {children}\n      </DialogTrigger>\n      <DialogContent className=\"max-w-2xl\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center\">\n            <TestTube className=\"h-5 w-5 mr-2\" />\n            SIP Connection Test\n          </DialogTitle>\n          <DialogDescription>\n            Test SIP trunk connectivity and registration\n          </DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-6\">\n          {/* Quick Test Buttons */}\n          <div className=\"flex space-x-2\">\n            <Button \n              onClick={handleTestMessagenet} \n              disabled={loading}\n              variant=\"outline\"\n              className=\"flex-1\"\n            >\n              <Wifi className=\"h-4 w-4 mr-2\" />\n              Test Messagenet\n            </Button>\n            <Button \n              onClick={handleTestConnection} \n              disabled={loading}\n              className=\"flex-1\"\n            >\n              <TestTube className=\"h-4 w-4 mr-2\" />\n              Test Custom\n            </Button>\n          </div>\n\n          {/* Configuration Form */}\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n              <Label htmlFor=\"provider\">Provider</Label>\n              <Input\n                id=\"provider\"\n                value={formData.provider}\n                onChange={(e) => setFormData({...formData, provider: e.target.value})}\n                placeholder=\"Provider name\"\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"proxy\">Proxy/Host</Label>\n              <Input\n                id=\"proxy\"\n                value={formData.proxy}\n                onChange={(e) => setFormData({...formData, proxy: e.target.value})}\n                placeholder=\"sip.provider.com\"\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"port\">Port</Label>\n              <Input\n                id=\"port\"\n                type=\"number\"\n                value={formData.port}\n                onChange={(e) => setFormData({...formData, port: parseInt(e.target.value)})}\n                placeholder=\"5060\"\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"transport\">Transport</Label>\n              <Select \n                value={formData.transport} \n                onValueChange={(value: 'udp' | 'tcp' | 'tls') => setFormData({...formData, transport: value})}\n              >\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"udp\">UDP</SelectItem>\n                  <SelectItem value=\"tcp\">TCP</SelectItem>\n                  <SelectItem value=\"tls\">TLS</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            <div>\n              <Label htmlFor=\"auth_username\">Username</Label>\n              <Input\n                id=\"auth_username\"\n                value={formData.auth_username}\n                onChange={(e) => setFormData({...formData, auth_username: e.target.value})}\n                placeholder=\"SIP username\"\n              />\n            </div>\n            <div>\n              <Label htmlFor=\"auth_password\">Password</Label>\n              <Input\n                id=\"auth_password\"\n                type=\"password\"\n                value={formData.auth_password}\n                onChange={(e) => setFormData({...formData, auth_password: e.target.value})}\n                placeholder=\"SIP password\"\n              />\n            </div>\n          </div>\n\n          {/* Test Results */}\n          {testResult && (\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center\">\n                  {getStatusIcon(testResult.status)}\n                  <span className=\"ml-2\">Test Results</span>\n                </CardTitle>\n                <CardDescription>\n                  {testResult.message}\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"text-sm font-medium\">Status:</span>\n                  {getStatusBadge(testResult.status)}\n                </div>\n                \n                {testResult.response_time_ms && (\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm font-medium\">Response Time:</span>\n                    <span className=\"text-sm\">{testResult.response_time_ms}ms</span>\n                  </div>\n                )}\n\n                {testResult.registration_details && (\n                  <div className=\"space-y-2\">\n                    <span className=\"text-sm font-medium\">Registration Details:</span>\n                    <div className=\"bg-gray-50 p-3 rounded-md space-y-1\">\n                      {testResult.registration_details.expires && (\n                        <div className=\"text-xs\">\n                          <span className=\"font-medium\">Expires:</span> {testResult.registration_details.expires}s\n                        </div>\n                      )}\n                      {testResult.registration_details.contact && (\n                        <div className=\"text-xs\">\n                          <span className=\"font-medium\">Contact:</span> {testResult.registration_details.contact}\n                        </div>\n                      )}\n                      {testResult.registration_details.user_agent && (\n                        <div className=\"text-xs\">\n                          <span className=\"font-medium\">User Agent:</span> {testResult.registration_details.user_agent}\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                )}\n\n                {testResult.error_details && (\n                  <div className=\"space-y-2\">\n                    <span className=\"text-sm font-medium text-red-600\">Error Details:</span>\n                    <div className=\"bg-red-50 p-3 rounded-md\">\n                      <span className=\"text-xs text-red-700\">{testResult.error_details}</span>\n                    </div>\n                  </div>\n                )}\n              </CardContent>\n            </Card>\n          )}\n\n          {/* Loading State */}\n          {loading && (\n            <div className=\"flex items-center justify-center py-8\">\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600\"></div>\n                <span className=\"text-sm text-muted-foreground\">Testing connection...</span>\n              </div>\n            </div>\n          )}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n","size_bytes":10753},"packages/backend/src/routes/analytics.ts":{"content":"import express from 'express';\r\nimport { getClient } from '@w3-voip/database';\r\nimport { authenticateToken, requireSuperAdmin, AuthRequest } from '../middleware/auth';\r\nimport { asyncHandler, successResponse, errorResponse } from '../utils/response';\r\n\r\nconst router = express.Router();\r\n\r\n// Apply authentication and super admin middleware to all routes\r\nrouter.use(authenticateToken);\r\nrouter.use(requireSuperAdmin);\r\n\r\n// GET /api/analytics/cross-tenant/calls - CDR aggregato tutti tenant\r\nrouter.get('/cross-tenant/calls', asyncHandler(async (req: AuthRequest, res) => {\r\n  const { start_date, end_date, tenant_id, limit = 100 } = req.query;\r\n  \r\n  const client = await getClient();\r\n  \r\n  try {\r\n    let whereClause = '';\r\n    let queryParams: any[] = [];\r\n    let paramCount = 1;\r\n\r\n    if (start_date) {\r\n      whereClause += ` AND c.start_time >= $${paramCount++}`;\r\n      queryParams.push(start_date);\r\n    }\r\n    \r\n    if (end_date) {\r\n      whereClause += ` AND c.start_time <= $${paramCount++}`;\r\n      queryParams.push(end_date);\r\n    }\r\n    \r\n    if (tenant_id) {\r\n      whereClause += ` AND c.tenant_id = $${paramCount++}`;\r\n      queryParams.push(tenant_id);\r\n    }\r\n\r\n    const result = await client.query(`\r\n      SELECT \r\n        c.*,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        u.email as user_email\r\n      FROM cdr c\r\n      JOIN tenants t ON c.tenant_id = t.id\r\n      LEFT JOIN users u ON c.user_id = u.id\r\n      WHERE 1=1 ${whereClause}\r\n      ORDER BY c.start_time DESC\r\n      LIMIT $${paramCount}\r\n    `, [...queryParams, parseInt(limit as string)]);\r\n\r\n    successResponse(res, result.rows, 'Cross-tenant calls retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\n// GET /api/analytics/cross-tenant/extensions - Conteggi estensioni per tenant\r\nrouter.get('/cross-tenant/extensions', asyncHandler(async (req: AuthRequest, res) => {\r\n  const client = await getClient();\r\n  \r\n  try {\r\n    const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        t.status as tenant_status,\r\n        COUNT(e.id) as extensions_count,\r\n        COUNT(CASE WHEN e.status = 'active' THEN 1 END) as active_extensions,\r\n        COUNT(CASE WHEN e.status = 'inactive' THEN 1 END) as inactive_extensions\r\n      FROM tenants t\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      GROUP BY t.id, t.name, t.slug, t.status\r\n      ORDER BY extensions_count DESC\r\n    `);\r\n\r\n    successResponse(res, result.rows, 'Cross-tenant extensions statistics retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\n// GET /api/analytics/cross-tenant/live-calls - Live calls tutti tenant\r\nrouter.get('/cross-tenant/live-calls', asyncHandler(async (req: AuthRequest, res) => {\r\n  const client = await getClient();\r\n  \r\n  try {\r\n    const result = await client.query(`\r\n      SELECT \r\n        ac.*,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        u.email as user_email\r\n      FROM active_calls ac\r\n      JOIN tenants t ON ac.tenant_id = t.id\r\n      LEFT JOIN users u ON ac.user_id = u.id\r\n      ORDER BY ac.start_time DESC\r\n    `);\r\n\r\n    successResponse(res, result.rows, 'Cross-tenant live calls retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\n// GET /api/analytics/cross-tenant/users - Statistiche utenti per tenant\r\nrouter.get('/cross-tenant/users', asyncHandler(async (req: AuthRequest, res) => {\r\n  const client = await getClient();\r\n  \r\n  try {\r\n    const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        t.status as tenant_status,\r\n        COUNT(u.id) as users_count,\r\n        COUNT(CASE WHEN u.status = 'active' THEN 1 END) as active_users,\r\n        COUNT(CASE WHEN u.role = 'tenant_admin' THEN 1 END) as admin_users,\r\n        COUNT(CASE WHEN u.role = 'user' THEN 1 END) as regular_users,\r\n        MAX(u.last_login) as last_login\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      GROUP BY t.id, t.name, t.slug, t.status\r\n      ORDER BY users_count DESC\r\n    `);\r\n\r\n    successResponse(res, result.rows, 'Cross-tenant users statistics retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\n// GET /api/analytics/cross-tenant/companies - Statistiche companies per tenant\r\nrouter.get('/cross-tenant/companies', asyncHandler(async (req: AuthRequest, res) => {\r\n  const client = await getClient();\r\n  \r\n  try {\r\n    const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        COUNT(c.id) as companies_count,\r\n        COUNT(CASE WHEN c.is_primary = true THEN 1 END) as primary_companies,\r\n        COUNT(cont.id) as contacts_count,\r\n        COUNT(CASE WHEN cont.is_primary = true THEN 1 END) as primary_contacts\r\n      FROM tenants t\r\n      LEFT JOIN companies c ON t.id = c.tenant_id\r\n      LEFT JOIN tenant_contacts cont ON t.id = cont.tenant_id\r\n      GROUP BY t.id, t.name, t.slug\r\n      ORDER BY companies_count DESC\r\n    `);\r\n\r\n    successResponse(res, result.rows, 'Cross-tenant companies statistics retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\n// GET /api/analytics/cross-tenant/summary - Summary completo cross-tenant\r\nrouter.get('/cross-tenant/summary', asyncHandler(async (req: AuthRequest, res) => {\r\n  const { period = '24h' } = req.query;\r\n  \r\n  const client = await getClient();\r\n  \r\n  try {\r\n    let timeFilter = '';\r\n    switch (period) {\r\n      case '1h':\r\n        timeFilter = \"AND c.start_time > NOW() - INTERVAL '1 hour'\";\r\n        break;\r\n      case '24h':\r\n        timeFilter = \"AND c.start_time > NOW() - INTERVAL '24 hours'\";\r\n        break;\r\n      case '7d':\r\n        timeFilter = \"AND c.start_time > NOW() - INTERVAL '7 days'\";\r\n        break;\r\n      case '30d':\r\n        timeFilter = \"AND c.start_time > NOW() - INTERVAL '30 days'\";\r\n        break;\r\n    }\r\n\r\n    const result = await client.query(`\r\n      SELECT \r\n        COUNT(DISTINCT t.id) as total_tenants,\r\n        COUNT(DISTINCT CASE WHEN t.status = 'active' THEN t.id END) as active_tenants,\r\n        COUNT(DISTINCT u.id) as total_users,\r\n        COUNT(DISTINCT e.id) as total_extensions,\r\n        COUNT(DISTINCT c.id) as total_calls,\r\n        COUNT(DISTINCT ac.id) as active_calls,\r\n        COUNT(DISTINCT comp.id) as total_companies,\r\n        COUNT(DISTINCT cont.id) as total_contacts,\r\n        AVG(c.duration) as avg_call_duration,\r\n        SUM(c.duration) as total_call_duration\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      LEFT JOIN cdr c ON t.id = c.tenant_id ${timeFilter}\r\n      LEFT JOIN active_calls ac ON t.id = ac.tenant_id\r\n      LEFT JOIN companies comp ON t.id = comp.tenant_id\r\n      LEFT JOIN tenant_contacts cont ON t.id = cont.tenant_id\r\n    `);\r\n\r\n    successResponse(res, result.rows[0], 'Cross-tenant summary retrieved successfully');\r\n  } finally {\r\n    await client.release();\r\n  }\r\n}));\r\n\r\nexport default router;\r\n","size_bytes":7218},"packages/frontend/src/styles/extension-blocker.css":{"content":"/* Extension Blocker CSS - Hide extension elements */\r\n\r\n/* Hide any extension-related elements */\r\n[data-extension-id],\r\n[class*=\"extension\"],\r\n[id*=\"extension\"],\r\n[class*=\"chrome-extension\"],\r\n[id*=\"chrome-extension\"],\r\niframe[src*=\"chrome-extension://\"],\r\niframe[src*=\"pejdijmoenmkgeppbflobdenhhabjlaj\"],\r\n.completion_list,\r\n.autocomplete-extension,\r\n.extension-popup,\r\n.extension-overlay {\r\n  display: none !important;\r\n  visibility: hidden !important;\r\n  opacity: 0 !important;\r\n  pointer-events: none !important;\r\n  position: absolute !important;\r\n  left: -9999px !important;\r\n  top: -9999px !important;\r\n  width: 0 !important;\r\n  height: 0 !important;\r\n  overflow: hidden !important;\r\n}\r\n\r\n/* Hide any extension-related tooltips or overlays */\r\n[title*=\"extension\"],\r\n[title*=\"chrome-extension\"],\r\n[aria-label*=\"extension\"],\r\n[aria-label*=\"chrome-extension\"] {\r\n  display: none !important;\r\n}\r\n\r\n/* Prevent extension scripts from modifying our styles */\r\nbody {\r\n  position: relative !important;\r\n}\r\n\r\n/* Hide any extension-injected content */\r\nscript[src*=\"chrome-extension://\"],\r\nscript[src*=\"pejdijmoenmkgeppbflobdenhhabjlaj\"],\r\nlink[href*=\"chrome-extension://\"],\r\nlink[href*=\"pejdijmoenmkgeppbflobdenhhabjlaj\"] {\r\n  display: none !important;\r\n}\r\n","size_bytes":1257},"packages/shared/src/types/trunk.ts":{"content":"import { z } from 'zod';\r\n\r\n// SIP Trunk schema\r\nexport const SipTrunkSchema = z.object({\r\n  id: z.string().uuid(),\r\n  tenant_id: z.string().uuid(),\r\n  store_id: z.string().uuid().optional(),\r\n  name: z.string().min(1).max(100),\r\n  provider: z.string().min(1).max(100),\r\n  status: z.enum(['active', 'inactive', 'testing']),\r\n  created_at: z.date(),\r\n  updated_at: z.date(),\r\n  \r\n  // SIP Configuration\r\n  sip_config: z.object({\r\n    host: z.string().min(1),\r\n    port: z.number().min(1).max(65535).default(5060),\r\n    transport: z.enum(['udp', 'tcp', 'tls']).default('udp'),\r\n    username: z.string().min(1),\r\n    password: z.string().min(1),\r\n    realm: z.string().optional(),\r\n    from_user: z.string().optional(),\r\n    from_domain: z.string().optional(),\r\n    register: z.boolean().default(true),\r\n    register_proxy: z.string().optional(),\r\n    register_transport: z.enum(['udp', 'tcp', 'tls']).optional(),\r\n    retry_seconds: z.number().min(30).max(3600).default(60),\r\n    caller_id_in_from: z.boolean().default(false),\r\n    contact_params: z.string().optional(),\r\n    ping: z.boolean().default(true),\r\n    ping_time: z.number().min(30).max(300).default(60)\r\n  }),\r\n  \r\n  // DID Configuration\r\n  did_config: z.object({\r\n    number: z.string().regex(/^\\+?[1-9]\\d{1,14}$/), // E.164 format\r\n    country_code: z.string().length(2), // ISO 3166-1 alpha-2\r\n    area_code: z.string().optional(),\r\n    local_number: z.string().min(1),\r\n    provider_did: z.string().optional(),\r\n    inbound_route: z.string().optional()\r\n  }),\r\n  \r\n  // Security & Compliance\r\n  security: z.object({\r\n    encryption: z.enum(['none', 'tls', 'srtp']).default('tls'),\r\n    authentication: z.enum(['none', 'digest', 'tls']).default('digest'),\r\n    acl: z.array(z.string()).default([]), // IP whitelist\r\n    rate_limit: z.object({\r\n      enabled: z.boolean().default(true),\r\n      calls_per_minute: z.number().min(1).max(1000).default(60),\r\n      calls_per_hour: z.number().min(1).max(10000).default(1000)\r\n    })\r\n  }),\r\n  \r\n  // GDPR Compliance\r\n  gdpr: z.object({\r\n    data_retention_days: z.number().min(30).max(2555).default(365), // 1 year max\r\n    recording_consent_required: z.boolean().default(true),\r\n    data_processing_purpose: z.string().default('Business communications'),\r\n    lawful_basis: z.enum(['consent', 'contract', 'legitimate_interest']).default('legitimate_interest'),\r\n    data_controller: z.string().min(1),\r\n    dpo_contact: z.string().email().optional()\r\n  })\r\n});\r\n\r\nexport type SipTrunk = z.infer<typeof SipTrunkSchema>;\r\n\r\n// Trunk registration form schema (for UI)\r\nexport const TrunkRegistrationSchema = z.object({\r\n  // Basic Info\r\n  name: z.string().min(1, 'Nome trunk richiesto').max(100),\r\n  provider: z.string().min(1, 'Provider richiesto').max(100),\r\n  \r\n  // SIP Settings\r\n  host: z.string().min(1, 'Host SIP richiesto'),\r\n  port: z.number().min(1).max(65535).default(5060),\r\n  transport: z.enum(['udp', 'tcp', 'tls']).default('udp'),\r\n  username: z.string().min(1, 'Username SIP richiesto'),\r\n  password: z.string().min(1, 'Password SIP richiesta'),\r\n  realm: z.string().optional(),\r\n  \r\n  // DID Settings\r\n  number: z.string().regex(/^\\+?[1-9]\\d{1,14}$/, 'Formato numero non valido (E.164)'),\r\n  country_code: z.string().length(2, 'Codice paese richiesto (2 caratteri)'),\r\n  local_number: z.string().min(1, 'Numero locale richiesto'),\r\n  \r\n  // Security\r\n  encryption: z.enum(['none', 'tls', 'srtp']).default('tls'),\r\n  authentication: z.enum(['none', 'digest', 'tls']).default('digest'),\r\n  \r\n  // GDPR Compliance\r\n  data_retention_days: z.number().min(30).max(2555).default(365),\r\n  recording_consent_required: z.boolean().default(true),\r\n  data_controller: z.string().min(1, 'Titolare del trattamento richiesto'),\r\n  dpo_contact: z.string().email('Email DPO non valida').optional(),\r\n  \r\n  // Terms acceptance\r\n  gdpr_consent: z.boolean().refine(val => val === true, 'Consenso GDPR richiesto'),\r\n  terms_accepted: z.boolean().refine(val => val === true, 'Termini e condizioni richiesti')\r\n});\r\n\r\nexport type TrunkRegistration = z.infer<typeof TrunkRegistrationSchema>;\r\n\r\n","size_bytes":4092},"packages/frontend/src/pages/Voicemail.tsx":{"content":"import { useState, useEffect } from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Switch } from '@/components/ui/switch';\r\nimport { \r\n  Plus, \r\n  Search, \r\n  Edit, \r\n  Trash2, \r\n  Mic,\r\n  Eye,\r\n  MoreHorizontal,\r\n  RefreshCw,\r\n  Clock,\r\n  Mail\r\n} from 'lucide-react';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\ninterface VoicemailBox {\r\n  id: string;\r\n  mailbox_id: string;\r\n  password: string;\r\n  full_name?: string;\r\n  email?: string;\r\n  pager_email?: string;\r\n  timezone: string;\r\n  attach_file: boolean;\r\n  delete_voicemail: boolean;\r\n  say_caller_id: boolean;\r\n  say_caller_id_name: boolean;\r\n  say_envelope: boolean;\r\n  skip_greeting: boolean;\r\n  skip_instructions: boolean;\r\n  email_attachment_format: string;\r\n  voicemail_password?: string;\r\n  max_greeting_length: number;\r\n  max_message_length: number;\r\n  settings: any;\r\n  enabled: boolean;\r\n  created_at: Date;\r\n  updated_at: Date;\r\n}\r\n\r\n\r\nexport default function Voicemail() {\r\n  const { user } = useAuth();\r\n  const [voicemailBoxes, setVoicemailBoxes] = useState<VoicemailBox[]>([]);\r\n  const [showModal, setShowModal] = useState(false);\r\n  const [modalType, setModalType] = useState<'create' | 'edit' | 'view'>('create');\r\n  const [loading, setLoading] = useState(false);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [formData, setFormData] = useState<Partial<VoicemailBox>>({});\r\n  const [editingItem, setEditingItem] = useState<VoicemailBox | null>(null);\r\n\r\n  // Load voicemail boxes on component mount\r\n  useEffect(() => {\r\n    loadVoicemailBoxes();\r\n  }, []);\r\n\r\n  const loadVoicemailBoxes = async () => {\r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/voicemail-boxes`);\r\n      const data = await response.json();\r\n      \r\n      if (data?.success && Array.isArray(data?.data)) {\r\n        setVoicemailBoxes(data.data);\r\n      } else {\r\n        console.warn('⚠️ Invalid API response format');\r\n        setVoicemailBoxes([]);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error loading voicemail boxes:', error);\r\n      setVoicemailBoxes([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleCreate = async () => {\r\n    if (!user?.tenant_id) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/voicemail-boxes`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          ...formData,\r\n          tenant_id: user.tenant_id\r\n        })\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadVoicemailBoxes();\r\n        setShowModal(false);\r\n        setFormData({});\r\n      } else {\r\n        console.error('❌ Error creating voicemail box:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error creating voicemail box:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleEdit = async () => {\r\n    if (!editingItem) return;\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/voicemail-boxes/${editingItem.id}`, {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(formData)\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadVoicemailBoxes();\r\n        setShowModal(false);\r\n        setFormData({});\r\n        setEditingItem(null);\r\n      } else {\r\n        console.error('❌ Error updating voicemail box:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error updating voicemail box:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (box: VoicemailBox) => {\r\n    if (!confirm(`Are you sure you want to delete voicemail box \"${box.mailbox_id}\"?`)) {\r\n      return;\r\n    }\r\n    \r\n    setLoading(true);\r\n    try {\r\n      const API_BASE_URL = 'http://localhost:3000/api';\r\n      const response = await fetch(`${API_BASE_URL}/voicemail-boxes/${box.id}`, {\r\n        method: 'DELETE'\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        await loadVoicemailBoxes();\r\n      } else {\r\n        console.error('❌ Error deleting voicemail box:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error deleting voicemail box:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const filteredBoxes = voicemailBoxes.filter(box =>\r\n    box.mailbox_id.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n    box.full_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n    box.email?.toLowerCase().includes(searchTerm.toLowerCase())\r\n  );\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold\">Voicemail</h1>\r\n          <p className=\"text-gray-600\">Manage voicemail boxes and messages</p>\r\n        </div>\r\n        <Button onClick={() => {\r\n          setModalType('create');\r\n          setFormData({\r\n            timezone: 'UTC',\r\n            attach_file: true,\r\n            delete_voicemail: false,\r\n            say_caller_id: true,\r\n            say_caller_id_name: true,\r\n            say_envelope: true,\r\n            skip_greeting: false,\r\n            skip_instructions: false,\r\n            email_attachment_format: 'wav',\r\n            max_greeting_length: 60,\r\n            max_message_length: 300,\r\n            settings: {}\r\n          });\r\n          setShowModal(true);\r\n        }}>\r\n          <Plus className=\"h-4 w-4 mr-2\" />\r\n          Add Voicemail Box\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Search and Stats */}\r\n      <div className=\"flex items-center space-x-4\">\r\n        <div className=\"relative flex-1 max-w-md\">\r\n          <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4\" />\r\n          <Input\r\n            placeholder=\"Search voicemail boxes...\"\r\n            value={searchTerm}\r\n            onChange={(e) => setSearchTerm(e.target.value)}\r\n            className=\"pl-10\"\r\n          />\r\n        </div>\r\n        <Button variant=\"outline\" onClick={loadVoicemailBoxes} disabled={loading}>\r\n          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />\r\n          Refresh\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Voicemail Boxes Grid */}\r\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\r\n        {filteredBoxes.map((box) => (\r\n          <Card key={box.id} className=\"relative\">\r\n            <CardHeader className=\"pb-3\">\r\n              <div className=\"flex items-start justify-between\">\r\n                <div className=\"flex-1\">\r\n                  <CardTitle className=\"text-lg\">{box.mailbox_id}</CardTitle>\r\n                  <CardDescription>{box.full_name}</CardDescription>\r\n                </div>\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Badge variant={box.enabled ? 'default' : 'secondary'}>\r\n                    {box.enabled ? 'Active' : 'Inactive'}\r\n                  </Badge>\r\n                  <Button variant=\"ghost\" size=\"sm\">\r\n                    <MoreHorizontal className=\"h-4 w-4\" />\r\n                  </Button>\r\n                </div>\r\n              </div>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              {/* Email */}\r\n              {box.email && (\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Mail className=\"h-4 w-4 text-gray-500\" />\r\n                  <span className=\"text-sm text-gray-600\">{box.email}</span>\r\n                </div>\r\n              )}\r\n\r\n              {/* Timezone */}\r\n              <div className=\"flex items-center space-x-2\">\r\n                <Clock className=\"h-4 w-4 text-gray-500\" />\r\n                <span className=\"text-sm text-gray-600\">{box.timezone}</span>\r\n              </div>\r\n\r\n              {/* Settings */}\r\n              <div className=\"space-y-2\">\r\n                <div className=\"flex items-center justify-between text-sm\">\r\n                  <span className=\"text-gray-600\">Attach Files</span>\r\n                  <Badge variant={box.attach_file ? 'default' : 'secondary'}>\r\n                    {box.attach_file ? 'Yes' : 'No'}\r\n                  </Badge>\r\n                </div>\r\n                <div className=\"flex items-center justify-between text-sm\">\r\n                  <span className=\"text-gray-600\">Say Caller ID</span>\r\n                  <Badge variant={box.say_caller_id ? 'default' : 'secondary'}>\r\n                    {box.say_caller_id ? 'Yes' : 'No'}\r\n                  </Badge>\r\n                </div>\r\n                <div className=\"flex items-center justify-between text-sm\">\r\n                  <span className=\"text-gray-600\">Max Message Length</span>\r\n                  <span className=\"text-sm text-gray-600\">{box.max_message_length}s</span>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"flex items-center space-x-2 pt-2 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('edit');\r\n                    setFormData(box);\r\n                    setEditingItem(box);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Edit className=\"h-4 w-4 mr-1\" />\r\n                  Edit\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => {\r\n                    setModalType('view');\r\n                    setFormData(box);\r\n                    setEditingItem(box);\r\n                    setShowModal(true);\r\n                  }}\r\n                >\r\n                  <Eye className=\"h-4 w-4 mr-1\" />\r\n                  View\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={() => handleDelete(box)}\r\n                  className=\"text-red-600 hover:text-red-700\"\r\n                >\r\n                  <Trash2 className=\"h-4 w-4\" />\r\n                </Button>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Empty State */}\r\n      {filteredBoxes.length === 0 && !loading && (\r\n        <Card>\r\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\r\n            <Mic className=\"h-12 w-12 text-gray-400 mb-4\" />\r\n            <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No Voicemail Boxes Found</h3>\r\n            <p className=\"text-gray-500 text-center mb-4\">\r\n              {searchTerm ? 'No voicemail boxes match your search criteria.' : 'Create your first voicemail box to get started.'}\r\n            </p>\r\n            {!searchTerm && (\r\n              <Button onClick={() => {\r\n                setModalType('create');\r\n                setFormData({\r\n                  timezone: 'UTC',\r\n                  attach_file: true,\r\n                  delete_voicemail: false,\r\n                  say_caller_id: true,\r\n                  say_caller_id_name: true,\r\n                  say_envelope: true,\r\n                  skip_greeting: false,\r\n                  skip_instructions: false,\r\n                  email_attachment_format: 'wav',\r\n                  max_greeting_length: 60,\r\n                  max_message_length: 300,\r\n                  settings: {}\r\n                });\r\n                setShowModal(true);\r\n              }}>\r\n                <Plus className=\"h-4 w-4 mr-2\" />\r\n                Create Voicemail Box\r\n              </Button>\r\n            )}\r\n          </CardContent>\r\n        </Card>\r\n      )}\r\n\r\n      {/* Create/Edit Modal */}\r\n      {showModal && (\r\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n          <Card className=\"w-full max-w-2xl max-h-[90vh] overflow-y-auto\">\r\n            <CardHeader>\r\n              <CardTitle>\r\n                {modalType === 'create' ? 'Create Voicemail Box' : \r\n                 modalType === 'edit' ? 'Edit Voicemail Box' : 'View Voicemail Box'}\r\n              </CardTitle>\r\n              <CardDescription>\r\n                {modalType === 'create' ? 'Create a new voicemail box' :\r\n                 modalType === 'edit' ? 'Update voicemail box settings' :\r\n                 'View voicemail box details'}\r\n              </CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4\">\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Mailbox ID</label>\r\n                  <Input\r\n                    value={formData.mailbox_id || ''}\r\n                    onChange={(e) => setFormData({ ...formData, mailbox_id: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"100\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Password</label>\r\n                  <Input\r\n                    type=\"password\"\r\n                    value={formData.password || ''}\r\n                    onChange={(e) => setFormData({ ...formData, password: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"1234\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Full Name</label>\r\n                  <Input\r\n                    value={formData.full_name || ''}\r\n                    onChange={(e) => setFormData({ ...formData, full_name: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"John Doe\"\r\n                  />\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Email</label>\r\n                  <Input\r\n                    type=\"email\"\r\n                    value={formData.email || ''}\r\n                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}\r\n                    disabled={modalType === 'view'}\r\n                    placeholder=\"john@example.com\"\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Timezone</label>\r\n                  <Select\r\n                    value={formData.timezone || 'UTC'}\r\n                    onValueChange={(value) => setFormData({ ...formData, timezone: value })}\r\n                    disabled={modalType === 'view'}\r\n                  >\r\n                    <SelectTrigger>\r\n                      <SelectValue />\r\n                    </SelectTrigger>\r\n                    <SelectContent>\r\n                      <SelectItem value=\"UTC\">UTC</SelectItem>\r\n                      <SelectItem value=\"Europe/Rome\">Europe/Rome</SelectItem>\r\n                      <SelectItem value=\"America/New_York\">America/New_York</SelectItem>\r\n                      <SelectItem value=\"Asia/Tokyo\">Asia/Tokyo</SelectItem>\r\n                    </SelectContent>\r\n                  </Select>\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-sm font-medium\">Email Attachment Format</label>\r\n                  <Select\r\n                    value={formData.email_attachment_format || 'wav'}\r\n                    onValueChange={(value) => setFormData({ ...formData, email_attachment_format: value })}\r\n                    disabled={modalType === 'view'}\r\n                  >\r\n                    <SelectTrigger>\r\n                      <SelectValue />\r\n                    </SelectTrigger>\r\n                    <SelectContent>\r\n                      <SelectItem value=\"wav\">WAV</SelectItem>\r\n                      <SelectItem value=\"mp3\">MP3</SelectItem>\r\n                      <SelectItem value=\"gsm\">GSM</SelectItem>\r\n                    </SelectContent>\r\n                  </Select>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Settings */}\r\n              <div className=\"space-y-3\">\r\n                <h4 className=\"font-medium\">Settings</h4>\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Switch\r\n                      checked={formData.attach_file || false}\r\n                      onCheckedChange={(checked) => setFormData({ ...formData, attach_file: checked })}\r\n                      disabled={modalType === 'view'}\r\n                    />\r\n                    <label className=\"text-sm font-medium\">Attach Files</label>\r\n                  </div>\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Switch\r\n                      checked={formData.say_caller_id || false}\r\n                      onCheckedChange={(checked) => setFormData({ ...formData, say_caller_id: checked })}\r\n                      disabled={modalType === 'view'}\r\n                    />\r\n                    <label className=\"text-sm font-medium\">Say Caller ID</label>\r\n                  </div>\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Switch\r\n                      checked={formData.say_caller_id_name || false}\r\n                      onCheckedChange={(checked) => setFormData({ ...formData, say_caller_id_name: checked })}\r\n                      disabled={modalType === 'view'}\r\n                    />\r\n                    <label className=\"text-sm font-medium\">Say Caller ID Name</label>\r\n                  </div>\r\n                  <div className=\"flex items-center space-x-2\">\r\n                    <Switch\r\n                      checked={formData.say_envelope || false}\r\n                      onCheckedChange={(checked) => setFormData({ ...formData, say_envelope: checked })}\r\n                      disabled={modalType === 'view'}\r\n                    />\r\n                    <label className=\"text-sm font-medium\">Say Envelope</label>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Modal Actions */}\r\n              <div className=\"flex items-center justify-end space-x-2 pt-4 border-t\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  onClick={() => {\r\n                    setShowModal(false);\r\n                    setFormData({});\r\n                    setEditingItem(null);\r\n                  }}\r\n                >\r\n                  Cancel\r\n                </Button>\r\n                {modalType !== 'view' && (\r\n                  <Button\r\n                    onClick={modalType === 'create' ? handleCreate : handleEdit}\r\n                    disabled={loading}\r\n                  >\r\n                    {loading ? 'Saving...' : modalType === 'create' ? 'Create' : 'Update'}\r\n                  </Button>\r\n                )}\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","size_bytes":19925},"packages/frontend/src/main.tsx":{"content":"import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.tsx'\nimport './index.css'\nimport './styles/extension-blocker.css'\nimport './utils/error-handler'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)","size_bytes":306},"packages/frontend/src/pages/LiveCalls.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Phone, PhoneIncoming, PhoneOutgoing, Mic, MicOff, Square, Pause, Play } from 'lucide-react';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface LiveCall {\n  id: string;\n  uuid: string;\n  direction: 'inbound' | 'outbound' | 'internal';\n  caller_number: string;\n  caller_name?: string;\n  callee_number: string;\n  callee_name?: string;\n  start_time: string;\n  duration: number;\n  status: 'ringing' | 'answered' | 'on_hold' | 'muted';\n  recording: boolean;\n}\n\nexport default function LiveCalls() {\n  const [liveCalls, setLiveCalls] = useState<LiveCall[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const { toast } = useToast();\n\n  useEffect(() => {\n    loadLiveCalls();\n    \n    // Simulate real-time updates\n    const interval = setInterval(loadLiveCalls, 5000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const loadLiveCalls = async () => {\n    try {\n      // In a real implementation, this would connect to WebSocket or Server-Sent Events\n      // For now, we'll simulate some live calls\n      const mockCalls: LiveCall[] = [\n        {\n          id: '1',\n          uuid: 'call-uuid-1',\n          direction: 'inbound',\n          caller_number: '+1234567890',\n          caller_name: 'John Doe',\n          callee_number: '1001',\n          callee_name: 'Reception',\n          start_time: new Date(Date.now() - 120000).toISOString(), // 2 minutes ago\n          duration: 120,\n          status: 'answered',\n          recording: true,\n        },\n        {\n          id: '2',\n          uuid: 'call-uuid-2',\n          direction: 'outbound',\n          caller_number: '1002',\n          caller_name: 'Sales Team',\n          callee_number: '+0987654321',\n          callee_name: 'Customer',\n          start_time: new Date(Date.now() - 300000).toISOString(), // 5 minutes ago\n          duration: 300,\n          status: 'answered',\n          recording: false,\n        },\n      ];\n      \n      setLiveCalls(mockCalls);\n    } catch (error) {\n      console.error('Failed to load live calls:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleCallAction = async (callUuid: string, action: string) => {\n    try {\n      // In a real implementation, this would call the API\n      toast({\n        title: \"Action performed\",\n        description: `${action} action sent for call ${callUuid}`,\n      });\n    } catch (error) {\n      toast({\n        title: \"Action failed\",\n        description: `Failed to perform ${action} action`,\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const getDirectionIcon = (direction: string) => {\n    switch (direction) {\n      case 'inbound':\n        return <PhoneIncoming className=\"h-5 w-5 text-green-600\" />;\n      case 'outbound':\n        return <PhoneOutgoing className=\"h-5 w-5 text-blue-600\" />;\n      case 'internal':\n        return <Phone className=\"h-5 w-5 text-purple-600\" />;\n      default:\n        return <Phone className=\"h-5 w-5 text-gray-600\" />;\n    }\n  };\n\n  const getStatusBadge = (status: string) => {\n    switch (status) {\n      case 'ringing':\n        return <Badge variant=\"secondary\">Ringing</Badge>;\n      case 'answered':\n        return <Badge variant=\"default\">Active</Badge>;\n      case 'on_hold':\n        return <Badge variant=\"outline\">On Hold</Badge>;\n      case 'muted':\n        return <Badge variant=\"destructive\">Muted</Badge>;\n      default:\n        return <Badge variant=\"outline\">Unknown</Badge>;\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold tracking-tight\">Live Calls</h1>\n          <p className=\"text-muted-foreground\">\n            Monitor active calls in real-time\n          </p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-2 w-2 bg-green-500 rounded-full animate-pulse\"></div>\n          <span className=\"text-sm text-gray-600\">Live</span>\n        </div>\n      </div>\n\n      {/* Active Calls Count */}\n      <div className=\"grid gap-4 md:grid-cols-4\">\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Total Active</CardTitle>\n            <Phone className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">{liveCalls.length}</div>\n            <p className=\"text-xs text-muted-foreground\">\n              Currently in progress\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Inbound</CardTitle>\n            <PhoneIncoming className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              {liveCalls.filter(call => call.direction === 'inbound').length}\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Incoming calls\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Outbound</CardTitle>\n            <PhoneOutgoing className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              {liveCalls.filter(call => call.direction === 'outbound').length}\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Outgoing calls\n            </p>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Internal</CardTitle>\n            <Phone className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              {liveCalls.filter(call => call.direction === 'internal').length}\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              Internal calls\n            </p>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Live Calls List */}\n      <div className=\"grid gap-4\">\n        {liveCalls.map((call) => (\n          <Card key={call.id}>\n            <CardHeader>\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-3\">\n                  {getDirectionIcon(call.direction)}\n                  <div>\n                    <CardTitle className=\"text-lg\">\n                      {call.caller_number} → {call.callee_number}\n                    </CardTitle>\n                    <CardDescription>\n                      {call.caller_name} → {call.callee_name}\n                    </CardDescription>\n                  </div>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  {getStatusBadge(call.status)}\n                  {call.recording && (\n                    <Badge variant=\"destructive\">Recording</Badge>\n                  )}\n                </div>\n              </div>\n            </CardHeader>\n            <CardContent>\n              <div className=\"grid gap-4 md:grid-cols-2\">\n                <div className=\"space-y-2\">\n                  <div className=\"text-sm\">\n                    <span className=\"font-medium\">Duration:</span>\n                    <span className=\"ml-2 text-muted-foreground\">\n                      {formatDuration(call.duration)}\n                    </span>\n                  </div>\n                  <div className=\"text-sm\">\n                    <span className=\"font-medium\">Started:</span>\n                    <span className=\"ml-2 text-muted-foreground\">\n                      {new Date(call.start_time).toLocaleTimeString()}\n                    </span>\n                  </div>\n                  <div className=\"text-sm\">\n                    <span className=\"font-medium\">Call UUID:</span>\n                    <span className=\"ml-2 text-muted-foreground font-mono text-xs\">\n                      {call.uuid}\n                    </span>\n                  </div>\n                </div>\n                \n                <div className=\"flex flex-wrap gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleCallAction(call.uuid, 'hold')}\n                  >\n                    <Pause className=\"h-4 w-4 mr-1\" />\n                    Hold\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleCallAction(call.uuid, 'mute')}\n                  >\n                    {call.status === 'muted' ? (\n                      <MicOff className=\"h-4 w-4 mr-1\" />\n                    ) : (\n                      <Mic className=\"h-4 w-4 mr-1\" />\n                    )}\n                    {call.status === 'muted' ? 'Unmute' : 'Mute'}\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleCallAction(call.uuid, 'record')}\n                  >\n                    {call.recording ? (\n                      <Square className=\"h-4 w-4 mr-1\" />\n                    ) : (\n                      <Play className=\"h-4 w-4 mr-1\" />\n                    )}\n                    {call.recording ? 'Stop Recording' : 'Start Recording'}\n                  </Button>\n                  <Button\n                    variant=\"destructive\"\n                    size=\"sm\"\n                    onClick={() => handleCallAction(call.uuid, 'hangup')}\n                  >\n                    <Phone className=\"h-4 w-4 mr-1\" />\n                    Hangup\n                  </Button>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {liveCalls.length === 0 && (\n        <Card>\n          <CardContent className=\"flex flex-col items-center justify-center py-12\">\n            <div className=\"text-center\">\n              <Phone className=\"h-12 w-12 text-gray-400 mx-auto mb-4\" />\n              <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                No active calls\n              </h3>\n              <p className=\"text-gray-500\">\n                There are currently no active calls in the system.\n              </p>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}","size_bytes":11522},"packages/backend/src/utils/response.ts":{"content":"import { Response } from 'express';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { ApiResponse } from '@w3-voip/shared';\r\n\r\n// Success response helper\r\nexport const successResponse = <T>(\r\n  res: Response,\r\n  data: T,\r\n  message?: string,\r\n  statusCode: number = 200\r\n): void => {\r\n  const response: ApiResponse<T> = {\r\n    success: true,\r\n    data,\r\n    meta: {\r\n      timestamp: new Date(),\r\n      request_id: res.get('X-Request-ID') || uuidv4(),\r\n      tenant_id: res.get('X-Tenant-ID') || undefined\r\n    }\r\n  };\r\n\r\n  if (message) {\r\n    (response as any).message = message;\r\n  }\r\n\r\n  res.status(statusCode).json(response);\r\n};\r\n\r\n// Error response helper\r\nexport const errorResponse = (\r\n  res: Response,\r\n  message: string,\r\n  statusCode: number = 500,\r\n  code?: string,\r\n  details?: any\r\n): void => {\r\n  const response: ApiResponse = {\r\n    success: false,\r\n    error: {\r\n      code: code || 'INTERNAL_ERROR',\r\n      message,\r\n      details\r\n    },\r\n    meta: {\r\n      timestamp: new Date(),\r\n      request_id: res.get('X-Request-ID') || uuidv4(),\r\n      tenant_id: res.get('X-Tenant-ID') || undefined\r\n    }\r\n  };\r\n\r\n  res.status(statusCode).json(response);\r\n};\r\n\r\n// Paginated response helper\r\nexport const paginatedResponse = <T>(\r\n  res: Response,\r\n  data: T[],\r\n  pagination: {\r\n    page: number;\r\n    limit: number;\r\n    total: number;\r\n    totalPages: number;\r\n  },\r\n  message?: string\r\n): void => {\r\n  const response: ApiResponse<{\r\n    items: T[];\r\n    pagination: typeof pagination;\r\n  }> = {\r\n    success: true,\r\n    data: {\r\n      items: data,\r\n      pagination\r\n    },\r\n    meta: {\r\n      timestamp: new Date(),\r\n      request_id: res.get('X-Request-ID') || uuidv4(),\r\n      tenant_id: res.get('X-Tenant-ID') || undefined\r\n    }\r\n  };\r\n\r\n  if (message) {\r\n    (response as any).message = message;\r\n  }\r\n\r\n  res.json(response);\r\n};\r\n\r\n// Created response helper\r\nexport const createdResponse = <T>(\r\n  res: Response,\r\n  data: T,\r\n  message: string = 'Resource created successfully'\r\n): void => {\r\n  successResponse(res, data, message, 201);\r\n};\r\n\r\n// Updated response helper\r\nexport const updatedResponse = <T>(\r\n  res: Response,\r\n  data: T,\r\n  message: string = 'Resource updated successfully'\r\n): void => {\r\n  successResponse(res, data, message, 200);\r\n};\r\n\r\n// Deleted response helper\r\nexport const deletedResponse = (\r\n  res: Response,\r\n  message: string = 'Resource deleted successfully'\r\n): void => {\r\n  successResponse(res, null, message, 200);\r\n};\r\n\r\n// Not found response helper\r\nexport const notFoundResponse = (\r\n  res: Response,\r\n  message: string = 'Resource not found'\r\n): void => {\r\n  errorResponse(res, message, 404, 'NOT_FOUND');\r\n};\r\n\r\n// Unauthorized response helper\r\nexport const unauthorizedResponse = (\r\n  res: Response,\r\n  message: string = 'Unauthorized access'\r\n): void => {\r\n  errorResponse(res, message, 401, 'UNAUTHORIZED');\r\n};\r\n\r\n// Forbidden response helper\r\nexport const forbiddenResponse = (\r\n  res: Response,\r\n  message: string = 'Access forbidden'\r\n): void => {\r\n  errorResponse(res, message, 403, 'FORBIDDEN');\r\n};\r\n\r\n// Bad request response helper\r\nexport const badRequestResponse = (\r\n  res: Response,\r\n  message: string = 'Bad request',\r\n  details?: any\r\n): void => {\r\n  errorResponse(res, message, 400, 'BAD_REQUEST', details);\r\n};\r\n\r\n// Conflict response helper\r\nexport const conflictResponse = (\r\n  res: Response,\r\n  message: string = 'Resource conflict'\r\n): void => {\r\n  errorResponse(res, message, 409, 'CONFLICT');\r\n};\r\n\r\n// Too many requests response helper\r\nexport const tooManyRequestsResponse = (\r\n  res: Response,\r\n  message: string = 'Too many requests'\r\n): void => {\r\n  errorResponse(res, message, 429, 'TOO_MANY_REQUESTS');\r\n};\r\n\r\n// Internal server error response helper\r\nexport const internalServerErrorResponse = (\r\n  res: Response,\r\n  message: string = 'Internal server error',\r\n  details?: any\r\n): void => {\r\n  errorResponse(res, message, 500, 'INTERNAL_SERVER_ERROR', details);\r\n};\r\n\r\n// Service unavailable response helper\r\nexport const serviceUnavailableResponse = (\r\n  res: Response,\r\n  message: string = 'Service temporarily unavailable'\r\n): void => {\r\n  errorResponse(res, message, 503, 'SERVICE_UNAVAILABLE');\r\n};\r\n\r\n// Async error handler wrapper\r\nexport const asyncHandler = (fn: Function) => {\r\n  return (req: any, res: any, next: any) => {\r\n    Promise.resolve(fn(req, res, next)).catch(next);\r\n  };\r\n};\r\n\r\n// Error handler middleware\r\nexport const errorHandler = (\r\n  error: any,\r\n  req: any,\r\n  res: any,\r\n  next: any\r\n): void => {\r\n  console.error('Error:', error);\r\n\r\n  // Default error\r\n  let statusCode = 500;\r\n  let message = 'Internal server error';\r\n  let code = 'INTERNAL_SERVER_ERROR';\r\n  let details = undefined;\r\n\r\n  // Handle specific error types\r\n  if (error.name === 'ValidationError') {\r\n    statusCode = 400;\r\n    message = 'Validation error';\r\n    code = 'VALIDATION_ERROR';\r\n    details = error.details;\r\n  } else if (error.name === 'UnauthorizedError') {\r\n    statusCode = 401;\r\n    message = 'Unauthorized';\r\n    code = 'UNAUTHORIZED';\r\n  } else if (error.name === 'ForbiddenError') {\r\n    statusCode = 403;\r\n    message = 'Forbidden';\r\n    code = 'FORBIDDEN';\r\n  } else if (error.name === 'NotFoundError') {\r\n    statusCode = 404;\r\n    message = 'Not found';\r\n    code = 'NOT_FOUND';\r\n  } else if (error.name === 'ConflictError') {\r\n    statusCode = 409;\r\n    message = 'Conflict';\r\n    code = 'CONFLICT';\r\n  } else if (error.name === 'RateLimitError') {\r\n    statusCode = 429;\r\n    message = 'Too many requests';\r\n    code = 'TOO_MANY_REQUESTS';\r\n  } else if (error.code === '23505') { // PostgreSQL unique violation\r\n    statusCode = 409;\r\n    message = 'Resource already exists';\r\n    code = 'DUPLICATE_RESOURCE';\r\n  } else if (error.code === '23503') { // PostgreSQL foreign key violation\r\n    statusCode = 400;\r\n    message = 'Referenced resource does not exist';\r\n    code = 'FOREIGN_KEY_VIOLATION';\r\n  } else if (error.code === '23502') { // PostgreSQL not null violation\r\n    statusCode = 400;\r\n    message = 'Required field is missing';\r\n    code = 'NOT_NULL_VIOLATION';\r\n  } else if (error.message) {\r\n    message = error.message;\r\n  }\r\n\r\n  // Don't expose internal errors in production\r\n  if (process.env.NODE_ENV === 'production' && statusCode === 500) {\r\n    message = 'Internal server error';\r\n    details = undefined;\r\n  }\r\n\r\n  errorResponse(res, message, statusCode, code, details);\r\n};\r\n\r\n","size_bytes":6417},"packages/frontend/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }","size_bytes":1055},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-select.js":{"content":"\"use client\";\nimport {\n  useDirection\n} from \"./chunk-YNLI6ANZ.js\";\nimport {\n  VISUALLY_HIDDEN_STYLES\n} from \"./chunk-LCRF5QSU.js\";\nimport {\n  createCollection\n} from \"./chunk-G7D2KNJE.js\";\nimport {\n  usePrevious,\n  useSize\n} from \"./chunk-NYXOVAH5.js\";\nimport {\n  Combination_default,\n  FocusScope,\n  hideOthers,\n  useFocusGuards\n} from \"./chunk-MCNPHWP5.js\";\nimport {\n  useId\n} from \"./chunk-O7ZJEN5H.js\";\nimport {\n  DismissableLayer,\n  Portal\n} from \"./chunk-UP2KX7JD.js\";\nimport {\n  useCallbackRef\n} from \"./chunk-Y2D2AKKB.js\";\nimport {\n  composeEventHandlers,\n  createContextScope,\n  useControllableState,\n  useLayoutEffect2\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  createSlot,\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport {\n  require_react_dom\n} from \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-select/dist/index.mjs\nvar React4 = __toESM(require_react(), 1);\nvar ReactDOM2 = __toESM(require_react_dom(), 1);\n\n// ../../node_modules/@radix-ui/number/dist/index.mjs\nfunction clamp(value, [min2, max2]) {\n  return Math.min(max2, Math.max(min2, value));\n}\n\n// ../../node_modules/@radix-ui/react-popper/dist/index.mjs\nvar React3 = __toESM(require_react(), 1);\n\n// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\nvar sides = [\"top\", \"right\", \"bottom\", \"left\"];\nvar alignments = [\"start\", \"end\"];\nvar placements = sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nvar min = Math.min;\nvar max = Math.max;\nvar round = Math.round;\nvar floor = Math.floor;\nvar createCoords = (v) => ({\n  x: v,\n  y: v\n});\nvar oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nvar oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp2(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nvar yAxisSides = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nvar lrPlacement = [\"left\", \"right\"];\nvar rlPlacement = [\"right\", \"left\"];\nvar tbPlacement = [\"top\", \"bottom\"];\nvar btPlacement = [\"bottom\", \"top\"];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case \"left\":\n    case \"right\":\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\n// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nvar computePosition = async (reference, floating, config) => {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));\n  let rects = await platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform: platform2,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = \"clippingAncestors\",\n    rootBoundary = \"viewport\",\n    elementContext = \"floating\",\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({\n    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === \"floating\" ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));\n  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\nvar arrow = (options) => ({\n  name: \"arrow\",\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform: platform2,\n      elements,\n      middlewareData\n    } = state;\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform2.getDimensions(element);\n    const isYAxis = axis === \"y\";\n    const minProp = isYAxis ? \"top\" : \"left\";\n    const maxProp = isYAxis ? \"bottom\" : \"right\";\n    const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n    const min$1 = minPadding;\n    const max2 = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset4 = clamp2(min$1, center, max2);\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset4,\n        centerOffset: center - offset4 - alignmentOffset,\n        ...shouldAddOffset && {\n          alignmentOffset\n        }\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\nvar flip = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform: platform2,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = \"bestFit\",\n        fallbackAxisSideDirection = \"none\",\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements2 = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides2 = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n      if (!overflows.every((side2) => side2 <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements2[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === \"alignment\" ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case \"bestFit\": {\n              var _overflowsData$filter2;\n              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {\n                if (hasFallbackAxisSideDirection) {\n                  const currentSideAxis = getSideAxis(d.placement);\n                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                  // reading directions favoring greater width.\n                  currentSideAxis === \"y\";\n                }\n                return true;\n              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n              if (placement2) {\n                resetPlacement = placement2;\n              }\n              break;\n            }\n            case \"initialPlacement\":\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some((side) => overflow[side] >= 0);\n}\nvar hide = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"hide\",\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = \"referenceHidden\",\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case \"referenceHidden\": {\n          const overflow = await detectOverflow(state, {\n            ...detectOverflowOptions,\n            elementContext: \"reference\"\n          });\n          const offsets = getSideOffsets(overflow, rects.reference);\n          return {\n            data: {\n              referenceHiddenOffsets: offsets,\n              referenceHidden: isAnySideFullyClipped(offsets)\n            }\n          };\n        }\n        case \"escaped\": {\n          const overflow = await detectOverflow(state, {\n            ...detectOverflowOptions,\n            altBoundary: true\n          });\n          const offsets = getSideOffsets(overflow, rects.floating);\n          return {\n            data: {\n              escapedOffsets: offsets,\n              escaped: isAnySideFullyClipped(offsets)\n            }\n          };\n        }\n        default: {\n          return {};\n        }\n      }\n    }\n  };\n};\nvar originSides = /* @__PURE__ */ new Set([\"left\", \"top\"]);\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform: platform2,\n    elements\n  } = state;\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === \"y\";\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === \"number\" ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === \"number\") {\n    crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\nvar offset = function(options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: \"offset\",\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\nvar shift = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: (_ref) => {\n            let {\n              x: x2,\n              y: y2\n            } = _ref;\n            return {\n              x: x2,\n              y: y2\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = mainAxisCoord + overflow[minSide];\n        const max2 = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = crossAxisCoord + overflow[minSide];\n        const max2 = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\nvar limitShift = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset: offset4 = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset4, state);\n      const computedOffset = typeof rawOffset === \"number\" ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === \"y\" ? \"height\" : \"width\";\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === \"y\" ? \"width\" : \"height\";\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\nvar size = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"size\",\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform: platform2,\n        elements\n      } = state;\n      const {\n        apply = () => {\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === \"y\";\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === \"top\" || side === \"bottom\") {\n        heightSide = side;\n        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n      } else {\n        widthSide = side;\n        heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform2.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nvar invalidOverflowDisplayValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle2(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nvar tableElements = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nvar topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nvar transformProperties = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"];\nvar willChangeValues = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"];\nvar containValues = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;\n  return transformProperties.some((value) => css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || willChangeValues.some((value) => (css.willChange || \"\").includes(value)) || containValues.some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nvar lastTraversableNodeNames = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle2(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\nfunction getCssDimensions(element) {\n  const css = getComputedStyle2(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nvar noOffsets = createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle2(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle2(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nvar SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === \"CSS1Compat\" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nvar absoluteOrFixed = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle2(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle2(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle2(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle2(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle2(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\nvar getElementRects = async function(data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\nfunction isRTL(element) {\n  return getComputedStyle2(element).direction === \"rtl\";\n}\nvar platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1e3);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nvar offset2 = offset;\nvar shift2 = shift;\nvar flip2 = flip;\nvar size2 = size;\nvar hide2 = hide;\nvar arrow2 = arrow;\nvar limitShift2 = limitShift;\nvar computePosition2 = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\nvar React = __toESM(require_react(), 1);\nvar import_react = __toESM(require_react(), 1);\nvar ReactDOM = __toESM(require_react_dom(), 1);\nvar isClient = typeof document !== \"undefined\";\nvar noop = function noop2() {\n};\nvar index = isClient ? import_react.useLayoutEffect : noop;\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === \"function\" && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === \"object\") {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0; ) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0; ) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0; ) {\n      const key = keys[i];\n      if (key === \"_owner\" && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback((node) => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback((node) => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform2);\n  const openRef = useLatestRef(open);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {\n      const fullData = {\n        ...data2,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData((data2) => ({\n        ...data2,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...getDPR(elements.floating) >= 1.5 && {\n          willChange: \"transform\"\n        }\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\nvar arrow$1 = (options) => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, \"current\");\n  }\n  return {\n    name: \"arrow\",\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === \"function\" ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow2({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow2({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\nvar offset3 = (options, deps) => ({\n  ...offset2(options),\n  options: [options, deps]\n});\nvar shift3 = (options, deps) => ({\n  ...shift2(options),\n  options: [options, deps]\n});\nvar limitShift3 = (options, deps) => ({\n  ...limitShift2(options),\n  options: [options, deps]\n});\nvar flip3 = (options, deps) => ({\n  ...flip2(options),\n  options: [options, deps]\n});\nvar size3 = (options, deps) => ({\n  ...size2(options),\n  options: [options, deps]\n});\nvar hide3 = (options, deps) => ({\n  ...hide2(options),\n  options: [options, deps]\n});\nvar arrow3 = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\n// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs\nvar React2 = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar NAME = \"Arrow\";\nvar Arrow = React2.forwardRef((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return (0, import_jsx_runtime.jsx)(\n    Primitive.svg,\n    {\n      ...arrowProps,\n      ref: forwardedRef,\n      width,\n      height,\n      viewBox: \"0 0 30 10\",\n      preserveAspectRatio: \"none\",\n      children: props.asChild ? children : (0, import_jsx_runtime.jsx)(\"polygon\", { points: \"0,0 30,0 15,10\" })\n    }\n  );\n});\nArrow.displayName = NAME;\nvar Root = Arrow;\n\n// ../../node_modules/@radix-ui/react-popper/dist/index.mjs\nvar import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = (props) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React3.useState(null);\n  return (0, import_jsx_runtime2.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React3.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React3.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const anchorRef = React3.useRef(null);\n    React3.useEffect(() => {\n      const previousAnchor = anchorRef.current;\n      anchorRef.current = virtualRef?.current || ref.current;\n      if (previousAnchor !== anchorRef.current) {\n        context.onAnchorChange(anchorRef.current);\n      }\n    });\n    return virtualRef ? null : (0, import_jsx_runtime2.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });\n  }\n);\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React3.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = \"bottom\",\n      sideOffset = 0,\n      align = \"center\",\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = \"partial\",\n      hideWhenDetached = false,\n      updatePositionStrategy = \"optimized\",\n      onPlaced,\n      ...contentProps\n    } = props;\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n    const [content, setContent] = React3.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [arrow4, setArrow] = React3.useState(null);\n    const arrowSize = useSize(arrow4);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n    const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n    const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries\n    };\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: \"fixed\",\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === \"always\"\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor\n      },\n      middleware: [\n        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions && shift3({\n          mainAxis: true,\n          crossAxis: false,\n          limiter: sticky === \"partial\" ? limitShift3() : void 0,\n          ...detectOverflowOptions\n        }),\n        avoidCollisions && flip3({ ...detectOverflowOptions }),\n        size3({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty(\"--radix-popper-available-width\", `${availableWidth}px`);\n            contentStyle.setProperty(\"--radix-popper-available-height\", `${availableHeight}px`);\n            contentStyle.setProperty(\"--radix-popper-anchor-width\", `${anchorWidth}px`);\n            contentStyle.setProperty(\"--radix-popper-anchor-height\", `${anchorHeight}px`);\n          }\n        }),\n        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide3({ strategy: \"referenceHidden\", ...detectOverflowOptions })\n      ]\n    });\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect2(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const [contentZIndex, setContentZIndex] = React3.useState();\n    useLayoutEffect2(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n    return (0, import_jsx_runtime2.jsx)(\n      \"div\",\n      {\n        ref: refs.setFloating,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: {\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: contentZIndex,\n          [\"--radix-popper-transform-origin\"]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y\n          ].join(\" \"),\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...middlewareData.hide?.referenceHidden && {\n            visibility: \"hidden\",\n            pointerEvents: \"none\"\n          }\n        },\n        dir: props.dir,\n        children: (0, import_jsx_runtime2.jsx)(\n          PopperContentProvider,\n          {\n            scope: __scopePopper,\n            placedSide,\n            onArrowChange: setArrow,\n            arrowX,\n            arrowY,\n            shouldHideArrow: cannotCenterArrow,\n            children: (0, import_jsx_runtime2.jsx)(\n              Primitive.div,\n              {\n                \"data-side\": placedSide,\n                \"data-align\": placedAlign,\n                ...contentProps,\n                ref: composedRefs,\n                style: {\n                  ...contentProps.style,\n                  // if the PopperContent hasn't been placed yet (not all measurements done)\n                  // we prevent animations so that users's animation don't kick in too early referring wrong sides\n                  animation: !isPositioned ? \"none\" : void 0\n                }\n              }\n            )\n          }\n        )\n      }\n    );\n  }\n);\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React3.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    (0, import_jsx_runtime2.jsx)(\n      \"span\",\n      {\n        ref: contentContext.onArrowChange,\n        style: {\n          position: \"absolute\",\n          left: contentContext.arrowX,\n          top: contentContext.arrowY,\n          [baseSide]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[contentContext.placedSide],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: `rotate(180deg)`,\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[contentContext.placedSide],\n          visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n        },\n        children: (0, import_jsx_runtime2.jsx)(\n          Root,\n          {\n            ...arrowProps,\n            ref: forwardedRef,\n            style: {\n              ...arrowProps.style,\n              // ensures the element can be measured correctly (mostly for if SVG)\n              display: \"block\"\n            }\n          }\n        )\n      }\n    )\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = (options) => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[placedAlign];\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow2 = PopperArrow;\n\n// ../../node_modules/@radix-ui/react-select/dist/index.mjs\nvar import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);\nvar OPEN_KEYS = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"];\nvar SELECTION_KEYS = [\" \", \"Enter\"];\nvar SELECT_NAME = \"Select\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);\nvar [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [\n  createCollectionScope,\n  createPopperScope\n]);\nvar usePopperScope = createPopperScope();\nvar [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);\nvar [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);\nvar Select = (props) => {\n  const {\n    __scopeSelect,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    value: valueProp,\n    defaultValue,\n    onValueChange,\n    dir,\n    name,\n    autoComplete,\n    disabled,\n    required,\n    form\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const [trigger, setTrigger] = React4.useState(null);\n  const [valueNode, setValueNode] = React4.useState(null);\n  const [valueNodeHasChildren, setValueNodeHasChildren] = React4.useState(false);\n  const direction = useDirection(dir);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: SELECT_NAME\n  });\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n    caller: SELECT_NAME\n  });\n  const triggerPointerDownPosRef = React4.useRef(null);\n  const isFormControl = trigger ? form || !!trigger.closest(\"form\") : true;\n  const [nativeOptionsSet, setNativeOptionsSet] = React4.useState(/* @__PURE__ */ new Set());\n  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(\";\");\n  return (0, import_jsx_runtime3.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime3.jsxs)(\n    SelectProvider,\n    {\n      required,\n      scope: __scopeSelect,\n      trigger,\n      onTriggerChange: setTrigger,\n      valueNode,\n      onValueNodeChange: setValueNode,\n      valueNodeHasChildren,\n      onValueNodeHasChildrenChange: setValueNodeHasChildren,\n      contentId: useId(),\n      value,\n      onValueChange: setValue,\n      open,\n      onOpenChange: setOpen,\n      dir: direction,\n      triggerPointerDownPosRef,\n      disabled,\n      children: [\n        (0, import_jsx_runtime3.jsx)(Collection.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime3.jsx)(\n          SelectNativeOptionsProvider,\n          {\n            scope: props.__scopeSelect,\n            onNativeOptionAdd: React4.useCallback((option) => {\n              setNativeOptionsSet((prev) => new Set(prev).add(option));\n            }, []),\n            onNativeOptionRemove: React4.useCallback((option) => {\n              setNativeOptionsSet((prev) => {\n                const optionsSet = new Set(prev);\n                optionsSet.delete(option);\n                return optionsSet;\n              });\n            }, []),\n            children\n          }\n        ) }),\n        isFormControl ? (0, import_jsx_runtime3.jsxs)(\n          SelectBubbleInput,\n          {\n            \"aria-hidden\": true,\n            required,\n            tabIndex: -1,\n            name,\n            autoComplete,\n            value,\n            onChange: (event) => setValue(event.target.value),\n            disabled,\n            form,\n            children: [\n              value === void 0 ? (0, import_jsx_runtime3.jsx)(\"option\", { value: \"\" }) : null,\n              Array.from(nativeOptionsSet)\n            ]\n          },\n          nativeSelectKey\n        ) : null\n      ]\n    }\n  ) });\n};\nSelect.displayName = SELECT_NAME;\nvar TRIGGER_NAME = \"SelectTrigger\";\nvar SelectTrigger = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, disabled = false, ...triggerProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n    const isDisabled = context.disabled || disabled;\n    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);\n    const getItems = useCollection(__scopeSelect);\n    const pointerTypeRef = React4.useRef(\"touch\");\n    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.value === context.value);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem !== void 0) {\n        context.onValueChange(nextItem.value);\n      }\n    });\n    const handleOpen = (pointerEvent) => {\n      if (!isDisabled) {\n        context.onOpenChange(true);\n        resetTypeahead();\n      }\n      if (pointerEvent) {\n        context.triggerPointerDownPosRef.current = {\n          x: Math.round(pointerEvent.pageX),\n          y: Math.round(pointerEvent.pageY)\n        };\n      }\n    };\n    return (0, import_jsx_runtime3.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime3.jsx)(\n      Primitive.button,\n      {\n        type: \"button\",\n        role: \"combobox\",\n        \"aria-controls\": context.contentId,\n        \"aria-expanded\": context.open,\n        \"aria-required\": context.required,\n        \"aria-autocomplete\": \"none\",\n        dir: context.dir,\n        \"data-state\": context.open ? \"open\" : \"closed\",\n        disabled: isDisabled,\n        \"data-disabled\": isDisabled ? \"\" : void 0,\n        \"data-placeholder\": shouldShowPlaceholder(context.value) ? \"\" : void 0,\n        ...triggerProps,\n        ref: composedRefs,\n        onClick: composeEventHandlers(triggerProps.onClick, (event) => {\n          event.currentTarget.focus();\n          if (pointerTypeRef.current !== \"mouse\") {\n            handleOpen(event);\n          }\n        }),\n        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {\n          pointerTypeRef.current = event.pointerType;\n          const target = event.target;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n          }\n          if (event.button === 0 && event.ctrlKey === false && event.pointerType === \"mouse\") {\n            handleOpen(event);\n            event.preventDefault();\n          }\n        }),\n        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {\n          const isTypingAhead = searchRef.current !== \"\";\n          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n          if (isTypingAhead && event.key === \" \") return;\n          if (OPEN_KEYS.includes(event.key)) {\n            handleOpen();\n            event.preventDefault();\n          }\n        })\n      }\n    ) });\n  }\n);\nSelectTrigger.displayName = TRIGGER_NAME;\nvar VALUE_NAME = \"SelectValue\";\nvar SelectValue = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, className, style, children, placeholder = \"\", ...valueProps } = props;\n    const context = useSelectContext(VALUE_NAME, __scopeSelect);\n    const { onValueNodeHasChildrenChange } = context;\n    const hasChildren = children !== void 0;\n    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n    useLayoutEffect2(() => {\n      onValueNodeHasChildrenChange(hasChildren);\n    }, [onValueNodeHasChildrenChange, hasChildren]);\n    return (0, import_jsx_runtime3.jsx)(\n      Primitive.span,\n      {\n        ...valueProps,\n        ref: composedRefs,\n        style: { pointerEvents: \"none\" },\n        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: placeholder }) : children\n      }\n    );\n  }\n);\nSelectValue.displayName = VALUE_NAME;\nvar ICON_NAME = \"SelectIcon\";\nvar SelectIcon = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, children, ...iconProps } = props;\n    return (0, import_jsx_runtime3.jsx)(Primitive.span, { \"aria-hidden\": true, ...iconProps, ref: forwardedRef, children: children || \"▼\" });\n  }\n);\nSelectIcon.displayName = ICON_NAME;\nvar PORTAL_NAME = \"SelectPortal\";\nvar SelectPortal = (props) => {\n  return (0, import_jsx_runtime3.jsx)(Portal, { asChild: true, ...props });\n};\nSelectPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME2 = \"SelectContent\";\nvar SelectContent = React4.forwardRef(\n  (props, forwardedRef) => {\n    const context = useSelectContext(CONTENT_NAME2, props.__scopeSelect);\n    const [fragment, setFragment] = React4.useState();\n    useLayoutEffect2(() => {\n      setFragment(new DocumentFragment());\n    }, []);\n    if (!context.open) {\n      const frag = fragment;\n      return frag ? ReactDOM2.createPortal(\n        (0, import_jsx_runtime3.jsx)(SelectContentProvider, { scope: props.__scopeSelect, children: (0, import_jsx_runtime3.jsx)(Collection.Slot, { scope: props.__scopeSelect, children: (0, import_jsx_runtime3.jsx)(\"div\", { children: props.children }) }) }),\n        frag\n      ) : null;\n    }\n    return (0, import_jsx_runtime3.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });\n  }\n);\nSelectContent.displayName = CONTENT_NAME2;\nvar CONTENT_MARGIN = 10;\nvar [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME2);\nvar CONTENT_IMPL_NAME = \"SelectContentImpl\";\nvar Slot = createSlot(\"SelectContent.RemoveScroll\");\nvar SelectContentImpl = React4.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSelect,\n      position = \"item-aligned\",\n      onCloseAutoFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      //\n      // PopperContent props\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      arrowPadding,\n      collisionBoundary,\n      collisionPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions,\n      //\n      ...contentProps\n    } = props;\n    const context = useSelectContext(CONTENT_NAME2, __scopeSelect);\n    const [content, setContent] = React4.useState(null);\n    const [viewport, setViewport] = React4.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [selectedItem, setSelectedItem] = React4.useState(null);\n    const [selectedItemText, setSelectedItemText] = React4.useState(\n      null\n    );\n    const getItems = useCollection(__scopeSelect);\n    const [isPositioned, setIsPositioned] = React4.useState(false);\n    const firstValidItemFoundRef = React4.useRef(false);\n    React4.useEffect(() => {\n      if (content) return hideOthers(content);\n    }, [content]);\n    useFocusGuards();\n    const focusFirst = React4.useCallback(\n      (candidates) => {\n        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);\n        const [lastItem] = restItems.slice(-1);\n        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n        for (const candidate of candidates) {\n          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n          candidate?.scrollIntoView({ block: \"nearest\" });\n          if (candidate === firstItem && viewport) viewport.scrollTop = 0;\n          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;\n          candidate?.focus();\n          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n        }\n      },\n      [getItems, viewport]\n    );\n    const focusSelectedItem = React4.useCallback(\n      () => focusFirst([selectedItem, content]),\n      [focusFirst, selectedItem, content]\n    );\n    React4.useEffect(() => {\n      if (isPositioned) {\n        focusSelectedItem();\n      }\n    }, [isPositioned, focusSelectedItem]);\n    const { onOpenChange, triggerPointerDownPosRef } = context;\n    React4.useEffect(() => {\n      if (content) {\n        let pointerMoveDelta = { x: 0, y: 0 };\n        const handlePointerMove = (event) => {\n          pointerMoveDelta = {\n            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),\n            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))\n          };\n        };\n        const handlePointerUp = (event) => {\n          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n            event.preventDefault();\n          } else {\n            if (!content.contains(event.target)) {\n              onOpenChange(false);\n            }\n          }\n          document.removeEventListener(\"pointermove\", handlePointerMove);\n          triggerPointerDownPosRef.current = null;\n        };\n        if (triggerPointerDownPosRef.current !== null) {\n          document.addEventListener(\"pointermove\", handlePointerMove);\n          document.addEventListener(\"pointerup\", handlePointerUp, { capture: true, once: true });\n        }\n        return () => {\n          document.removeEventListener(\"pointermove\", handlePointerMove);\n          document.removeEventListener(\"pointerup\", handlePointerUp, { capture: true });\n        };\n      }\n    }, [content, onOpenChange, triggerPointerDownPosRef]);\n    React4.useEffect(() => {\n      const close = () => onOpenChange(false);\n      window.addEventListener(\"blur\", close);\n      window.addEventListener(\"resize\", close);\n      return () => {\n        window.removeEventListener(\"blur\", close);\n        window.removeEventListener(\"resize\", close);\n      };\n    }, [onOpenChange]);\n    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem) {\n        setTimeout(() => nextItem.ref.current.focus());\n      }\n    });\n    const itemRefCallback = React4.useCallback(\n      (node, value, disabled) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== void 0 && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItem(node);\n          if (isFirstValidItem) firstValidItemFoundRef.current = true;\n        }\n      },\n      [context.value]\n    );\n    const handleItemLeave = React4.useCallback(() => content?.focus(), [content]);\n    const itemTextRefCallback = React4.useCallback(\n      (node, value, disabled) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== void 0 && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItemText(node);\n        }\n      },\n      [context.value]\n    );\n    const SelectPosition = position === \"popper\" ? SelectPopperPosition : SelectItemAlignedPosition;\n    const popperContentProps = SelectPosition === SelectPopperPosition ? {\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      arrowPadding,\n      collisionBoundary,\n      collisionPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions\n    } : {};\n    return (0, import_jsx_runtime3.jsx)(\n      SelectContentProvider,\n      {\n        scope: __scopeSelect,\n        content,\n        viewport,\n        onViewportChange: setViewport,\n        itemRefCallback,\n        selectedItem,\n        onItemLeave: handleItemLeave,\n        itemTextRefCallback,\n        focusSelectedItem,\n        selectedItemText,\n        position,\n        isPositioned,\n        searchRef,\n        children: (0, import_jsx_runtime3.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: (0, import_jsx_runtime3.jsx)(\n          FocusScope,\n          {\n            asChild: true,\n            trapped: context.open,\n            onMountAutoFocus: (event) => {\n              event.preventDefault();\n            },\n            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {\n              context.trigger?.focus({ preventScroll: true });\n              event.preventDefault();\n            }),\n            children: (0, import_jsx_runtime3.jsx)(\n              DismissableLayer,\n              {\n                asChild: true,\n                disableOutsidePointerEvents: true,\n                onEscapeKeyDown,\n                onPointerDownOutside,\n                onFocusOutside: (event) => event.preventDefault(),\n                onDismiss: () => context.onOpenChange(false),\n                children: (0, import_jsx_runtime3.jsx)(\n                  SelectPosition,\n                  {\n                    role: \"listbox\",\n                    id: context.contentId,\n                    \"data-state\": context.open ? \"open\" : \"closed\",\n                    dir: context.dir,\n                    onContextMenu: (event) => event.preventDefault(),\n                    ...contentProps,\n                    ...popperContentProps,\n                    onPlaced: () => setIsPositioned(true),\n                    ref: composedRefs,\n                    style: {\n                      // flex layout so we can place the scroll buttons properly\n                      display: \"flex\",\n                      flexDirection: \"column\",\n                      // reset the outline by default as the content MAY get focused\n                      outline: \"none\",\n                      ...contentProps.style\n                    },\n                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {\n                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                      if (event.key === \"Tab\") event.preventDefault();\n                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n                      if ([\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(event.key)) {\n                        const items = getItems().filter((item) => !item.disabled);\n                        let candidateNodes = items.map((item) => item.ref.current);\n                        if ([\"ArrowUp\", \"End\"].includes(event.key)) {\n                          candidateNodes = candidateNodes.slice().reverse();\n                        }\n                        if ([\"ArrowUp\", \"ArrowDown\"].includes(event.key)) {\n                          const currentElement = event.target;\n                          const currentIndex = candidateNodes.indexOf(currentElement);\n                          candidateNodes = candidateNodes.slice(currentIndex + 1);\n                        }\n                        setTimeout(() => focusFirst(candidateNodes));\n                        event.preventDefault();\n                      }\n                    })\n                  }\n                )\n              }\n            )\n          }\n        ) })\n      }\n    );\n  }\n);\nSelectContentImpl.displayName = CONTENT_IMPL_NAME;\nvar ITEM_ALIGNED_POSITION_NAME = \"SelectItemAlignedPosition\";\nvar SelectItemAlignedPosition = React4.forwardRef((props, forwardedRef) => {\n  const { __scopeSelect, onPlaced, ...popperProps } = props;\n  const context = useSelectContext(CONTENT_NAME2, __scopeSelect);\n  const contentContext = useSelectContentContext(CONTENT_NAME2, __scopeSelect);\n  const [contentWrapper, setContentWrapper] = React4.useState(null);\n  const [content, setContent] = React4.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n  const getItems = useCollection(__scopeSelect);\n  const shouldExpandOnScrollRef = React4.useRef(false);\n  const shouldRepositionRef = React4.useRef(true);\n  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;\n  const position = React4.useCallback(() => {\n    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {\n      const triggerRect = context.trigger.getBoundingClientRect();\n      const contentRect = content.getBoundingClientRect();\n      const valueNodeRect = context.valueNode.getBoundingClientRect();\n      const itemTextRect = selectedItemText.getBoundingClientRect();\n      if (context.dir !== \"rtl\") {\n        const itemTextOffset = itemTextRect.left - contentRect.left;\n        const left = valueNodeRect.left - itemTextOffset;\n        const leftDelta = triggerRect.left - left;\n        const minContentWidth = triggerRect.width + leftDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const rightEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedLeft = clamp(left, [\n          CONTENT_MARGIN,\n          // Prevents the content from going off the starting edge of the\n          // viewport. It may still go off the ending edge, but this can be\n          // controlled by the user since they may want to manage overflow in a\n          // specific way.\n          // https://github.com/radix-ui/primitives/issues/2049\n          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)\n        ]);\n        contentWrapper.style.minWidth = minContentWidth + \"px\";\n        contentWrapper.style.left = clampedLeft + \"px\";\n      } else {\n        const itemTextOffset = contentRect.right - itemTextRect.right;\n        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;\n        const rightDelta = window.innerWidth - triggerRect.right - right;\n        const minContentWidth = triggerRect.width + rightDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const leftEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedRight = clamp(right, [\n          CONTENT_MARGIN,\n          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)\n        ]);\n        contentWrapper.style.minWidth = minContentWidth + \"px\";\n        contentWrapper.style.right = clampedRight + \"px\";\n      }\n      const items = getItems();\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n      const itemsHeight = viewport.scrollHeight;\n      const contentStyles = window.getComputedStyle(content);\n      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);\n      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);\n      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);\n      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);\n      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;\n      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);\n      const viewportStyles = window.getComputedStyle(viewport);\n      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);\n      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);\n      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;\n      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;\n      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;\n      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;\n      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;\n      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;\n      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;\n      if (willAlignWithoutTopOverflow) {\n        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;\n        contentWrapper.style.bottom = \"0px\";\n        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;\n        const clampedTriggerMiddleToBottomEdge = Math.max(\n          triggerMiddleToBottomEdge,\n          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport\n          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth\n        );\n        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;\n        contentWrapper.style.height = height + \"px\";\n      } else {\n        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;\n        contentWrapper.style.top = \"0px\";\n        const clampedTopEdgeToTriggerMiddle = Math.max(\n          topEdgeToTriggerMiddle,\n          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport\n          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight\n        );\n        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;\n        contentWrapper.style.height = height + \"px\";\n        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;\n      }\n      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;\n      contentWrapper.style.minHeight = minContentHeight + \"px\";\n      contentWrapper.style.maxHeight = availableHeight + \"px\";\n      onPlaced?.();\n      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);\n    }\n  }, [\n    getItems,\n    context.trigger,\n    context.valueNode,\n    contentWrapper,\n    content,\n    viewport,\n    selectedItem,\n    selectedItemText,\n    context.dir,\n    onPlaced\n  ]);\n  useLayoutEffect2(() => position(), [position]);\n  const [contentZIndex, setContentZIndex] = React4.useState();\n  useLayoutEffect2(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  const handleScrollButtonChange = React4.useCallback(\n    (node) => {\n      if (node && shouldRepositionRef.current === true) {\n        position();\n        focusSelectedItem?.();\n        shouldRepositionRef.current = false;\n      }\n    },\n    [position, focusSelectedItem]\n  );\n  return (0, import_jsx_runtime3.jsx)(\n    SelectViewportProvider,\n    {\n      scope: __scopeSelect,\n      contentWrapper,\n      shouldExpandOnScrollRef,\n      onScrollButtonChange: handleScrollButtonChange,\n      children: (0, import_jsx_runtime3.jsx)(\n        \"div\",\n        {\n          ref: setContentWrapper,\n          style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            position: \"fixed\",\n            zIndex: contentZIndex\n          },\n          children: (0, import_jsx_runtime3.jsx)(\n            Primitive.div,\n            {\n              ...popperProps,\n              ref: composedRefs,\n              style: {\n                // When we get the height of the content, it includes borders. If we were to set\n                // the height without having `boxSizing: 'border-box'` it would be too big.\n                boxSizing: \"border-box\",\n                // We need to ensure the content doesn't get taller than the wrapper\n                maxHeight: \"100%\",\n                ...popperProps.style\n              }\n            }\n          )\n        }\n      )\n    }\n  );\n});\nSelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;\nvar POPPER_POSITION_NAME = \"SelectPopperPosition\";\nvar SelectPopperPosition = React4.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    align = \"start\",\n    collisionPadding = CONTENT_MARGIN,\n    ...popperProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  return (0, import_jsx_runtime3.jsx)(\n    Content,\n    {\n      ...popperScope,\n      ...popperProps,\n      ref: forwardedRef,\n      align,\n      collisionPadding,\n      style: {\n        // Ensure border-box for floating-ui calculations\n        boxSizing: \"border-box\",\n        ...popperProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        }\n      }\n    }\n  );\n});\nSelectPopperPosition.displayName = POPPER_POSITION_NAME;\nvar [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME2, {});\nvar VIEWPORT_NAME = \"SelectViewport\";\nvar SelectViewport = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, nonce, ...viewportProps } = props;\n    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);\n    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);\n    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);\n    const prevScrollTopRef = React4.useRef(0);\n    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [\n      (0, import_jsx_runtime3.jsx)(\n        \"style\",\n        {\n          dangerouslySetInnerHTML: {\n            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`\n          },\n          nonce\n        }\n      ),\n      (0, import_jsx_runtime3.jsx)(Collection.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime3.jsx)(\n        Primitive.div,\n        {\n          \"data-radix-select-viewport\": \"\",\n          role: \"presentation\",\n          ...viewportProps,\n          ref: composedRefs,\n          style: {\n            // we use position: 'relative' here on the `viewport` so that when we call\n            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n            // (independent of the scrollUpButton).\n            position: \"relative\",\n            flex: 1,\n            // Viewport should only be scrollable in the vertical direction.\n            // This won't work in vertical writing modes, so we'll need to\n            // revisit this if/when that is supported\n            // https://developer.chrome.com/blog/vertical-form-controls\n            overflow: \"hidden auto\",\n            ...viewportProps.style\n          },\n          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {\n            const viewport = event.currentTarget;\n            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;\n            if (shouldExpandOnScrollRef?.current && contentWrapper) {\n              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);\n              if (scrolledBy > 0) {\n                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);\n                const cssHeight = parseFloat(contentWrapper.style.height);\n                const prevHeight = Math.max(cssMinHeight, cssHeight);\n                if (prevHeight < availableHeight) {\n                  const nextHeight = prevHeight + scrolledBy;\n                  const clampedNextHeight = Math.min(availableHeight, nextHeight);\n                  const heightDiff = nextHeight - clampedNextHeight;\n                  contentWrapper.style.height = clampedNextHeight + \"px\";\n                  if (contentWrapper.style.bottom === \"0px\") {\n                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;\n                    contentWrapper.style.justifyContent = \"flex-end\";\n                  }\n                }\n              }\n            }\n            prevScrollTopRef.current = viewport.scrollTop;\n          })\n        }\n      ) })\n    ] });\n  }\n);\nSelectViewport.displayName = VIEWPORT_NAME;\nvar GROUP_NAME = \"SelectGroup\";\nvar [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);\nvar SelectGroup = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...groupProps } = props;\n    const groupId = useId();\n    return (0, import_jsx_runtime3.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime3.jsx)(Primitive.div, { role: \"group\", \"aria-labelledby\": groupId, ...groupProps, ref: forwardedRef }) });\n  }\n);\nSelectGroup.displayName = GROUP_NAME;\nvar LABEL_NAME = \"SelectLabel\";\nvar SelectLabel = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...labelProps } = props;\n    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n    return (0, import_jsx_runtime3.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });\n  }\n);\nSelectLabel.displayName = LABEL_NAME;\nvar ITEM_NAME = \"SelectItem\";\nvar [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);\nvar SelectItem = React4.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSelect,\n      value,\n      disabled = false,\n      textValue: textValueProp,\n      ...itemProps\n    } = props;\n    const context = useSelectContext(ITEM_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);\n    const isSelected = context.value === value;\n    const [textValue, setTextValue] = React4.useState(textValueProp ?? \"\");\n    const [isFocused, setIsFocused] = React4.useState(false);\n    const composedRefs = useComposedRefs(\n      forwardedRef,\n      (node) => contentContext.itemRefCallback?.(node, value, disabled)\n    );\n    const textId = useId();\n    const pointerTypeRef = React4.useRef(\"touch\");\n    const handleSelect = () => {\n      if (!disabled) {\n        context.onValueChange(value);\n        context.onOpenChange(false);\n      }\n    };\n    if (value === \"\") {\n      throw new Error(\n        \"A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    }\n    return (0, import_jsx_runtime3.jsx)(\n      SelectItemContextProvider,\n      {\n        scope: __scopeSelect,\n        value,\n        disabled,\n        textId,\n        isSelected,\n        onItemTextChange: React4.useCallback((node) => {\n          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? \"\").trim());\n        }, []),\n        children: (0, import_jsx_runtime3.jsx)(\n          Collection.ItemSlot,\n          {\n            scope: __scopeSelect,\n            value,\n            disabled,\n            textValue,\n            children: (0, import_jsx_runtime3.jsx)(\n              Primitive.div,\n              {\n                role: \"option\",\n                \"aria-labelledby\": textId,\n                \"data-highlighted\": isFocused ? \"\" : void 0,\n                \"aria-selected\": isSelected && isFocused,\n                \"data-state\": isSelected ? \"checked\" : \"unchecked\",\n                \"aria-disabled\": disabled || void 0,\n                \"data-disabled\": disabled ? \"\" : void 0,\n                tabIndex: disabled ? void 0 : -1,\n                ...itemProps,\n                ref: composedRefs,\n                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),\n                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),\n                onClick: composeEventHandlers(itemProps.onClick, () => {\n                  if (pointerTypeRef.current !== \"mouse\") handleSelect();\n                }),\n                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {\n                  if (pointerTypeRef.current === \"mouse\") handleSelect();\n                }),\n                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {\n                  pointerTypeRef.current = event.pointerType;\n                }),\n                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {\n                  pointerTypeRef.current = event.pointerType;\n                  if (disabled) {\n                    contentContext.onItemLeave?.();\n                  } else if (pointerTypeRef.current === \"mouse\") {\n                    event.currentTarget.focus({ preventScroll: true });\n                  }\n                }),\n                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {\n                  if (event.currentTarget === document.activeElement) {\n                    contentContext.onItemLeave?.();\n                  }\n                }),\n                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {\n                  const isTypingAhead = contentContext.searchRef?.current !== \"\";\n                  if (isTypingAhead && event.key === \" \") return;\n                  if (SELECTION_KEYS.includes(event.key)) handleSelect();\n                  if (event.key === \" \") event.preventDefault();\n                })\n              }\n            )\n          }\n        )\n      }\n    );\n  }\n);\nSelectItem.displayName = ITEM_NAME;\nvar ITEM_TEXT_NAME = \"SelectItemText\";\nvar SelectItemText = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, className, style, ...itemTextProps } = props;\n    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);\n    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);\n    const [itemTextNode, setItemTextNode] = React4.useState(null);\n    const composedRefs = useComposedRefs(\n      forwardedRef,\n      (node) => setItemTextNode(node),\n      itemContext.onItemTextChange,\n      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)\n    );\n    const textContent = itemTextNode?.textContent;\n    const nativeOption = React4.useMemo(\n      () => (0, import_jsx_runtime3.jsx)(\"option\", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),\n      [itemContext.disabled, itemContext.value, textContent]\n    );\n    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;\n    useLayoutEffect2(() => {\n      onNativeOptionAdd(nativeOption);\n      return () => onNativeOptionRemove(nativeOption);\n    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);\n    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [\n      (0, import_jsx_runtime3.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),\n      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM2.createPortal(itemTextProps.children, context.valueNode) : null\n    ] });\n  }\n);\nSelectItemText.displayName = ITEM_TEXT_NAME;\nvar ITEM_INDICATOR_NAME = \"SelectItemIndicator\";\nvar SelectItemIndicator = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...itemIndicatorProps } = props;\n    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n    return itemContext.isSelected ? (0, import_jsx_runtime3.jsx)(Primitive.span, { \"aria-hidden\": true, ...itemIndicatorProps, ref: forwardedRef }) : null;\n  }\n);\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\nvar SCROLL_UP_BUTTON_NAME = \"SelectScrollUpButton\";\nvar SelectScrollUpButton = React4.forwardRef((props, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollUp, setCanScrollUp] = React4.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n  useLayoutEffect2(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      let handleScroll2 = function() {\n        const canScrollUp2 = viewport.scrollTop > 0;\n        setCanScrollUp(canScrollUp2);\n      };\n      var handleScroll = handleScroll2;\n      const viewport = contentContext.viewport;\n      handleScroll2();\n      viewport.addEventListener(\"scroll\", handleScroll2);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll2);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n  return canScrollUp ? (0, import_jsx_runtime3.jsx)(\n    SelectScrollButtonImpl,\n    {\n      ...props,\n      ref: composedRefs,\n      onAutoScroll: () => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;\n        }\n      }\n    }\n  ) : null;\n});\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\nvar SCROLL_DOWN_BUTTON_NAME = \"SelectScrollDownButton\";\nvar SelectScrollDownButton = React4.forwardRef((props, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollDown, setCanScrollDown] = React4.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n  useLayoutEffect2(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      let handleScroll2 = function() {\n        const maxScroll = viewport.scrollHeight - viewport.clientHeight;\n        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;\n        setCanScrollDown(canScrollDown2);\n      };\n      var handleScroll = handleScroll2;\n      const viewport = contentContext.viewport;\n      handleScroll2();\n      viewport.addEventListener(\"scroll\", handleScroll2);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll2);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n  return canScrollDown ? (0, import_jsx_runtime3.jsx)(\n    SelectScrollButtonImpl,\n    {\n      ...props,\n      ref: composedRefs,\n      onAutoScroll: () => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;\n        }\n      }\n    }\n  ) : null;\n});\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\nvar SelectScrollButtonImpl = React4.forwardRef((props, forwardedRef) => {\n  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;\n  const contentContext = useSelectContentContext(\"SelectScrollButton\", __scopeSelect);\n  const autoScrollTimerRef = React4.useRef(null);\n  const getItems = useCollection(__scopeSelect);\n  const clearAutoScrollTimer = React4.useCallback(() => {\n    if (autoScrollTimerRef.current !== null) {\n      window.clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n  React4.useEffect(() => {\n    return () => clearAutoScrollTimer();\n  }, [clearAutoScrollTimer]);\n  useLayoutEffect2(() => {\n    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);\n    activeItem?.ref.current?.scrollIntoView({ block: \"nearest\" });\n  }, [getItems]);\n  return (0, import_jsx_runtime3.jsx)(\n    Primitive.div,\n    {\n      \"aria-hidden\": true,\n      ...scrollIndicatorProps,\n      ref: forwardedRef,\n      style: { flexShrink: 0, ...scrollIndicatorProps.style },\n      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      }),\n      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {\n        contentContext.onItemLeave?.();\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      }),\n      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {\n        clearAutoScrollTimer();\n      })\n    }\n  );\n});\nvar SEPARATOR_NAME = \"SelectSeparator\";\nvar SelectSeparator = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...separatorProps } = props;\n    return (0, import_jsx_runtime3.jsx)(Primitive.div, { \"aria-hidden\": true, ...separatorProps, ref: forwardedRef });\n  }\n);\nSelectSeparator.displayName = SEPARATOR_NAME;\nvar ARROW_NAME2 = \"SelectArrow\";\nvar SelectArrow = React4.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(ARROW_NAME2, __scopeSelect);\n    const contentContext = useSelectContentContext(ARROW_NAME2, __scopeSelect);\n    return context.open && contentContext.position === \"popper\" ? (0, import_jsx_runtime3.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;\n  }\n);\nSelectArrow.displayName = ARROW_NAME2;\nvar BUBBLE_INPUT_NAME = \"SelectBubbleInput\";\nvar SelectBubbleInput = React4.forwardRef(\n  ({ __scopeSelect, value, ...props }, forwardedRef) => {\n    const ref = React4.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const prevValue = usePrevious(value);\n    React4.useEffect(() => {\n      const select = ref.current;\n      if (!select) return;\n      const selectProto = window.HTMLSelectElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        selectProto,\n        \"value\"\n      );\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event(\"change\", { bubbles: true });\n        setValue.call(select, value);\n        select.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n    return (0, import_jsx_runtime3.jsx)(\n      Primitive.select,\n      {\n        ...props,\n        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },\n        ref: composedRefs,\n        defaultValue: value\n      }\n    );\n  }\n);\nSelectBubbleInput.displayName = BUBBLE_INPUT_NAME;\nfunction shouldShowPlaceholder(value) {\n  return value === \"\" || value === void 0;\n}\nfunction useTypeaheadSearch(onSearchChange) {\n  const handleSearchChange = useCallbackRef(onSearchChange);\n  const searchRef = React4.useRef(\"\");\n  const timerRef = React4.useRef(0);\n  const handleTypeaheadSearch = React4.useCallback(\n    (key) => {\n      const search = searchRef.current + key;\n      handleSearchChange(search);\n      (function updateSearch(value) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== \"\") timerRef.current = window.setTimeout(() => updateSearch(\"\"), 1e3);\n      })(search);\n    },\n    [handleSearchChange]\n  );\n  const resetTypeahead = React4.useCallback(() => {\n    searchRef.current = \"\";\n    window.clearTimeout(timerRef.current);\n  }, []);\n  React4.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  return [searchRef, handleTypeaheadSearch, resetTypeahead];\n}\nfunction findNextItem(items, search, currentItem) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;\n  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));\n  const excludeCurrentItem = normalizedSearch.length === 1;\n  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n  const nextItem = wrappedItems.find(\n    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextItem !== currentItem ? nextItem : void 0;\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index2) => array[(startIndex + index2) % array.length]);\n}\nvar Root22 = Select;\nvar Trigger = SelectTrigger;\nvar Value = SelectValue;\nvar Icon = SelectIcon;\nvar Portal2 = SelectPortal;\nvar Content2 = SelectContent;\nvar Viewport = SelectViewport;\nvar Group = SelectGroup;\nvar Label = SelectLabel;\nvar Item = SelectItem;\nvar ItemText = SelectItemText;\nvar ItemIndicator = SelectItemIndicator;\nvar ScrollUpButton = SelectScrollUpButton;\nvar ScrollDownButton = SelectScrollDownButton;\nvar Separator = SelectSeparator;\nvar Arrow22 = SelectArrow;\nexport {\n  Arrow22 as Arrow,\n  Content2 as Content,\n  Group,\n  Icon,\n  Item,\n  ItemIndicator,\n  ItemText,\n  Label,\n  Portal2 as Portal,\n  Root22 as Root,\n  ScrollDownButton,\n  ScrollUpButton,\n  Select,\n  SelectArrow,\n  SelectContent,\n  SelectGroup,\n  SelectIcon,\n  SelectItem,\n  SelectItemIndicator,\n  SelectItemText,\n  SelectLabel,\n  SelectPortal,\n  SelectScrollDownButton,\n  SelectScrollUpButton,\n  SelectSeparator,\n  SelectTrigger,\n  SelectValue,\n  SelectViewport,\n  Separator,\n  Trigger,\n  Value,\n  Viewport,\n  createSelectScope\n};\n//# sourceMappingURL=@radix-ui_react-select.js.map\n","size_bytes":122641},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-dialog.js":{"content":"\"use client\";\nimport {\n  Presence\n} from \"./chunk-7ARIJ2HB.js\";\nimport {\n  Combination_default,\n  FocusScope,\n  hideOthers,\n  useFocusGuards\n} from \"./chunk-MCNPHWP5.js\";\nimport {\n  useId\n} from \"./chunk-O7ZJEN5H.js\";\nimport {\n  DismissableLayer,\n  Portal\n} from \"./chunk-UP2KX7JD.js\";\nimport \"./chunk-Y2D2AKKB.js\";\nimport {\n  composeEventHandlers,\n  createContext2,\n  createContextScope,\n  useControllableState\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  createSlot,\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar DIALOG_NAME = \"Dialog\";\nvar [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);\nvar [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);\nvar Dialog = (props) => {\n  const {\n    __scopeDialog,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true\n  } = props;\n  const triggerRef = React.useRef(null);\n  const contentRef = React.useRef(null);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: DIALOG_NAME\n  });\n  return (0, import_jsx_runtime.jsx)(\n    DialogProvider,\n    {\n      scope: __scopeDialog,\n      triggerRef,\n      contentRef,\n      contentId: useId(),\n      titleId: useId(),\n      descriptionId: useId(),\n      open,\n      onOpenChange: setOpen,\n      onOpenToggle: React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),\n      modal,\n      children\n    }\n  );\n};\nDialog.displayName = DIALOG_NAME;\nvar TRIGGER_NAME = \"DialogTrigger\";\nvar DialogTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...triggerProps } = props;\n    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n    return (0, import_jsx_runtime.jsx)(\n      Primitive.button,\n      {\n        type: \"button\",\n        \"aria-haspopup\": \"dialog\",\n        \"aria-expanded\": context.open,\n        \"aria-controls\": context.contentId,\n        \"data-state\": getState(context.open),\n        ...triggerProps,\n        ref: composedTriggerRef,\n        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)\n      }\n    );\n  }\n);\nDialogTrigger.displayName = TRIGGER_NAME;\nvar PORTAL_NAME = \"DialogPortal\";\nvar [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {\n  forceMount: void 0\n});\nvar DialogPortal = (props) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = useDialogContext(PORTAL_NAME, __scopeDialog);\n  return (0, import_jsx_runtime.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React.Children.map(children, (child) => (0, import_jsx_runtime.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime.jsx)(Portal, { asChild: true, container, children: child }) })) });\n};\nDialogPortal.displayName = PORTAL_NAME;\nvar OVERLAY_NAME = \"DialogOverlay\";\nvar DialogOverlay = React.forwardRef(\n  (props, forwardedRef) => {\n    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);\n    return context.modal ? (0, import_jsx_runtime.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;\n  }\n);\nDialogOverlay.displayName = OVERLAY_NAME;\nvar Slot = createSlot(\"DialogOverlay.RemoveScroll\");\nvar DialogOverlayImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);\n    return (\n      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n      // ie. when `Overlay` and `Content` are siblings\n      (0, import_jsx_runtime.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime.jsx)(\n        Primitive.div,\n        {\n          \"data-state\": getState(context.open),\n          ...overlayProps,\n          ref: forwardedRef,\n          style: { pointerEvents: \"auto\", ...overlayProps.style }\n        }\n      ) })\n    );\n  }\n);\nvar CONTENT_NAME = \"DialogContent\";\nvar DialogContent = React.forwardRef(\n  (props, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    return (0, import_jsx_runtime.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });\n  }\n);\nDialogContent.displayName = CONTENT_NAME;\nvar DialogContentModal = React.forwardRef(\n  (props, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const contentRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);\n    React.useEffect(() => {\n      const content = contentRef.current;\n      if (content) return hideOthers(content);\n    }, []);\n    return (0, import_jsx_runtime.jsx)(\n      DialogContentImpl,\n      {\n        ...props,\n        ref: composedRefs,\n        trapFocus: context.open,\n        disableOutsidePointerEvents: true,\n        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          event.preventDefault();\n          context.triggerRef.current?.focus();\n        }),\n        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const originalEvent = event.detail.originalEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n          if (isRightClick) event.preventDefault();\n        }),\n        onFocusOutside: composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault()\n        )\n      }\n    );\n  }\n);\nvar DialogContentNonModal = React.forwardRef(\n  (props, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const hasInteractedOutsideRef = React.useRef(false);\n    const hasPointerDownOutsideRef = React.useRef(false);\n    return (0, import_jsx_runtime.jsx)(\n      DialogContentImpl,\n      {\n        ...props,\n        ref: forwardedRef,\n        trapFocus: false,\n        disableOutsidePointerEvents: false,\n        onCloseAutoFocus: (event) => {\n          props.onCloseAutoFocus?.(event);\n          if (!event.defaultPrevented) {\n            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n            event.preventDefault();\n          }\n          hasInteractedOutsideRef.current = false;\n          hasPointerDownOutsideRef.current = false;\n        },\n        onInteractOutside: (event) => {\n          props.onInteractOutside?.(event);\n          if (!event.defaultPrevented) {\n            hasInteractedOutsideRef.current = true;\n            if (event.detail.originalEvent.type === \"pointerdown\") {\n              hasPointerDownOutsideRef.current = true;\n            }\n          }\n          const target = event.target;\n          const targetIsTrigger = context.triggerRef.current?.contains(target);\n          if (targetIsTrigger) event.preventDefault();\n          if (event.detail.originalEvent.type === \"focusin\" && hasPointerDownOutsideRef.current) {\n            event.preventDefault();\n          }\n        }\n      }\n    );\n  }\n);\nvar DialogContentImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, __scopeDialog);\n    const contentRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n    useFocusGuards();\n    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [\n      (0, import_jsx_runtime.jsx)(\n        FocusScope,\n        {\n          asChild: true,\n          loop: true,\n          trapped: trapFocus,\n          onMountAutoFocus: onOpenAutoFocus,\n          onUnmountAutoFocus: onCloseAutoFocus,\n          children: (0, import_jsx_runtime.jsx)(\n            DismissableLayer,\n            {\n              role: \"dialog\",\n              id: context.contentId,\n              \"aria-describedby\": context.descriptionId,\n              \"aria-labelledby\": context.titleId,\n              \"data-state\": getState(context.open),\n              ...contentProps,\n              ref: composedRefs,\n              onDismiss: () => context.onOpenChange(false)\n            }\n          )\n        }\n      ),\n      (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [\n        (0, import_jsx_runtime.jsx)(TitleWarning, { titleId: context.titleId }),\n        (0, import_jsx_runtime.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })\n      ] })\n    ] });\n  }\n);\nvar TITLE_NAME = \"DialogTitle\";\nvar DialogTitle = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...titleProps } = props;\n    const context = useDialogContext(TITLE_NAME, __scopeDialog);\n    return (0, import_jsx_runtime.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });\n  }\n);\nDialogTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"DialogDescription\";\nvar DialogDescription = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...descriptionProps } = props;\n    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);\n    return (0, import_jsx_runtime.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });\n  }\n);\nDialogDescription.displayName = DESCRIPTION_NAME;\nvar CLOSE_NAME = \"DialogClose\";\nvar DialogClose = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...closeProps } = props;\n    const context = useDialogContext(CLOSE_NAME, __scopeDialog);\n    return (0, import_jsx_runtime.jsx)(\n      Primitive.button,\n      {\n        type: \"button\",\n        ...closeProps,\n        ref: forwardedRef,\n        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))\n      }\n    );\n  }\n);\nDialogClose.displayName = CLOSE_NAME;\nfunction getState(open) {\n  return open ? \"open\" : \"closed\";\n}\nvar TITLE_WARNING_NAME = \"DialogTitleWarning\";\nvar [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {\n  contentName: CONTENT_NAME,\n  titleName: TITLE_NAME,\n  docsSlug: \"dialog\"\n});\nvar TitleWarning = ({ titleId }) => {\n  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);\n  const MESSAGE = `\\`${titleWarningContext.contentName}\\` requires a \\`${titleWarningContext.titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleWarningContext.titleName}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;\n  React.useEffect(() => {\n    if (titleId) {\n      const hasTitle = document.getElementById(titleId);\n      if (!hasTitle) console.error(MESSAGE);\n    }\n  }, [MESSAGE, titleId]);\n  return null;\n};\nvar DESCRIPTION_WARNING_NAME = \"DialogDescriptionWarning\";\nvar DescriptionWarning = ({ contentRef, descriptionId }) => {\n  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);\n  const MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby={undefined}\\` for {${descriptionWarningContext.contentName}}.`;\n  React.useEffect(() => {\n    const describedById = contentRef.current?.getAttribute(\"aria-describedby\");\n    if (descriptionId && describedById) {\n      const hasDescription = document.getElementById(descriptionId);\n      if (!hasDescription) console.warn(MESSAGE);\n    }\n  }, [MESSAGE, contentRef, descriptionId]);\n  return null;\n};\nvar Root = Dialog;\nvar Trigger = DialogTrigger;\nvar Portal2 = DialogPortal;\nvar Overlay = DialogOverlay;\nvar Content = DialogContent;\nvar Title = DialogTitle;\nvar Description = DialogDescription;\nvar Close = DialogClose;\nexport {\n  Close,\n  Content,\n  Description,\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n  Overlay,\n  Portal2 as Portal,\n  Root,\n  Title,\n  Trigger,\n  WarningProvider,\n  createDialogScope\n};\n//# sourceMappingURL=@radix-ui_react-dialog.js.map\n","size_bytes":13198},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-switch.js":{"content":"\"use client\";\nimport {\n  usePrevious,\n  useSize\n} from \"./chunk-NYXOVAH5.js\";\nimport {\n  composeEventHandlers,\n  createContextScope,\n  useControllableState\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-switch/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar SWITCH_NAME = \"Switch\";\nvar [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);\nvar [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);\nvar Switch = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSwitch,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = \"on\",\n      onCheckedChange,\n      form,\n      ...switchProps\n    } = props;\n    const [button, setButton] = React.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    const isFormControl = button ? form || !!button.closest(\"form\") : true;\n    const [checked, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked ?? false,\n      onChange: onCheckedChange,\n      caller: SWITCH_NAME\n    });\n    return (0, import_jsx_runtime.jsxs)(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [\n      (0, import_jsx_runtime.jsx)(\n        Primitive.button,\n        {\n          type: \"button\",\n          role: \"switch\",\n          \"aria-checked\": checked,\n          \"aria-required\": required,\n          \"data-state\": getState(checked),\n          \"data-disabled\": disabled ? \"\" : void 0,\n          disabled,\n          value,\n          ...switchProps,\n          ref: composedRefs,\n          onClick: composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => !prevChecked);\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })\n        }\n      ),\n      isFormControl && (0, import_jsx_runtime.jsx)(\n        SwitchBubbleInput,\n        {\n          control: button,\n          bubbles: !hasConsumerStoppedPropagationRef.current,\n          name,\n          value,\n          checked,\n          required,\n          disabled,\n          form,\n          style: { transform: \"translateX(-100%)\" }\n        }\n      )\n    ] });\n  }\n);\nSwitch.displayName = SWITCH_NAME;\nvar THUMB_NAME = \"SwitchThumb\";\nvar SwitchThumb = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSwitch, ...thumbProps } = props;\n    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);\n    return (0, import_jsx_runtime.jsx)(\n      Primitive.span,\n      {\n        \"data-state\": getState(context.checked),\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        ...thumbProps,\n        ref: forwardedRef\n      }\n    );\n  }\n);\nSwitchThumb.displayName = THUMB_NAME;\nvar BUBBLE_INPUT_NAME = \"SwitchBubbleInput\";\nvar SwitchBubbleInput = React.forwardRef(\n  ({\n    __scopeSwitch,\n    control,\n    checked,\n    bubbles = true,\n    ...props\n  }, forwardedRef) => {\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(ref, forwardedRef);\n    const prevChecked = usePrevious(checked);\n    const controlSize = useSize(control);\n    React.useEffect(() => {\n      const input = ref.current;\n      if (!input) return;\n      const inputProto = window.HTMLInputElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        inputProto,\n        \"checked\"\n      );\n      const setChecked = descriptor.set;\n      if (prevChecked !== checked && setChecked) {\n        const event = new Event(\"click\", { bubbles });\n        setChecked.call(input, checked);\n        input.dispatchEvent(event);\n      }\n    }, [prevChecked, checked, bubbles]);\n    return (0, import_jsx_runtime.jsx)(\n      \"input\",\n      {\n        type: \"checkbox\",\n        \"aria-hidden\": true,\n        defaultChecked: checked,\n        ...props,\n        tabIndex: -1,\n        ref: composedRefs,\n        style: {\n          ...props.style,\n          ...controlSize,\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }\n    );\n  }\n);\nSwitchBubbleInput.displayName = BUBBLE_INPUT_NAME;\nfunction getState(checked) {\n  return checked ? \"checked\" : \"unchecked\";\n}\nvar Root = Switch;\nvar Thumb = SwitchThumb;\nexport {\n  Root,\n  Switch,\n  SwitchThumb,\n  Thumb,\n  createSwitchScope\n};\n//# sourceMappingURL=@radix-ui_react-switch.js.map\n","size_bytes":4982},"packages/database/dist/seed.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.seedDatabase = seedDatabase;\nconst pg_1 = require(\"pg\");\nconst uuid_1 = require(\"uuid\");\nconst bcryptjs_1 = __importDefault(require(\"bcryptjs\"));\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\n// Load environment variables\ndotenv_1.default.config();\nconst pool = new pg_1.Pool({\n    connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/edgvoip',\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n});\nasync function seedDatabase() {\n    const client = await pool.connect();\n    try {\n        console.log('🌱 Starting database seeding...');\n        // Check if data already exists\n        const tenantCount = await client.query('SELECT COUNT(*) FROM tenants');\n        if (parseInt(tenantCount.rows[0].count) > 0) {\n            console.log('⏭️  Database already seeded, skipping...');\n            // Print existing tenant IDs\n            const existingTenants = await client.query('SELECT id, name FROM tenants');\n            console.log('📋 Existing tenants:');\n            existingTenants.rows.forEach(t => console.log(`  - ${t.name}: ${t.id}`));\n            // Print existing extensions\n            const existingExtensions = await client.query('SELECT extension, display_name, tenant_id FROM extensions');\n            console.log('📋 Existing extensions:', existingExtensions.rows.length);\n            existingExtensions.rows.forEach(e => console.log(`  - ${e.extension} (${e.display_name}) - tenant: ${e.tenant_id}`));\n            return;\n        }\n        // Create demo tenant\n        const tenantId = (0, uuid_1.v4)();\n        await client.query(`\r\n      INSERT INTO tenants (id, name, domain, sip_domain, status, settings)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n    `, [\n            tenantId,\n            'Demo Tenant',\n            'demo-tenant',\n            'demo-tenant.pbx.w3suite.it',\n            'active',\n            JSON.stringify({\n                max_concurrent_calls: 20,\n                recording_enabled: true,\n                gdpr_compliant: true,\n                timezone: 'Europe/Rome',\n                language: 'it'\n            })\n        ]);\n        // Create demo store\n        const storeId = (0, uuid_1.v4)();\n        await client.query(`\r\n      INSERT INTO stores (id, tenant_id, name, store_id, status, settings)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n    `, [\n            storeId,\n            tenantId,\n            'Demo Store Roma',\n            'store-roma-001',\n            'active',\n            JSON.stringify({\n                business_hours: {\n                    enabled: true,\n                    timezone: 'Europe/Rome',\n                    schedule: {\n                        monday: { open: '09:00', close: '18:00' },\n                        tuesday: { open: '09:00', close: '18:00' },\n                        wednesday: { open: '09:00', close: '18:00' },\n                        thursday: { open: '09:00', close: '18:00' },\n                        friday: { open: '09:00', close: '18:00' },\n                        saturday: { open: '10:00', close: '16:00' },\n                        sunday: { open: '10:00', close: '14:00' }\n                    }\n                },\n                outbound_caller_id: '+393331234567',\n                recording_consent_required: true\n            })\n        ]);\n        // Create demo extensions\n        const extensions = [\n            { extension: '1001', display_name: 'Mario Rossi', type: 'user' },\n            { extension: '1002', display_name: 'Giulia Bianchi', type: 'user' },\n            { extension: '1003', display_name: 'Alessandro Verdi', type: 'user' },\n            { extension: '2000', display_name: 'Coda Vendite', type: 'queue' },\n            { extension: '3000', display_name: 'Conferenza', type: 'conference' }\n        ];\n        for (const ext of extensions) {\n            const extensionId = (0, uuid_1.v4)();\n            const password = await bcryptjs_1.default.hash('password123', 10);\n            await client.query(`\r\n        INSERT INTO extensions (id, tenant_id, store_id, extension, password, display_name, type, settings)\r\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      `, [\n                extensionId,\n                tenantId,\n                storeId,\n                ext.extension,\n                password,\n                ext.display_name,\n                ext.type,\n                JSON.stringify({\n                    voicemail_enabled: true,\n                    call_forwarding: { enabled: false, destination: null },\n                    dnd_enabled: false,\n                    recording_enabled: true\n                })\n            ]);\n        }\n        // Create demo SIP trunk\n        const trunkId = (0, uuid_1.v4)();\n        await client.query(`\r\n      INSERT INTO sip_trunks (id, tenant_id, store_id, name, provider, status, sip_config, did_config, security, gdpr)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n    `, [\n            trunkId,\n            tenantId,\n            storeId,\n            'Demo Trunk Roma',\n            'Demo Provider',\n            'testing',\n            JSON.stringify({\n                host: 'sip.demo-provider.com',\n                port: 5060,\n                transport: 'udp',\n                username: 'demo_user',\n                password: 'demo_password',\n                realm: 'sip.demo-provider.com',\n                register: true,\n                retry_seconds: 60,\n                caller_id_in_from: false,\n                ping: true,\n                ping_time: 60\n            }),\n            JSON.stringify({\n                number: '+393331234567',\n                country_code: 'IT',\n                area_code: '333',\n                local_number: '1234567',\n                provider_did: 'IT_333_1234567',\n                inbound_route: 'demo-route'\n            }),\n            JSON.stringify({\n                encryption: 'tls',\n                authentication: 'digest',\n                acl: ['192.168.1.0/24', '10.0.0.0/8'],\n                rate_limit: {\n                    enabled: true,\n                    calls_per_minute: 60,\n                    calls_per_hour: 1000\n                }\n            }),\n            JSON.stringify({\n                data_retention_days: 365,\n                recording_consent_required: true,\n                data_processing_purpose: 'Business communications',\n                lawful_basis: 'legitimate_interest',\n                data_controller: 'Demo Company SRL',\n                dpo_contact: 'dpo@demo-company.it'\n            })\n        ]);\n        // Create some demo CDR records\n        const demoCDRs = [\n            {\n                call_uuid: (0, uuid_1.v4)(),\n                call_direction: 'inbound',\n                caller_id_number: '+393339876543',\n                caller_id_name: 'Cliente Demo',\n                callee_extension: '1001',\n                start_time: new Date(Date.now() - 3600000), // 1 hour ago\n                answer_time: new Date(Date.now() - 3595000), // 5 seconds later\n                end_time: new Date(Date.now() - 3000000), // 10 minutes call\n                duration: 600,\n                bill_seconds: 600,\n                hangup_cause: 'NORMAL_CLEARING',\n                hangup_disposition: 'answered',\n                audio_codec: 'PCMU',\n                recording_enabled: true,\n                recording_consent: true,\n                fs_uuid: (0, uuid_1.v4)(),\n                fs_domain: 'demo-tenant.pbx.w3suite.it'\n            },\n            {\n                call_uuid: (0, uuid_1.v4)(),\n                call_direction: 'outbound',\n                caller_extension: '1002',\n                callee_id_number: '+393339876544',\n                callee_id_name: 'Fornitore Demo',\n                start_time: new Date(Date.now() - 1800000), // 30 minutes ago\n                answer_time: new Date(Date.now() - 1795000), // 5 seconds later\n                end_time: new Date(Date.now() - 1200000), // 10 minutes call\n                duration: 600,\n                bill_seconds: 600,\n                hangup_cause: 'NORMAL_CLEARING',\n                hangup_disposition: 'answered',\n                audio_codec: 'PCMU',\n                recording_enabled: true,\n                recording_consent: true,\n                fs_uuid: (0, uuid_1.v4)(),\n                fs_domain: 'demo-tenant.pbx.w3suite.it'\n            }\n        ];\n        for (const cdr of demoCDRs) {\n            await client.query(`\r\n        INSERT INTO cdr (\r\n          tenant_id, store_id, extension_id, trunk_id, call_uuid, call_direction,\r\n          caller_id_number, caller_id_name, caller_extension, callee_id_number,\r\n          callee_id_name, callee_extension, start_time, answer_time, end_time,\r\n          duration, bill_seconds, hangup_cause, hangup_disposition, audio_codec,\r\n          recording_enabled, recording_consent, fs_uuid, fs_domain\r\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24)\r\n      `, [\n                tenantId, storeId, null, trunkId, cdr.call_uuid, cdr.call_direction,\n                cdr.caller_id_number, cdr.caller_id_name, cdr.caller_extension, cdr.callee_id_number,\n                cdr.callee_id_name, cdr.callee_extension, cdr.start_time, cdr.answer_time, cdr.end_time,\n                cdr.duration, cdr.bill_seconds, cdr.hangup_cause, cdr.hangup_disposition, cdr.audio_codec,\n                cdr.recording_enabled, cdr.recording_consent, cdr.fs_uuid, cdr.fs_domain\n            ]);\n        }\n        console.log('✅ Database seeded successfully!');\n        console.log('📊 Created:');\n        console.log('  - 1 Demo Tenant');\n        console.log('  - 1 Demo Store');\n        console.log('  - 5 Demo Extensions');\n        console.log('  - 1 Demo SIP Trunk');\n        console.log('  - 2 Demo CDR Records');\n    }\n    catch (error) {\n        console.error('❌ Seeding failed:', error);\n        throw error;\n    }\n    finally {\n        client.release();\n    }\n}\nasync function main() {\n    try {\n        await seedDatabase();\n        process.exit(0);\n    }\n    catch (error) {\n        console.error('Seeding process failed:', error);\n        process.exit(1);\n    }\n}\nif (require.main === module) {\n    main();\n}\n//# sourceMappingURL=seed.js.map","size_bytes":10505},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-label.js":{"content":"\"use client\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport \"./chunk-E7DYAJFJ.js\";\nimport \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-label/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar NAME = \"Label\";\nvar Label = React.forwardRef((props, forwardedRef) => {\n  return (0, import_jsx_runtime.jsx)(\n    Primitive.label,\n    {\n      ...props,\n      ref: forwardedRef,\n      onMouseDown: (event) => {\n        const target = event.target;\n        if (target.closest(\"button, input, select, textarea\")) return;\n        props.onMouseDown?.(event);\n        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n      }\n    }\n  );\n});\nLabel.displayName = NAME;\nvar Root = Label;\nexport {\n  Label,\n  Root\n};\n//# sourceMappingURL=@radix-ui_react-label.js.map\n","size_bytes":1035},"packages/database/dist/index.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pool = exports.DatabaseClient = void 0;\nexports.getClient = getClient;\nexports.queryWithTenant = queryWithTenant;\nexports.withTransaction = withTransaction;\nexports.healthCheck = healthCheck;\nexports.startPeriodicHealthCheck = startPeriodicHealthCheck;\nexports.stopPeriodicHealthCheck = stopPeriodicHealthCheck;\nexports.closePool = closePool;\nexports.getPoolStats = getPoolStats;\nconst pg_1 = require(\"pg\");\n// Validate DATABASE_URL is set\nif (!process.env.DATABASE_URL) {\n    console.error('❌ DATABASE_URL environment variable is required');\n    console.error('💡 Please set DATABASE_URL in your .env file');\n    console.error('Example: DATABASE_URL=postgresql://user:password@host:5432/database');\n    process.exit(1);\n}\n// Database connection pool with optimized settings for Replit environment\nconst pool = new pg_1.Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    max: 20,\n    min: 2,\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 10000,\n    keepAlive: true,\n    keepAliveInitialDelayMillis: 10000,\n    allowExitOnIdle: false,\n});\nexports.pool = pool;\n// Pool event handlers for resilience\npool.on('error', (err, client) => {\n    console.error('⚠️ Unexpected database pool error:', err.message);\n    console.error('⚠️ Error code:', err.code);\n    // Don't crash on connection termination - pool will recover\n    if (err.code === '57P01' || err.message.includes('terminating connection')) {\n        console.warn('⚠️ Connection terminated by database server - pool will create new connections');\n        return;\n    }\n    // Log other errors but don't crash\n    console.error('⚠️ Pool error details:', err);\n});\npool.on('connect', (client) => {\n    console.log('✅ New database connection established in pool');\n});\npool.on('acquire', (client) => {\n    // Client acquired from pool - uncomment for debugging\n    // console.log('📊 Database client acquired from pool');\n});\npool.on('remove', (client) => {\n    console.log('🔄 Database client removed from pool');\n});\n// Graceful pool cleanup\nlet isPoolClosing = false;\nasync function gracefulPoolShutdown() {\n    if (isPoolClosing)\n        return;\n    isPoolClosing = true;\n    console.log('🛑 Closing database connection pool...');\n    try {\n        await pool.end();\n        console.log('✅ Database pool closed gracefully');\n    }\n    catch (error) {\n        console.error('❌ Error closing database pool:', error);\n    }\n}\nprocess.on('SIGTERM', gracefulPoolShutdown);\nprocess.on('SIGINT', gracefulPoolShutdown);\n// Database client with tenant context\nclass DatabaseClient {\n    constructor(client) {\n        this.tenantId = null;\n        this.userRole = null;\n        this.released = false;\n        this.client = client;\n    }\n    // Set tenant context for RLS\n    async setTenantContext(tenantId, userRole = 'user') {\n        this.tenantId = tenantId;\n        this.userRole = userRole;\n        try {\n            await this.client.query('SELECT set_tenant_context($1, $2)', [tenantId, userRole]);\n        }\n        catch (error) {\n            // If tenant context function doesn't exist, just skip it\n            if (error.code === '42883') {\n                console.warn('⚠️ set_tenant_context function not found - skipping RLS setup');\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    // Clear tenant context\n    async clearTenantContext() {\n        this.tenantId = null;\n        this.userRole = null;\n        try {\n            await this.client.query('SELECT clear_tenant_context()');\n        }\n        catch (error) {\n            // If function doesn't exist, just skip it\n            if (error.code === '42883') {\n                // Function doesn't exist - that's ok\n            }\n            else {\n                console.warn('⚠️ Error clearing tenant context:', error.message);\n            }\n        }\n    }\n    // Get current tenant ID\n    getCurrentTenantId() {\n        return this.tenantId;\n    }\n    // Get current user role\n    getCurrentUserRole() {\n        return this.userRole;\n    }\n    // Query with tenant context\n    async query(text, params) {\n        if (this.released) {\n            throw new Error('Cannot query on released client');\n        }\n        return this.client.query(text, params);\n    }\n    // Release client\n    async release() {\n        if (this.released)\n            return;\n        try {\n            await this.clearTenantContext();\n        }\n        catch (error) {\n            console.warn('⚠️ Error clearing context before release:', error);\n        }\n        this.client.release();\n        this.released = true;\n    }\n}\nexports.DatabaseClient = DatabaseClient;\n// Retry helper with exponential backoff\nasync function retryWithBackoff(fn, maxRetries = 3, initialDelay = 1000) {\n    let lastError;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            lastError = error;\n            // Don't retry on certain errors\n            if (error.code === '42P01' || error.code === '42883') {\n                throw error;\n            }\n            if (attempt < maxRetries - 1) {\n                const delay = initialDelay * Math.pow(2, attempt);\n                console.warn(`⚠️ Database operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            }\n        }\n    }\n    throw lastError;\n}\n// Get database client with tenant context and retry logic\nasync function getClient(tenantId, userRole) {\n    const client = await retryWithBackoff(async () => {\n        return await pool.connect();\n    }, 3, 500);\n    const dbClient = new DatabaseClient(client);\n    if (tenantId) {\n        await dbClient.setTenantContext(tenantId, userRole || 'user');\n    }\n    return dbClient;\n}\n// Execute query with tenant context\nasync function queryWithTenant(text, params = [], tenantId, userRole) {\n    const client = await getClient(tenantId, userRole);\n    try {\n        const result = await client.query(text, params);\n        return result;\n    }\n    finally {\n        await client.release();\n    }\n}\n// Transaction helper\nasync function withTransaction(callback, tenantId, userRole) {\n    const client = await getClient(tenantId, userRole);\n    try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n    }\n    catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n    }\n    finally {\n        await client.release();\n    }\n}\n// Health check with retry\nasync function healthCheck() {\n    try {\n        const result = await retryWithBackoff(async () => {\n            return await pool.query('SELECT 1 as health');\n        }, 2, 500);\n        return result.rows.length > 0 && result.rows[0].health === 1;\n    }\n    catch (error) {\n        console.error('❌ Database health check failed:', error);\n        return false;\n    }\n}\n// Periodic health check (runs every 30 seconds)\nlet healthCheckInterval = null;\nfunction startPeriodicHealthCheck(intervalMs = 30000) {\n    if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n    }\n    healthCheckInterval = setInterval(async () => {\n        const isHealthy = await healthCheck();\n        if (!isHealthy) {\n            console.warn('⚠️ Periodic health check failed - database may be unavailable');\n        }\n    }, intervalMs);\n    console.log(`🏥 Started periodic database health check (every ${intervalMs / 1000}s)`);\n}\nfunction stopPeriodicHealthCheck() {\n    if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n        healthCheckInterval = null;\n        console.log('🛑 Stopped periodic database health check');\n    }\n}\n// Close all connections\nasync function closePool() {\n    stopPeriodicHealthCheck();\n    await gracefulPoolShutdown();\n}\n// Pool statistics\nfunction getPoolStats() {\n    return {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n    };\n}\n//# sourceMappingURL=index.js.map","size_bytes":8342},"packages/backend/dist/index.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.io = exports.server = exports.app = void 0;\nconst express_1 = __importDefault(require(\"express\"));\nconst cors_1 = __importDefault(require(\"cors\"));\nconst compression_1 = __importDefault(require(\"compression\"));\nconst morgan_1 = __importDefault(require(\"morgan\"));\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\nconst http_1 = require(\"http\");\nconst socket_io_1 = require(\"socket.io\");\n// Load environment variables\ndotenv_1.default.config();\n// Import middleware\nconst security_1 = require(\"./middleware/security\");\nconst logger_1 = require(\"./utils/logger\");\nconst response_1 = require(\"./utils/response\");\n// Import routes\nconst routes_1 = __importDefault(require(\"./routes\"));\n// Import database\nconst database_1 = require(\"@w3-voip/database\");\nconst app = (0, express_1.default)();\nexports.app = app;\nconst server = (0, http_1.createServer)(app);\nexports.server = server;\nconst io = new socket_io_1.Server(server, {\n    cors: {\n        origin: true,\n        methods: ['GET', 'POST'],\n        credentials: true\n    }\n});\nexports.io = io;\nconst PORT = process.env.PORT || 3001;\nconst JWT_SECRET = process.env.JWT_SECRET || 'edg-voip-secret-key-2024';\n// Security middleware\napp.use(security_1.securityHeaders);\napp.use(security_1.requestId);\napp.use(security_1.securityEventLogger);\n// CORS configuration - Allow all origins in development\napp.use((0, cors_1.default)({\n    origin: true,\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID']\n}));\n// Compression\napp.use((0, compression_1.default)());\n// Request logging\napp.use((0, morgan_1.default)('combined'));\napp.use(logger_1.requestLogger);\n// Debug middleware for login requests\napp.use((req, res, next) => {\n    if (req.path.includes('/login')) {\n        console.log('🔍 Login Request Debug:');\n        console.log('  Path:', req.path);\n        console.log('  Method:', req.method);\n        console.log('  Content-Type:', req.headers['content-type']);\n        console.log('  Headers:', JSON.stringify(req.headers, null, 2));\n    }\n    next();\n});\n// Body parsing middleware\napp.use(express_1.default.json({ limit: '10mb' }));\napp.use(express_1.default.urlencoded({ extended: true, limit: '10mb' }));\n// Input sanitization\napp.use(security_1.sanitizeInput);\n// Request size limiting\napp.use((0, security_1.requestSizeLimit)('10mb'));\n// Rate limiting\napp.use('/api', security_1.apiRateLimit);\n// API routes\napp.use('/api', routes_1.default);\n// Root endpoint\napp.get('/', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            message: 'W3 VoIP System API',\n            version: process.env.npm_package_version || '1.0.0',\n            timestamp: new Date().toISOString(),\n            endpoints: {\n                health: '/api/health',\n                tenants: '/api/tenants',\n                stores: '/api/stores',\n                extensions: '/api/extensions'\n            }\n        }\n    });\n});\n// 404 handler\napp.use('*', (req, res) => {\n    res.status(404).json({\n        success: false,\n        error: {\n            code: 'NOT_FOUND',\n            message: 'Endpoint not found'\n        }\n    });\n});\n// Body parser error handler\napp.use((err, req, res, next) => {\n    if (err instanceof SyntaxError && 'body' in err) {\n        console.error('❌ Body parser error:', err.message);\n        console.error('❌ Request path:', req.path);\n        console.error('❌ Content-Type:', req.headers['content-type']);\n        return res.status(400).json({\n            success: false,\n            error: {\n                code: 'INVALID_JSON',\n                message: 'Invalid JSON in request body'\n            }\n        });\n    }\n    next(err);\n});\n// Error handling middleware\napp.use(response_1.errorHandler);\n// Socket.IO connection handling\nio.on('connection', (socket) => {\n    console.log('Client connected:', socket.id);\n    // Join tenant room for real-time updates\n    socket.on('join-tenant', (tenantId) => {\n        socket.join(`tenant:${tenantId}`);\n        console.log(`Client ${socket.id} joined tenant: ${tenantId}`);\n    });\n    // Leave tenant room\n    socket.on('leave-tenant', (tenantId) => {\n        socket.leave(`tenant:${tenantId}`);\n        console.log(`Client ${socket.id} left tenant: ${tenantId}`);\n    });\n    socket.on('disconnect', () => {\n        console.log('Client disconnected:', socket.id);\n    });\n});\n// Make io available to other modules\napp.set('io', io);\n// Database health check\nasync function checkDatabaseHealth() {\n    try {\n        const isHealthy = await (0, database_1.healthCheck)();\n        if (!isHealthy) {\n            console.error('❌ Database health check failed');\n            process.exit(1);\n        }\n        console.log('✅ Database health check passed');\n    }\n    catch (error) {\n        console.error('❌ Database connection failed:', error);\n        process.exit(1);\n    }\n}\n// Start server\nasync function startServer() {\n    try {\n        // Check database health\n        await checkDatabaseHealth();\n        // Start HTTP server\n        server.listen(Number(PORT), '0.0.0.0', () => {\n            console.log(`🚀 W3 VoIP System API running on port ${PORT}`);\n            console.log(`📊 Environment: ${process.env.NODE_ENV || 'development'}`);\n            console.log(`🔗 CORS Origin: ${process.env.CORS_ORIGIN || 'http://192.168.172.234:3000'}`);\n            console.log(`📡 Socket.IO enabled for real-time updates`);\n        });\n    }\n    catch (error) {\n        console.error('❌ Failed to start server:', error);\n        process.exit(1);\n    }\n}\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n    console.log('🛑 SIGTERM received, shutting down gracefully');\n    server.close(() => {\n        console.log('✅ Server closed');\n        process.exit(0);\n    });\n});\nprocess.on('SIGINT', () => {\n    console.log('🛑 SIGINT received, shutting down gracefully');\n    server.close(() => {\n        console.log('✅ Server closed');\n        process.exit(0);\n    });\n});\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n    console.error('❌ Uncaught Exception:', error);\n    process.exit(1);\n});\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(1);\n});\n// Start the server\nstartServer();\n//# sourceMappingURL=index.js.map","size_bytes":6639},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-toast.js":{"content":"\"use client\";\nimport {\n  Presence\n} from \"./chunk-7ARIJ2HB.js\";\nimport {\n  VisuallyHidden\n} from \"./chunk-LCRF5QSU.js\";\nimport {\n  createCollection\n} from \"./chunk-G7D2KNJE.js\";\nimport {\n  Branch,\n  Portal,\n  Root\n} from \"./chunk-UP2KX7JD.js\";\nimport {\n  useCallbackRef\n} from \"./chunk-Y2D2AKKB.js\";\nimport {\n  composeEventHandlers,\n  createContextScope,\n  useControllableState,\n  useLayoutEffect2\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive,\n  dispatchDiscreteCustomEvent\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport {\n  require_react_dom\n} from \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-toast/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar ReactDOM = __toESM(require_react_dom(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = (props) => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n  return (0, import_jsx_runtime.jsx)(Collection.Provider, { scope: __scopeToast, children: (0, import_jsx_runtime.jsx)(\n    ToastProviderProvider,\n    {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    }\n  ) });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = \"Notifications ({hotkey})\",\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef(null);\n    const headFocusProxyRef = React.useRef(null);\n    const tailFocusProxyRef = React.useRef(null);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n    const hasToasts = context.toastCount > 0;\n    React.useEffect(() => {\n      const handleKeyDown = (event) => {\n        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener(\"keydown\", handleKeyDown);\n      return () => document.removeEventListener(\"keydown\", handleKeyDown);\n    }, [hotkey]);\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n        const handleFocusOutResume = (event) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n          if (isFocusMovingOutside) handleResume();\n        };\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n        wrapper.addEventListener(\"focusin\", handlePause);\n        wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.addEventListener(\"pointermove\", handlePause);\n        wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.addEventListener(\"blur\", handlePause);\n        window.addEventListener(\"focus\", handleResume);\n        return () => {\n          wrapper.removeEventListener(\"focusin\", handlePause);\n          wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n          wrapper.removeEventListener(\"pointermove\", handlePause);\n          wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n          window.removeEventListener(\"blur\", handlePause);\n          window.removeEventListener(\"focus\", handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n        });\n        return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n      },\n      [getItems]\n    );\n    React.useEffect(() => {\n      const viewport = ref.current;\n      if (viewport) {\n        const handleKeyDown = (event) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === \"Tab\" && !isMetaKey;\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n            const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n        viewport.addEventListener(\"keydown\", handleKeyDown);\n        return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n    return (0, import_jsx_runtime.jsxs)(\n      Branch,\n      {\n        ref: wrapperRef,\n        role: \"region\",\n        \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n        tabIndex: -1,\n        style: { pointerEvents: hasToasts ? void 0 : \"none\" },\n        children: [\n          hasToasts && (0, import_jsx_runtime.jsx)(\n            FocusProxy,\n            {\n              ref: headFocusProxyRef,\n              onFocusFromOutsideViewport: () => {\n                const tabbableCandidates = getSortedTabbableCandidates({\n                  tabbingDirection: \"forwards\"\n                });\n                focusFirst(tabbableCandidates);\n              }\n            }\n          ),\n          (0, import_jsx_runtime.jsx)(Collection.Slot, { scope: __scopeToast, children: (0, import_jsx_runtime.jsx)(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),\n          hasToasts && (0, import_jsx_runtime.jsx)(\n            FocusProxy,\n            {\n              ref: tailFocusProxyRef,\n              onFocusFromOutsideViewport: () => {\n                const tabbableCandidates = getSortedTabbableCandidates({\n                  tabbingDirection: \"backwards\"\n                });\n                focusFirst(tabbableCandidates);\n              }\n            }\n          )\n        ]\n      }\n    );\n  }\n);\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n    return (0, import_jsx_runtime.jsx)(\n      VisuallyHidden,\n      {\n        tabIndex: 0,\n        ...proxyProps,\n        ref: forwardedRef,\n        style: { position: \"fixed\" },\n        onFocus: (event) => {\n          const prevFocusedElement = event.relatedTarget;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }\n      }\n    );\n  }\n);\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef(\n  (props, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME\n    });\n    return (0, import_jsx_runtime.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime.jsx)(\n      ToastImpl,\n      {\n        open,\n        ...toastProps,\n        ref: forwardedRef,\n        onClose: () => setOpen(false),\n        onPause: useCallbackRef(props.onPause),\n        onResume: useCallbackRef(props.onResume),\n        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {\n          event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n        }),\n        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {\n          const { x, y } = event.detail.delta;\n          event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n          event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n          event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n        }),\n        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {\n          event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n        }),\n        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {\n          const { x, y } = event.detail.delta;\n          event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n          event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n          event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n          event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n          setOpen(false);\n        })\n      }\n    ) });\n  }\n);\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {\n  }\n});\nvar ToastImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = \"foreground\",\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));\n    const pointerStartRef = React.useRef(null);\n    const swipeDeltaRef = React.useRef(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n    const startTimer = React.useCallback(\n      (duration2) => {\n        if (!duration2 || duration2 === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration2);\n      },\n      [handleClose]\n    );\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n    if (!context.viewport) return null;\n    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [\n      announceTextContent && (0, import_jsx_runtime.jsx)(\n        ToastAnnounce,\n        {\n          __scopeToast,\n          role: \"status\",\n          \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n          children: announceTextContent\n        }\n      ),\n      (0, import_jsx_runtime.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM.createPortal(\n        (0, import_jsx_runtime.jsx)(Collection.ItemSlot, { scope: __scopeToast, children: (0, import_jsx_runtime.jsx)(\n          Root,\n          {\n            asChild: true,\n            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n              context.isFocusedToastEscapeKeyDownRef.current = false;\n            }),\n            children: (0, import_jsx_runtime.jsx)(\n              Primitive.li,\n              {\n                tabIndex: 0,\n                \"data-state\": open ? \"open\" : \"closed\",\n                \"data-swipe-direction\": context.swipeDirection,\n                ...toastProps,\n                ref: composedRefs,\n                style: { userSelect: \"none\", touchAction: \"none\", ...props.style },\n                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {\n                  if (event.key !== \"Escape\") return;\n                  onEscapeKeyDown?.(event.nativeEvent);\n                  if (!event.nativeEvent.defaultPrevented) {\n                    context.isFocusedToastEscapeKeyDownRef.current = true;\n                    handleClose();\n                  }\n                }),\n                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {\n                  if (event.button !== 0) return;\n                  pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                }),\n                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {\n                  if (!pointerStartRef.current) return;\n                  const x = event.clientX - pointerStartRef.current.x;\n                  const y = event.clientY - pointerStartRef.current.y;\n                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                  const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n                  const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n                  const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                  const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                  const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n                  const delta = { x: clampedX, y: clampedY };\n                  const eventDetail = { originalEvent: event, delta };\n                  if (hasSwipeMoveStarted) {\n                    swipeDeltaRef.current = delta;\n                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                      discrete: false\n                    });\n                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                    swipeDeltaRef.current = delta;\n                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                      discrete: false\n                    });\n                    event.target.setPointerCapture(event.pointerId);\n                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                    pointerStartRef.current = null;\n                  }\n                }),\n                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {\n                  const delta = swipeDeltaRef.current;\n                  const target = event.target;\n                  if (target.hasPointerCapture(event.pointerId)) {\n                    target.releasePointerCapture(event.pointerId);\n                  }\n                  swipeDeltaRef.current = null;\n                  pointerStartRef.current = null;\n                  if (delta) {\n                    const toast = event.currentTarget;\n                    const eventDetail = { originalEvent: event, delta };\n                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                        discrete: true\n                      });\n                    } else {\n                      handleAndDispatchCustomEvent(\n                        TOAST_SWIPE_CANCEL,\n                        onSwipeCancel,\n                        eventDetail,\n                        {\n                          discrete: true\n                        }\n                      );\n                    }\n                    toast.addEventListener(\"click\", (event2) => event2.preventDefault(), {\n                      once: true\n                    });\n                  }\n                })\n              }\n            )\n          }\n        ) }),\n        context.viewport\n      ) })\n    ] });\n  }\n);\nvar ToastAnnounce = (props) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : (0, import_jsx_runtime.jsx)(Portal, { asChild: true, children: (0, import_jsx_runtime.jsx)(VisuallyHidden, { ...announceProps, children: renderAnnounceText && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [\n    context.label,\n    \" \",\n    children\n  ] }) }) });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return (0, import_jsx_runtime.jsx)(Primitive.div, { ...titleProps, ref: forwardedRef });\n  }\n);\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return (0, import_jsx_runtime.jsx)(Primitive.div, { ...descriptionProps, ref: forwardedRef });\n  }\n);\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef(\n  (props, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n    return (0, import_jsx_runtime.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: (0, import_jsx_runtime.jsx)(ToastClose, { ...actionProps, ref: forwardedRef }) });\n  }\n);\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n    return (0, import_jsx_runtime.jsx)(ToastAnnounceExclude, { asChild: true, children: (0, import_jsx_runtime.jsx)(\n      Primitive.button,\n      {\n        type: \"button\",\n        ...closeProps,\n        ref: forwardedRef,\n        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n      }\n    ) });\n  }\n);\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n  return (0, import_jsx_runtime.jsx)(\n    Primitive.div,\n    {\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": altText || void 0,\n      ...announceExcludeProps,\n      ref: forwardedRef\n    }\n  );\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler, { once: true });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = (delta, direction, threshold = 0) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame(callback = () => {\n}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect2(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport {\n  Action,\n  Close,\n  Description,\n  Provider,\n  Root2 as Root,\n  Title,\n  Toast,\n  ToastAction,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n  Viewport,\n  createToastScope\n};\n//# sourceMappingURL=@radix-ui_react-toast.js.map\n","size_bytes":26659},"packages/database/dist/migrate.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.runMigrations = runMigrations;\nconst pg_1 = require(\"pg\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\n// Load environment variables\ndotenv_1.default.config();\nconst pool = new pg_1.Pool({\n    connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/edgvoip',\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n});\nasync function runMigrations() {\n    const client = await pool.connect();\n    try {\n        console.log('🚀 Starting database migrations...');\n        // Create migrations table if it doesn't exist\n        await client.query(`\r\n      CREATE TABLE IF NOT EXISTS migrations (\r\n        id SERIAL PRIMARY KEY,\r\n        filename VARCHAR(255) UNIQUE NOT NULL,\r\n        executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\r\n      )\r\n    `);\n        // Get list of migration files\n        const migrationFiles = [\n            '001_create_tenants_table.sql',\n            '002_create_rls_policies.sql',\n            '003_create_call_events_table.sql',\n            '004_enhance_sip_trunks.sql',\n            '005_dialplan_routes.sql',\n            '006_ring_groups.sql',\n            '007_call_queues.sql',\n            '008_time_conditions.sql',\n            '009_ivr_menus.sql',\n            '010_conference_rooms.sql',\n            '011_voicemail_boxes.sql',\n            '012_cdr_enhanced.sql',\n            '013_add_tenant_slug_and_companies.sql',\n            '014_create_users_table.sql',\n            '015_enhance_auth_system.sql',\n            '016_update_master_slug.sql'\n        ];\n        for (const filename of migrationFiles) {\n            // Check if migration already executed\n            const result = await client.query('SELECT id FROM migrations WHERE filename = $1', [filename]);\n            if (result.rows.length > 0) {\n                console.log(`⏭️  Skipping ${filename} (already executed)`);\n                continue;\n            }\n            console.log(`📝 Executing ${filename}...`);\n            // Read and execute migration file\n            const migrationPath = (0, path_1.join)(__dirname, 'migrations', filename);\n            const migrationSQL = (0, fs_1.readFileSync)(migrationPath, 'utf8');\n            await client.query(migrationSQL);\n            // Record migration as executed\n            await client.query('INSERT INTO migrations (filename) VALUES ($1)', [filename]);\n            console.log(`✅ ${filename} executed successfully`);\n        }\n        console.log('🎉 All migrations completed successfully!');\n    }\n    catch (error) {\n        console.error('❌ Migration failed:', error);\n        throw error;\n    }\n    finally {\n        client.release();\n    }\n}\nasync function main() {\n    try {\n        await runMigrations();\n        process.exit(0);\n    }\n    catch (error) {\n        console.error('Migration process failed:', error);\n        process.exit(1);\n    }\n}\nif (require.main === module) {\n    main();\n}\n//# sourceMappingURL=migrate.js.map","size_bytes":3262},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-checkbox.js":{"content":"\"use client\";\nimport {\n  Presence\n} from \"./chunk-7ARIJ2HB.js\";\nimport {\n  usePrevious,\n  useSize\n} from \"./chunk-NYXOVAH5.js\";\nimport {\n  composeEventHandlers,\n  createContextScope,\n  useControllableState\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-checkbox/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar CHECKBOX_NAME = \"Checkbox\";\nvar [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\nvar [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);\nfunction CheckboxProvider(props) {\n  const {\n    __scopeCheckbox,\n    checked: checkedProp,\n    children,\n    defaultChecked,\n    disabled,\n    form,\n    name,\n    onCheckedChange,\n    required,\n    value = \"on\",\n    // @ts-expect-error\n    internal_do_not_use_render\n  } = props;\n  const [checked, setChecked] = useControllableState({\n    prop: checkedProp,\n    defaultProp: defaultChecked ?? false,\n    onChange: onCheckedChange,\n    caller: CHECKBOX_NAME\n  });\n  const [control, setControl] = React.useState(null);\n  const [bubbleInput, setBubbleInput] = React.useState(null);\n  const hasConsumerStoppedPropagationRef = React.useRef(false);\n  const isFormControl = control ? !!form || !!control.closest(\"form\") : (\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    true\n  );\n  const context = {\n    checked,\n    disabled,\n    setChecked,\n    control,\n    setControl,\n    name,\n    form,\n    value,\n    hasConsumerStoppedPropagationRef,\n    required,\n    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,\n    isFormControl,\n    bubbleInput,\n    setBubbleInput\n  };\n  return (0, import_jsx_runtime.jsx)(\n    CheckboxProviderImpl,\n    {\n      scope: __scopeCheckbox,\n      ...context,\n      children: isFunction(internal_do_not_use_render) ? internal_do_not_use_render(context) : children\n    }\n  );\n}\nvar TRIGGER_NAME = \"CheckboxTrigger\";\nvar CheckboxTrigger = React.forwardRef(\n  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {\n    const {\n      control,\n      value,\n      disabled,\n      checked,\n      required,\n      setControl,\n      setChecked,\n      hasConsumerStoppedPropagationRef,\n      isFormControl,\n      bubbleInput\n    } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);\n    const composedRefs = useComposedRefs(forwardedRef, setControl);\n    const initialCheckedStateRef = React.useRef(checked);\n    React.useEffect(() => {\n      const form = control?.form;\n      if (form) {\n        const reset = () => setChecked(initialCheckedStateRef.current);\n        form.addEventListener(\"reset\", reset);\n        return () => form.removeEventListener(\"reset\", reset);\n      }\n    }, [control, setChecked]);\n    return (0, import_jsx_runtime.jsx)(\n      Primitive.button,\n      {\n        type: \"button\",\n        role: \"checkbox\",\n        \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n        \"aria-required\": required,\n        \"data-state\": getState(checked),\n        \"data-disabled\": disabled ? \"\" : void 0,\n        disabled,\n        value,\n        ...checkboxProps,\n        ref: composedRefs,\n        onKeyDown: composeEventHandlers(onKeyDown, (event) => {\n          if (event.key === \"Enter\") event.preventDefault();\n        }),\n        onClick: composeEventHandlers(onClick, (event) => {\n          setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);\n          if (bubbleInput && isFormControl) {\n            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n          }\n        })\n      }\n    );\n  }\n);\nCheckboxTrigger.displayName = TRIGGER_NAME;\nvar Checkbox = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      name,\n      checked,\n      defaultChecked,\n      required,\n      disabled,\n      value,\n      onCheckedChange,\n      form,\n      ...checkboxProps\n    } = props;\n    return (0, import_jsx_runtime.jsx)(\n      CheckboxProvider,\n      {\n        __scopeCheckbox,\n        checked,\n        defaultChecked,\n        disabled,\n        required,\n        onCheckedChange,\n        name,\n        form,\n        value,\n        internal_do_not_use_render: ({ isFormControl }) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [\n          (0, import_jsx_runtime.jsx)(\n            CheckboxTrigger,\n            {\n              ...checkboxProps,\n              ref: forwardedRef,\n              __scopeCheckbox\n            }\n          ),\n          isFormControl && (0, import_jsx_runtime.jsx)(\n            CheckboxBubbleInput,\n            {\n              __scopeCheckbox\n            }\n          )\n        ] })\n      }\n    );\n  }\n);\nCheckbox.displayName = CHECKBOX_NAME;\nvar INDICATOR_NAME = \"CheckboxIndicator\";\nvar CheckboxIndicator = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (0, import_jsx_runtime.jsx)(\n      Presence,\n      {\n        present: forceMount || isIndeterminate(context.checked) || context.checked === true,\n        children: (0, import_jsx_runtime.jsx)(\n          Primitive.span,\n          {\n            \"data-state\": getState(context.checked),\n            \"data-disabled\": context.disabled ? \"\" : void 0,\n            ...indicatorProps,\n            ref: forwardedRef,\n            style: { pointerEvents: \"none\", ...props.style }\n          }\n        )\n      }\n    );\n  }\n);\nCheckboxIndicator.displayName = INDICATOR_NAME;\nvar BUBBLE_INPUT_NAME = \"CheckboxBubbleInput\";\nvar CheckboxBubbleInput = React.forwardRef(\n  ({ __scopeCheckbox, ...props }, forwardedRef) => {\n    const {\n      control,\n      hasConsumerStoppedPropagationRef,\n      checked,\n      defaultChecked,\n      required,\n      disabled,\n      name,\n      value,\n      form,\n      bubbleInput,\n      setBubbleInput\n    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);\n    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);\n    const prevChecked = usePrevious(checked);\n    const controlSize = useSize(control);\n    React.useEffect(() => {\n      const input = bubbleInput;\n      if (!input) return;\n      const inputProto = window.HTMLInputElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        inputProto,\n        \"checked\"\n      );\n      const setChecked = descriptor.set;\n      const bubbles = !hasConsumerStoppedPropagationRef.current;\n      if (prevChecked !== checked && setChecked) {\n        const event = new Event(\"click\", { bubbles });\n        input.indeterminate = isIndeterminate(checked);\n        setChecked.call(input, isIndeterminate(checked) ? false : checked);\n        input.dispatchEvent(event);\n      }\n    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);\n    const defaultCheckedRef = React.useRef(isIndeterminate(checked) ? false : checked);\n    return (0, import_jsx_runtime.jsx)(\n      Primitive.input,\n      {\n        type: \"checkbox\",\n        \"aria-hidden\": true,\n        defaultChecked: defaultChecked ?? defaultCheckedRef.current,\n        required,\n        disabled,\n        name,\n        value,\n        form,\n        ...props,\n        tabIndex: -1,\n        ref: composedRefs,\n        style: {\n          ...props.style,\n          ...controlSize,\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0,\n          // We transform because the input is absolutely positioned but we have\n          // rendered it **after** the button. This pulls it back to sit on top\n          // of the button.\n          transform: \"translateX(-100%)\"\n        }\n      }\n    );\n  }\n);\nCheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction getState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nexport {\n  Checkbox,\n  CheckboxIndicator,\n  CheckboxIndicator as Indicator,\n  Checkbox as Root,\n  createCheckboxScope,\n  CheckboxBubbleInput as unstable_BubbleInput,\n  CheckboxBubbleInput as unstable_CheckboxBubbleInput,\n  CheckboxProvider as unstable_CheckboxProvider,\n  CheckboxTrigger as unstable_CheckboxTrigger,\n  CheckboxProvider as unstable_Provider,\n  CheckboxTrigger as unstable_Trigger\n};\n//# sourceMappingURL=@radix-ui_react-checkbox.js.map\n","size_bytes":8954},"packages/frontend/node_modules/.vite/deps/@radix-ui_react-tabs.js":{"content":"\"use client\";\nimport {\n  Presence\n} from \"./chunk-7ARIJ2HB.js\";\nimport {\n  useDirection\n} from \"./chunk-YNLI6ANZ.js\";\nimport {\n  createCollection\n} from \"./chunk-G7D2KNJE.js\";\nimport {\n  useId\n} from \"./chunk-O7ZJEN5H.js\";\nimport {\n  useCallbackRef\n} from \"./chunk-Y2D2AKKB.js\";\nimport {\n  composeEventHandlers,\n  createContextScope,\n  useControllableState\n} from \"./chunk-X33UD2YA.js\";\nimport {\n  Primitive\n} from \"./chunk-3TQR5GFZ.js\";\nimport {\n  useComposedRefs\n} from \"./chunk-E7DYAJFJ.js\";\nimport \"./chunk-B3GHQWXA.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-SY54FM37.js\";\nimport {\n  require_react\n} from \"./chunk-PZHMDCWN.js\";\nimport {\n  __toESM\n} from \"./chunk-G3PMV62Z.js\";\n\n// ../../node_modules/@radix-ui/react-tabs/dist/index.mjs\nvar React2 = __toESM(require_react(), 1);\n\n// ../../node_modules/@radix-ui/react-roving-focus/dist/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_jsx_runtime = __toESM(require_jsx_runtime(), 1);\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = { bubbles: false, cancelable: true };\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef(\n  (props, forwardedRef) => {\n    return (0, import_jsx_runtime.jsx)(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime.jsx)(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });\n  }\n);\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return (0, import_jsx_runtime.jsx)(\n    RovingFocusProvider,\n    {\n      scope: __scopeRovingFocusGroup,\n      orientation,\n      dir: direction,\n      loop,\n      currentTabStopId,\n      onItemFocus: React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      ),\n      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n      onFocusableItemAdd: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      ),\n      onFocusableItemRemove: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      ),\n      children: (0, import_jsx_runtime.jsx)(\n        Primitive.div,\n        {\n          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n          \"data-orientation\": orientation,\n          ...groupProps,\n          ref: composedRefs,\n          style: { outline: \"none\", ...props.style },\n          onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n            isClickFocusRef.current = true;\n          }),\n          onFocus: composeEventHandlers(props.onFocus, (event) => {\n            const isKeyboardFocus = !isClickFocusRef.current;\n            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n              event.currentTarget.dispatchEvent(entryFocusEvent);\n              if (!entryFocusEvent.defaultPrevented) {\n                const items = getItems().filter((item) => item.focusable);\n                const activeItem = items.find((item) => item.active);\n                const currentItem = items.find((item) => item.id === currentTabStopId);\n                const candidateItems = [activeItem, currentItem, ...items].filter(\n                  Boolean\n                );\n                const candidateNodes = candidateItems.map((item) => item.ref.current);\n                focusFirst(candidateNodes, preventScrollOnEntryFocus);\n              }\n            }\n            isClickFocusRef.current = false;\n          }),\n          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n        }\n      )\n    }\n  );\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n    return (0, import_jsx_runtime.jsx)(\n      Collection.ItemSlot,\n      {\n        scope: __scopeRovingFocusGroup,\n        id,\n        focusable,\n        active,\n        children: (0, import_jsx_runtime.jsx)(\n          Primitive.span,\n          {\n            tabIndex: isCurrentTabStop ? 0 : -1,\n            \"data-orientation\": context.orientation,\n            ...itemProps,\n            ref: forwardedRef,\n            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {\n              if (!focusable) event.preventDefault();\n              else context.onItemFocus(id);\n            }),\n            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {\n              if (event.key === \"Tab\" && event.shiftKey) {\n                context.onItemShiftTab();\n                return;\n              }\n              if (event.target !== event.currentTarget) return;\n              const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n              if (focusIntent !== void 0) {\n                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n                event.preventDefault();\n                const items = getItems().filter((item) => item.focusable);\n                let candidateNodes = items.map((item) => item.ref.current);\n                if (focusIntent === \"last\") candidateNodes.reverse();\n                else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n                  if (focusIntent === \"prev\") candidateNodes.reverse();\n                  const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n                }\n                setTimeout(() => focusFirst(candidateNodes));\n              }\n            }),\n            children: typeof children === \"function\" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children\n          }\n        )\n      }\n    );\n  }\n);\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates, preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\n\n// ../../node_modules/@radix-ui/react-tabs/dist/index.mjs\nvar import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);\nvar TABS_NAME = \"Tabs\";\nvar [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [\n  createRovingFocusGroupScope\n]);\nvar useRovingFocusGroupScope = createRovingFocusGroupScope();\nvar [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);\nvar Tabs = React2.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeTabs,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = \"horizontal\",\n      dir,\n      activationMode = \"automatic\",\n      ...tabsProps\n    } = props;\n    const direction = useDirection(dir);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue ?? \"\",\n      caller: TABS_NAME\n    });\n    return (0, import_jsx_runtime2.jsx)(\n      TabsProvider,\n      {\n        scope: __scopeTabs,\n        baseId: useId(),\n        value,\n        onValueChange: setValue,\n        orientation,\n        dir: direction,\n        activationMode,\n        children: (0, import_jsx_runtime2.jsx)(\n          Primitive.div,\n          {\n            dir: direction,\n            \"data-orientation\": orientation,\n            ...tabsProps,\n            ref: forwardedRef\n          }\n        )\n      }\n    );\n  }\n);\nTabs.displayName = TABS_NAME;\nvar TAB_LIST_NAME = \"TabsList\";\nvar TabsList = React2.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, loop = true, ...listProps } = props;\n    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    return (0, import_jsx_runtime2.jsx)(\n      Root,\n      {\n        asChild: true,\n        ...rovingFocusGroupScope,\n        orientation: context.orientation,\n        dir: context.dir,\n        loop,\n        children: (0, import_jsx_runtime2.jsx)(\n          Primitive.div,\n          {\n            role: \"tablist\",\n            \"aria-orientation\": context.orientation,\n            ...listProps,\n            ref: forwardedRef\n          }\n        )\n      }\n    );\n  }\n);\nTabsList.displayName = TAB_LIST_NAME;\nvar TRIGGER_NAME = \"TabsTrigger\";\nvar TabsTrigger = React2.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;\n    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    return (0, import_jsx_runtime2.jsx)(\n      Item,\n      {\n        asChild: true,\n        ...rovingFocusGroupScope,\n        focusable: !disabled,\n        active: isSelected,\n        children: (0, import_jsx_runtime2.jsx)(\n          Primitive.button,\n          {\n            type: \"button\",\n            role: \"tab\",\n            \"aria-selected\": isSelected,\n            \"aria-controls\": contentId,\n            \"data-state\": isSelected ? \"active\" : \"inactive\",\n            \"data-disabled\": disabled ? \"\" : void 0,\n            disabled,\n            id: triggerId,\n            ...triggerProps,\n            ref: forwardedRef,\n            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {\n              if (!disabled && event.button === 0 && event.ctrlKey === false) {\n                context.onValueChange(value);\n              } else {\n                event.preventDefault();\n              }\n            }),\n            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {\n              if ([\" \", \"Enter\"].includes(event.key)) context.onValueChange(value);\n            }),\n            onFocus: composeEventHandlers(props.onFocus, () => {\n              const isAutomaticActivation = context.activationMode !== \"manual\";\n              if (!isSelected && !disabled && isAutomaticActivation) {\n                context.onValueChange(value);\n              }\n            })\n          }\n        )\n      }\n    );\n  }\n);\nTabsTrigger.displayName = TRIGGER_NAME;\nvar CONTENT_NAME = \"TabsContent\";\nvar TabsContent = React2.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;\n    const context = useTabsContext(CONTENT_NAME, __scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    const isMountAnimationPreventedRef = React2.useRef(isSelected);\n    React2.useEffect(() => {\n      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);\n      return () => cancelAnimationFrame(rAF);\n    }, []);\n    return (0, import_jsx_runtime2.jsx)(Presence, { present: forceMount || isSelected, children: ({ present }) => (0, import_jsx_runtime2.jsx)(\n      Primitive.div,\n      {\n        \"data-state\": isSelected ? \"active\" : \"inactive\",\n        \"data-orientation\": context.orientation,\n        role: \"tabpanel\",\n        \"aria-labelledby\": triggerId,\n        hidden: !present,\n        id: contentId,\n        tabIndex: 0,\n        ...contentProps,\n        ref: forwardedRef,\n        style: {\n          ...props.style,\n          animationDuration: isMountAnimationPreventedRef.current ? \"0s\" : void 0\n        },\n        children: present && children\n      }\n    ) });\n  }\n);\nTabsContent.displayName = CONTENT_NAME;\nfunction makeTriggerId(baseId, value) {\n  return `${baseId}-trigger-${value}`;\n}\nfunction makeContentId(baseId, value) {\n  return `${baseId}-content-${value}`;\n}\nvar Root2 = Tabs;\nvar List = TabsList;\nvar Trigger = TabsTrigger;\nvar Content = TabsContent;\nexport {\n  Content,\n  List,\n  Root2 as Root,\n  Tabs,\n  TabsContent,\n  TabsList,\n  TabsTrigger,\n  Trigger,\n  createTabsScope\n};\n//# sourceMappingURL=@radix-ui_react-tabs.js.map\n","size_bytes":15466},"replit.md":{"content":"# W3 VoIP System - Enterprise Multi-tenant VoIP Platform\n\n## Overview\n\nW3 VoIP System is a comprehensive multi-tenant enterprise VoIP platform designed for modern communication needs. It features a React frontend with a glassmorphism UI, an Express backend with secure RESTful APIs, a PostgreSQL database for PBX functionalities, and deep integration with FreeSWITCH for full enterprise PBX capabilities. The system supports multi-tenancy with complete data isolation, targeting deployment on Debian VPS instances. The project aims to provide a robust, scalable, and secure VoIP solution for businesses.\n\n## User Preferences\n\n### Communication\n- **Language:** Italiano\n- **Style:** Professional, concise\n\n### Development\n- **Security First:** Always validate inputs, use env vars for secrets\n- **Multi-tenant:** Strict data isolation per tenant\n- **Error Handling:** Comprehensive logging and error messages\n\n## System Architecture\n\nThe W3 VoIP System adopts a microservices-like architecture with distinct frontend, backend, and database layers, integrated with FreeSWITCH.\n\n**Technology Stack:**\n-   **Frontend:** React with Vite for a modern glassmorphism UI, real-time dashboards, and multi-tenant admin panels.\n-   **Backend:** Express.js with TypeScript, providing multi-tenant isolation, JWT authentication, RESTful APIs for PBX features, FreeSWITCH ESL client for call control, and an XML service for dynamic FreeSWITCH configuration.\n-   **Database:** PostgreSQL, structured for multi-tenancy to manage IVR, Queues, Voicemail, CDR, and Extensions.\n-   **PBX Core:** FreeSWITCH, handling SIP/RTP, trunking, IVR, queues, and voicemail functionalities.\n\n**Key Design Decisions & Features:**\n-   **Multi-tenancy:** Implemented with strict data isolation at the database level and enforced via backend middleware.\n-   **Security:** Focus on SQL injection prevention (whitelist validation), environment variable-based secrets management, and restrictive CORS configuration.\n-   **Database Stability (2025-10-24):**\n    -   **Connection Pool:** Enterprise-grade pool with automatic reconnection, exponential backoff retry logic (1s → 2s → 4s → 8s → 16s), and comprehensive event handlers (error, connect, remove, acquire, release)\n    -   **Health Monitoring:** Periodic health checks every 30 seconds with detailed pool statistics logging\n    -   **Error Handling:** Graceful handling of all PostgreSQL connection errors (57P01, 57P02, 57P03, 08003, 08006, ECONNREFUSED) without process termination\n    -   **Resilience:** Backend continues operation during PostgreSQL restarts/disconnections with automatic recovery\n-   **FreeSWITCH Integration:**\n    -   **ESL Service:** Robust auto-reconnecting client for real-time event handling (CHANNEL_CREATE, CHANNEL_ANSWER, CHANNEL_HANGUP) and comprehensive CDR tracking.\n    -   **XML Service:** Dynamic configuration generation for FreeSWITCH, including user authentication, dialplan, IVR, queue, and voicemail routing. Critical for dynamic tenant lookup and routing of Italian national and international numbers.\n-   **Frontend UI/UX:** Utilizes a modern glassmorphism design with specific CSS classes for cards, headers, sidebars, modals, inputs, and buttons, along with gradient backgrounds and status indicators.\n-   **Database Schema:** Comprehensive multi-tenant schema including `Tenants`, `Extensions`, `SIP Trunks`, `IVR Menus`, `Call Queues`, `Voicemail Boxes`, `Conference Rooms`, and `CDR`.\n-   **Deployment:** Automated VPS setup script for Debian, configuring Node.js, PostgreSQL, FreeSWITCH (with necessary modules like `mod_xml_curl`, `mod_event_socket`, `mod_sofia`), UFW firewall rules, and systemd services.\n-   **API Endpoints:** Structured API for authentication, tenant management, and extension management, with planned expansion for IVR, queues, voicemail, conference, and call control.\n\n## External Dependencies\n\n-   **PostgreSQL:** Relational database for all application data, managed with Drizzle ORM.\n-   **FreeSWITCH:** Open-source telephony platform integrated via Event Socket Layer (ESL) for real-time control and XML Curl for dynamic configuration.\n-   **MessageNet (example SIP provider):** Used for SIP trunking for external calls.\n-   **Node.js:** Runtime environment for backend services.\n-   **NPM/Yarn:** Package managers for project dependencies.\n-   **Vite:** Frontend build tool for React application.\n-   **systemd:** Service manager for running backend and FreeSWITCH on Linux.\n-   **UFW (Uncomplicated Firewall):** For managing network security on the VPS.","size_bytes":4559},"packages/backend/dist/services/extension.service.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtensionService = void 0;\n// @ts-nocheck\nconst database_1 = require(\"@w3-voip/database\");\n// import { Extension, ExtensionSchema } from '@w3-voip/shared';\nconst uuid_1 = require(\"uuid\");\nconst bcryptjs_1 = __importDefault(require(\"bcryptjs\"));\nclass ExtensionService {\n    // Create a new extension\n    async createExtension(extensionData) {\n        return (0, database_1.withTransaction)(async (client) => {\n            // Verify tenant exists\n            const tenantResult = await client.query('SELECT id FROM tenants WHERE id = $1 AND status = $2', [extensionData.tenant_id, 'active']);\n            if (tenantResult.rows.length === 0) {\n                throw new Error('Tenant not found or inactive');\n            }\n            // Verify store exists if provided\n            if (extensionData.store_id) {\n                const storeResult = await client.query('SELECT id FROM stores WHERE id = $1 AND tenant_id = $2 AND status = $3', [extensionData.store_id, extensionData.tenant_id, 'active']);\n                if (storeResult.rows.length === 0) {\n                    throw new Error('Store not found or inactive');\n                }\n            }\n            // Check if extension already exists for this tenant\n            const existingExtension = await client.query('SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2', [extensionData.tenant_id, extensionData.extension]);\n            if (existingExtension.rows.length > 0) {\n                throw new Error('Extension already exists for this tenant');\n            }\n            // Hash password\n            const hashedPassword = await bcryptjs_1.default.hash(extensionData.password, 12);\n            // Create extension\n            const result = await client.query(`INSERT INTO extensions (id, tenant_id, store_id, extension, password, display_name, status, type, settings)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n         RETURNING *`, [\n                (0, uuid_1.v4)(),\n                extensionData.tenant_id,\n                extensionData.store_id || null,\n                extensionData.extension,\n                hashedPassword,\n                extensionData.display_name,\n                extensionData.status || 'active',\n                extensionData.type || 'user',\n                JSON.stringify(extensionData.settings)\n            ]);\n            const extension = result.rows[0];\n            return {\n                ...extension,\n                password: extensionData.password, // Return original password for response\n                settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n            };\n        });\n    }\n    // Get extension by ID\n    async getExtensionById(extensionId, tenantId) {\n        const client = await (0, database_1.getClient)();\n        try {\n            let query = 'SELECT * FROM extensions WHERE id = $1';\n            let params = [extensionId];\n            if (tenantId) {\n                query += ' AND tenant_id = $2';\n                params.push(tenantId);\n            }\n            const result = await client.query(query, params);\n            if (result.rows.length === 0) {\n                return null;\n            }\n            const extension = result.rows[0];\n            return {\n                ...extension,\n                settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n            };\n        }\n        finally {\n            await client.release();\n        }\n    }\n    // Get extension by extension number and tenant\n    async getExtensionByNumber(extension, tenantId) {\n        const client = await (0, database_1.getClient)();\n        try {\n            const result = await client.query('SELECT * FROM extensions WHERE extension = $1 AND tenant_id = $2', [extension, tenantId]);\n            if (result.rows.length === 0) {\n                return null;\n            }\n            const ext = result.rows[0];\n            return {\n                ...ext,\n                settings: typeof ext.settings === 'string' ? JSON.parse(ext.settings) : ext.settings\n            };\n        }\n        finally {\n            await client.release();\n        }\n    }\n    // Update extension\n    async updateExtension(extensionId, updates, tenantId) {\n        return (0, database_1.withTransaction)(async (client) => {\n            // Check if extension conflicts with other extensions in the same tenant\n            if (updates.extension) {\n                const existingExtension = await client.query('SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2 AND id != $3', [tenantId, updates.extension, extensionId]);\n                if (existingExtension.rows.length > 0) {\n                    throw new Error('Extension already exists for this tenant');\n                }\n            }\n            // Build update query\n            const updateFields = [];\n            const values = [];\n            let paramCount = 1;\n            if (updates.extension !== undefined) {\n                updateFields.push(`extension = $${paramCount++}`);\n                values.push(updates.extension);\n            }\n            if (updates.password !== undefined) {\n                const hashedPassword = await bcryptjs_1.default.hash(updates.password, 12);\n                updateFields.push(`password = $${paramCount++}`);\n                values.push(hashedPassword);\n            }\n            if (updates.display_name !== undefined) {\n                updateFields.push(`display_name = $${paramCount++}`);\n                values.push(updates.display_name);\n            }\n            if (updates.status !== undefined) {\n                updateFields.push(`status = $${paramCount++}`);\n                values.push(updates.status);\n            }\n            if (updates.type !== undefined) {\n                updateFields.push(`type = $${paramCount++}`);\n                values.push(updates.type);\n            }\n            if (updates.store_id !== undefined) {\n                updateFields.push(`store_id = $${paramCount++}`);\n                values.push(updates.store_id || null);\n            }\n            if (updates.settings !== undefined) {\n                updateFields.push(`settings = $${paramCount++}`);\n                values.push(JSON.stringify(updates.settings));\n            }\n            if (updateFields.length === 0) {\n                throw new Error('No fields to update');\n            }\n            values.push(extensionId);\n            let query = `UPDATE extensions SET ${updateFields.join(', ')}, updated_at = NOW() WHERE id = $${paramCount}`;\n            if (tenantId) {\n                query += ` AND tenant_id = $${paramCount + 1}`;\n                values.push(tenantId);\n            }\n            query += ' RETURNING *';\n            const result = await client.query(query, values);\n            if (result.rows.length === 0) {\n                throw new Error('Extension not found');\n            }\n            const extension = result.rows[0];\n            return {\n                ...extension,\n                password: updates.password || '[HIDDEN]', // Return updated password or hidden\n                settings: typeof extension.settings === 'string' ? JSON.parse(extension.settings) : extension.settings\n            };\n        });\n    }\n    // Delete extension\n    async deleteExtension(extensionId, tenantId) {\n        return (0, database_1.withTransaction)(async (client) => {\n            let query = 'DELETE FROM extensions WHERE id = $1';\n            let params = [extensionId];\n            if (tenantId) {\n                query += ' AND tenant_id = $2';\n                params.push(tenantId);\n            }\n            const result = await client.query(query, params);\n            if (result.rowCount === 0) {\n                throw new Error('Extension not found');\n            }\n        });\n    }\n    // List extensions for a tenant\n    async listExtensions(tenantId, storeId, page = 1, limit = 50, search) {\n        const client = await (0, database_1.getClient)();\n        try {\n            const offset = (page - 1) * limit;\n            let whereClause = 'WHERE tenant_id = $1';\n            let queryParams = [tenantId];\n            if (storeId) {\n                whereClause += ' AND store_id = $2';\n                queryParams.push(storeId);\n            }\n            if (search) {\n                const searchParam = storeId ? 3 : 2;\n                whereClause += ` AND (extension ILIKE $${searchParam} OR display_name ILIKE $${searchParam})`;\n                queryParams.push(`%${search}%`);\n            }\n            // Get total count\n            const countResult = await client.query(`SELECT COUNT(*) FROM extensions ${whereClause}`, queryParams);\n            const total = parseInt(countResult.rows[0].count);\n            // Get extensions\n            const result = await client.query(`SELECT * FROM extensions ${whereClause}\n         ORDER BY extension ASC\n         LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`, [...queryParams, limit, offset]);\n            const extensions = result.rows.map(row => ({\n                ...row,\n                password: '[HIDDEN]', // Hide passwords in list\n                settings: typeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings\n            }));\n            return {\n                extensions,\n                total,\n                totalPages: Math.ceil(total / limit)\n            };\n        }\n        finally {\n            await client.release();\n        }\n    }\n    // Verify extension password\n    async verifyExtensionPassword(extension, password, tenantId) {\n        const client = await (0, database_1.getClient)();\n        try {\n            const result = await client.query('SELECT * FROM extensions WHERE extension = $1 AND tenant_id = $2 AND status = $3', [extension, tenantId, 'active']);\n            if (result.rows.length === 0) {\n                return null;\n            }\n            const ext = result.rows[0];\n            const isValidPassword = await bcryptjs_1.default.compare(password, ext.password);\n            if (!isValidPassword) {\n                return null;\n            }\n            return {\n                ...ext,\n                password: '[HIDDEN]',\n                settings: typeof ext.settings === 'string' ? JSON.parse(ext.settings) : ext.settings\n            };\n        }\n        finally {\n            await client.release();\n        }\n    }\n    // Activate extension\n    async activateExtension(extensionId, tenantId) {\n        return this.updateExtension(extensionId, { status: 'active' }, tenantId);\n    }\n    // Deactivate extension\n    async deactivateExtension(extensionId, tenantId) {\n        return this.updateExtension(extensionId, { status: 'inactive' }, tenantId);\n    }\n    // Lock extension\n    async lockExtension(extensionId, tenantId) {\n        return this.updateExtension(extensionId, { status: 'inactive' }, tenantId);\n    }\n    // Validate extension number uniqueness within tenant\n    async validateExtensionUniqueness(extension, tenantId, excludeExtensionId) {\n        const client = await (0, database_1.getClient)();\n        try {\n            let query = 'SELECT id FROM extensions WHERE tenant_id = $1 AND extension = $2';\n            let params = [tenantId, extension];\n            if (excludeExtensionId) {\n                query += ' AND id != $3';\n                params.push(excludeExtensionId);\n            }\n            const result = await client.query(query, params);\n            return result.rows.length === 0;\n        }\n        finally {\n            await client.release();\n        }\n    }\n    // Get extension statistics\n    async getExtensionStats(extensionId, tenantId) {\n        const client = await (0, database_1.getClient)();\n        try {\n            let whereClause = 'WHERE e.id = $1';\n            let params = [extensionId];\n            if (tenantId) {\n                whereClause += ' AND e.tenant_id = $2';\n                params.push(tenantId);\n            }\n            const result = await client.query(`SELECT \n           COUNT(DISTINCT c.id) as total_calls,\n           COUNT(DISTINCT CASE WHEN c.hangup_disposition = 'answered' THEN c.id END) as answered_calls,\n           COUNT(DISTINCT CASE WHEN c.hangup_disposition IN ('no_answer', 'busy') THEN c.id END) as missed_calls,\n           COALESCE(SUM(c.duration), 0) as total_duration,\n           MAX(c.start_time) as last_call_time\n         FROM extensions e\n         LEFT JOIN cdr c ON e.id = c.extension_id\n         ${whereClause}\n         GROUP BY e.id`, params);\n            if (result.rows.length === 0) {\n                throw new Error('Extension not found');\n            }\n            return result.rows[0];\n        }\n        finally {\n            await client.release();\n        }\n    }\n}\nexports.ExtensionService = ExtensionService;\n//# sourceMappingURL=extension.service.js.map","size_bytes":13123},"QUICK_DEPLOY.md":{"content":"# ⚡ Quick Deploy Guide\n\n## 🎯 Modifiche da Deployare\n\n### 1. Fix JSON.parse (CRITICO)\n- **File**: `packages/backend/src/services/extension.service.ts`\n- **Bug**: Extensions non visibili in frontend\n- **Fix**: Type check prima di JSON.parse per JSONB fields\n\n### 2. Fix Database Timeout\n- **File**: `packages/database/src/index.ts`  \n- **Bug**: Connection timeout errors\n- **Fix**: Timeout aumentato a 10s + keepAlive\n\n## 🚀 Deployment Rapido\n\n### Step 1: Commit da Replit\n```bash\ngit add .\ngit commit -m \"Fix: JSON.parse JSONB + database timeout\"\ngit push origin main\n```\n\n### Step 2: Deploy sul Server\n```bash\n# SSH al server\nssh root@93.93.113.13\ncd /root/w3voip-app\n\n# Backup database\npg_dump -U voip_user -d voip_production > /root/backups/db_$(date +%Y%m%d_%H%M).sql\n\n# Pull + Build + Restart\ngit pull origin main && npm install && npm run build && systemctl restart voip-backend\n\n# Verifica\nsystemctl status voip-backend\njournalctl -u voip-backend -n 20\n```\n\n### Step 3: Test\n```bash\n# Test API\ncurl http://localhost:3001/api/health\n\n# Verifica extension 100\npsql -U voip_user -d voip_production -c \"SELECT extension, display_name FROM extensions WHERE extension='100';\"\n```\n\n## ✅ Done!\n\nSe tutto ok, le extensions dovrebbero essere visibili nel frontend.\n\n## ⚠️ Se qualcosa va storto\n\n```bash\n# Rollback Git\ngit reset --hard HEAD~1\n\n# Ripristina database\npsql -U voip_user -d voip_production < /root/backups/db_YYYYMMDD_HHMM.sql\n\n# Riavvia\nnpm run build && systemctl restart voip-backend\n```\n\n---\n\n**Per dettagli completi vedi `DEPLOYMENT.md`**\n","size_bytes":1564},"DEPLOYMENT.md":{"content":"# 🚀 Deployment Guide - W3 VoIP System\n\n## 📋 Pre-requisiti\n\n- Accesso SSH al server production (93.93.113.13)\n- Repository Git configurato sul server\n- Node.js e npm installati\n- PostgreSQL database in esecuzione\n- FreeSWITCH installato\n\n## 🔄 Procedura di Deployment\n\n### 1. Commit e Push da Replit (LOCALE)\n\n```bash\n# Verifica le modifiche\ngit status\n\n# Aggiungi tutte le modifiche\ngit add .\n\n# Commit con messaggio descrittivo\ngit commit -m \"Fix: JSON.parse per JSONB settings + database timeout aumentato\"\n\n# Push su repository\ngit push origin main\n```\n\n### 2. Deploy sul Server Production\n\nConnettiti al server:\n\n```bash\nssh root@93.93.113.13\ncd /root/w3voip-app\n```\n\nEsegui il deployment:\n\n```bash\n# 1. Backup del database (IMPORTANTE!)\npg_dump -U voip_user -d voip_production > /root/backups/db_backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 2. Pull delle modifiche da Git\ngit fetch origin\ngit pull origin main\n\n# 3. Installa/aggiorna dipendenze\nnpm install\n\n# 4. Build del progetto\nnpm run build\n\n# 5. Verifica schema database (se necessario)\ncd packages/backend\nnpm run db:push\n\n# 6. Riavvia i servizi\nsystemctl restart voip-backend\n\n# 7. Verifica che il backend sia attivo\nsystemctl status voip-backend\n\n# 8. Controlla i log per errori\njournalctl -u voip-backend -n 50 --no-pager\n\n# 9. Riavvia FreeSWITCH (solo se necessario)\n# systemctl restart freeswitch\n# systemctl status freeswitch\n```\n\n### 3. Verifica Deployment\n\n```bash\n# Test API backend\ncurl -I http://localhost:3001/api/health\n\n# Verifica connessione database\npsql -U voip_user -d voip_production -c \"SELECT COUNT(*) FROM tenants;\"\n\n# Test extension 100\npsql -U voip_user -d voip_production -c \"SELECT id, extension, display_name FROM extensions WHERE extension = '100';\"\n\n# Verifica FreeSWITCH\n/usr/local/freeswitch/bin/fs_cli -x \"sofia status profile internal\"\n```\n\n## 📝 Modifiche in Questo Deploy\n\n### Fix JSON.parse per JSONB (CRITICO)\n- **File**: `packages/backend/src/services/extension.service.ts`\n- **Problema**: PostgreSQL ritorna JSONB come oggetto in production ma come stringa in development\n- **Soluzione**: Check del tipo prima di JSON.parse\n```typescript\ntypeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings\n```\n- **Occorrenze**: 6 fix applicati\n\n### Fix Database Connection Timeout\n- **File**: `packages/database/src/index.ts`\n- **Problema**: Timeout di 2s troppo basso per connessioni di rete\n- **Modifiche**:\n  - `connectionTimeoutMillis`: 2000 → 10000 (10 secondi)\n  - Aggiunto `keepAlive: true`\n  - Aggiunto `keepAliveInitialDelayMillis: 10000`\n\n## ⚠️ Troubleshooting\n\n### Backend non si avvia\n\n```bash\n# Controlla errori nel log\njournalctl -u voip-backend -n 100 --no-pager\n\n# Verifica porta 3001 libera\nnetstat -tuln | grep 3001\n\n# Kill processo bloccato\npkill -f \"node.*backend\"\nsystemctl restart voip-backend\n```\n\n### Database non si connette\n\n```bash\n# Test connessione database\npsql -U voip_user -d voip_production -c \"SELECT 1;\"\n\n# Verifica DATABASE_URL in .env\ncat /root/w3voip-app/packages/backend/.env | grep DATABASE_URL\n```\n\n### FreeSWITCH non parte\n\n```bash\n# NON modificare manualmente i file di configurazione!\n# Verifica errori\n/usr/local/freeswitch/bin/freeswitch -c 2>&1 | head -50\n\n# Se necessario, ripristina configurazione\ncd /usr/local/freeswitch/conf\n# Verifica backup disponibili\nls -la *.bak\n```\n\n## 🔙 Rollback\n\nSe qualcosa va storto:\n\n```bash\n# 1. Torna alla versione precedente\ncd /root/w3voip-app\ngit log --oneline -5  # Vedi commit recenti\ngit reset --hard <commit-hash-precedente>\n\n# 2. Ripristina database\npsql -U voip_user -d voip_production < /root/backups/db_backup_YYYYMMDD_HHMMSS.sql\n\n# 3. Rebuild e riavvia\nnpm run build\nsystemctl restart voip-backend\n```\n\n## 📊 Monitoring Post-Deployment\n\n```bash\n# Monitora log in real-time\njournalctl -u voip-backend -f\n\n# Monitora registrazioni SIP\ntail -f /usr/local/freeswitch/log/freeswitch.log | grep -i REGISTER\n\n# CPU e memoria\ntop -bn1 | grep -E \"(node|freeswitch)\"\n```\n\n## ✅ Checklist Post-Deploy\n\n- [ ] Backend risponde su porta 3001\n- [ ] Database accessibile\n- [ ] FreeSWITCH in esecuzione\n- [ ] Extension 100 visibile in frontend\n- [ ] Nessun errore nei log\n- [ ] Test login su frontend funzionante\n\n## 🆘 Supporto\n\nSe incontri problemi:\n1. Controlla i log: `journalctl -u voip-backend -n 100`\n2. Verifica status servizi: `systemctl status voip-backend freeswitch`\n3. Non modificare manualmente file sul server - usa sempre Git workflow\n","size_bytes":4452},"FREESWITCH_TROUBLESHOOTING.md":{"content":"# FreeSWITCH Troubleshooting Guide\n\n## Issue: mod_sofia Crash on Production Server\n\n**Server:** 93.93.113.13  \n**Error:** `mod_sofia` module crashes on startup  \n**Impact:** SIP registration and calls not working  \n\n---\n\n## Diagnosis Steps\n\n1. **Check FreeSWITCH Logs:**\n   ```bash\n   sudo tail -f /var/log/freeswitch/freeswitch.log\n   ```\n\n2. **Check Module Status:**\n   ```bash\n   fs_cli -x \"module_exists mod_sofia\"\n   fs_cli -x \"sofia status\"\n   ```\n\n3. **Verify Dependencies:**\n   ```bash\n   ldd /usr/lib/freeswitch/mod/mod_sofia.so\n   ```\n\n---\n\n## Solution Options\n\n### Option 1: Reinstall FreeSWITCH (Recommended)\n\n```bash\n# Backup configuration\nsudo cp -r /etc/freeswitch /etc/freeswitch.backup.$(date +%Y%m%d)\n\n# Remove existing installation\nsudo apt remove --purge freeswitch freeswitch-all\nsudo apt autoremove\n\n# Add FreeSWITCH repository\nwget -O - https://files.freeswitch.org/repo/deb/debian-release/fsstretch-archive-keyring.asc | sudo apt-key add -\necho \"deb https://files.freeswitch.org/repo/deb/debian-release/ $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/freeswitch.list\n\n# Install FreeSWITCH with mod_sofia\nsudo apt update\nsudo apt install -y freeswitch-all freeswitch-mod-sofia\n\n# Restore configuration\nsudo rsync -av /etc/freeswitch.backup.*/ /etc/freeswitch/\n\n# Start FreeSWITCH\nsudo systemctl start freeswitch\nsudo systemctl status freeswitch\n```\n\n### Option 2: Recompile mod_sofia from Source\n\n```bash\n# Install build dependencies\nsudo apt install -y build-essential autoconf automake libtool pkg-config\nsudo apt install -y libsofia-sip-ua-dev libsofia-sip-ua-glib-dev\n\n# Navigate to FreeSWITCH source (if available)\ncd /usr/src/freeswitch\n\n# Rebuild mod_sofia\nmake mod_sofia-clean\nmake mod_sofia\nsudo make mod_sofia-install\n\n# Restart FreeSWITCH\nsudo systemctl restart freeswitch\n```\n\n### Option 3: Check Missing Libraries\n\n```bash\n# Find missing dependencies\nldd /usr/lib/freeswitch/mod/mod_sofia.so | grep \"not found\"\n\n# Install missing libraries (example)\nsudo apt install -y libsofia-sip-ua0\n```\n\n---\n\n## Verification\n\nAfter applying the fix:\n\n1. **Check mod_sofia loads:**\n   ```bash\n   fs_cli -x \"module_exists mod_sofia\"\n   # Should return: true\n   ```\n\n2. **Check SIP profiles:**\n   ```bash\n   fs_cli -x \"sofia status\"\n   # Should show profiles running\n   ```\n\n3. **Test SIP registration from extension 100:**\n   - Configure SIP client with:\n     - Domain: `demo.edgvoip.it`\n     - Username: `100`\n     - Password: `DemoExt100Pass!`\n     - Server: `93.93.113.13`\n\n4. **Check FreeSWITCH XML provisioning:**\n   ```bash\n   curl -X POST \"http://localhost:3001/api/freeswitch/xml\" \\\n     -d \"section=directory&key_value=demo.edgvoip.it&user=100\"\n   ```\n\n---\n\n## Prevention\n\n1. **Never edit files directly on production**  \n   Use Git workflow: `Replit dev` → `Git push` → `Server pull`\n\n2. **Document all changes in DEPLOYMENT.md**\n\n3. **Test on Replit dev environment first**\n\n4. **Keep FreeSWITCH and dependencies updated:**\n   ```bash\n   sudo apt update\n   sudo apt upgrade freeswitch-all\n   ```\n\n---\n\n## Related Files\n\n- XML Provisioning: `packages/backend/src/services/freeswitch-xml.service.ts`\n- FreeSWITCH Routes: `packages/backend/src/routes/freeswitch-xml.routes.ts`\n- Deployment Guide: `DEPLOYMENT.md`\n\n---\n\n## Contact\n\nFor issues, check:\n- FreeSWITCH Logs: `/var/log/freeswitch/`\n- Application Logs: Backend server console\n- Database: Verify tenant and extension data\n","size_bytes":3427},"packages/backend/scripts/seed-demo-tenant.ts":{"content":"import { Pool } from 'pg';\nimport * as bcrypt from 'bcryptjs';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL\n});\n\nasync function seedDemoTenant() {\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n\n    console.log('🌱 Seeding demo tenant...');\n\n    // 1. Create or update demo tenant\n    const tenantResult = await client.query(`\n      INSERT INTO tenants (id, name, slug, domain, sip_domain, status)\n      VALUES (\n        gen_random_uuid(),\n        'Demo Tenant',\n        'demo',\n        'demo.edgvoip.it',\n        'demo.edgvoip.it',\n        'active'\n      )\n      ON CONFLICT (slug) \n      DO UPDATE SET \n        name = EXCLUDED.name,\n        domain = EXCLUDED.domain,\n        sip_domain = EXCLUDED.sip_domain,\n        status = EXCLUDED.status\n      RETURNING id\n    `);\n\n    const tenantId = tenantResult.rows[0].id;\n    console.log(`✅ Demo tenant created/updated: ${tenantId}`);\n\n    // 2. Create demo admin user for web login\n    console.log('👤 Creating demo admin user...');\n    \n    const hashedPassword = await bcrypt.hash('tenantadmin123', 10);\n    \n    await client.query(`\n      INSERT INTO users (\n        id, tenant_id, email, password_hash, first_name, last_name, role, status\n      )\n      VALUES (\n        gen_random_uuid(),\n        $1,\n        'admin@demo.local',\n        $2,\n        'Demo',\n        'Admin',\n        'tenant_admin',\n        'active'\n      )\n      ON CONFLICT (email)\n      DO UPDATE SET\n        password_hash = EXCLUDED.password_hash,\n        status = EXCLUDED.status\n    `, [tenantId, hashedPassword]);\n\n    console.log('✅ Demo admin user created/updated');\n\n    // 3. Create extensions 100 and 102\n    console.log('📞 Creating extensions 100 and 102...');\n    \n    await client.query(`\n      INSERT INTO extensions (id, tenant_id, extension, password, display_name, status)\n      VALUES \n        (gen_random_uuid(), $1, '100', 'test123456', 'Extension 100', 'active'),\n        (gen_random_uuid(), $1, '102', 'test123456', 'Extension 102', 'active')\n      ON CONFLICT (extension, tenant_id) \n      DO UPDATE SET \n        password = EXCLUDED.password,\n        display_name = EXCLUDED.display_name,\n        status = EXCLUDED.status\n    `, [tenantId]);\n\n    console.log('✅ Extensions 100 and 102 created/updated');\n\n    // 3. Create MessageNet SIP Trunk\n    console.log('🔗 Creating MessageNet SIP trunk...');\n    \n    // Skip trunk creation for now - can be configured via UI later\n    console.log('⏩ Skipping SIP trunk creation (can be configured via UI)');\n\n    // 4. Create voicemail boxes for extensions\n    console.log('📫 Creating voicemail boxes...');\n    \n    await client.query(`\n      INSERT INTO voicemail_boxes (id, tenant_id, mailbox_id, password, full_name, enabled)\n      VALUES \n        (gen_random_uuid(), $1, '100', '100', 'Extension 100', true),\n        (gen_random_uuid(), $1, '102', '102', 'Extension 102', true)\n      ON CONFLICT (mailbox_id) \n      DO UPDATE SET \n        full_name = EXCLUDED.full_name,\n        enabled = EXCLUDED.enabled\n    `, [tenantId]);\n\n    console.log('✅ Voicemail boxes created/updated');\n\n    // 5. Create a demo IVR menu\n    console.log('🎤 Creating demo IVR menu...');\n    \n    await client.query(`\n      INSERT INTO ivr_menus (\n        id, tenant_id, name, description, extension,\n        greeting_sound, timeout, max_failures,\n        timeout_action, invalid_action, options, enabled\n      )\n      VALUES (\n        gen_random_uuid(),\n        $1,\n        'Main Menu',\n        'Main IVR menu for demo tenant',\n        '1000',\n        '/sounds/greeting.wav',\n        10,\n        3,\n        '{\"type\": \"hangup\", \"destination\": \"\"}'::jsonb,\n        '{\"type\": \"hangup\", \"destination\": \"\"}'::jsonb,\n        '{\n          \"1\": {\"action\": \"extension\", \"destination\": \"100\"},\n          \"2\": {\"action\": \"extension\", \"destination\": \"102\"},\n          \"3\": {\"action\": \"queue\", \"destination\": \"3000\"}\n        }'::jsonb,\n        true\n      )\n      ON CONFLICT (extension) \n      DO UPDATE SET \n        name = EXCLUDED.name,\n        description = EXCLUDED.description,\n        enabled = EXCLUDED.enabled\n    `, [tenantId]);\n\n    console.log('✅ Demo IVR menu created/updated');\n\n    // 6. Create a demo call queue\n    console.log('📋 Creating demo call queue...');\n    \n    const queueResult = await client.query(`\n      INSERT INTO call_queues (\n        id, tenant_id, name, description, extension,\n        strategy, max_wait_time, enabled\n      )\n      VALUES (\n        gen_random_uuid(),\n        $1,\n        'Support Queue',\n        'Main support queue',\n        '3000',\n        'longest-idle',\n        300,\n        true\n      )\n      ON CONFLICT (extension)\n      DO UPDATE SET\n        name = EXCLUDED.name,\n        description = EXCLUDED.description,\n        enabled = EXCLUDED.enabled\n      RETURNING id\n    `, [tenantId]);\n\n    const queueId = queueResult.rows[0].id;\n    console.log(`✅ Demo call queue created/updated: ${queueId}`);\n\n    // 7. Add agents to queue\n    console.log('👤 Adding agents to queue...');\n    \n    const extensionsResult = await client.query(`\n      SELECT id, extension FROM extensions WHERE tenant_id = $1 AND extension IN ('100', '102')\n    `, [tenantId]);\n\n    for (const ext of extensionsResult.rows) {\n      await client.query(`\n        INSERT INTO queue_agents (\n          id, queue_id, extension_id, agent_name, agent_type,\n          contact, tier_level, tier_position, enabled\n        )\n        VALUES (\n          gen_random_uuid(),\n          $1,\n          $2,\n          $3,\n          'callback',\n          'user/${ext.extension}@demo.edgvoip.it',\n          1,\n          1,\n          true\n        )\n        ON CONFLICT (queue_id, extension_id)\n        DO UPDATE SET\n          enabled = EXCLUDED.enabled\n      `, [queueId, ext.id, `Agent ${ext.extension}`]);\n    }\n\n    console.log('✅ Agents added to queue');\n\n    await client.query('COMMIT');\n    \n    console.log('');\n    console.log('🎉 Demo tenant seeded successfully!');\n    console.log('');\n    console.log('📋 Summary:');\n    console.log(`   Tenant: demo (demo.edgvoip.it)`);\n    console.log(`   Extensions: 100, 102 (password: test123456)`);\n    console.log(`   Trunk: MessageNet (sip.messagenet.it)`);\n    console.log(`   IVR Menu: 1000`);\n    console.log(`   Queue: 3000`);\n    console.log('');\n\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('❌ Error seeding demo tenant:', error);\n    throw error;\n  } finally {\n    client.release();\n    await pool.end();\n  }\n}\n\n// Run seeding\nseedDemoTenant()\n  .then(() => {\n    console.log('✅ Seeding completed');\n    process.exit(0);\n  })\n  .catch((error) => {\n    console.error('❌ Seeding failed:', error);\n    process.exit(1);\n  });\n","size_bytes":6823},"deployment/setup-vps.sh":{"content":"#!/bin/bash\n###########################################\n# W3 VoIP System - VPS Setup Script\n# \n# This script installs FreeSWITCH, PostgreSQL,\n# Node.js and configures all services for\n# production deployment on Debian/Ubuntu\n###########################################\n\nset -e  # Exit on error\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\n# Function to print colored output\nprint_info() {\n    echo -e \"${GREEN}[INFO]${NC} $1\"\n}\n\nprint_warn() {\n    echo -e \"${YELLOW}[WARN]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\n# Check if running as root\nif [[ $EUID -ne 0 ]]; then\n   print_error \"This script must be run as root\"\n   exit 1\nfi\n\nprint_info \"Starting W3 VoIP System VPS Setup...\"\n\n###########################################\n# 1. System Update & Dependencies\n###########################################\nprint_info \"Updating system packages...\"\napt-get update\napt-get upgrade -y\n\nprint_info \"Installing basic dependencies...\"\napt-get install -y \\\n    curl \\\n    wget \\\n    gnupg2 \\\n    lsb-release \\\n    ca-certificates \\\n    apt-transport-https \\\n    software-properties-common \\\n    build-essential \\\n    git \\\n    vim \\\n    htop \\\n    net-tools\n\n###########################################\n# 2. Install Node.js 20.x\n###########################################\nprint_info \"Installing Node.js 20.x...\"\ncurl -fsSL https://deb.nodesource.com/setup_20.x | bash -\napt-get install -y nodejs\n\n# Verify Node.js installation\nNODE_VERSION=$(node --version)\nNPM_VERSION=$(npm --version)\nprint_info \"Node.js $NODE_VERSION installed\"\nprint_info \"NPM $NPM_VERSION installed\"\n\n###########################################\n# 3. Install PostgreSQL\n###########################################\nprint_info \"Installing PostgreSQL...\"\napt-get install -y postgresql postgresql-contrib\n\n# Start PostgreSQL service\nsystemctl start postgresql\nsystemctl enable postgresql\n\nprint_info \"PostgreSQL installed and started\"\n\n###########################################\n# 4. Install FreeSWITCH\n###########################################\nprint_info \"Installing FreeSWITCH...\"\n\n# Add FreeSWITCH repository (SignalWire)\nwget --http-user=signalwire --http-password=pat_tDkhM9WGu2xGwKsWFpWCLxH9 \\\n  -O /usr/share/keyrings/signalwire-freeswitch-repo.gpg \\\n  https://freeswitch.signalwire.com/repo/deb/debian-release/signalwire-freeswitch-repo.gpg\n\necho \"deb [signed-by=/usr/share/keyrings/signalwire-freeswitch-repo.gpg] \\\n  https://freeswitch.signalwire.com/repo/deb/debian-release/ $(lsb_release -sc) main\" \\\n  > /etc/apt/sources.list.d/freeswitch.list\n\napt-get update\n\n# Install FreeSWITCH and essential modules\napt-get install -y \\\n    freeswitch-meta-all \\\n    freeswitch-mod-xml-curl \\\n    freeswitch-mod-event-socket \\\n    freeswitch-mod-opus \\\n    freeswitch-mod-g729 \\\n    freeswitch-mod-amr \\\n    freeswitch-mod-voicemail \\\n    freeswitch-mod-conference \\\n    freeswitch-mod-fifo \\\n    freeswitch-mod-callcenter \\\n    freeswitch-mod-ivr \\\n    freeswitch-mod-native-file \\\n    freeswitch-mod-local-stream \\\n    freeswitch-mod-tone-stream \\\n    freeswitch-mod-db \\\n    freeswitch-mod-curl \\\n    freeswitch-mod-xml-cdr\n\n# Create FreeSWITCH user if not exists\nif ! id -u freeswitch > /dev/null 2>&1; then\n    adduser --disabled-password --quiet --system \\\n        --home /var/lib/freeswitch --gecos \"FreeSWITCH\" \\\n        --ingroup daemon freeswitch\nfi\n\n# Set correct permissions\nchown -R freeswitch:daemon /etc/freeswitch\nchown -R freeswitch:daemon /var/lib/freeswitch\nchown -R freeswitch:daemon /var/log/freeswitch\nchown -R freeswitch:daemon /usr/share/freeswitch\n\nprint_info \"FreeSWITCH installed\"\n\n###########################################\n# 5. Configure FreeSWITCH\n###########################################\nprint_info \"Configuring FreeSWITCH...\"\n\n# Copy configuration files from deployment directory\nif [ -d \"/var/www/voip-system/deployment/freeswitch\" ]; then\n    cp /var/www/voip-system/deployment/freeswitch/event_socket.conf.xml \\\n       /etc/freeswitch/autoload_configs/\n    \n    cp /var/www/voip-system/deployment/freeswitch/xml_curl.conf.xml \\\n       /etc/freeswitch/autoload_configs/\n    \n    cp /var/www/voip-system/deployment/freeswitch/sofia.conf.xml \\\n       /etc/freeswitch/autoload_configs/\n    \n    cp /var/www/voip-system/deployment/freeswitch/modules.conf.xml \\\n       /etc/freeswitch/autoload_configs/\n    \n    print_info \"FreeSWITCH configuration files copied\"\nelse\n    print_warn \"Configuration files not found in /var/www/voip-system/deployment/freeswitch\"\n    print_warn \"Please copy configuration files manually\"\nfi\n\n# Enable and start FreeSWITCH\nsystemctl enable freeswitch\nsystemctl start freeswitch\n\nprint_info \"FreeSWITCH configured and started\"\n\n###########################################\n# 6. Setup PostgreSQL Database\n###########################################\nprint_info \"Setting up PostgreSQL database...\"\n\n# Check if database already exists\nDB_EXISTS=$(sudo -u postgres psql -tAc \"SELECT 1 FROM pg_database WHERE datname='voip_production'\")\n\nif [ \"$DB_EXISTS\" = \"1\" ]; then\n    print_warn \"Database voip_production already exists, skipping creation\"\nelse\n    # Create database and user\n    sudo -u postgres psql <<EOF\nCREATE USER voip_user WITH PASSWORD 'VoipSecure2025!';\nCREATE DATABASE voip_production OWNER voip_user;\nGRANT ALL PRIVILEGES ON DATABASE voip_production TO voip_user;\n\\c voip_production\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\nEOF\n    \n    print_info \"Database voip_production created\"\nfi\n\n###########################################\n# 7. Setup Application\n###########################################\nprint_info \"Setting up application...\"\n\n# Create application directory if not exists\nmkdir -p /var/www/voip-system\n\n# Set environment variables file\ncat > /var/www/voip-system/.env <<EOF\n# Database Configuration\nDATABASE_URL=postgresql://voip_user:VoipSecure2025!@localhost:5432/voip_production\n\n# JWT Secret (CHANGE THIS IN PRODUCTION!)\nJWT_SECRET=$(openssl rand -hex 32)\n\n# CORS Origin\nCORS_ORIGIN=*\n\n# FreeSWITCH ESL Configuration\nFREESWITCH_ESL_HOST=127.0.0.1\nFREESWITCH_ESL_PORT=8021\nFREESWITCH_ESL_PASSWORD=ClueCon\n\n# Application Port\nPORT=5000\n\n# Node Environment\nNODE_ENV=production\nEOF\n\nprint_info \"Environment file created at /var/www/voip-system/.env\"\nprint_warn \"IMPORTANT: Edit /var/www/voip-system/.env and change default values!\"\n\n###########################################\n# 8. Create systemd service for backend\n###########################################\nprint_info \"Creating systemd service for backend...\"\n\ncat > /etc/systemd/system/voip-backend.service <<EOF\n[Unit]\nDescription=W3 VoIP System Backend API\nAfter=network.target postgresql.service freeswitch.service\nWants=postgresql.service freeswitch.service\n\n[Service]\nType=simple\nUser=root\nWorkingDirectory=/var/www/voip-system/packages/backend\nEnvironmentFile=/var/www/voip-system/.env\nExecStart=/usr/bin/npm start\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=voip-backend\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# Reload systemd and enable service\nsystemctl daemon-reload\nsystemctl enable voip-backend\n\nprint_info \"Backend systemd service created\"\n\n###########################################\n# 9. Firewall Configuration\n###########################################\nprint_info \"Configuring firewall...\"\n\n# Install ufw if not present\nif ! command -v ufw &> /dev/null; then\n    apt-get install -y ufw\nfi\n\n# Configure UFW\nufw --force enable\nufw default deny incoming\nufw default allow outgoing\n\n# Allow SSH\nufw allow 22/tcp\n\n# Allow HTTP/HTTPS\nufw allow 80/tcp\nufw allow 443/tcp\n\n# Allow SIP (FreeSWITCH)\nufw allow 5060/udp\nufw allow 5060/tcp\nufw allow 5080/udp\nufw allow 5080/tcp\n\n# Allow RTP (FreeSWITCH media)\nufw allow 16384:32768/udp\n\n# Allow backend API\nufw allow 5000/tcp\n\n# Reload firewall\nufw reload\n\nprint_info \"Firewall configured\"\n\n###########################################\n# 10. Final Steps\n###########################################\nprint_info \"Setup complete!\"\necho \"\"\nprint_info \"Next steps:\"\necho \"  1. Edit /var/www/voip-system/.env with your configuration\"\necho \"  2. Copy your application code to /var/www/voip-system/\"\necho \"  3. Run database migrations: cd /var/www/voip-system/packages/database && npm run migrate\"\necho \"  4. Start the backend: systemctl start voip-backend\"\necho \"  5. Check status: systemctl status voip-backend\"\necho \"  6. Check FreeSWITCH: systemctl status freeswitch\"\necho \"  7. View logs: journalctl -u voip-backend -f\"\necho \"\"\nprint_info \"FreeSWITCH CLI: /usr/bin/fs_cli\"\nprint_info \"Database: psql -U voip_user -d voip_production\"\necho \"\"\nprint_warn \"SECURITY REMINDERS:\"\necho \"  - Change default passwords in /var/www/voip-system/.env\"\necho \"  - Change FreeSWITCH ESL password in /etc/freeswitch/autoload_configs/event_socket.conf.xml\"\necho \"  - Configure SSL certificates for production\"\necho \"  - Restrict CORS_ORIGIN to specific domains\"\necho \"\"\nprint_info \"Setup script finished successfully!\"\n","size_bytes":9030},"packages/backend/src/services/esl.service.ts":{"content":"import { FreeSwitchClient } from 'esl';\nimport { EventEmitter } from 'events';\nimport { getClient } from '@w3-voip/database';\n\n/**\n * FreeSWITCH Event Socket Layer (ESL) Service\n * Manages connection to FreeSWITCH Event Socket for real-time events and call control\n */\nexport class ESLService extends EventEmitter {\n  private connection: FreeSwitchClient | null = null;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private reconnectAttempts: number = 0;\n  private maxReconnectAttempts: number = 10;\n  private reconnectDelay: number = 1000; // Start with 1 second\n  private maxReconnectDelay: number = 60000; // Max 60 seconds\n  private isConnecting: boolean = false;\n  private isShuttingDown: boolean = false;\n\n  private host: string;\n  private port: number;\n  private password: string;\n\n  constructor() {\n    super();\n    \n    // Get ESL configuration from environment variables\n    this.host = process.env.FREESWITCH_ESL_HOST || '127.0.0.1';\n    this.port = parseInt(process.env.FREESWITCH_ESL_PORT || '8021', 10);\n    this.password = process.env.FREESWITCH_ESL_PASSWORD || 'ClueCon';\n\n    console.log(`📞 ESL Service initialized - ${this.host}:${this.port}`);\n  }\n\n  /**\n   * Connect to FreeSWITCH Event Socket\n   */\n  async connect(): Promise<void> {\n    if (this.isConnecting || this.connection) {\n      console.log('⏳ ESL already connecting or connected');\n      return;\n    }\n\n    this.isConnecting = true;\n\n    try {\n      console.log(`🔌 Connecting to FreeSWITCH ESL at ${this.host}:${this.port}...`);\n      \n      this.connection = new FreeSwitchClient({ \n        host: this.host, \n        port: this.port, \n        password: this.password \n      });\n      \n      // Setup event handlers BEFORE connecting\n      this.setupEventHandlers();\n      \n      // Actually connect to FreeSWITCH (CRITICAL - was missing!)\n      await this.connection.connect();\n      \n      console.log('✅ ESL socket authenticated');\n      \n      // Connection is now ready (ready event already handled in setupEventHandlers)\n\n      // Subscribe to all events\n      await this.subscribeToEvents();\n\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      this.isConnecting = false;\n\n      console.log('✅ ESL connected successfully');\n      this.emit('connected');\n\n    } catch (error) {\n      this.isConnecting = false;\n      this.connection = null;\n      \n      console.error('❌ ESL connection failed:', error);\n      this.emit('error', error);\n      \n      // Attempt reconnection\n      if (!this.isShuttingDown) {\n        this.scheduleReconnect();\n      }\n    }\n  }\n\n  /**\n   * Setup event handlers for ESL connection\n   */\n  private setupEventHandlers(): void {\n    if (!this.connection) return;\n\n    // Connection ready (correct event name for FreeSwitchClient)\n    this.connection.on('ready', () => {\n      console.log('✅ ESL connection ready');\n    });\n\n    // Connection ended (correct event name for FreeSwitchClient)\n    this.connection.on('end', () => {\n      console.warn('⚠️ ESL connection ended');\n      this.connection = null;\n      \n      if (!this.isShuttingDown) {\n        this.scheduleReconnect();\n      }\n    });\n\n    // Connection error\n    this.connection.on('error', (error: Error) => {\n      console.error('❌ ESL connection error:', error);\n      this.emit('error', error);\n    });\n\n    // Handle FreeSWITCH events (correct event pattern for FreeSwitchClient)\n    this.connection.on('esl::event::*', (event: any) => {\n      this.handleFreeSWITCHEvent(event);\n    });\n  }\n\n  /**\n   * Subscribe to FreeSWITCH events\n   */\n  private async subscribeToEvents(): Promise<void> {\n    if (!this.connection) return;\n\n    try {\n      // Subscribe to important events for CDR and call tracking\n      await this.sendCommand('event plain CHANNEL_CREATE CHANNEL_ANSWER CHANNEL_BRIDGE CHANNEL_UNBRIDGE CHANNEL_HANGUP CHANNEL_HANGUP_COMPLETE');\n      console.log('✅ Subscribed to FreeSWITCH events');\n    } catch (error) {\n      console.error('❌ Failed to subscribe to events:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Handle FreeSWITCH events\n   */\n  private async handleFreeSWITCHEvent(event: any): Promise<void> {\n    try {\n      const eventName = event.getHeader('Event-Name');\n      const callUuid = event.getHeader('Unique-ID');\n      \n      if (!eventName || !callUuid) return;\n\n      console.log(`📡 ESL Event: ${eventName} - UUID: ${callUuid}`);\n\n      // Emit specific event types\n      this.emit('event', { eventName, event });\n      this.emit(`event:${eventName}`, event);\n\n      // Handle specific events for CDR\n      switch (eventName) {\n        case 'CHANNEL_CREATE':\n          await this.handleChannelCreate(event);\n          break;\n        \n        case 'CHANNEL_ANSWER':\n          await this.handleChannelAnswer(event);\n          break;\n        \n        case 'CHANNEL_BRIDGE':\n          await this.handleChannelBridge(event);\n          break;\n        \n        case 'CHANNEL_HANGUP':\n        case 'CHANNEL_HANGUP_COMPLETE':\n          await this.handleChannelHangup(event);\n          break;\n      }\n    } catch (error) {\n      console.error('❌ Error handling FreeSWITCH event:', error);\n    }\n  }\n\n  /**\n   * Handle CHANNEL_CREATE event - Call initiated\n   */\n  private async handleChannelCreate(event: any): Promise<void> {\n    const client = await getClient();\n    \n    try {\n      const callUuid = event.getHeader('Unique-ID');\n      const callerIdName = event.getHeader('Caller-Caller-ID-Name');\n      const callerIdNumber = event.getHeader('Caller-Caller-ID-Number');\n      const destinationNumber = event.getHeader('Caller-Destination-Number');\n      const callDirection = event.getHeader('Call-Direction');\n      const context = event.getHeader('Caller-Context');\n\n      // Find tenant from context\n      const tenantResult = await client.query(\n        'SELECT id FROM tenants WHERE slug = $1 LIMIT 1',\n        [context]\n      );\n\n      if (tenantResult.rows.length === 0) {\n        console.warn(`⚠️ Tenant not found for context: ${context}`);\n        return;\n      }\n\n      const tenantId = tenantResult.rows[0].id;\n\n      // Insert into call_status table for real-time tracking\n      await client.query(`\n        INSERT INTO call_status (\n          tenant_id, call_uuid, caller_id_name, caller_id_number, \n          destination_number, call_direction, call_state, start_time\n        ) VALUES ($1, $2, $3, $4, $5, $6, 'RINGING', CURRENT_TIMESTAMP)\n        ON CONFLICT (call_uuid) DO UPDATE \n        SET call_state = 'RINGING', last_updated = CURRENT_TIMESTAMP\n      `, [tenantId, callUuid, callerIdName, callerIdNumber, destinationNumber, callDirection]);\n\n      console.log(`📞 Call Created: ${callerIdNumber} → ${destinationNumber} (${callUuid})`);\n\n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Handle CHANNEL_ANSWER event - Call answered\n   */\n  private async handleChannelAnswer(event: any): Promise<void> {\n    const client = await getClient();\n    \n    try {\n      const callUuid = event.getHeader('Unique-ID');\n\n      await client.query(`\n        UPDATE call_status \n        SET call_state = 'ANSWERED', \n            answer_time = CURRENT_TIMESTAMP,\n            last_updated = CURRENT_TIMESTAMP\n        WHERE call_uuid = $1\n      `, [callUuid]);\n\n      console.log(`✅ Call Answered: ${callUuid}`);\n\n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Handle CHANNEL_BRIDGE event - Calls bridged\n   */\n  private async handleChannelBridge(event: any): Promise<void> {\n    const client = await getClient();\n    \n    try {\n      const callUuid = event.getHeader('Unique-ID');\n\n      await client.query(`\n        UPDATE call_status \n        SET call_state = 'BRIDGED',\n            last_updated = CURRENT_TIMESTAMP\n        WHERE call_uuid = $1\n      `, [callUuid]);\n\n      console.log(`🔗 Call Bridged: ${callUuid}`);\n\n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Handle CHANNEL_HANGUP event - Call ended\n   */\n  private async handleChannelHangup(event: any): Promise<void> {\n    const client = await getClient();\n    \n    try {\n      const callUuid = event.getHeader('Unique-ID');\n      const hangupCause = event.getHeader('Hangup-Cause');\n      const duration = parseInt(event.getHeader('variable_duration') || '0', 10);\n      const billSec = parseInt(event.getHeader('variable_billsec') || '0', 10);\n\n      // Move from call_status to cdr_enhanced\n      await client.query(`\n        UPDATE call_status \n        SET call_state = 'HANGUP',\n            last_updated = CURRENT_TIMESTAMP\n        WHERE call_uuid = $1\n      `, [callUuid]);\n\n      console.log(`📴 Call Hangup: ${callUuid} - ${hangupCause} (Duration: ${duration}s)`);\n\n      // Note: The database trigger will automatically move this to cdr_enhanced\n\n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff\n   */\n  private scheduleReconnect(): void {\n    if (this.isShuttingDown) return;\n\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error(`❌ Max reconnection attempts (${this.maxReconnectAttempts}) reached`);\n      this.emit('max_reconnect_attempts');\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);\n\n    console.log(`⏳ Reconnecting to ESL in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n\n    this.reconnectTimer = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  /**\n   * Send command to FreeSWITCH via ESL\n   */\n  async sendCommand(command: string): Promise<any> {\n    if (!this.connection) {\n      throw new Error('ESL not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connection!.api(command, (response: any) => {\n        if (response.getHeader('Content-Type') === 'api/response' && \n            response.getBody() === '-ERR') {\n          reject(new Error(`ESL command failed: ${command}`));\n        } else {\n          resolve(response);\n        }\n      });\n    });\n  }\n\n  /**\n   * Execute bgapi command (background API)\n   */\n  async sendBgapi(command: string): Promise<string> {\n    if (!this.connection) {\n      throw new Error('ESL not connected');\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connection!.bgapi(command, (response: any) => {\n        const jobUuid = response.getHeader('Job-UUID');\n        if (jobUuid) {\n          resolve(jobUuid);\n        } else {\n          reject(new Error('Failed to get Job-UUID from bgapi command'));\n        }\n      });\n    });\n  }\n\n  /**\n   * Hangup a call\n   */\n  async hangupCall(uuid: string, cause: string = 'NORMAL_CLEARING'): Promise<void> {\n    await this.sendCommand(`uuid_kill ${uuid} ${cause}`);\n    console.log(`📴 Hangup call: ${uuid} with cause ${cause}`);\n  }\n\n  /**\n   * Transfer a call\n   */\n  async transferCall(uuid: string, destination: string): Promise<void> {\n    await this.sendCommand(`uuid_transfer ${uuid} ${destination}`);\n    console.log(`📞 Transfer call: ${uuid} to ${destination}`);\n  }\n\n  /**\n   * Park a call\n   */\n  async parkCall(uuid: string): Promise<void> {\n    await this.sendCommand(`uuid_park ${uuid}`);\n    console.log(`🅿️ Park call: ${uuid}`);\n  }\n\n  /**\n   * Hold a call\n   */\n  async holdCall(uuid: string): Promise<void> {\n    await this.sendCommand(`uuid_hold ${uuid}`);\n    console.log(`⏸️ Hold call: ${uuid}`);\n  }\n\n  /**\n   * Unhold a call\n   */\n  async unholdCall(uuid: string): Promise<void> {\n    await this.sendCommand(`uuid_hold off ${uuid}`);\n    console.log(`▶️ Unhold call: ${uuid}`);\n  }\n\n  /**\n   * Get active calls\n   */\n  async getActiveCalls(): Promise<any[]> {\n    const client = await getClient();\n    \n    try {\n      const result = await client.query(`\n        SELECT * FROM call_status \n        WHERE call_state != 'HANGUP'\n        ORDER BY start_time DESC\n      `);\n      \n      return result.rows;\n    } finally {\n      await client.release();\n    }\n  }\n\n  /**\n   * Check if ESL is connected\n   */\n  isConnected(): boolean {\n    return this.connection !== null;\n  }\n\n  /**\n   * Disconnect from FreeSWITCH ESL\n   */\n  async disconnect(): Promise<void> {\n    this.isShuttingDown = true;\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.connection) {\n      this.connection.disconnect();\n      this.connection = null;\n      console.log('🔌 ESL disconnected');\n    }\n\n    this.emit('disconnected');\n  }\n}\n\n// Singleton instance\nlet eslServiceInstance: ESLService | null = null;\n\nexport function getESLService(): ESLService {\n  if (!eslServiceInstance) {\n    eslServiceInstance = new ESLService();\n  }\n  return eslServiceInstance;\n}\n\nexport async function initializeESLService(): Promise<void> {\n  const eslService = getESLService();\n  \n  // Only attempt connection if ESL is configured\n  if (process.env.FREESWITCH_ESL_HOST) {\n    try {\n      await eslService.connect();\n    } catch (error) {\n      console.error('❌ Failed to initialize ESL service:', error);\n      console.warn('⚠️ ESL service will retry connection in background');\n    }\n  } else {\n    console.warn('⚠️ FREESWITCH_ESL_HOST not configured, ESL service will not connect');\n  }\n}\n","size_bytes":13306},"packages/backend/scripts/seed-master-tenant.ts":{"content":"import { Pool } from 'pg';\nimport * as bcrypt from 'bcryptjs';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL\n});\n\nasync function seedMasterTenant() {\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n\n    console.log('👑 Seeding master tenant edgvoip...');\n\n    // 1. Create or update edgvoip master tenant\n    const tenantResult = await client.query(`\n      INSERT INTO tenants (id, name, slug, domain, sip_domain, status)\n      VALUES (\n        gen_random_uuid(),\n        'EdgeVoIP Master',\n        'edgvoip',\n        'edgvoip.edgvoip.it',\n        'edgvoip.edgvoip.it',\n        'active'\n      )\n      ON CONFLICT (slug) \n      DO UPDATE SET \n        name = EXCLUDED.name,\n        domain = EXCLUDED.domain,\n        sip_domain = EXCLUDED.sip_domain,\n        status = EXCLUDED.status\n      RETURNING id\n    `);\n\n    const tenantId = tenantResult.rows[0].id;\n    console.log(`✅ Master tenant edgvoip created/updated: ${tenantId}`);\n\n    // 2. Create super admin user\n    console.log('👤 Creating super admin user...');\n    \n    const hashedPassword = await bcrypt.hash('admin123', 10);\n    \n    await client.query(`\n      INSERT INTO users (\n        id, tenant_id, email, password_hash, first_name, last_name, role, status\n      )\n      VALUES (\n        gen_random_uuid(),\n        $1,\n        'admin@edgvoip.it',\n        $2,\n        'Super',\n        'Administrator',\n        'super_admin',\n        'active'\n      )\n      ON CONFLICT (email)\n      DO UPDATE SET\n        password_hash = EXCLUDED.password_hash,\n        role = 'super_admin',\n        status = EXCLUDED.status\n    `, [tenantId, hashedPassword]);\n\n    console.log('✅ Super admin user created/updated');\n\n    // 3. Create master tenant extensions for testing\n    console.log('📞 Creating master tenant extensions...');\n    \n    await client.query(`\n      INSERT INTO extensions (id, tenant_id, extension, password, display_name, status)\n      VALUES \n        (gen_random_uuid(), $1, '1000', 'master123', 'Master Extension 1000', 'active'),\n        (gen_random_uuid(), $1, '1001', 'master123', 'Master Extension 1001', 'active')\n      ON CONFLICT (extension, tenant_id) \n      DO UPDATE SET \n        password = EXCLUDED.password,\n        display_name = EXCLUDED.display_name,\n        status = EXCLUDED.status\n    `, [tenantId]);\n\n    console.log('✅ Master tenant extensions created/updated');\n\n    await client.query('COMMIT');\n    \n    console.log('');\n    console.log('🎉 Master tenant edgvoip seeded successfully!');\n    console.log('');\n    console.log('📋 Summary:');\n    console.log(`   Tenant: edgvoip (edgvoip.edgvoip.it)`);\n    console.log(`   Super Admin: admin@edgvoip.it (password: admin123)`);\n    console.log(`   Extensions: 1000, 1001 (password: master123)`);\n    console.log('');\n    console.log('⚠️  SECURITY WARNING:');\n    console.log('   Please change the super admin password after first login!');\n    console.log('');\n\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('❌ Error seeding master tenant:', error);\n    throw error;\n  } finally {\n    client.release();\n    await pool.end();\n  }\n}\n\n// Run seeding\nseedMasterTenant()\n  .then(() => {\n    console.log('✅ Seeding completed');\n    process.exit(0);\n  })\n  .catch((error) => {\n    console.error('❌ Seeding failed:', error);\n    process.exit(1);\n  });\n","size_bytes":3443},"voip-system/packages/backend/dist/routes/freeswitch-xml.routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=freeswitch-xml.routes.d.ts.map","size_bytes":140},"voip-system/packages/backend/dist/routes/cdr-activity-routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=cdr-activity-routes.d.ts.map","size_bytes":138},"voip-system/packages/backend/dist/routes/cdr.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=cdr.d.ts.map","size_bytes":122},"voip-system/packages/backend/dist/routes/stores.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=stores.d.ts.map","size_bytes":125},"voip-system/packages/backend/dist/routes/webhooks.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=webhooks.d.ts.map","size_bytes":127},"voip-system/packages/backend/dist/routes/voip-routes.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = require(\"express\");\nconst voip_service_1 = require(\"../services/voip-service\");\nconst tenant_context_1 = require(\"../middleware/tenant-context\");\n// import { \n//   InboundRoute, \n//   OutboundRoute, \n//   TimeCondition, \n//   IvrMenu, \n//   RingGroup, \n//   Queue, \n//   ConferenceRoom, \n//   VoicemailBox,\n//   SipExtensionConfig,\n//   SipTrunkConfig,\n//   OpenSipsRoute\n// } from '@w3-voip/shared';\nconst router = (0, express_1.Router)();\n// Apply tenant context middleware to all VoIP routes\nrouter.use(tenant_context_1.tenantContextMiddleware);\n// Initialize VoIP Service with configuration\nconst voipService = new voip_service_1.VoipService({\n    host: process.env.FREESWITCH_HOST || '192.168.172.234',\n    port: parseInt(process.env.FREESWITCH_PORT || '8021'),\n    password: process.env.FREESWITCH_PASSWORD || 'ClueCon',\n    context: process.env.FREESWITCH_CONTEXT || 'default'\n}, {\n    host: process.env.OPENSIPS_HOST || '192.168.172.234',\n    port: parseInt(process.env.OPENSIPS_PORT || '5060'),\n    database: {\n        host: process.env.OPENSIPS_DB_HOST || '192.168.172.234',\n        port: parseInt(process.env.OPENSIPS_DB_PORT || '5432'),\n        name: process.env.OPENSIPS_DB_NAME || 'opensips',\n        user: process.env.OPENSIPS_DB_USER || 'opensips',\n        password: process.env.OPENSIPS_DB_PASSWORD || 'opensips'\n    }\n}, {\n    host: process.env.FUSIONPBX_HOST || '192.168.172.234',\n    port: parseInt(process.env.FUSIONPBX_PORT || '80'),\n    database: {\n        host: process.env.FUSIONPBX_DB_HOST || '192.168.172.234',\n        port: parseInt(process.env.FUSIONPBX_DB_PORT || '5432'),\n        name: process.env.FUSIONPBX_DB_NAME || 'fusionpbx',\n        user: process.env.FUSIONPBX_DB_USER || 'fusionpbx',\n        password: process.env.FUSIONPBX_DB_PASSWORD || 'fusionpbx'\n    }\n});\n// ===== INBOUND ROUTES =====\nrouter.post('/inbound-routes', async (req, res) => {\n    try {\n        const route = req.body;\n        const createdRoute = await voipService.createInboundRoute(req.tenantContext, route);\n        res.status(201).json(createdRoute);\n    }\n    catch (error) {\n        console.error('Error creating inbound route:', error);\n        res.status(500).json({ error: 'Failed to create inbound route' });\n    }\n});\nrouter.get('/inbound-routes', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const routes = await voipService.getInboundRoutes(tenantId);\n        res.json(routes);\n    }\n    catch (error) {\n        console.error('Error fetching inbound routes:', error);\n        res.status(500).json({ error: 'Failed to fetch inbound routes' });\n    }\n});\nrouter.get('/inbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        // TODO: Implement get inbound route by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching inbound route:', error);\n        res.status(500).json({ error: 'Failed to fetch inbound route' });\n    }\n});\nrouter.put('/inbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const route = req.body;\n        const updatedRoute = await voipService.updateInboundRoute(routeId, route);\n        res.json(updatedRoute);\n    }\n    catch (error) {\n        console.error('Error updating inbound route:', error);\n        res.status(500).json({ error: 'Failed to update inbound route' });\n    }\n});\nrouter.delete('/inbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        await voipService.deleteInboundRoute(routeId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting inbound route:', error);\n        res.status(500).json({ error: 'Failed to delete inbound route' });\n    }\n});\n// ===== OUTBOUND ROUTES =====\nrouter.post('/outbound-routes', async (req, res) => {\n    try {\n        const route = req.body;\n        const createdRoute = await voipService.createOutboundRoute(req.tenantContext, route);\n        res.status(201).json(createdRoute);\n    }\n    catch (error) {\n        console.error('Error creating outbound route:', error);\n        res.status(500).json({ error: 'Failed to create outbound route' });\n    }\n});\nrouter.get('/outbound-routes', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const routes = await voipService.getOutboundRoutes(tenantId);\n        res.json(routes);\n    }\n    catch (error) {\n        console.error('Error fetching outbound routes:', error);\n        res.status(500).json({ error: 'Failed to fetch outbound routes' });\n    }\n});\nrouter.get('/outbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        // TODO: Implement get outbound route by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching outbound route:', error);\n        res.status(500).json({ error: 'Failed to fetch outbound route' });\n    }\n});\nrouter.put('/outbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const route = req.body;\n        const updatedRoute = await voipService.updateOutboundRoute(routeId, route);\n        res.json(updatedRoute);\n    }\n    catch (error) {\n        console.error('Error updating outbound route:', error);\n        res.status(500).json({ error: 'Failed to update outbound route' });\n    }\n});\nrouter.delete('/outbound-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        await voipService.deleteOutboundRoute(routeId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting outbound route:', error);\n        res.status(500).json({ error: 'Failed to delete outbound route' });\n    }\n});\n// ===== TIME CONDITIONS =====\nrouter.post('/time-conditions', async (req, res) => {\n    try {\n        const condition = req.body;\n        const createdCondition = await voipService.createTimeCondition(req.tenantContext, condition);\n        res.status(201).json(createdCondition);\n    }\n    catch (error) {\n        console.error('Error creating time condition:', error);\n        res.status(500).json({ error: 'Failed to create time condition' });\n    }\n});\nrouter.get('/time-conditions', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const conditions = await voipService.getTimeConditions(tenantId);\n        res.json(conditions);\n    }\n    catch (error) {\n        console.error('Error fetching time conditions:', error);\n        res.status(500).json({ error: 'Failed to fetch time conditions' });\n    }\n});\nrouter.get('/time-conditions/:id', async (req, res) => {\n    try {\n        const conditionId = req.params.id;\n        // TODO: Implement get time condition by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching time condition:', error);\n        res.status(500).json({ error: 'Failed to fetch time condition' });\n    }\n});\nrouter.put('/time-conditions/:id', async (req, res) => {\n    try {\n        const conditionId = req.params.id;\n        const condition = req.body;\n        const updatedCondition = await voipService.updateTimeCondition(conditionId, condition);\n        res.json(updatedCondition);\n    }\n    catch (error) {\n        console.error('Error updating time condition:', error);\n        res.status(500).json({ error: 'Failed to update time condition' });\n    }\n});\nrouter.delete('/time-conditions/:id', async (req, res) => {\n    try {\n        const conditionId = req.params.id;\n        await voipService.deleteTimeCondition(conditionId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting time condition:', error);\n        res.status(500).json({ error: 'Failed to delete time condition' });\n    }\n});\n// ===== IVR MENUS =====\nrouter.post('/ivr-menus', async (req, res) => {\n    try {\n        const menu = req.body;\n        const createdMenu = await voipService.createIvrMenu(req.tenantContext, menu);\n        res.status(201).json(createdMenu);\n    }\n    catch (error) {\n        console.error('Error creating IVR menu:', error);\n        res.status(500).json({ error: 'Failed to create IVR menu' });\n    }\n});\nrouter.get('/ivr-menus', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const menus = await voipService.getIvrMenus(tenantId);\n        res.json(menus);\n    }\n    catch (error) {\n        console.error('Error fetching IVR menus:', error);\n        res.status(500).json({ error: 'Failed to fetch IVR menus' });\n    }\n});\nrouter.get('/ivr-menus/:id', async (req, res) => {\n    try {\n        const menuId = req.params.id;\n        // TODO: Implement get IVR menu by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching IVR menu:', error);\n        res.status(500).json({ error: 'Failed to fetch IVR menu' });\n    }\n});\nrouter.put('/ivr-menus/:id', async (req, res) => {\n    try {\n        const menuId = req.params.id;\n        const menu = req.body;\n        const updatedMenu = await voipService.updateIvrMenu(menuId, menu);\n        res.json(updatedMenu);\n    }\n    catch (error) {\n        console.error('Error updating IVR menu:', error);\n        res.status(500).json({ error: 'Failed to update IVR menu' });\n    }\n});\nrouter.delete('/ivr-menus/:id', async (req, res) => {\n    try {\n        const menuId = req.params.id;\n        await voipService.deleteIvrMenu(menuId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting IVR menu:', error);\n        res.status(500).json({ error: 'Failed to delete IVR menu' });\n    }\n});\n// ===== RING GROUPS =====\nrouter.post('/ring-groups', async (req, res) => {\n    try {\n        const group = req.body;\n        const createdGroup = await voipService.createRingGroup(req.tenantContext, group);\n        res.status(201).json(createdGroup);\n    }\n    catch (error) {\n        console.error('Error creating ring group:', error);\n        res.status(500).json({ error: 'Failed to create ring group' });\n    }\n});\nrouter.get('/ring-groups', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const groups = await voipService.getRingGroups(tenantId);\n        res.json(groups);\n    }\n    catch (error) {\n        console.error('Error fetching ring groups:', error);\n        res.status(500).json({ error: 'Failed to fetch ring groups' });\n    }\n});\nrouter.get('/ring-groups/:id', async (req, res) => {\n    try {\n        const groupId = req.params.id;\n        // TODO: Implement get ring group by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching ring group:', error);\n        res.status(500).json({ error: 'Failed to fetch ring group' });\n    }\n});\nrouter.put('/ring-groups/:id', async (req, res) => {\n    try {\n        const groupId = req.params.id;\n        const group = req.body;\n        const updatedGroup = await voipService.updateRingGroup(groupId, group);\n        res.json(updatedGroup);\n    }\n    catch (error) {\n        console.error('Error updating ring group:', error);\n        res.status(500).json({ error: 'Failed to update ring group' });\n    }\n});\nrouter.delete('/ring-groups/:id', async (req, res) => {\n    try {\n        const groupId = req.params.id;\n        await voipService.deleteRingGroup(groupId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting ring group:', error);\n        res.status(500).json({ error: 'Failed to delete ring group' });\n    }\n});\n// ===== QUEUES =====\nrouter.post('/queues', async (req, res) => {\n    try {\n        const queue = req.body;\n        const createdQueue = await voipService.createQueue(req.tenantContext, queue);\n        res.status(201).json(createdQueue);\n    }\n    catch (error) {\n        console.error('Error creating queue:', error);\n        res.status(500).json({ error: 'Failed to create queue' });\n    }\n});\nrouter.get('/queues', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const queues = await voipService.getQueues(tenantId);\n        res.json(queues);\n    }\n    catch (error) {\n        console.error('Error fetching queues:', error);\n        res.status(500).json({ error: 'Failed to fetch queues' });\n    }\n});\nrouter.get('/queues/:id', async (req, res) => {\n    try {\n        const queueId = req.params.id;\n        // TODO: Implement get queue by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching queue:', error);\n        res.status(500).json({ error: 'Failed to fetch queue' });\n    }\n});\nrouter.put('/queues/:id', async (req, res) => {\n    try {\n        const queueId = req.params.id;\n        const queue = req.body;\n        const updatedQueue = await voipService.updateQueue(queueId, queue);\n        res.json(updatedQueue);\n    }\n    catch (error) {\n        console.error('Error updating queue:', error);\n        res.status(500).json({ error: 'Failed to update queue' });\n    }\n});\nrouter.delete('/queues/:id', async (req, res) => {\n    try {\n        const queueId = req.params.id;\n        await voipService.deleteQueue(queueId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting queue:', error);\n        res.status(500).json({ error: 'Failed to delete queue' });\n    }\n});\n// ===== CONFERENCE ROOMS =====\nrouter.post('/conference-rooms', async (req, res) => {\n    try {\n        const room = req.body;\n        const createdRoom = await voipService.createConferenceRoom(req.tenantContext, room);\n        res.status(201).json(createdRoom);\n    }\n    catch (error) {\n        console.error('Error creating conference room:', error);\n        res.status(500).json({ error: 'Failed to create conference room' });\n    }\n});\nrouter.get('/conference-rooms', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const rooms = await voipService.getConferenceRooms(tenantId);\n        res.json(rooms);\n    }\n    catch (error) {\n        console.error('Error fetching conference rooms:', error);\n        res.status(500).json({ error: 'Failed to fetch conference rooms' });\n    }\n});\nrouter.get('/conference-rooms/:id', async (req, res) => {\n    try {\n        const roomId = req.params.id;\n        // TODO: Implement get conference room by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching conference room:', error);\n        res.status(500).json({ error: 'Failed to fetch conference room' });\n    }\n});\nrouter.put('/conference-rooms/:id', async (req, res) => {\n    try {\n        const roomId = req.params.id;\n        const room = req.body;\n        const updatedRoom = await voipService.updateConferenceRoom(roomId, room);\n        res.json(updatedRoom);\n    }\n    catch (error) {\n        console.error('Error updating conference room:', error);\n        res.status(500).json({ error: 'Failed to update conference room' });\n    }\n});\nrouter.delete('/conference-rooms/:id', async (req, res) => {\n    try {\n        const roomId = req.params.id;\n        await voipService.deleteConferenceRoom(roomId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting conference room:', error);\n        res.status(500).json({ error: 'Failed to delete conference room' });\n    }\n});\n// ===== VOICEMAIL BOXES =====\nrouter.post('/voicemail-boxes', async (req, res) => {\n    try {\n        const box = req.body;\n        const createdBox = await voipService.createVoicemailBox(req.tenantContext, box);\n        res.status(201).json(createdBox);\n    }\n    catch (error) {\n        console.error('Error creating voicemail box:', error);\n        res.status(500).json({ error: 'Failed to create voicemail box' });\n    }\n});\nrouter.get('/voicemail-boxes', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const boxes = await voipService.getVoicemailBoxes(tenantId);\n        res.json(boxes);\n    }\n    catch (error) {\n        console.error('Error fetching voicemail boxes:', error);\n        res.status(500).json({ error: 'Failed to fetch voicemail boxes' });\n    }\n});\nrouter.get('/voicemail-boxes/:id', async (req, res) => {\n    try {\n        const boxId = req.params.id;\n        // TODO: Implement get voicemail box by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching voicemail box:', error);\n        res.status(500).json({ error: 'Failed to fetch voicemail box' });\n    }\n});\nrouter.put('/voicemail-boxes/:id', async (req, res) => {\n    try {\n        const boxId = req.params.id;\n        const box = req.body;\n        const updatedBox = await voipService.updateVoicemailBox(boxId, box);\n        res.json(updatedBox);\n    }\n    catch (error) {\n        console.error('Error updating voicemail box:', error);\n        res.status(500).json({ error: 'Failed to update voicemail box' });\n    }\n});\nrouter.delete('/voicemail-boxes/:id', async (req, res) => {\n    try {\n        const boxId = req.params.id;\n        await voipService.deleteVoicemailBox(boxId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting voicemail box:', error);\n        res.status(500).json({ error: 'Failed to delete voicemail box' });\n    }\n});\n// ===== SIP EXTENSIONS =====\nrouter.post('/sip-extensions', async (req, res) => {\n    try {\n        const extension = req.body;\n        const createdExtension = await voipService.createSipExtension(req.tenantContext, extension);\n        res.status(201).json(createdExtension);\n    }\n    catch (error) {\n        console.error('Error creating SIP extension:', error);\n        res.status(500).json({ error: 'Failed to create SIP extension' });\n    }\n});\nrouter.get('/sip-extensions', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const extensions = await voipService.getSipExtensions(tenantId);\n        res.json(extensions);\n    }\n    catch (error) {\n        console.error('Error fetching SIP extensions:', error);\n        res.status(500).json({ error: 'Failed to fetch SIP extensions' });\n    }\n});\nrouter.get('/sip-extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        // TODO: Implement get SIP extension by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching SIP extension:', error);\n        res.status(500).json({ error: 'Failed to fetch SIP extension' });\n    }\n});\nrouter.put('/sip-extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        const extension = req.body;\n        const updatedExtension = await voipService.updateSipExtension(extensionId, extension);\n        res.json(updatedExtension);\n    }\n    catch (error) {\n        console.error('Error updating SIP extension:', error);\n        res.status(500).json({ error: 'Failed to update SIP extension' });\n    }\n});\nrouter.delete('/sip-extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        await voipService.deleteSipExtension(extensionId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting SIP extension:', error);\n        res.status(500).json({ error: 'Failed to delete SIP extension' });\n    }\n});\n// ===== SIP TRUNKS =====\nrouter.post('/sip-trunks', async (req, res) => {\n    try {\n        const trunk = req.body;\n        const createdTrunk = await voipService.createSipTrunk(req.tenantContext, trunk);\n        res.status(201).json(createdTrunk);\n    }\n    catch (error) {\n        console.error('Error creating SIP trunk:', error);\n        res.status(500).json({ error: 'Failed to create SIP trunk' });\n    }\n});\nrouter.get('/sip-trunks', async (req, res) => {\n    try {\n        // tenant_id is automatically available from tenantContext\n        const tenantId = req.tenantContext.tenant_id;\n        const trunks = await voipService.getSipTrunks(tenantId);\n        res.json({\n            success: true,\n            data: trunks,\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error fetching SIP trunks:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Failed to fetch SIP trunks',\n            timestamp: new Date().toISOString()\n        });\n    }\n});\nrouter.get('/sip-trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        // TODO: Implement get SIP trunk by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching SIP trunk:', error);\n        res.status(500).json({ error: 'Failed to fetch SIP trunk' });\n    }\n});\nrouter.put('/sip-trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        const trunk = req.body;\n        const updatedTrunk = await voipService.updateSipTrunk(trunkId, trunk);\n        res.json(updatedTrunk);\n    }\n    catch (error) {\n        console.error('Error updating SIP trunk:', error);\n        res.status(500).json({ error: 'Failed to update SIP trunk' });\n    }\n});\nrouter.delete('/sip-trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        await voipService.deleteSipTrunk(trunkId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting SIP trunk:', error);\n        res.status(500).json({ error: 'Failed to delete SIP trunk' });\n    }\n});\n// ===== OPENSIPS ROUTES =====\nrouter.post('/opensips-routes', async (req, res) => {\n    try {\n        const route = req.body;\n        const createdRoute = await voipService.createOpenSipsRoute(route);\n        res.status(201).json(createdRoute);\n    }\n    catch (error) {\n        console.error('Error creating OpenSIPS route:', error);\n        res.status(500).json({ error: 'Failed to create OpenSIPS route' });\n    }\n});\nrouter.get('/opensips-routes', async (req, res) => {\n    try {\n        const tenantId = req.query.tenant_id;\n        // TODO: Implement get OpenSIPS routes from database\n        res.json([]);\n    }\n    catch (error) {\n        console.error('Error fetching OpenSIPS routes:', error);\n        res.status(500).json({ error: 'Failed to fetch OpenSIPS routes' });\n    }\n});\nrouter.get('/opensips-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        // TODO: Implement get OpenSIPS route by ID from database\n        res.json({});\n    }\n    catch (error) {\n        console.error('Error fetching OpenSIPS route:', error);\n        res.status(500).json({ error: 'Failed to fetch OpenSIPS route' });\n    }\n});\nrouter.put('/opensips-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const route = req.body;\n        const updatedRoute = await voipService.updateOpenSipsRoute(routeId, route);\n        res.json(updatedRoute);\n    }\n    catch (error) {\n        console.error('Error updating OpenSIPS route:', error);\n        res.status(500).json({ error: 'Failed to update OpenSIPS route' });\n    }\n});\nrouter.delete('/opensips-routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        await voipService.deleteOpenSipsRoute(routeId);\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting OpenSIPS route:', error);\n        res.status(500).json({ error: 'Failed to delete OpenSIPS route' });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=voip-routes.js.map","size_bytes":24370},"voip-system/packages/backend/dist/index.d.ts":{"content":"import { Server as SocketIOServer } from 'socket.io';\ndeclare const app: import(\"express-serve-static-core\").Express;\ndeclare const server: import(\"http\").Server<typeof import(\"http\").IncomingMessage, typeof import(\"http\").ServerResponse>;\ndeclare const io: SocketIOServer<import(\"socket.io\").DefaultEventsMap, import(\"socket.io\").DefaultEventsMap, import(\"socket.io\").DefaultEventsMap, any>;\nexport { app, server, io };\n//# sourceMappingURL=index.d.ts.map","size_bytes":456},"voip-system/packages/backend/dist/index-simple.d.ts":{"content":"declare const app: import(\"express-serve-static-core\").Express;\nexport default app;\n//# sourceMappingURL=index-simple.d.ts.map","size_bytes":126},"voip-system/packages/backend/dist/index-simple.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = __importDefault(require(\"express\"));\nconst cors_1 = __importDefault(require(\"cors\"));\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\nconst express_2 = require(\"express\");\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\nconst voip_routes_1 = __importDefault(require(\"./routes/voip-routes\"));\nconst sip_test_routes_1 = __importDefault(require(\"./routes/sip-test-routes\"));\nconst w3_voip_routes_1 = __importDefault(require(\"./routes/w3-voip-routes\"));\nconst cdr_activity_routes_1 = __importDefault(require(\"./routes/cdr-activity-routes\"));\nconst logs_1 = __importDefault(require(\"./routes/logs\"));\nconst sip_trunks_1 = __importDefault(require(\"./routes/sip-trunks\"));\n// Load environment variables\ndotenv_1.default.config();\nconst app = (0, express_1.default)();\nconst PORT = process.env.API_PORT || 3000;\nconst JWT_SECRET = process.env.JWT_SECRET || 'edg-voip-secret-key-2024';\n// Middleware\napp.use((0, cors_1.default)({\n    origin: process.env.CORS_ORIGIN || ['http://localhost:5173', 'http://localhost:5174', 'http://localhost:5175'],\n    credentials: true\n}));\napp.use((0, express_2.json)());\n// Test users with different roles\nconst testUsers = [\n    {\n        email: 'superadmin@edgvoip.local',\n        password: 'superadmin123',\n        id: '1',\n        name: 'Super Administrator',\n        role: 'super_admin',\n        tenant_id: 'bfb2e4dc-55f4-4240-8c7d-0fc8c7ecadd8'\n    },\n    {\n        email: 'tenantadmin@edgvoip.local',\n        password: 'tenantadmin123',\n        id: '2',\n        name: 'Tenant Administrator',\n        role: 'tenant_admin',\n        tenant_id: 'bfb2e4dc-55f4-4240-8c7d-0fc8c7ecadd8'\n    },\n    {\n        email: 'user@edgvoip.local',\n        password: 'user123',\n        id: '3',\n        name: 'Regular User',\n        role: 'tenant_user',\n        tenant_id: 'bfb2e4dc-55f4-4240-8c7d-0fc8c7ecadd8'\n    }\n];\n// Simple authentication endpoint\napp.post('/api/auth/login', (req, res) => {\n    const { email, password } = req.body;\n    // Find user by credentials\n    const user = testUsers.find(u => u.email === email && u.password === password);\n    if (user) {\n        // Create a proper JWT token\n        const payload = {\n            id: user.id,\n            email: user.email,\n            name: user.name,\n            tenant_id: user.tenant_id,\n            role: user.role,\n            iat: Math.floor(Date.now() / 1000),\n            exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n        };\n        const token = jsonwebtoken_1.default.sign(payload, JWT_SECRET);\n        res.json({\n            success: true,\n            data: {\n                token,\n                user: {\n                    id: user.id,\n                    email: user.email,\n                    name: user.name,\n                    tenantId: user.tenant_id,\n                    role: user.role\n                }\n            },\n            message: 'Login successful'\n        });\n    }\n    else {\n        res.status(401).json({\n            success: false,\n            message: 'Invalid credentials'\n        });\n    }\n});\n// VoIP routes\napp.use('/api/voip', voip_routes_1.default);\n// SIP Test routes\napp.use('/api/sip-test', sip_test_routes_1.default);\n// W3 VoIP routes (CRUD for real database tables)\napp.use('/api/w3-voip', w3_voip_routes_1.default);\n// CDR and Activity Log routes\napp.use('/api/cdr-activity', cdr_activity_routes_1.default);\n// Logs routes\napp.use('/api/logs', logs_1.default);\n// SIP Trunks routes\napp.use('/api/sip-trunks', sip_trunks_1.default);\n// ===== MOCK ENDPOINTS (Database integration pending) =====\n// Stores endpoints\napp.get('/api/stores', (req, res) => {\n    res.json({\n        success: true,\n        data: [],\n        pagination: {\n            total: 0,\n            page: 1,\n            limit: 10,\n            totalPages: 0\n        }\n    });\n});\napp.get('/api/stores/:id', (req, res) => {\n    res.status(404).json({\n        success: false,\n        message: 'Store not found'\n    });\n});\napp.post('/api/stores', (req, res) => {\n    res.status(501).json({\n        success: false,\n        message: 'Store creation not yet implemented'\n    });\n});\n// Calls status endpoint\napp.get('/api/calls/status', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            freeswitch: {\n                connected: false,\n                message: 'FreeSWITCH integration pending'\n            },\n            timestamp: new Date().toISOString()\n        }\n    });\n});\n// Health check\napp.get('/api/health', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            version: '1.0.0'\n        }\n    });\n});\n// Helper function to generate SIP domain from tenant name\nfunction generateSipDomain(tenantName) {\n    return `${tenantName\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, '-')\n        .replace(/[^a-z0-9-]/g, '')}.edgvoip.local`;\n}\n// Helper function to validate SIP domain format\nfunction validateSipDomain(sipDomain) {\n    const regex = /^[a-z0-9-]+\\.edgvoip\\.local$/;\n    return regex.test(sipDomain) && sipDomain.length <= 253;\n}\n// Mock tenants data\nconst mockTenants = [\n    {\n        id: 'tenant-1',\n        name: 'Demo Tenant',\n        domain: 'demo.local',\n        sip_domain: 'demo-tenant.edgvoip.local',\n        edg_suite_id: 'demo-001',\n        created_at: new Date().toISOString()\n    }\n];\n// Mock API endpoints for testing\napp.get('/api/tenants', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            tenants: mockTenants\n        }\n    });\n});\n// Create tenant endpoint\napp.post('/api/tenants', (req, res) => {\n    const { name, domain, edg_suite_id } = req.body;\n    if (!name || !domain || !edg_suite_id) {\n        return res.status(400).json({\n            success: false,\n            message: 'Missing required fields: name, domain, edg_suite_id'\n        });\n    }\n    // Generate SIP domain\n    const sip_domain = generateSipDomain(name);\n    // Validate SIP domain format\n    if (!validateSipDomain(sip_domain)) {\n        return res.status(400).json({\n            success: false,\n            message: 'Invalid SIP domain format generated'\n        });\n    }\n    // Check for uniqueness (in production, check database)\n    const existingTenant = mockTenants.find(t => t.sip_domain === sip_domain);\n    if (existingTenant) {\n        return res.status(409).json({\n            success: false,\n            message: 'SIP domain already exists'\n        });\n    }\n    // Create new tenant\n    const newTenant = {\n        id: `tenant-${Date.now()}`,\n        name,\n        domain,\n        sip_domain,\n        edg_suite_id,\n        created_at: new Date().toISOString()\n    };\n    mockTenants.push(newTenant);\n    res.status(201).json({\n        success: true,\n        data: newTenant,\n        message: 'Tenant created successfully'\n    });\n});\napp.get('/api/stores', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            stores: [\n                {\n                    id: 'store-1',\n                    name: 'Demo Store',\n                    store_id: 'store-001',\n                    tenant_id: 'tenant-1',\n                    created_at: new Date().toISOString()\n                }\n            ]\n        }\n    });\n});\napp.get('/api/extensions', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            extensions: [\n                {\n                    id: 'ext-1',\n                    extension_number: '1001',\n                    name: 'Demo Extension',\n                    tenant_id: 'tenant-1',\n                    status: 'active',\n                    created_at: new Date().toISOString()\n                }\n            ]\n        }\n    });\n});\napp.get('/api/cdr', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            cdr: [\n                {\n                    id: 'cdr-1',\n                    call_uuid: 'call-123',\n                    caller_id_number: '+1234567890',\n                    destination_number: '+0987654321',\n                    start_time: new Date().toISOString(),\n                    duration: 120,\n                    hangup_cause: 'NORMAL_CLEARING',\n                    direction: 'outbound'\n                }\n            ]\n        }\n    });\n});\n// Start server\napp.listen(PORT, () => {\n    console.log(`🚀 W3 VoIP Backend running on http://localhost:${PORT}`);\n    console.log(`📊 Health check: http://localhost:${PORT}/api/health`);\n    console.log(`🔑 Login endpoint: http://localhost:${PORT}/api/auth/login`);\n});\nexports.default = app;\n//# sourceMappingURL=index-simple.js.map","size_bytes":8871},"voip-system/packages/backend/dist/routes/index.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst auth_routes_1 = __importDefault(require(\"./auth.routes\"));\nconst tenants_1 = __importDefault(require(\"./tenants\"));\nconst stores_1 = __importDefault(require(\"./stores\"));\nconst extensions_1 = __importDefault(require(\"./extensions\"));\nconst calls_1 = __importDefault(require(\"./calls\"));\nconst cdr_1 = __importDefault(require(\"./cdr\"));\nconst webhooks_1 = __importDefault(require(\"./webhooks\"));\nconst analytics_1 = __importDefault(require(\"./analytics\"));\nconst system_1 = __importDefault(require(\"./system\"));\nconst voip_1 = __importDefault(require(\"./voip\"));\nconst sip_trunks_1 = __importDefault(require(\"./sip-trunks\"));\nconst freeswitch_xml_routes_1 = __importDefault(require(\"./freeswitch-xml.routes\"));\nconst router = (0, express_1.Router)();\n// FreeSWITCH XML Curl endpoint (NO auth - internal FreeSWITCH call)\nrouter.use('/freeswitch', freeswitch_xml_routes_1.default);\n// API routes\nrouter.use('/', auth_routes_1.default); // Auth routes at root level (/:tenantSlug/login)\nrouter.use('/tenants', tenants_1.default);\nrouter.use('/stores', stores_1.default);\nrouter.use('/extensions', extensions_1.default);\nrouter.use('/calls', calls_1.default);\nrouter.use('/cdr', cdr_1.default);\nrouter.use('/webhooks', webhooks_1.default);\nrouter.use('/analytics', analytics_1.default);\nrouter.use('/voip', voip_1.default);\nrouter.use('/sip-trunks', sip_trunks_1.default);\nrouter.use('/', system_1.default);\n// Health check endpoint\nrouter.get('/health', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            version: process.env.npm_package_version || '1.0.0'\n        }\n    });\n});\nexports.default = router;\n//# sourceMappingURL=index.js.map","size_bytes":2005},"voip-system/packages/backend/dist/services/cdr-activity-service.d.ts":{"content":"export interface VoipCdr {\n    id: string;\n    tenant_id: string;\n    store_id?: string;\n    extension_id?: string;\n    trunk_id?: string;\n    call_uuid: string;\n    direction: 'inbound' | 'outbound' | 'internal';\n    caller_id: string;\n    called_id: string;\n    start_time: Date;\n    answer_time?: Date;\n    end_time?: Date;\n    duration: number;\n    bill_seconds: number;\n    disposition: 'ANSWERED' | 'NO_ANSWER' | 'BUSY' | 'FAILED';\n    hangup_cause: string;\n    recording_path?: string;\n    created_at: Date;\n}\nexport interface VoipActivityLog {\n    id: string;\n    tenant_id: string;\n    store_id?: string;\n    extension_id?: string;\n    trunk_id?: string;\n    action: string;\n    details: any;\n    timestamp: Date;\n    created_at: Date;\n}\nexport interface TenantContext {\n    tenant_id: string;\n    sip_domain: string;\n    store_id?: string;\n}\nexport interface CdrFilters {\n    tenant_id: string;\n    store_id?: string;\n    start_date?: string;\n    end_date?: string;\n    direction?: 'in' | 'out';\n    disposition?: 'ANSWERED' | 'NO_ANSWER' | 'BUSY' | 'FAILED';\n    ext_number?: string;\n    did_e164?: string;\n    limit?: number;\n    offset?: number;\n}\nexport interface ActivityLogFilters {\n    tenant_id: string;\n    actor?: string;\n    action?: 'create' | 'update' | 'delete' | 'provision' | 'sync';\n    target_type?: 'trunk' | 'did' | 'ext' | 'route' | 'policy';\n    target_id?: string;\n    status?: 'ok' | 'fail';\n    start_date?: string;\n    end_date?: string;\n    limit?: number;\n    offset?: number;\n}\nexport declare class CdrActivityService {\n    private mockCdrs;\n    private mockActivityLogs;\n    createCdr(cdrData: Partial<VoipCdr>): Promise<VoipCdr>;\n    getCdrs(filters: CdrFilters): Promise<{\n        cdrs: VoipCdr[];\n        total: number;\n    }>;\n    getCdrById(cdrId: string, tenantId: string): Promise<VoipCdr | null>;\n    getCdrStats(tenantId: string, storeId?: string, startDate?: string, endDate?: string): Promise<{\n        total_calls: number;\n        answered_calls: number;\n        missed_calls: number;\n        total_duration: number;\n        avg_duration: number;\n        by_direction: {\n            inbound: number;\n            outbound: number;\n        };\n        by_disposition: Record<string, number>;\n    }>;\n    createActivityLog(tenantContext: TenantContext, logData: {\n        actor: string;\n        action: 'create' | 'update' | 'delete' | 'provision' | 'sync';\n        target_type: 'trunk' | 'did' | 'ext' | 'route' | 'policy';\n        target_id: string;\n        status: 'ok' | 'fail';\n        details_json?: any;\n    }): Promise<VoipActivityLog>;\n    getActivityLogs(filters: ActivityLogFilters): Promise<{\n        logs: VoipActivityLog[];\n        total: number;\n    }>;\n    getActivityLogById(logId: string, tenantId: string): Promise<VoipActivityLog | null>;\n    getActivityStats(tenantId: string, startDate?: string, endDate?: string): Promise<{\n        total_actions: number;\n        successful_actions: number;\n        failed_actions: number;\n        by_action: Record<string, number>;\n        by_target_type: Record<string, number>;\n        by_actor: Record<string, number>;\n    }>;\n    generateMockData(tenantId: string, sipDomain: string): Promise<void>;\n}\n//# sourceMappingURL=cdr-activity-service.d.ts.map","size_bytes":3261},"voip-system/packages/backend/dist/services/cdr-activity-service.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CdrActivityService = void 0;\n// @ts-nocheck\nconst uuid_1 = require(\"uuid\");\nclass CdrActivityService {\n    constructor() {\n        // Mock database - in production this would be real database operations\n        this.mockCdrs = [];\n        this.mockActivityLogs = [];\n    }\n    // ===== VOIP CDR =====\n    async createCdr(cdrData) {\n        const cdr = {\n            id: (0, uuid_1.v4)(),\n            tenant_id: cdrData.tenant_id,\n            store_id: cdrData.store_id,\n            sip_domain: cdrData.sip_domain,\n            call_id: cdrData.call_id,\n            direction: cdrData.direction,\n            from_uri: cdrData.from_uri,\n            to_uri: cdrData.to_uri,\n            did_e164: cdrData.did_e164,\n            ext_number: cdrData.ext_number,\n            start_ts: cdrData.start_ts,\n            answer_ts: cdrData.answer_ts,\n            end_ts: cdrData.end_ts,\n            billsec: cdrData.billsec || 0,\n            disposition: cdrData.disposition,\n            recording_url: cdrData.recording_url,\n            meta_json: cdrData.meta_json\n        };\n        this.mockCdrs.push(cdr);\n        console.log(`Created CDR: ${cdr.call_id} for tenant: ${cdr.tenant_id}`);\n        return cdr;\n    }\n    async getCdrs(filters) {\n        let filteredCdrs = this.mockCdrs.filter(cdr => cdr.tenant_id === filters.tenant_id);\n        // Apply filters\n        if (filters.store_id) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.store_id === filters.store_id);\n        }\n        if (filters.direction) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.direction === filters.direction);\n        }\n        if (filters.disposition) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.disposition === filters.disposition);\n        }\n        if (filters.ext_number) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.ext_number === filters.ext_number);\n        }\n        if (filters.did_e164) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.did_e164 === filters.did_e164);\n        }\n        if (filters.start_date) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts >= filters.start_date);\n        }\n        if (filters.end_date) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts <= filters.end_date);\n        }\n        const total = filteredCdrs.length;\n        // Apply pagination\n        const offset = filters.offset || 0;\n        const limit = filters.limit || 100;\n        const paginatedCdrs = filteredCdrs.slice(offset, offset + limit);\n        return { cdrs: paginatedCdrs, total };\n    }\n    async getCdrById(cdrId, tenantId) {\n        return this.mockCdrs.find(cdr => cdr.id === cdrId && cdr.tenant_id === tenantId) || null;\n    }\n    async getCdrStats(tenantId, storeId, startDate, endDate) {\n        let filteredCdrs = this.mockCdrs.filter(cdr => cdr.tenant_id === tenantId);\n        if (storeId) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.store_id === storeId);\n        }\n        if (startDate) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts >= startDate);\n        }\n        if (endDate) {\n            filteredCdrs = filteredCdrs.filter(cdr => cdr.start_ts <= endDate);\n        }\n        const total_calls = filteredCdrs.length;\n        const answered_calls = filteredCdrs.filter(cdr => cdr.disposition === 'ANSWERED').length;\n        const missed_calls = total_calls - answered_calls;\n        const total_duration = filteredCdrs.reduce((sum, cdr) => sum + cdr.billsec, 0);\n        const avg_duration = total_calls > 0 ? total_duration / total_calls : 0;\n        const by_direction = {\n            inbound: filteredCdrs.filter(cdr => cdr.direction === 'in').length,\n            outbound: filteredCdrs.filter(cdr => cdr.direction === 'out').length\n        };\n        const by_disposition = filteredCdrs.reduce((acc, cdr) => {\n            acc[cdr.disposition] = (acc[cdr.disposition] || 0) + 1;\n            return acc;\n        }, {});\n        return {\n            total_calls,\n            answered_calls,\n            missed_calls,\n            total_duration,\n            avg_duration,\n            by_direction,\n            by_disposition\n        };\n    }\n    // ===== VOIP ACTIVITY LOG =====\n    async createActivityLog(tenantContext, logData) {\n        const log = {\n            id: (0, uuid_1.v4)(),\n            tenant_id: tenantContext.tenant_id,\n            actor: logData.actor,\n            action: logData.action,\n            target_type: logData.target_type,\n            target_id: logData.target_id,\n            status: logData.status,\n            details_json: logData.details_json,\n            ts: new Date().toISOString()\n        };\n        this.mockActivityLogs.push(log);\n        console.log(`Created activity log: ${log.action} ${log.target_type} for tenant: ${log.tenant_id}`);\n        return log;\n    }\n    async getActivityLogs(filters) {\n        let filteredLogs = this.mockActivityLogs.filter(log => log.tenant_id === filters.tenant_id);\n        // Apply filters\n        if (filters.actor) {\n            filteredLogs = filteredLogs.filter(log => log.actor.includes(filters.actor));\n        }\n        if (filters.action) {\n            filteredLogs = filteredLogs.filter(log => log.action === filters.action);\n        }\n        if (filters.target_type) {\n            filteredLogs = filteredLogs.filter(log => log.target_type === filters.target_type);\n        }\n        if (filters.target_id) {\n            filteredLogs = filteredLogs.filter(log => log.target_id === filters.target_id);\n        }\n        if (filters.status) {\n            filteredLogs = filteredLogs.filter(log => log.status === filters.status);\n        }\n        if (filters.start_date) {\n            filteredLogs = filteredLogs.filter(log => log.ts >= filters.start_date);\n        }\n        if (filters.end_date) {\n            filteredLogs = filteredLogs.filter(log => log.ts <= filters.end_date);\n        }\n        const total = filteredLogs.length;\n        // Apply pagination\n        const offset = filters.offset || 0;\n        const limit = filters.limit || 100;\n        const paginatedLogs = filteredLogs.slice(offset, offset + limit);\n        return { logs: paginatedLogs, total };\n    }\n    async getActivityLogById(logId, tenantId) {\n        return this.mockActivityLogs.find(log => log.id === logId && log.tenant_id === tenantId) || null;\n    }\n    async getActivityStats(tenantId, startDate, endDate) {\n        let filteredLogs = this.mockActivityLogs.filter(log => log.tenant_id === tenantId);\n        if (startDate) {\n            filteredLogs = filteredLogs.filter(log => log.ts >= startDate);\n        }\n        if (endDate) {\n            filteredLogs = filteredLogs.filter(log => log.ts <= endDate);\n        }\n        const total_actions = filteredLogs.length;\n        const successful_actions = filteredLogs.filter(log => log.status === 'ok').length;\n        const failed_actions = filteredLogs.filter(log => log.status === 'fail').length;\n        const by_action = filteredLogs.reduce((acc, log) => {\n            acc[log.action] = (acc[log.action] || 0) + 1;\n            return acc;\n        }, {});\n        const by_target_type = filteredLogs.reduce((acc, log) => {\n            acc[log.target_type] = (acc[log.target_type] || 0) + 1;\n            return acc;\n        }, {});\n        const by_actor = filteredLogs.reduce((acc, log) => {\n            acc[log.actor] = (acc[log.actor] || 0) + 1;\n            return acc;\n        }, {});\n        return {\n            total_actions,\n            successful_actions,\n            failed_actions,\n            by_action,\n            by_target_type,\n            by_actor\n        };\n    }\n    // ===== UTILITY METHODS =====\n    async generateMockData(tenantId, sipDomain) {\n        // Generate some mock CDRs\n        const mockCdrs = [\n            {\n                tenant_id: tenantId,\n                sip_domain: sipDomain,\n                call_id: 'call-001',\n                direction: 'inbound',\n                from_uri: '+390686356924',\n                to_uri: '1001',\n                did_e164: '+390686356924',\n                ext_number: '1001',\n                start_ts: new Date(Date.now() - 3600000).toISOString(),\n                answer_ts: new Date(Date.now() - 3595000).toISOString(),\n                end_ts: new Date(Date.now() - 3000000).toISOString(),\n                billsec: 600,\n                disposition: 'ANSWERED',\n                recording_url: 'https://recordings.example.com/call-001.wav',\n                meta_json: { codec: 'G729', mos: 4.2 }\n            },\n            {\n                tenant_id: tenantId,\n                sip_domain: sipDomain,\n                call_id: 'call-002',\n                direction: 'outbound',\n                from_uri: '1001',\n                to_uri: '+39061234567',\n                ext_number: '1001',\n                start_ts: new Date(Date.now() - 1800000).toISOString(),\n                end_ts: new Date(Date.now() - 1750000).toISOString(),\n                billsec: 0,\n                disposition: 'NO_ANSWER',\n                meta_json: { codec: 'G729' }\n            }\n        ];\n        for (const cdrData of mockCdrs) {\n            await this.createCdr(cdrData);\n        }\n        // Generate some mock activity logs\n        const mockLogs = [\n            {\n                actor: 'user:admin',\n                action: 'create',\n                target_type: 'trunk',\n                target_id: 'trunk-001',\n                status: 'ok',\n                details_json: { provider: 'Messagenet', proxy: 'sip.messagenet.it' }\n            },\n            {\n                actor: 'user:admin',\n                action: 'create',\n                target_type: 'ext',\n                target_id: 'ext-001',\n                status: 'ok',\n                details_json: { ext_number: '1001', display_name: 'John Doe' }\n            }\n        ];\n        for (const logData of mockLogs) {\n            await this.createActivityLog({ tenant_id: tenantId, sip_domain: sipDomain }, logData);\n        }\n        console.log(`Generated mock data for tenant: ${tenantId}`);\n    }\n}\nexports.CdrActivityService = CdrActivityService;\n//# sourceMappingURL=cdr-activity-service.js.map","size_bytes":10276},"voip-system/packages/backend/dist/middleware/auth.middleware.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.authenticateJWT = authenticateJWT;\nexports.requireSuperAdmin = requireSuperAdmin;\nexports.requireAdmin = requireAdmin;\nexports.requireTenantAccess = requireTenantAccess;\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\n/**\n * Middleware to authenticate JWT tokens\n */\nfunction authenticateJWT(req, res, next) {\n    const authHeader = req.headers.authorization;\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n    if (!token) {\n        return res.status(401).json({\n            success: false,\n            error: 'Access token required'\n        });\n    }\n    try {\n        const decoded = jsonwebtoken_1.default.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n        req.user = {\n            id: decoded.id,\n            email: decoded.email,\n            role: decoded.role,\n            tenant_id: decoded.tenant_id,\n            tenant_slug: decoded.tenant_slug\n        };\n        next();\n    }\n    catch (error) {\n        return res.status(403).json({\n            success: false,\n            error: 'Invalid or expired token'\n        });\n    }\n}\n/**\n * Middleware to require super admin role\n */\nfunction requireSuperAdmin(req, res, next) {\n    if (!req.user) {\n        return res.status(401).json({\n            success: false,\n            error: 'Authentication required'\n        });\n    }\n    if (req.user.role !== 'super_admin') {\n        return res.status(403).json({\n            success: false,\n            error: 'Super admin access required'\n        });\n    }\n    next();\n}\n/**\n * Middleware to require admin role (super admin or tenant admin)\n */\nfunction requireAdmin(req, res, next) {\n    if (!req.user) {\n        return res.status(401).json({\n            success: false,\n            error: 'Authentication required'\n        });\n    }\n    if (req.user.role !== 'super_admin' && req.user.role !== 'admin') {\n        return res.status(403).json({\n            success: false,\n            error: 'Admin access required'\n        });\n    }\n    next();\n}\n/**\n * Middleware to require tenant access (user must belong to the tenant)\n */\nfunction requireTenantAccess(req, res, next) {\n    if (!req.user) {\n        return res.status(401).json({\n            success: false,\n            error: 'Authentication required'\n        });\n    }\n    // Super admin can access any tenant\n    if (req.user.role === 'super_admin') {\n        return next();\n    }\n    // Regular users must belong to the tenant\n    const tenantId = req.params.tenantId || req.body.tenant_id;\n    if (req.user.tenant_id !== tenantId) {\n        return res.status(403).json({\n            success: false,\n            error: 'Access denied for this tenant'\n        });\n    }\n    next();\n}\n//# sourceMappingURL=auth.middleware.js.map","size_bytes":2972},"voip-system/packages/backend/dist/routes/sip-trunks.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=sip-trunks.d.ts.map","size_bytes":129},"voip-system/packages/backend/dist/routes/webhooks.js":{"content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = require(\"express\");\nconst zod_1 = require(\"zod\");\nconst cdr_service_1 = require(\"../services/cdr.service\");\nconst validation_1 = require(\"../middleware/validation\");\nconst response_1 = require(\"../utils/response\");\n// Removed unused import: logWebhookEvent\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst router = (0, express_1.Router)();\nconst cdrService = new cdr_service_1.CDRService();\n// Webhook signature validation\nconst validateWebhookSignature = (req, res, next) => {\n    const signature = req.headers['x-webhook-signature'];\n    const webhookSecret = process.env.WEBHOOK_SECRET || 'default-secret';\n    if (!signature) {\n        return (0, response_1.errorResponse)(res, 'Missing webhook signature', 401);\n    }\n    const payload = JSON.stringify(req.body);\n    const expectedSignature = crypto_1.default\n        .createHmac('sha256', webhookSecret)\n        .update(payload)\n        .digest('hex');\n    const providedSignature = signature.replace('sha256=', '');\n    if (!crypto_1.default.timingSafeEqual(Buffer.from(expectedSignature, 'hex'), Buffer.from(providedSignature, 'hex'))) {\n        return (0, response_1.errorResponse)(res, 'Invalid webhook signature', 401);\n    }\n    next();\n};\n// CDR webhook validation schema\nconst cdrWebhookSchema = zod_1.z.object({\n    event_name: zod_1.z.string(),\n    call_uuid: zod_1.z.string().uuid(),\n    tenant_domain: zod_1.z.string(),\n    store_id: zod_1.z.string().optional(),\n    extension_id: zod_1.z.string().uuid().optional(),\n    trunk_id: zod_1.z.string().uuid().optional(),\n    call_direction: zod_1.z.enum(['inbound', 'outbound', 'internal']),\n    call_type: zod_1.z.enum(['voice', 'video', 'fax']).default('voice'),\n    caller_id_number: zod_1.z.string().optional(),\n    caller_id_name: zod_1.z.string().optional(),\n    caller_extension: zod_1.z.string().optional(),\n    callee_id_number: zod_1.z.string().optional(),\n    callee_id_name: zod_1.z.string().optional(),\n    callee_extension: zod_1.z.string().optional(),\n    start_time: zod_1.z.string().datetime(),\n    answer_time: zod_1.z.string().datetime().optional(),\n    end_time: zod_1.z.string().datetime().optional(),\n    duration: zod_1.z.number().min(0).default(0),\n    bill_seconds: zod_1.z.number().min(0).default(0),\n    hangup_cause: zod_1.z.string().optional(),\n    hangup_disposition: zod_1.z.enum(['answered', 'no_answer', 'busy', 'failed', 'unknown']).default('unknown'),\n    audio_codec: zod_1.z.string().optional(),\n    video_codec: zod_1.z.string().optional(),\n    rtp_audio_in_mos: zod_1.z.number().min(1).max(5).optional(),\n    rtp_audio_out_mos: zod_1.z.number().min(1).max(5).optional(),\n    recording_enabled: zod_1.z.boolean().default(false),\n    recording_path: zod_1.z.string().optional(),\n    recording_duration: zod_1.z.number().min(0).optional(),\n    recording_consent: zod_1.z.boolean().optional(),\n    local_ip: zod_1.z.string().optional(),\n    remote_ip: zod_1.z.string().optional(),\n    local_port: zod_1.z.number().optional(),\n    remote_port: zod_1.z.number().optional(),\n    fs_uuid: zod_1.z.string(),\n    fs_domain: zod_1.z.string(),\n    fs_context: zod_1.z.string().optional(),\n    fs_profile: zod_1.z.string().optional(),\n    metadata: zod_1.z.record(zod_1.z.any()).optional(),\n    tags: zod_1.z.array(zod_1.z.string()).optional()\n});\n// Call event webhook validation schema\nconst callEventWebhookSchema = zod_1.z.object({\n    event_name: zod_1.z.string(),\n    call_uuid: zod_1.z.string().uuid(),\n    tenant_domain: zod_1.z.string(),\n    event_type: zod_1.z.enum(['call_started', 'call_answered', 'call_ended', 'call_transferred', 'recording_started', 'recording_stopped']),\n    timestamp: zod_1.z.string().datetime(),\n    data: zod_1.z.record(zod_1.z.any()).optional()\n});\n// CDR webhook endpoint\nrouter.post('/cdr', validateWebhookSignature, (0, validation_1.validateRequest)(cdrWebhookSchema), async (req, res) => {\n    try {\n        const cdrData = req.body;\n        logWebhookEvent('cdr_received', {\n            call_uuid: cdrData.call_uuid,\n            tenant_domain: cdrData.tenant_domain,\n            event_name: cdrData.event_name\n        });\n        // Find tenant by domain\n        const { getClient } = await Promise.resolve().then(() => __importStar(require('@w3-voip/database')));\n        const client = await getClient();\n        try {\n            const tenantResult = await client.query('SELECT id FROM tenants WHERE domain = $1', [cdrData.tenant_domain]);\n            if (tenantResult.rows.length === 0) {\n                logWebhookEvent('cdr_error', {\n                    call_uuid: cdrData.call_uuid,\n                    error: 'Tenant not found',\n                    tenant_domain: cdrData.tenant_domain\n                });\n                return (0, response_1.errorResponse)(res, 'Tenant not found', 404);\n            }\n            const tenantId = tenantResult.rows[0].id;\n            // Check if CDR already exists\n            const existingCDR = await cdrService.getCDRByCallUuid(cdrData.call_uuid, tenantId);\n            if (existingCDR) {\n                // Update existing CDR\n                const updates = {};\n                if (cdrData.answer_time)\n                    updates.answer_time = new Date(cdrData.answer_time);\n                if (cdrData.end_time)\n                    updates.end_time = new Date(cdrData.end_time);\n                if (cdrData.duration !== undefined)\n                    updates.duration = cdrData.duration;\n                if (cdrData.bill_seconds !== undefined)\n                    updates.bill_seconds = cdrData.bill_seconds;\n                if (cdrData.hangup_cause)\n                    updates.hangup_cause = cdrData.hangup_cause;\n                if (cdrData.hangup_disposition)\n                    updates.hangup_disposition = cdrData.hangup_disposition;\n                if (cdrData.audio_codec)\n                    updates.audio_codec = cdrData.audio_codec;\n                if (cdrData.video_codec)\n                    updates.video_codec = cdrData.video_codec;\n                if (cdrData.rtp_audio_in_mos)\n                    updates.rtp_audio_in_mos = cdrData.rtp_audio_in_mos;\n                if (cdrData.rtp_audio_out_mos)\n                    updates.rtp_audio_out_mos = cdrData.rtp_audio_out_mos;\n                if (cdrData.recording_enabled !== undefined)\n                    updates.recording_enabled = cdrData.recording_enabled;\n                if (cdrData.recording_path)\n                    updates.recording_path = cdrData.recording_path;\n                if (cdrData.recording_duration)\n                    updates.recording_duration = cdrData.recording_duration;\n                if (cdrData.recording_consent !== undefined)\n                    updates.recording_consent = cdrData.recording_consent;\n                if (cdrData.metadata)\n                    updates.metadata = cdrData.metadata;\n                if (cdrData.tags)\n                    updates.tags = cdrData.tags;\n                await cdrService.updateCDR(existingCDR.id, updates, tenantId);\n                logWebhookEvent('cdr_updated', {\n                    call_uuid: cdrData.call_uuid,\n                    tenant_id: tenantId,\n                    cdr_id: existingCDR.id\n                });\n            }\n            else {\n                // Create new CDR\n                const newCDRData = {\n                    tenant_id: tenantId,\n                    store_id: cdrData.store_id || undefined,\n                    extension_id: cdrData.extension_id || undefined,\n                    trunk_id: cdrData.trunk_id || undefined,\n                    call_uuid: cdrData.call_uuid,\n                    call_direction: cdrData.call_direction,\n                    call_type: cdrData.call_type,\n                    caller_id_number: cdrData.caller_id_number || undefined,\n                    caller_id_name: cdrData.caller_id_name || undefined,\n                    caller_extension: cdrData.caller_extension || undefined,\n                    callee_id_number: cdrData.callee_id_number || undefined,\n                    callee_id_name: cdrData.callee_id_name || undefined,\n                    callee_extension: cdrData.callee_extension || undefined,\n                    start_time: new Date(cdrData.start_time),\n                    answer_time: cdrData.answer_time ? new Date(cdrData.answer_time) : undefined,\n                    end_time: cdrData.end_time ? new Date(cdrData.end_time) : undefined,\n                    duration: cdrData.duration,\n                    bill_seconds: cdrData.bill_seconds,\n                    hangup_cause: cdrData.hangup_cause || undefined,\n                    hangup_disposition: cdrData.hangup_disposition,\n                    audio_codec: cdrData.audio_codec || undefined,\n                    video_codec: cdrData.video_codec || undefined,\n                    rtp_audio_in_mos: cdrData.rtp_audio_in_mos || undefined,\n                    rtp_audio_out_mos: cdrData.rtp_audio_out_mos || undefined,\n                    recording_enabled: cdrData.recording_enabled,\n                    recording_path: cdrData.recording_path || undefined,\n                    recording_duration: cdrData.recording_duration || undefined,\n                    recording_consent: cdrData.recording_consent || undefined,\n                    local_ip: cdrData.local_ip || undefined,\n                    remote_ip: cdrData.remote_ip || undefined,\n                    local_port: cdrData.local_port || undefined,\n                    remote_port: cdrData.remote_port || undefined,\n                    fs_uuid: cdrData.fs_uuid,\n                    fs_domain: cdrData.fs_domain,\n                    fs_context: cdrData.fs_context || undefined,\n                    fs_profile: cdrData.fs_profile || undefined,\n                    metadata: cdrData.metadata || undefined,\n                    tags: cdrData.tags || []\n                };\n                const cdr = await cdrService.createCDR(newCDRData);\n                logWebhookEvent('cdr_created', {\n                    call_uuid: cdrData.call_uuid,\n                    tenant_id: tenantId,\n                    cdr_id: cdr.id\n                });\n            }\n            (0, response_1.successResponse)(res, {\n                status: 'processed',\n                call_uuid: cdrData.call_uuid,\n                tenant_domain: cdrData.tenant_domain\n            });\n        }\n        finally {\n            await client.release();\n        }\n    }\n    catch (error) {\n        console.error('Error processing CDR webhook:', error);\n        logWebhookEvent('cdr_error', {\n            call_uuid: req.body.call_uuid,\n            error: error.message\n        });\n        (0, response_1.errorResponse)(res, 'Failed to process CDR webhook', 500);\n    }\n});\n// Call event webhook endpoint\nrouter.post('/call-event', validateWebhookSignature, (0, validation_1.validateRequest)(callEventWebhookSchema), async (req, res) => {\n    try {\n        const eventData = req.body;\n        logWebhookEvent('call_event_received', {\n            call_uuid: eventData.call_uuid,\n            tenant_domain: eventData.tenant_domain,\n            event_type: eventData.event_type\n        });\n        // Find tenant by domain\n        const { getClient } = await Promise.resolve().then(() => __importStar(require('@w3-voip/database')));\n        const client = await getClient();\n        try {\n            const tenantResult = await client.query('SELECT id FROM tenants WHERE domain = $1', [eventData.tenant_domain]);\n            if (tenantResult.rows.length === 0) {\n                logWebhookEvent('call_event_error', {\n                    call_uuid: eventData.call_uuid,\n                    error: 'Tenant not found',\n                    tenant_domain: eventData.tenant_domain\n                });\n                return (0, response_1.errorResponse)(res, 'Tenant not found', 404);\n            }\n            const tenantId = tenantResult.rows[0].id;\n            // Store call event in database (optional - for audit trail)\n            await client.query(`INSERT INTO call_events (\r\n            id, tenant_id, call_uuid, event_type, event_name, \r\n            timestamp, data, created_at\r\n          ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`, [\n                require('uuid').v4(),\n                tenantId,\n                eventData.call_uuid,\n                eventData.event_type,\n                eventData.event_name,\n                new Date(eventData.timestamp),\n                eventData.data ? JSON.stringify(eventData.data) : null\n            ]);\n            // Forward event to W3 Suite if configured\n            const w3SuiteWebhookUrl = process.env.W3_SUITE_WEBHOOK_URL;\n            if (w3SuiteWebhookUrl) {\n                try {\n                    const fetch = require('node-fetch');\n                    await fetch(w3SuiteWebhookUrl, {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json',\n                            'X-Webhook-Source': 'w3-voip',\n                            'X-Webhook-Signature': crypto_1.default\n                                .createHmac('sha256', process.env.W3_SUITE_WEBHOOK_SECRET || 'default-secret')\n                                .update(JSON.stringify(eventData))\n                                .digest('hex')\n                        },\n                        body: JSON.stringify({\n                            ...eventData,\n                            tenant_id: tenantId\n                        })\n                    });\n                    logWebhookEvent('call_event_forwarded', {\n                        call_uuid: eventData.call_uuid,\n                        tenant_id: tenantId,\n                        w3_suite_url: w3SuiteWebhookUrl\n                    });\n                }\n                catch (forwardError) {\n                    logWebhookEvent('call_event_forward_error', {\n                        call_uuid: eventData.call_uuid,\n                        tenant_id: tenantId,\n                        error: forwardError.message\n                    });\n                }\n            }\n            (0, response_1.successResponse)(res, {\n                status: 'processed',\n                call_uuid: eventData.call_uuid,\n                event_type: eventData.event_type,\n                tenant_domain: eventData.tenant_domain\n            });\n        }\n        finally {\n            await client.release();\n        }\n    }\n    catch (error) {\n        console.error('Error processing call event webhook:', error);\n        logWebhookEvent('call_event_error', {\n            call_uuid: req.body.call_uuid,\n            error: error.message\n        });\n        (0, response_1.errorResponse)(res, 'Failed to process call event webhook', 500);\n    }\n});\n// Health check endpoint for webhooks\nrouter.get('/health', (req, res) => {\n    (0, response_1.successResponse)(res, {\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        service: 'w3-voip-webhooks'\n    });\n});\n// Webhook configuration endpoint\nrouter.get('/config', (req, res) => {\n    const config = {\n        cdr_webhook_url: `${process.env.API_BASE_URL || 'http://192.168.172.234:3000'}/api/webhooks/cdr`,\n        call_event_webhook_url: `${process.env.API_BASE_URL || 'http://192.168.172.234:3000'}/api/webhooks/call-event`,\n        supported_events: [\n            'CHANNEL_CREATE',\n            'CHANNEL_ANSWER',\n            'CHANNEL_HANGUP',\n            'CHANNEL_BRIDGE',\n            'RECORD_START',\n            'RECORD_STOP'\n        ],\n        authentication: {\n            type: 'hmac_sha256',\n            header: 'X-Webhook-Signature'\n        }\n    };\n    (0, response_1.successResponse)(res, config);\n});\nexports.default = router;\n//# sourceMappingURL=webhooks.js.map","size_bytes":17330},"voip-system/packages/backend/dist/routes/auth.routes.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = __importDefault(require(\"express\"));\nconst bcrypt_1 = __importDefault(require(\"bcrypt\"));\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\nconst database_1 = require(\"@w3-voip/database\");\nconst tenant_middleware_1 = require(\"../middleware/tenant.middleware\");\nconst router = express_1.default.Router();\n/**\n * Super admin login: POST /superadmin/login\n * Authenticates super admin users (no tenant validation)\n */\nrouter.post('/superadmin/login', async (req, res) => {\n    console.log('🚀 SUPER ADMIN LOGIN ROUTE REACHED!');\n    console.log('Super admin login request body:', JSON.stringify(req.body));\n    const { email, password } = req.body;\n    if (!email || !password) {\n        console.log('❌ Missing email or password');\n        return res.status(400).json({\n            success: false,\n            error: 'Email and password are required'\n        });\n    }\n    try {\n        console.log(`🔍 Looking for super admin user: email=${email}, role=super_admin, status=active`);\n        const client = await (0, database_1.getClient)();\n        const result = await client.query('SELECT * FROM users WHERE email = $1 AND role = $2 AND status = $3', [email, 'super_admin', 'active']);\n        console.log(`📊 Query result: ${result.rows.length} users found`);\n        if (result.rows.length === 0) {\n            console.log('❌ No super admin user found');\n            return res.status(401).json({\n                success: false,\n                error: 'Invalid credentials'\n            });\n        }\n        const user = result.rows[0];\n        console.log(`👤 User found: ${user.email}, role: ${user.role}`);\n        console.log(`🔐 Password hash: ${user.password_hash.substring(0, 20)}...`);\n        const passwordValid = await bcrypt_1.default.compare(password, user.password_hash);\n        console.log(`🔑 Password validation result: ${passwordValid}`);\n        if (!passwordValid) {\n            console.log('❌ Password validation failed');\n            return res.status(401).json({\n                success: false,\n                error: 'Invalid credentials'\n            });\n        }\n        // Create JWT token for super admin with 8 hours session timeout\n        const token = jsonwebtoken_1.default.sign({\n            id: user.id,\n            email: user.email,\n            role: user.role,\n            iat: Math.floor(Date.now() / 1000),\n            exp: Math.floor(Date.now() / 1000) + (8 * 60 * 60) // 8 hours session timeout\n        }, process.env.JWT_SECRET || 'fallback-secret');\n        res.json({\n            success: true,\n            data: {\n                token,\n                user: {\n                    id: user.id,\n                    email: user.email,\n                    firstName: user.first_name,\n                    lastName: user.last_name,\n                    role: user.role\n                }\n            },\n            message: 'Super admin login successful'\n        });\n    }\n    catch (error) {\n        console.error('Super admin login error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Tenant-scoped login: POST /:tenantSlug/login\n * Validates tenant slug and authenticates user within that tenant\n * Excludes 'superadmin' slug to avoid conflicts\n */\nrouter.post('/:tenantSlug/login', (req, res, next) => {\n    console.log('🔍 Checking tenantSlug:', req.params.tenantSlug);\n    if (req.params.tenantSlug === 'superadmin') {\n        console.log('❌ Blocking superadmin slug');\n        return res.status(404).json({\n            success: false,\n            error: 'Use /superadmin/login for super admin authentication'\n        });\n    }\n    console.log('✅ Allowing tenantSlug:', req.params.tenantSlug);\n    next();\n}, tenant_middleware_1.validateTenantSlug, async (req, res) => {\n    console.log('🚀 LOGIN ROUTE REACHED!');\n    console.log('Login request body:', JSON.stringify(req.body));\n    console.log('Login request headers:', req.headers);\n    const { email, password } = req.body;\n    const tenant = req.tenant;\n    if (!email || !password) {\n        return res.status(400).json({\n            success: false,\n            error: 'Email and password are required'\n        });\n    }\n    try {\n        const client = await (0, database_1.getClient)();\n        console.log(`Looking for user: email=${email}, tenant_id=${tenant.id}, status=active`);\n        const result = await client.query('SELECT * FROM users WHERE email = $1 AND tenant_id = $2 AND status = $3', [email, tenant.id, 'active']);\n        console.log(`Query result: ${result.rows.length} users found`);\n        if (result.rows.length === 0) {\n            console.log('No user found with these credentials');\n            return res.status(401).json({\n                success: false,\n                error: 'Invalid credentials'\n            });\n        }\n        const user = result.rows[0];\n        console.log(`User found: ${user.email}, role: ${user.role}`);\n        const passwordValid = await bcrypt_1.default.compare(password, user.password_hash);\n        console.log(`Password validation result: ${passwordValid}`);\n        if (!passwordValid) {\n            console.log('Password validation failed');\n            return res.status(401).json({\n                success: false,\n                error: 'Invalid credentials'\n            });\n        }\n        console.log('Login successful, creating JWT token');\n        // Create JWT token with 8 hours session timeout\n        const token = jsonwebtoken_1.default.sign({\n            id: user.id,\n            email: user.email,\n            tenant_id: user.tenant_id,\n            tenant_slug: tenant.slug,\n            role: user.role,\n            iat: Math.floor(Date.now() / 1000),\n            exp: Math.floor(Date.now() / 1000) + (8 * 60 * 60) // 8 hours session timeout\n        }, process.env.JWT_SECRET || 'fallback-secret');\n        res.json({\n            success: true,\n            data: {\n                token,\n                user: {\n                    id: user.id,\n                    email: user.email,\n                    firstName: user.first_name,\n                    lastName: user.last_name,\n                    role: user.role,\n                    tenantId: user.tenant_id,\n                    tenantSlug: tenant.slug\n                }\n            },\n            message: 'Login successful'\n        });\n    }\n    catch (error) {\n        console.error('Login error:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Verify token endpoint\n */\nrouter.post('/verify-token', async (req, res) => {\n    const { token } = req.body;\n    if (!token) {\n        return res.status(400).json({\n            success: false,\n            error: 'Token is required'\n        });\n    }\n    try {\n        const decoded = jsonwebtoken_1.default.verify(token, process.env.JWT_SECRET || 'fallback-secret');\n        res.json({\n            success: true,\n            data: {\n                valid: true,\n                user: {\n                    id: decoded.id,\n                    email: decoded.email,\n                    role: decoded.role,\n                    tenant_id: decoded.tenant_id,\n                    tenant_slug: decoded.tenant_slug\n                }\n            }\n        });\n    }\n    catch (error) {\n        res.status(401).json({\n            success: false,\n            error: 'Invalid or expired token'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=auth.routes.js.map","size_bytes":7818},"voip-system/FREESWITCH_TROUBLESHOOTING.md":{"content":"# FreeSWITCH Troubleshooting Guide\n\n## Issue: mod_sofia Crash on Production Server\n\n**Server:** 93.93.113.13  \n**Error:** `mod_sofia` module crashes on startup  \n**Impact:** SIP registration and calls not working  \n\n---\n\n## Diagnosis Steps\n\n1. **Check FreeSWITCH Logs:**\n   ```bash\n   sudo tail -f /var/log/freeswitch/freeswitch.log\n   ```\n\n2. **Check Module Status:**\n   ```bash\n   fs_cli -x \"module_exists mod_sofia\"\n   fs_cli -x \"sofia status\"\n   ```\n\n3. **Verify Dependencies:**\n   ```bash\n   ldd /usr/lib/freeswitch/mod/mod_sofia.so\n   ```\n\n---\n\n## Solution Options\n\n### Option 1: Reinstall FreeSWITCH (Recommended)\n\n```bash\n# Backup configuration\nsudo cp -r /etc/freeswitch /etc/freeswitch.backup.$(date +%Y%m%d)\n\n# Remove existing installation\nsudo apt remove --purge freeswitch freeswitch-all\nsudo apt autoremove\n\n# Add FreeSWITCH repository\nwget -O - https://files.freeswitch.org/repo/deb/debian-release/fsstretch-archive-keyring.asc | sudo apt-key add -\necho \"deb https://files.freeswitch.org/repo/deb/debian-release/ $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/freeswitch.list\n\n# Install FreeSWITCH with mod_sofia\nsudo apt update\nsudo apt install -y freeswitch-all freeswitch-mod-sofia\n\n# Restore configuration\nsudo rsync -av /etc/freeswitch.backup.*/ /etc/freeswitch/\n\n# Start FreeSWITCH\nsudo systemctl start freeswitch\nsudo systemctl status freeswitch\n```\n\n### Option 2: Recompile mod_sofia from Source\n\n```bash\n# Install build dependencies\nsudo apt install -y build-essential autoconf automake libtool pkg-config\nsudo apt install -y libsofia-sip-ua-dev libsofia-sip-ua-glib-dev\n\n# Navigate to FreeSWITCH source (if available)\ncd /usr/src/freeswitch\n\n# Rebuild mod_sofia\nmake mod_sofia-clean\nmake mod_sofia\nsudo make mod_sofia-install\n\n# Restart FreeSWITCH\nsudo systemctl restart freeswitch\n```\n\n### Option 3: Check Missing Libraries\n\n```bash\n# Find missing dependencies\nldd /usr/lib/freeswitch/mod/mod_sofia.so | grep \"not found\"\n\n# Install missing libraries (example)\nsudo apt install -y libsofia-sip-ua0\n```\n\n---\n\n## Verification\n\nAfter applying the fix:\n\n1. **Check mod_sofia loads:**\n   ```bash\n   fs_cli -x \"module_exists mod_sofia\"\n   # Should return: true\n   ```\n\n2. **Check SIP profiles:**\n   ```bash\n   fs_cli -x \"sofia status\"\n   # Should show profiles running\n   ```\n\n3. **Test SIP registration from extension 100:**\n   - Configure SIP client with:\n     - Domain: `demo.edgvoip.it`\n     - Username: `100`\n     - Password: `DemoExt100Pass!`\n     - Server: `93.93.113.13`\n\n4. **Check FreeSWITCH XML provisioning:**\n   ```bash\n   curl -X POST \"http://localhost:3001/api/freeswitch/xml\" \\\n     -d \"section=directory&key_value=demo.edgvoip.it&user=100\"\n   ```\n\n---\n\n## Prevention\n\n1. **Never edit files directly on production**  \n   Use Git workflow: `Replit dev` → `Git push` → `Server pull`\n\n2. **Document all changes in DEPLOYMENT.md**\n\n3. **Test on Replit dev environment first**\n\n4. **Keep FreeSWITCH and dependencies updated:**\n   ```bash\n   sudo apt update\n   sudo apt upgrade freeswitch-all\n   ```\n\n---\n\n## Related Files\n\n- XML Provisioning: `packages/backend/src/services/freeswitch-xml.service.ts`\n- FreeSWITCH Routes: `packages/backend/src/routes/freeswitch-xml.routes.ts`\n- Deployment Guide: `DEPLOYMENT.md`\n\n---\n\n## Contact\n\nFor issues, check:\n- FreeSWITCH Logs: `/var/log/freeswitch/`\n- Application Logs: Backend server console\n- Database: Verify tenant and extension data\n","size_bytes":3427},"voip-system/packages/backend/dist/routes/logs.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = __importDefault(require(\"express\"));\nconst child_process_1 = require(\"child_process\");\nconst util_1 = require(\"util\");\nconst execAsync = (0, util_1.promisify)(child_process_1.exec);\nconst router = express_1.default.Router();\n// Get FreeSWITCH logs\nrouter.get('/freeswitch', async (req, res) => {\n    try {\n        const { lines = '100', level = 'all', component = 'all' } = req.query;\n        // Check if FreeSWITCH container is running\n        try {\n            await execAsync('docker ps --filter name=voip_freeswitch --format \"{{.Names}}\"');\n        }\n        catch (error) {\n            return res.status(503).json({\n                error: 'FreeSWITCH container is not running',\n                message: 'Please start FreeSWITCH container first'\n            });\n        }\n        // Get FreeSWITCH logs from Docker container\n        const logCommand = `docker logs voip_freeswitch --tail ${lines}`;\n        const { stdout } = await execAsync(logCommand);\n        // Parse logs and convert to structured format\n        const logLines = stdout.split('\\n').filter(line => line.trim());\n        const parsedLogs = [];\n        logLines.forEach((line, index) => {\n            // Parse FreeSWITCH log format: [timestamp] level component message\n            const match = line.match(/^\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\] (\\w+)\\s+(.+)/);\n            if (match) {\n                const [, timestamp, level, rest] = match;\n                const componentMatch = rest.match(/^([a-zA-Z_]+)\\s+(.+)/);\n                if (componentMatch) {\n                    const [, component, message] = componentMatch;\n                    const logEntry = {\n                        id: `fs-${Date.now()}-${index}`,\n                        timestamp: new Date(timestamp).toISOString(),\n                        level: level.toUpperCase() || 'INFO',\n                        component: component || 'unknown',\n                        message: message || rest,\n                        source: 'freeswitch'\n                    };\n                    // Apply filters\n                    if (level === 'all' || logEntry.level === level.toUpperCase()) {\n                        if (component === 'all' || logEntry.component === component) {\n                            parsedLogs.push(logEntry);\n                        }\n                    }\n                }\n            }\n        });\n        res.json({\n            success: true,\n            logs: parsedLogs,\n            total: parsedLogs.length,\n            source: 'freeswitch',\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error fetching FreeSWITCH logs:', error);\n        res.status(500).json({\n            error: 'Failed to fetch FreeSWITCH logs',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Get backend logs\nrouter.get('/backend', async (req, res) => {\n    try {\n        const { lines = '100', level = 'all' } = req.query;\n        // For now, return sample backend logs\n        // In production, this would read from actual log files\n        const sampleLogs = [\n            {\n                id: `be-${Date.now()}-1`,\n                timestamp: new Date().toISOString(),\n                level: 'INFO',\n                component: 'api',\n                message: 'Server started successfully on port 3000',\n                source: 'backend'\n            },\n            {\n                id: `be-${Date.now()}-2`,\n                timestamp: new Date(Date.now() - 1000).toISOString(),\n                level: 'INFO',\n                component: 'auth',\n                message: 'User authentication successful',\n                source: 'backend'\n            },\n            {\n                id: `be-${Date.now()}-3`,\n                timestamp: new Date(Date.now() - 2000).toISOString(),\n                level: 'DEBUG',\n                component: 'database',\n                message: 'Database connection established',\n                source: 'backend'\n            }\n        ];\n        // Apply level filter\n        const filteredLogs = level === 'all'\n            ? sampleLogs\n            : sampleLogs.filter(log => log.level === level.toUpperCase());\n        res.json({\n            success: true,\n            logs: filteredLogs,\n            total: filteredLogs.length,\n            source: 'backend',\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error fetching backend logs:', error);\n        res.status(500).json({\n            error: 'Failed to fetch backend logs',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Get system logs (combined)\nrouter.get('/system', async (req, res) => {\n    try {\n        const { lines = '50' } = req.query;\n        // Get logs from multiple sources\n        const [freeswitchResponse, backendResponse] = await Promise.allSettled([\n            fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/freeswitch?lines=${lines}`),\n            fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/backend?lines=${lines}`)\n        ]);\n        const allLogs = [];\n        if (freeswitchResponse.status === 'fulfilled' && freeswitchResponse.value.ok) {\n            const fsData = await freeswitchResponse.value.json();\n            if (fsData.success) {\n                allLogs.push(...fsData.logs);\n            }\n        }\n        if (backendResponse.status === 'fulfilled' && backendResponse.value.ok) {\n            const beData = await backendResponse.value.json();\n            if (beData.success) {\n                allLogs.push(...beData.logs);\n            }\n        }\n        // Sort by timestamp (newest first)\n        allLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n        res.json({\n            success: true,\n            logs: allLogs,\n            total: allLogs.length,\n            sources: ['freeswitch', 'backend'],\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error fetching system logs:', error);\n        res.status(500).json({\n            error: 'Failed to fetch system logs',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Get log statistics\nrouter.get('/stats', async (req, res) => {\n    try {\n        // Get recent logs to calculate stats\n        const { lines = '1000' } = req.query;\n        const [freeswitchResponse, backendResponse] = await Promise.allSettled([\n            fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/freeswitch?lines=${lines}`),\n            fetch(`http://192.168.172.234:${process.env.PORT || 3000}/api/logs/backend?lines=${lines}`)\n        ]);\n        let totalLogs = 0;\n        let errorCount = 0;\n        let warningCount = 0;\n        if (freeswitchResponse.status === 'fulfilled' && freeswitchResponse.value.ok) {\n            const fsData = await freeswitchResponse.value.json();\n            if (fsData.success) {\n                totalLogs += fsData.logs.length;\n                errorCount += fsData.logs.filter((log) => log.level === 'ERROR' || log.level === 'CRITICAL').length;\n                warningCount += fsData.logs.filter((log) => log.level === 'WARN').length;\n            }\n        }\n        if (backendResponse.status === 'fulfilled' && backendResponse.value.ok) {\n            const beData = await backendResponse.value.json();\n            if (beData.success) {\n                totalLogs += beData.logs.length;\n                errorCount += beData.logs.filter((log) => log.level === 'ERROR' || log.level === 'CRITICAL').length;\n                warningCount += beData.logs.filter((log) => log.level === 'WARN').length;\n            }\n        }\n        res.json({\n            success: true,\n            stats: {\n                total: totalLogs,\n                errors: errorCount,\n                warnings: warningCount,\n                last_update: new Date().toISOString()\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error fetching log statistics:', error);\n        res.status(500).json({\n            error: 'Failed to fetch log statistics',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Set FreeSWITCH log level\nrouter.post('/freeswitch/level', async (req, res) => {\n    try {\n        const { level } = req.body;\n        if (!level || !['debug', 'info', 'notice', 'warning', 'error'].includes(level)) {\n            return res.status(400).json({\n                error: 'Invalid log level',\n                message: 'Level must be one of: debug, info, notice, warning, error'\n            });\n        }\n        // Execute FreeSWITCH command to set log level\n        const command = `docker exec voip_freeswitch fs_cli -x \"console loglevel ${level}\"`;\n        await execAsync(command);\n        res.json({\n            success: true,\n            message: `FreeSWITCH log level set to ${level}`,\n            level: level,\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error setting FreeSWITCH log level:', error);\n        res.status(500).json({\n            error: 'Failed to set FreeSWITCH log level',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Enable/disable SIP tracing\nrouter.post('/freeswitch/tracing', async (req, res) => {\n    try {\n        const { enabled } = req.body;\n        if (typeof enabled !== 'boolean') {\n            return res.status(400).json({\n                error: 'Invalid parameter',\n                message: 'enabled must be a boolean value'\n            });\n        }\n        // Execute FreeSWITCH command to enable/disable SIP tracing\n        const command = `docker exec voip_freeswitch fs_cli -x \"sofia loglevel ${enabled ? 'all' : 'info'}\"`;\n        await execAsync(command);\n        res.json({\n            success: true,\n            message: `SIP tracing ${enabled ? 'enabled' : 'disabled'}`,\n            enabled: enabled,\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error setting SIP tracing:', error);\n        res.status(500).json({\n            error: 'Failed to set SIP tracing',\n            message: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=logs.js.map","size_bytes":10808},"voip-system/packages/backend/dist/routes/queue-routes.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = __importDefault(require(\"express\"));\nconst queue_service_1 = require(\"../services/queue.service\");\nconst auth_middleware_1 = require(\"../middleware/auth.middleware\");\nconst router = express_1.default.Router();\nconst queueService = new queue_service_1.QueueService();\n// Apply authentication middleware to all routes\nrouter.use(auth_middleware_1.authenticateToken);\n// Get all queues for tenant\nrouter.get('/', async (req, res) => {\n    try {\n        const tenantId = req.user.tenant_id;\n        const queues = await queueService.listQueues(tenantId);\n        res.json({ success: true, data: queues });\n    }\n    catch (error) {\n        console.error('❌ Error listing queues:', error);\n        res.status(500).json({ success: false, message: 'Failed to list queues' });\n    }\n});\n// Get queue by ID\nrouter.get('/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const tenantId = req.user.tenant_id;\n        const queue = await queueService.getQueueById(id, tenantId);\n        if (!queue) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, data: queue });\n    }\n    catch (error) {\n        console.error('❌ Error getting queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to get queue' });\n    }\n});\n// Create new queue\nrouter.post('/', async (req, res) => {\n    try {\n        const tenantId = req.user.tenant_id;\n        const queueData = {\n            ...req.body,\n            tenant_id: tenantId,\n            agents: req.body.agents || []\n        };\n        const queue = await queueService.createQueue(queueData);\n        res.status(201).json({ success: true, data: queue });\n    }\n    catch (error) {\n        console.error('❌ Error creating queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to create queue' });\n    }\n});\n// Update queue\nrouter.put('/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const tenantId = req.user.tenant_id;\n        const queue = await queueService.updateQueue(id, tenantId, req.body);\n        if (!queue) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, data: queue });\n    }\n    catch (error) {\n        console.error('❌ Error updating queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to update queue' });\n    }\n});\n// Delete queue\nrouter.delete('/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const tenantId = req.user.tenant_id;\n        const success = await queueService.deleteQueue(id, tenantId);\n        if (!success) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, message: 'Queue deleted successfully' });\n    }\n    catch (error) {\n        console.error('❌ Error deleting queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to delete queue' });\n    }\n});\n// Add agent to queue\nrouter.post('/:id/agents', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const { extension_id } = req.body;\n        const tenantId = req.user.tenant_id;\n        if (!extension_id) {\n            return res.status(400).json({ success: false, message: 'Extension ID is required' });\n        }\n        const success = await queueService.addAgentToQueue(id, tenantId, extension_id);\n        if (!success) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, message: 'Agent added to queue successfully' });\n    }\n    catch (error) {\n        console.error('❌ Error adding agent to queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to add agent to queue' });\n    }\n});\n// Remove agent from queue\nrouter.delete('/:id/agents/:extensionId', async (req, res) => {\n    try {\n        const { id, extensionId } = req.params;\n        const tenantId = req.user.tenant_id;\n        const success = await queueService.removeAgentFromQueue(id, tenantId, extensionId);\n        if (!success) {\n            return res.status(404).json({ success: false, message: 'Queue or agent not found' });\n        }\n        res.json({ success: true, message: 'Agent removed from queue successfully' });\n    }\n    catch (error) {\n        console.error('❌ Error removing agent from queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to remove agent from queue' });\n    }\n});\n// Update agent status\nrouter.put('/:id/agents/:extensionId/status', async (req, res) => {\n    try {\n        const { id, extensionId } = req.params;\n        const { status, tier_level } = req.body;\n        const tenantId = req.user.tenant_id;\n        const success = await queueService.updateAgentStatus(id, tenantId, extensionId, status, tier_level);\n        if (!success) {\n            return res.status(404).json({ success: false, message: 'Queue or agent not found' });\n        }\n        res.json({ success: true, message: 'Agent status updated successfully' });\n    }\n    catch (error) {\n        console.error('❌ Error updating agent status:', error);\n        res.status(500).json({ success: false, message: 'Failed to update agent status' });\n    }\n});\n// Get queue statistics\nrouter.get('/:id/stats', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const tenantId = req.user.tenant_id;\n        const stats = await queueService.getQueueStats(id, tenantId);\n        if (!stats) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, data: stats });\n    }\n    catch (error) {\n        console.error('❌ Error getting queue stats:', error);\n        res.status(500).json({ success: false, message: 'Failed to get queue statistics' });\n    }\n});\n// Pause/Resume queue\nrouter.put('/:id/pause', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const { paused } = req.body;\n        const tenantId = req.user.tenant_id;\n        const success = await queueService.pauseQueue(id, tenantId, paused);\n        if (!success) {\n            return res.status(404).json({ success: false, message: 'Queue not found' });\n        }\n        res.json({ success: true, message: `Queue ${paused ? 'paused' : 'resumed'} successfully` });\n    }\n    catch (error) {\n        console.error('❌ Error pausing/resuming queue:', error);\n        res.status(500).json({ success: false, message: 'Failed to pause/resume queue' });\n    }\n});\n// Get agent statistics\nrouter.get('/:id/agents/:extensionId/stats', async (req, res) => {\n    try {\n        const { id, extensionId } = req.params;\n        const tenantId = req.user.tenant_id;\n        const stats = await queueService.getAgentStats(id, tenantId, extensionId);\n        if (!stats) {\n            return res.status(404).json({ success: false, message: 'Agent not found' });\n        }\n        res.json({ success: true, data: stats });\n    }\n    catch (error) {\n        console.error('❌ Error getting agent stats:', error);\n        res.status(500).json({ success: false, message: 'Failed to get agent statistics' });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=queue-routes.js.map","size_bytes":7620},"voip-system/QUICK_DEPLOY.md":{"content":"# ⚡ Quick Deploy Guide\n\n## 🎯 Modifiche da Deployare\n\n### 1. Fix JSON.parse (CRITICO)\n- **File**: `packages/backend/src/services/extension.service.ts`\n- **Bug**: Extensions non visibili in frontend\n- **Fix**: Type check prima di JSON.parse per JSONB fields\n\n### 2. Fix Database Timeout\n- **File**: `packages/database/src/index.ts`  \n- **Bug**: Connection timeout errors\n- **Fix**: Timeout aumentato a 10s + keepAlive\n\n## 🚀 Deployment Rapido\n\n### Step 1: Commit da Replit\n```bash\ngit add .\ngit commit -m \"Fix: JSON.parse JSONB + database timeout\"\ngit push origin main\n```\n\n### Step 2: Deploy sul Server\n```bash\n# SSH al server\nssh root@93.93.113.13\ncd /root/w3voip-app\n\n# Backup database\npg_dump -U voip_user -d voip_production > /root/backups/db_$(date +%Y%m%d_%H%M).sql\n\n# Pull + Build + Restart\ngit pull origin main && npm install && npm run build && systemctl restart voip-backend\n\n# Verifica\nsystemctl status voip-backend\njournalctl -u voip-backend -n 20\n```\n\n### Step 3: Test\n```bash\n# Test API\ncurl http://localhost:3001/api/health\n\n# Verifica extension 100\npsql -U voip_user -d voip_production -c \"SELECT extension, display_name FROM extensions WHERE extension='100';\"\n```\n\n## ✅ Done!\n\nSe tutto ok, le extensions dovrebbero essere visibili nel frontend.\n\n## ⚠️ Se qualcosa va storto\n\n```bash\n# Rollback Git\ngit reset --hard HEAD~1\n\n# Ripristina database\npsql -U voip_user -d voip_production < /root/backups/db_YYYYMMDD_HHMM.sql\n\n# Riavvia\nnpm run build && systemctl restart voip-backend\n```\n\n---\n\n**Per dettagli completi vedi `DEPLOYMENT.md`**\n","size_bytes":1564},"voip-system/packages/backend/dist/middleware/tenant-context.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nexport interface TenantContext {\n    tenant_id: string;\n    sip_domain: string;\n    store_id?: string;\n}\ndeclare global {\n    namespace Express {\n        interface Request {\n            tenantContext?: TenantContext;\n        }\n    }\n}\nexport declare function tenantContextMiddleware(req: Request, res: Response, next: NextFunction): Promise<Response<any, Record<string, any>>>;\nexport declare function generateSipDomain(tenantName: string): string;\nexport declare function validateSipDomain(sipDomain: string): boolean;\n//# sourceMappingURL=tenant-context.d.ts.map","size_bytes":623},"voip-system/packages/backend/dist/routes/auth.routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=auth.routes.d.ts.map","size_bytes":130},"voip-system/packages/backend/dist/routes/calls.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = require(\"express\");\nconst zod_1 = require(\"zod\");\nconst freeswitch_service_1 = require(\"../services/freeswitch.service\");\nconst mock_freeswitch_service_1 = require(\"../services/mock-freeswitch.service\");\nconst cdr_service_1 = require(\"../services/cdr.service\");\nconst auth_1 = require(\"../middleware/auth\");\nconst tenant_1 = require(\"../middleware/tenant\");\nconst validation_1 = require(\"../middleware/validation\");\nconst response_1 = require(\"../utils/response\");\n// Removed unused import: logAPICall\nconst router = (0, express_1.Router)();\n// Initialize services\n// Use Mock FreeSWITCH if FREESWITCH_MOCK=true or FreeSWITCH not available\nconst USE_MOCK = process.env.FREESWITCH_MOCK === 'true' || process.env.FREESWITCH_MOCK === '1';\nconst fsService = USE_MOCK\n    ? new mock_freeswitch_service_1.MockFreeSWITCHService()\n    : new freeswitch_service_1.FreeSWITCHService();\nconst cdrService = new cdr_service_1.CDRService();\n// Connect to FreeSWITCH on startup\nfsService.connect().catch((error) => {\n    console.error('Failed to connect to FreeSWITCH:', error);\n    console.log('💡 Tip: Set FREESWITCH_MOCK=true to use mock service for testing');\n});\n// Validation schemas\nconst originateCallSchema = zod_1.z.object({\n    caller_extension: zod_1.z.string().min(1, 'Caller extension is required'),\n    callee_number: zod_1.z.string().min(1, 'Callee number is required'),\n    domain: zod_1.z.string().min(1, 'Domain is required'),\n    options: zod_1.z.object({\n        timeout: zod_1.z.number().min(1).max(300).optional(),\n        caller_id: zod_1.z.string().optional(),\n        context: zod_1.z.string().optional(),\n        recording: zod_1.z.boolean().optional()\n    }).optional()\n});\nconst transferCallSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID'),\n    destination: zod_1.z.string().min(1, 'Destination is required'),\n    type: zod_1.z.enum(['attended', 'blind']).optional()\n});\nconst hangupCallSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID'),\n    cause: zod_1.z.string().optional()\n});\nconst holdCallSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID'),\n    hold: zod_1.z.boolean().optional()\n});\nconst muteCallSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID'),\n    mute: zod_1.z.boolean().optional()\n});\nconst recordCallSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID'),\n    record: zod_1.z.boolean().optional(),\n    path: zod_1.z.string().optional()\n});\nconst getCallInfoSchema = zod_1.z.object({\n    call_uuid: zod_1.z.string().uuid('Invalid call UUID')\n});\n// Originate a call\nrouter.post('/originate', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(originateCallSchema), async (req, res) => {\n    try {\n        const { caller_extension, callee_number, domain, options } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('originate_call', {\n            tenant_id: tenantId,\n            caller_extension,\n            callee_number,\n            domain\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Originate the call\n        const callUuid = await fsService.originateCall(caller_extension, callee_number, domain, options);\n        // Create initial CDR record\n        const cdrData = {\n            tenant_id: tenantId,\n            call_uuid: callUuid,\n            call_direction: 'outbound',\n            call_type: 'voice',\n            caller_extension: caller_extension,\n            callee_id_number: callee_number,\n            start_time: new Date(),\n            duration: 0,\n            bill_seconds: 0,\n            hangup_cause: 'UNKNOWN',\n            hangup_disposition: 'UNKNOWN',\n            recording_enabled: options?.recording || false,\n            fs_uuid: callUuid,\n            fs_domain: domain,\n            fs_context: options?.context || 'default',\n            fs_profile: 'internal'\n        };\n        const cdr = await cdrService.createCDR(cdrData);\n        (0, response_1.successResponse)(res, {\n            call_uuid: callUuid,\n            cdr_id: cdr.id,\n            status: 'originated'\n        }, 201);\n    }\n    catch (error) {\n        console.error('Error originating call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to originate call', 500);\n    }\n});\n// Transfer a call\nrouter.post('/transfer', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(transferCallSchema), async (req, res) => {\n    try {\n        const { call_uuid, destination, type } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('transfer_call', {\n            tenant_id: tenantId,\n            call_uuid,\n            destination,\n            type\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Verify CDR exists for this tenant\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Transfer the call\n        await fsService.transferCall(call_uuid, destination, type);\n        (0, response_1.successResponse)(res, {\n            call_uuid,\n            destination,\n            type: type || 'blind',\n            status: 'transferred'\n        });\n    }\n    catch (error) {\n        console.error('Error transferring call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to transfer call', 500);\n    }\n});\n// Hangup a call\nrouter.post('/hangup', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(hangupCallSchema), async (req, res) => {\n    try {\n        const { call_uuid, cause } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('hangup_call', {\n            tenant_id: tenantId,\n            call_uuid,\n            cause\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Verify CDR exists for this tenant\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Hangup the call\n        await fsService.hangupCall(call_uuid, cause);\n        (0, response_1.successResponse)(res, {\n            call_uuid,\n            cause: cause || 'NORMAL_CLEARING',\n            status: 'hungup'\n        });\n    }\n    catch (error) {\n        console.error('Error hanging up call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to hangup call', 500);\n    }\n});\n// Hold/Unhold a call\nrouter.post('/hold', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(holdCallSchema), async (req, res) => {\n    try {\n        const { call_uuid, hold } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('hold_call', {\n            tenant_id: tenantId,\n            call_uuid,\n            hold\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Verify CDR exists for this tenant\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Hold/Unhold the call\n        await fsService.holdCall(call_uuid, hold);\n        (0, response_1.successResponse)(res, {\n            call_uuid,\n            hold: hold !== false,\n            status: hold !== false ? 'held' : 'unheld'\n        });\n    }\n    catch (error) {\n        console.error('Error holding/unholding call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to hold/unhold call', 500);\n    }\n});\n// Mute/Unmute a call\nrouter.post('/mute', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(muteCallSchema), async (req, res) => {\n    try {\n        const { call_uuid, mute } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('mute_call', {\n            tenant_id: tenantId,\n            call_uuid,\n            mute\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Verify CDR exists for this tenant\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Mute/Unmute the call\n        await fsService.muteCall(call_uuid, mute);\n        (0, response_1.successResponse)(res, {\n            call_uuid,\n            mute: mute !== false,\n            status: mute !== false ? 'muted' : 'unmuted'\n        });\n    }\n    catch (error) {\n        console.error('Error muting/unmuting call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to mute/unmute call', 500);\n    }\n});\n// Start/Stop recording\nrouter.post('/record', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(recordCallSchema), async (req, res) => {\n    try {\n        const { call_uuid, record, path } = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('record_call', {\n            tenant_id: tenantId,\n            call_uuid,\n            record,\n            path\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Verify CDR exists for this tenant\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Start/Stop recording\n        await fsService.recordCall(call_uuid, record, path);\n        // Update CDR with recording info\n        if (record && path) {\n            await cdrService.updateCDR(cdr.id, {\n                recording_path: path,\n                recording_enabled: true\n            }, tenantId);\n        }\n        else if (!record) {\n            await cdrService.updateCDR(cdr.id, {\n                recording_enabled: false\n            }, tenantId);\n        }\n        (0, response_1.successResponse)(res, {\n            call_uuid,\n            record: record !== false,\n            recording_path: path,\n            status: record !== false ? 'recording' : 'stopped'\n        });\n    }\n    catch (error) {\n        console.error('Error recording call:', error);\n        (0, response_1.errorResponse)(res, 'Failed to record call', 500);\n    }\n});\n// Get call information\nrouter.get('/info/:call_uuid', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(getCallInfoSchema, 'params'), async (req, res) => {\n    try {\n        const { call_uuid } = req.params;\n        const tenantId = req.tenantId;\n        logAPICall('get_call_info', {\n            tenant_id: tenantId,\n            call_uuid\n        });\n        // Check if FreeSWITCH is connected\n        if (!fsService.isConnected()) {\n            return (0, response_1.errorResponse)(res, 'FreeSWITCH not connected', 503);\n        }\n        // Get CDR from database\n        const cdr = await cdrService.getCDRByCallUuid(call_uuid, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'Call not found', 404);\n        }\n        // Get live call info from FreeSWITCH\n        const callInfo = await fsService.getCallInfo(call_uuid);\n        (0, response_1.successResponse)(res, {\n            cdr,\n            live_info: callInfo,\n            status: 'active'\n        });\n    }\n    catch (error) {\n        console.error('Error getting call info:', error);\n        (0, response_1.errorResponse)(res, 'Failed to get call info', 500);\n    }\n});\n// Get FreeSWITCH connection status\nrouter.get('/status', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const status = fsService.getStatus();\n        (0, response_1.successResponse)(res, {\n            freeswitch: status,\n            timestamp: new Date().toISOString()\n        });\n    }\n    catch (error) {\n        console.error('Error getting status:', error);\n        (0, response_1.errorResponse)(res, 'Failed to get status', 500);\n    }\n});\n// WebSocket endpoint for real-time call events\nrouter.get('/events', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const tenantId = req.tenantId;\n        // Set up WebSocket connection\n        res.writeHead(200, {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache',\n            'Connection': 'keep-alive',\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Headers': 'Cache-Control'\n        });\n        // Send initial connection event\n        res.write(`data: ${JSON.stringify({\n            type: 'connected',\n            tenant_id: tenantId,\n            timestamp: new Date().toISOString()\n        })}\\n\\n`);\n        // Set up event listeners\n        const onCallStarted = (callInfo) => {\n            if (callInfo.domain === tenantId) {\n                res.write(`data: ${JSON.stringify({\n                    type: 'call_started',\n                    data: callInfo,\n                    timestamp: new Date().toISOString()\n                })}\\n\\n`);\n            }\n        };\n        const onCallAnswered = (callInfo) => {\n            res.write(`data: ${JSON.stringify({\n                type: 'call_answered',\n                data: callInfo,\n                timestamp: new Date().toISOString()\n            })}\\n\\n`);\n        };\n        const onCallEnded = (callInfo) => {\n            res.write(`data: ${JSON.stringify({\n                type: 'call_ended',\n                data: callInfo,\n                timestamp: new Date().toISOString()\n            })}\\n\\n`);\n        };\n        // Add event listeners\n        fsService.on('call_started', onCallStarted);\n        fsService.on('call_answered', onCallAnswered);\n        fsService.on('call_ended', onCallEnded);\n        // Handle client disconnect\n        req.on('close', () => {\n            fsService.off('call_started', onCallStarted);\n            fsService.off('call_answered', onCallAnswered);\n            fsService.off('call_ended', onCallEnded);\n        });\n    }\n    catch (error) {\n        console.error('Error setting up call events:', error);\n        (0, response_1.errorResponse)(res, 'Failed to setup call events', 500);\n    }\n});\nexports.default = router;\n//# sourceMappingURL=calls.js.map","size_bytes":15206},"voip-system/packages/backend/dist/routes/logs.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=logs.d.ts.map","size_bytes":123},"voip-system/packages/backend/dist/middleware/tenant.middleware.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nexport interface TenantRequest extends Request {\n    tenant?: {\n        id: string;\n        slug: string;\n        name: string;\n        domain: string;\n        sip_domain: string;\n    };\n}\n/**\n * Middleware to validate tenant slug from URL parameters\n * Extracts tenant information and attaches it to the request object\n */\nexport declare function validateTenantSlug(req: TenantRequest, res: Response, next: NextFunction): Promise<Response<any, Record<string, any>>>;\n/**\n * Middleware to extract tenant slug from JWT token\n * Used for API calls that don't have tenant slug in URL\n */\nexport declare function extractTenantFromToken(req: Request, res: Response, next: NextFunction): Response<any, Record<string, any>>;\n//# sourceMappingURL=tenant.middleware.d.ts.map","size_bytes":824},"voip-system/packages/backend/dist/middleware/security.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nexport declare const securityHeaders: (req: import(\"http\").IncomingMessage, res: import(\"http\").ServerResponse, next: (err?: unknown) => void) => void;\nexport declare const requestId: (req: Request, res: Response, next: NextFunction) => void;\nexport declare const createRateLimit: (windowMs: number, max: number, message?: string) => import(\"express-rate-limit\").RateLimitRequestHandler;\nexport declare const apiRateLimit: import(\"express-rate-limit\").RateLimitRequestHandler;\nexport declare const authRateLimit: import(\"express-rate-limit\").RateLimitRequestHandler;\nexport declare const cdrRateLimit: import(\"express-rate-limit\").RateLimitRequestHandler;\nexport declare const sanitizeInput: (req: Request, res: Response, next: NextFunction) => void;\nexport declare const validateContentType: (allowedTypes?: string[]) => (req: Request, res: Response, next: NextFunction) => void | Response<any, Record<string, any>>;\nexport declare const requestSizeLimit: (maxSize?: string) => (req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const ipWhitelist: (allowedIPs: string[]) => (req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const securityEventLogger: (req: Request, res: Response, next: NextFunction) => void;\n//# sourceMappingURL=security.d.ts.map","size_bytes":1415},"voip-system/packages/backend/dist/routes/superadmin.routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=superadmin.routes.d.ts.map","size_bytes":136},"voip-system/packages/backend/dist/middleware/tenant.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTenantResource = exports.tenantRateLimit = exports.setStoreContext = exports.setTenantContext = void 0;\nconst database_1 = require(\"@w3-voip/database\");\n// Tenant Context Middleware\nconst setTenantContext = async (req, res, next) => {\n    try {\n        if (!req.tenantId) {\n            return res.status(400).json({\n                success: false,\n                error: {\n                    code: 'TENANT_ID_REQUIRED',\n                    message: 'Tenant ID is required'\n                }\n            });\n        }\n        // Verify tenant exists and is active\n        const client = await (0, database_1.getClient)();\n        try {\n            const result = await client.query('SELECT id, name, status FROM tenants WHERE id = $1', [req.tenantId]);\n            if (result.rows.length === 0) {\n                return res.status(404).json({\n                    success: false,\n                    error: {\n                        code: 'TENANT_NOT_FOUND',\n                        message: 'Tenant not found'\n                    }\n                });\n            }\n            const tenant = result.rows[0];\n            if (tenant.status !== 'active') {\n                return res.status(403).json({\n                    success: false,\n                    error: {\n                        code: 'TENANT_INACTIVE',\n                        message: `Tenant is ${tenant.status}`\n                    }\n                });\n            }\n            // Set tenant context in request\n            req.tenantId = tenant.id;\n            // Add tenant info to response headers for debugging\n            res.set('X-Tenant-ID', tenant.id);\n            res.set('X-Tenant-Name', tenant.name);\n        }\n        finally {\n            await client.release();\n        }\n        next();\n    }\n    catch (error) {\n        console.error('Tenant context error:', error);\n        return res.status(500).json({\n            success: false,\n            error: {\n                code: 'TENANT_CONTEXT_ERROR',\n                message: 'Failed to set tenant context'\n            }\n        });\n    }\n};\nexports.setTenantContext = setTenantContext;\n// Store Context Middleware\nconst setStoreContext = async (req, res, next) => {\n    try {\n        const storeId = req.params.storeId || req.body.storeId || req.query.storeId;\n        if (!storeId) {\n            return next(); // Store is optional\n        }\n        if (!req.tenantId) {\n            return res.status(400).json({\n                success: false,\n                error: {\n                    code: 'TENANT_CONTEXT_REQUIRED',\n                    message: 'Tenant context required for store access'\n                }\n            });\n        }\n        // Verify store exists and belongs to tenant\n        const client = await (0, database_1.getClient)();\n        try {\n            const result = await client.query('SELECT id, name, status FROM stores WHERE id = $1 AND tenant_id = $2', [storeId, req.tenantId]);\n            if (result.rows.length === 0) {\n                return res.status(404).json({\n                    success: false,\n                    error: {\n                        code: 'STORE_NOT_FOUND',\n                        message: 'Store not found or access denied'\n                    }\n                });\n            }\n            const store = result.rows[0];\n            if (store.status !== 'active') {\n                return res.status(403).json({\n                    success: false,\n                    error: {\n                        code: 'STORE_INACTIVE',\n                        message: `Store is ${store.status}`\n                    }\n                });\n            }\n            // Set store context in request\n            req.storeId = store.id;\n            // Add store info to response headers for debugging\n            res.set('X-Store-ID', store.id);\n            res.set('X-Store-Name', store.name);\n        }\n        finally {\n            await client.release();\n        }\n        next();\n    }\n    catch (error) {\n        console.error('Store context error:', error);\n        return res.status(500).json({\n            success: false,\n            error: {\n                code: 'STORE_CONTEXT_ERROR',\n                message: 'Failed to set store context'\n            }\n        });\n    }\n};\nexports.setStoreContext = setStoreContext;\n// Tenant Rate Limiting Middleware\nconst tenantRateLimit = (maxRequests = 100, windowMs = 900000) => {\n    const requests = new Map();\n    return (req, res, next) => {\n        if (!req.tenantId) {\n            return next();\n        }\n        const now = Date.now();\n        const key = `tenant:${req.tenantId}`;\n        const tenantRequests = requests.get(key);\n        if (!tenantRequests || now > tenantRequests.resetTime) {\n            // Reset or initialize\n            requests.set(key, {\n                count: 1,\n                resetTime: now + windowMs\n            });\n            return next();\n        }\n        if (tenantRequests.count >= maxRequests) {\n            return res.status(429).json({\n                success: false,\n                error: {\n                    code: 'RATE_LIMIT_EXCEEDED',\n                    message: `Rate limit exceeded for tenant. Max ${maxRequests} requests per ${windowMs / 1000} seconds`\n                }\n            });\n        }\n        tenantRequests.count++;\n        next();\n    };\n};\nexports.tenantRateLimit = tenantRateLimit;\n// Tenant Resource Validation Middleware\nconst validateTenantResource = (resourceType) => {\n    return async (req, res, next) => {\n        try {\n            const resourceId = req.params.id || req.params[`${resourceType}Id`];\n            if (!resourceId) {\n                return next();\n            }\n            if (!req.tenantId) {\n                return res.status(400).json({\n                    success: false,\n                    error: {\n                        code: 'TENANT_CONTEXT_REQUIRED',\n                        message: 'Tenant context required for resource validation'\n                    }\n                });\n            }\n            // Validate resource belongs to tenant\n            const client = await (0, database_1.getClient)();\n            try {\n                // Whitelist di tabelle permesse (SICUREZZA: previene SQL injection)\n                const allowedTables = {\n                    'extension': 'extensions',\n                    'trunk': 'sip_trunks',\n                    'store': 'stores',\n                    'call': 'calls',\n                    'cdr': 'cdr'\n                };\n                const tableName = allowedTables[resourceType];\n                if (!tableName) {\n                    return res.status(400).json({\n                        success: false,\n                        error: {\n                            code: 'INVALID_RESOURCE_TYPE',\n                            message: 'Invalid resource type'\n                        }\n                    });\n                }\n                const result = await client.query(`SELECT id FROM ${tableName} WHERE id = $1 AND tenant_id = $2`, [resourceId, req.tenantId]);\n                if (result.rows.length === 0) {\n                    return res.status(404).json({\n                        success: false,\n                        error: {\n                            code: 'RESOURCE_NOT_FOUND',\n                            message: `${resourceType} not found or access denied`\n                        }\n                    });\n                }\n            }\n            finally {\n                await client.release();\n            }\n            next();\n        }\n        catch (error) {\n            console.error('Resource validation error:', error);\n            return res.status(500).json({\n                success: false,\n                error: {\n                    code: 'RESOURCE_VALIDATION_ERROR',\n                    message: 'Failed to validate resource access'\n                }\n            });\n        }\n    };\n};\nexports.validateTenantResource = validateTenantResource;\n//# sourceMappingURL=tenant.js.map","size_bytes":8096},"voip-system/packages/backend/dist/routes/system.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = __importDefault(require(\"express\"));\nconst router = express_1.default.Router();\n// FreeSWITCH status\n// GET /api/freeswitch/status\nrouter.get('/freeswitch/status', (req, res) => {\n    // Check if FreeSWITCH is running by testing the port\n    const net = require('net');\n    const client = new net.Socket();\n    client.setTimeout(1000);\n    client.connect(8021, '127.0.0.1', () => {\n        client.destroy();\n        return res.json({\n            success: true,\n            data: {\n                connected: true,\n                message: 'FreeSWITCH ESL is running and accessible',\n                timestamp: new Date().toISOString(),\n            },\n            timestamp: new Date().toISOString(),\n        });\n    });\n    client.on('error', () => {\n        return res.json({\n            success: true,\n            data: {\n                connected: false,\n                message: 'FreeSWITCH ESL is not accessible',\n                timestamp: new Date().toISOString(),\n            },\n            timestamp: new Date().toISOString(),\n        });\n    });\n});\n// Placeholder: CDR aggregated stats\n// GET /api/cdr-activity/cdr/stats\nrouter.get('/cdr-activity/cdr/stats', (req, res) => {\n    return res.json({\n        success: true,\n        data: {\n            totalCalls: 0,\n            answeredCalls: 0,\n            missedCalls: 0,\n            averageDuration: 0,\n            timestamp: new Date().toISOString(),\n        },\n        timestamp: new Date().toISOString(),\n    });\n});\nexports.default = router;\n//# sourceMappingURL=system.js.map","size_bytes":1775},"voip-system/packages/backend/dist/routes/analytics.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=analytics.d.ts.map","size_bytes":128},"voip-system/DEPLOYMENT.md":{"content":"# 🚀 Deployment Guide - W3 VoIP System\n\n## 📋 Pre-requisiti\n\n- Accesso SSH al server production (93.93.113.13)\n- Repository Git configurato sul server\n- Node.js e npm installati\n- PostgreSQL database in esecuzione\n- FreeSWITCH installato\n\n## 🔄 Procedura di Deployment\n\n### 1. Commit e Push da Replit (LOCALE)\n\n```bash\n# Verifica le modifiche\ngit status\n\n# Aggiungi tutte le modifiche\ngit add .\n\n# Commit con messaggio descrittivo\ngit commit -m \"Fix: JSON.parse per JSONB settings + database timeout aumentato\"\n\n# Push su repository\ngit push origin main\n```\n\n### 2. Deploy sul Server Production\n\nConnettiti al server:\n\n```bash\nssh root@93.93.113.13\ncd /root/w3voip-app\n```\n\nEsegui il deployment:\n\n```bash\n# 1. Backup del database (IMPORTANTE!)\npg_dump -U voip_user -d voip_production > /root/backups/db_backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 2. Pull delle modifiche da Git\ngit fetch origin\ngit pull origin main\n\n# 3. Installa/aggiorna dipendenze\nnpm install\n\n# 4. Build del progetto\nnpm run build\n\n# 5. Verifica schema database (se necessario)\ncd packages/backend\nnpm run db:push\n\n# 6. Riavvia i servizi\nsystemctl restart voip-backend\n\n# 7. Verifica che il backend sia attivo\nsystemctl status voip-backend\n\n# 8. Controlla i log per errori\njournalctl -u voip-backend -n 50 --no-pager\n\n# 9. Riavvia FreeSWITCH (solo se necessario)\n# systemctl restart freeswitch\n# systemctl status freeswitch\n```\n\n### 3. Verifica Deployment\n\n```bash\n# Test API backend\ncurl -I http://localhost:3001/api/health\n\n# Verifica connessione database\npsql -U voip_user -d voip_production -c \"SELECT COUNT(*) FROM tenants;\"\n\n# Test extension 100\npsql -U voip_user -d voip_production -c \"SELECT id, extension, display_name FROM extensions WHERE extension = '100';\"\n\n# Verifica FreeSWITCH\n/usr/local/freeswitch/bin/fs_cli -x \"sofia status profile internal\"\n```\n\n## 📝 Modifiche in Questo Deploy\n\n### Fix JSON.parse per JSONB (CRITICO)\n- **File**: `packages/backend/src/services/extension.service.ts`\n- **Problema**: PostgreSQL ritorna JSONB come oggetto in production ma come stringa in development\n- **Soluzione**: Check del tipo prima di JSON.parse\n```typescript\ntypeof row.settings === 'string' ? JSON.parse(row.settings) : row.settings\n```\n- **Occorrenze**: 6 fix applicati\n\n### Fix Database Connection Timeout\n- **File**: `packages/database/src/index.ts`\n- **Problema**: Timeout di 2s troppo basso per connessioni di rete\n- **Modifiche**:\n  - `connectionTimeoutMillis`: 2000 → 10000 (10 secondi)\n  - Aggiunto `keepAlive: true`\n  - Aggiunto `keepAliveInitialDelayMillis: 10000`\n\n## ⚠️ Troubleshooting\n\n### Backend non si avvia\n\n```bash\n# Controlla errori nel log\njournalctl -u voip-backend -n 100 --no-pager\n\n# Verifica porta 3001 libera\nnetstat -tuln | grep 3001\n\n# Kill processo bloccato\npkill -f \"node.*backend\"\nsystemctl restart voip-backend\n```\n\n### Database non si connette\n\n```bash\n# Test connessione database\npsql -U voip_user -d voip_production -c \"SELECT 1;\"\n\n# Verifica DATABASE_URL in .env\ncat /root/w3voip-app/packages/backend/.env | grep DATABASE_URL\n```\n\n### FreeSWITCH non parte\n\n```bash\n# NON modificare manualmente i file di configurazione!\n# Verifica errori\n/usr/local/freeswitch/bin/freeswitch -c 2>&1 | head -50\n\n# Se necessario, ripristina configurazione\ncd /usr/local/freeswitch/conf\n# Verifica backup disponibili\nls -la *.bak\n```\n\n## 🔙 Rollback\n\nSe qualcosa va storto:\n\n```bash\n# 1. Torna alla versione precedente\ncd /root/w3voip-app\ngit log --oneline -5  # Vedi commit recenti\ngit reset --hard <commit-hash-precedente>\n\n# 2. Ripristina database\npsql -U voip_user -d voip_production < /root/backups/db_backup_YYYYMMDD_HHMMSS.sql\n\n# 3. Rebuild e riavvia\nnpm run build\nsystemctl restart voip-backend\n```\n\n## 📊 Monitoring Post-Deployment\n\n```bash\n# Monitora log in real-time\njournalctl -u voip-backend -f\n\n# Monitora registrazioni SIP\ntail -f /usr/local/freeswitch/log/freeswitch.log | grep -i REGISTER\n\n# CPU e memoria\ntop -bn1 | grep -E \"(node|freeswitch)\"\n```\n\n## ✅ Checklist Post-Deploy\n\n- [ ] Backend risponde su porta 3001\n- [ ] Database accessibile\n- [ ] FreeSWITCH in esecuzione\n- [ ] Extension 100 visibile in frontend\n- [ ] Nessun errore nei log\n- [ ] Test login su frontend funzionante\n\n## 🆘 Supporto\n\nSe incontri problemi:\n1. Controlla i log: `journalctl -u voip-backend -n 100`\n2. Verifica status servizi: `systemctl status voip-backend freeswitch`\n3. Non modificare manualmente file sul server - usa sempre Git workflow\n","size_bytes":4452},"voip-system/packages/backend/dist/routes/freeswitch-xml.routes.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst freeswitch_xml_service_1 = require(\"../services/freeswitch-xml.service\");\nconst router = (0, express_1.Router)();\nrouter.get('/xml', async (req, res) => {\n    try {\n        console.log('FreeSWITCH XML GET Request:', req.query);\n        const params = { ...req.query };\n        const xml = await freeswitch_xml_service_1.freeSwitchXmlService.processXmlRequest(params);\n        res.setHeader('Content-Type', 'application/xml');\n        res.send(xml);\n    }\n    catch (error) {\n        console.error('FreeSWITCH XML GET error:', error);\n        res.setHeader('Content-Type', 'application/xml');\n        res.status(500).send('<document type=\" freeswitch/xml\\><section name=\\result\\><result status=\\error\\/></section></document>');\n    }\n});\nrouter.post('/xml', async (req, res) => {\n    try {\n        console.log('FreeSWITCH XML POST Request:', { body: req.body, query: req.query });\n        const params = { ...req.body, ...req.query };\n        const xml = await freeswitch_xml_service_1.freeSwitchXmlService.processXmlRequest(params);\n        res.setHeader('Content-Type', 'application/xml');\n        res.send(xml);\n    }\n    catch (error) {\n        console.error('FreeSWITCH XML POST error:', error);\n        res.setHeader('Content-Type', 'application/xml');\n        res.status(500).send('<document type=\\freeswitch/xml\\><section name=\\result\\><result status=\\error\\/></section></document>');\n    }\n});\nexports.default = router;\n//# sourceMappingURL=freeswitch-xml.routes.js.map","size_bytes":1598},"voip-system/packages/backend/dist/routes/tenants.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=tenants.d.ts.map","size_bytes":126},"voip-system/packages/backend/dist/routes/queue-routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=queue-routes.d.ts.map","size_bytes":131},"voip-system/packages/backend/dist/routes/superadmin.routes.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = __importDefault(require(\"express\"));\nconst bcrypt_1 = __importDefault(require(\"bcrypt\"));\nconst database_1 = require(\"@w3-voip/database\");\nconst auth_middleware_1 = require(\"../middleware/auth.middleware\");\nconst router = express_1.default.Router();\n/**\n * Get all tenants (super admin only)\n * GET /superadmin/tenants\n */\nrouter.get('/tenants', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    try {\n        const client = await (0, database_1.getClient)();\n        const result = await client.query(`\r\n      SELECT \r\n        t.*,\r\n        COUNT(DISTINCT u.id) as user_count,\r\n        COUNT(DISTINCT e.id) as extension_count,\r\n        COUNT(DISTINCT s.id) as store_count\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      LEFT JOIN stores s ON t.id = s.tenant_id\r\n      GROUP BY t.id\r\n      ORDER BY t.created_at DESC\r\n    `);\n        res.json({\n            success: true,\n            data: result.rows\n        });\n    }\n    catch (error) {\n        console.error('Error fetching tenants:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Create new tenant (super admin only)\n * POST /superadmin/tenants\n */\nrouter.post('/tenants', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    const { name, domain, sip_domain, companies, adminUser } = req.body;\n    if (!name || !domain || !sip_domain || !companies || !adminUser) {\n        return res.status(400).json({\n            success: false,\n            error: 'Missing required fields: name, domain, sip_domain, companies, adminUser'\n        });\n    }\n    try {\n        const client = await (0, database_1.getClient)();\n        // Start transaction\n        await client.query('BEGIN');\n        // Create tenant\n        const tenantResult = await client.query(`\r\n      INSERT INTO tenants (name, domain, sip_domain, companies, status, slug)\r\n      VALUES ($1, $2, $3, $4, $5, $6)\r\n      RETURNING *\r\n    `, [name, domain, sip_domain, JSON.stringify(companies), 'active', domain.replace(/[^a-zA-Z0-9-]/g, '-')]);\n        const tenant = tenantResult.rows[0];\n        // Create admin user for the tenant\n        const hashedPassword = await bcrypt_1.default.hash(adminUser.password, 10);\n        const userResult = await client.query(`\r\n      INSERT INTO users (tenant_id, email, password_hash, first_name, last_name, role, status)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n      RETURNING *\r\n    `, [tenant.id, adminUser.email, hashedPassword, adminUser.firstName, adminUser.lastName, 'admin', 'active']);\n        const user = userResult.rows[0];\n        // Commit transaction\n        await client.query('COMMIT');\n        res.json({\n            success: true,\n            data: {\n                tenant,\n                adminUser: {\n                    id: user.id,\n                    email: user.email,\n                    firstName: user.first_name,\n                    lastName: user.last_name,\n                    role: user.role\n                }\n            },\n            message: 'Tenant created successfully'\n        });\n    }\n    catch (error) {\n        console.error('Error creating tenant:', error);\n        await client.query('ROLLBACK');\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Update tenant (super admin only)\n * PUT /superadmin/tenants/:id\n */\nrouter.put('/tenants/:id', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    const { id } = req.params;\n    const { name, domain, sip_domain, companies, status } = req.body;\n    try {\n        const client = await (0, database_1.getClient)();\n        const result = await client.query(`\r\n      UPDATE tenants \r\n      SET name = $1, domain = $2, sip_domain = $3, companies = $4, status = $5, updated_at = NOW()\r\n      WHERE id = $6\r\n      RETURNING *\r\n    `, [name, domain, sip_domain, JSON.stringify(companies), status, id]);\n        if (result.rows.length === 0) {\n            return res.status(404).json({\n                success: false,\n                error: 'Tenant not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: result.rows[0],\n            message: 'Tenant updated successfully'\n        });\n    }\n    catch (error) {\n        console.error('Error updating tenant:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Delete tenant (super admin only)\n * DELETE /superadmin/tenants/:id\n */\nrouter.delete('/tenants/:id', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    const { id } = req.params;\n    try {\n        const client = await (0, database_1.getClient)();\n        // Start transaction\n        await client.query('BEGIN');\n        // Delete related data\n        await client.query('DELETE FROM users WHERE tenant_id = $1', [id]);\n        await client.query('DELETE FROM extensions WHERE tenant_id = $1', [id]);\n        await client.query('DELETE FROM stores WHERE tenant_id = $1', [id]);\n        // Delete tenant\n        const result = await client.query('DELETE FROM tenants WHERE id = $1 RETURNING *', [id]);\n        if (result.rows.length === 0) {\n            await client.query('ROLLBACK');\n            return res.status(404).json({\n                success: false,\n                error: 'Tenant not found'\n            });\n        }\n        // Commit transaction\n        await client.query('COMMIT');\n        res.json({\n            success: true,\n            message: 'Tenant deleted successfully'\n        });\n    }\n    catch (error) {\n        console.error('Error deleting tenant:', error);\n        await client.query('ROLLBACK');\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Get tenant users (super admin only)\n * GET /superadmin/tenants/:id/users\n */\nrouter.get('/tenants/:id/users', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    const { id } = req.params;\n    try {\n        const client = await (0, database_1.getClient)();\n        const result = await client.query(`\r\n      SELECT id, email, first_name, last_name, role, status, created_at, updated_at\r\n      FROM users \r\n      WHERE tenant_id = $1\r\n      ORDER BY created_at DESC\r\n    `, [id]);\n        res.json({\n            success: true,\n            data: result.rows\n        });\n    }\n    catch (error) {\n        console.error('Error fetching tenant users:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\n/**\n * Create user for tenant (super admin only)\n * POST /superadmin/tenants/:id/users\n */\nrouter.post('/tenants/:id/users', auth_middleware_1.authenticateJWT, auth_middleware_1.requireSuperAdmin, async (req, res) => {\n    const { id } = req.params;\n    const { email, password, firstName, lastName, role } = req.body;\n    if (!email || !password || !firstName || !lastName || !role) {\n        return res.status(400).json({\n            success: false,\n            error: 'Missing required fields: email, password, firstName, lastName, role'\n        });\n    }\n    try {\n        const client = await (0, database_1.getClient)();\n        const hashedPassword = await bcrypt_1.default.hash(password, 10);\n        const result = await client.query(`\r\n      INSERT INTO users (tenant_id, email, password_hash, first_name, last_name, role, status)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n      RETURNING id, email, first_name, last_name, role, status, created_at\r\n    `, [id, email, hashedPassword, firstName, lastName, role, 'active']);\n        res.json({\n            success: true,\n            data: result.rows[0],\n            message: 'User created successfully'\n        });\n    }\n    catch (error) {\n        console.error('Error creating user:', error);\n        res.status(500).json({\n            success: false,\n            error: 'Internal server error'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=superadmin.routes.js.map","size_bytes":8605},"voip-system/packages/backend/dist/routes/cdr-activity-routes.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst cdr_activity_service_1 = require(\"../services/cdr-activity-service\");\nconst tenant_context_1 = require(\"../middleware/tenant-context\");\nconst router = (0, express_1.Router)();\nconst cdrActivityService = new cdr_activity_service_1.CdrActivityService();\n// Apply tenant context middleware to all routes\nrouter.use(tenant_context_1.tenantContextMiddleware);\n// ===== VOIP CDR =====\nrouter.post('/cdr', async (req, res) => {\n    try {\n        const cdrData = req.body;\n        const cdr = await cdrActivityService.createCdr(cdrData);\n        res.status(201).json({\n            success: true,\n            data: cdr\n        });\n    }\n    catch (error) {\n        console.error('Error creating CDR:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create CDR',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/cdr', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const filters = {\n            tenant_id: tenantId,\n            store_id: req.query.store_id,\n            start_date: req.query.start_date,\n            end_date: req.query.end_date,\n            direction: req.query.direction,\n            disposition: req.query.disposition,\n            ext_number: req.query.ext_number,\n            did_e164: req.query.did_e164,\n            limit: req.query.limit ? parseInt(req.query.limit) : 100,\n            offset: req.query.offset ? parseInt(req.query.offset) : 0\n        };\n        const result = await cdrActivityService.getCdrs(filters);\n        res.json({\n            success: true,\n            data: result.cdrs,\n            pagination: {\n                total: result.total,\n                limit: filters.limit,\n                offset: filters.offset,\n                has_more: (filters.offset + filters.limit) < result.total\n            }\n        });\n    }\n    catch (error) {\n        console.error('Error fetching CDRs:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch CDRs',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/cdr/stats', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const storeId = req.query.store_id;\n        const startDate = req.query.start_date;\n        const endDate = req.query.end_date;\n        const stats = await cdrActivityService.getCdrStats(tenantId, storeId, startDate, endDate);\n        res.json({\n            success: true,\n            data: stats\n        });\n    }\n    catch (error) {\n        console.error('Error fetching CDR stats:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch CDR stats',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/cdr/:id', async (req, res) => {\n    try {\n        const cdrId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const cdr = await cdrActivityService.getCdrById(cdrId, tenantId);\n        if (!cdr) {\n            return res.status(404).json({\n                success: false,\n                message: 'CDR not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: cdr\n        });\n    }\n    catch (error) {\n        console.error('Error fetching CDR:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch CDR',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== VOIP ACTIVITY LOG =====\nrouter.post('/activity-log', async (req, res) => {\n    try {\n        const logData = req.body;\n        const log = await cdrActivityService.createActivityLog(req.tenantContext, logData);\n        res.status(201).json({\n            success: true,\n            data: log\n        });\n    }\n    catch (error) {\n        console.error('Error creating activity log:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create activity log',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/activity-log', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const filters = {\n            tenant_id: tenantId,\n            actor: req.query.actor,\n            action: req.query.action,\n            target_type: req.query.target_type,\n            target_id: req.query.target_id,\n            status: req.query.status,\n            start_date: req.query.start_date,\n            end_date: req.query.end_date,\n            limit: req.query.limit ? parseInt(req.query.limit) : 100,\n            offset: req.query.offset ? parseInt(req.query.offset) : 0\n        };\n        const result = await cdrActivityService.getActivityLogs(filters);\n        res.json({\n            success: true,\n            data: result.logs,\n            pagination: {\n                total: result.total,\n                limit: filters.limit,\n                offset: filters.offset,\n                has_more: (filters.offset + filters.limit) < result.total\n            }\n        });\n    }\n    catch (error) {\n        console.error('Error fetching activity logs:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch activity logs',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/activity-log/:id', async (req, res) => {\n    try {\n        const logId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const log = await cdrActivityService.getActivityLogById(logId, tenantId);\n        if (!log) {\n            return res.status(404).json({\n                success: false,\n                message: 'Activity log not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: log\n        });\n    }\n    catch (error) {\n        console.error('Error fetching activity log:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch activity log',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/activity-log/stats', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const startDate = req.query.start_date;\n        const endDate = req.query.end_date;\n        const stats = await cdrActivityService.getActivityStats(tenantId, startDate, endDate);\n        res.json({\n            success: true,\n            data: stats\n        });\n    }\n    catch (error) {\n        console.error('Error fetching activity stats:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch activity stats',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== UTILITY ENDPOINTS =====\nrouter.post('/generate-mock-data', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const sipDomain = req.tenantContext.sip_domain;\n        await cdrActivityService.generateMockData(tenantId, sipDomain);\n        res.json({\n            success: true,\n            message: 'Mock data generated successfully'\n        });\n    }\n    catch (error) {\n        console.error('Error generating mock data:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to generate mock data',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=cdr-activity-routes.js.map","size_bytes":7937},"voip-system/packages/backend/dist/routes/w3-voip-routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=w3-voip-routes.d.ts.map","size_bytes":133},"voip-system/packages/backend/dist/routes/voip-routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=voip-routes.d.ts.map","size_bytes":130},"voip-system/packages/backend/dist/middleware/tenant-context.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tenantContextMiddleware = tenantContextMiddleware;\nexports.generateSipDomain = generateSipDomain;\nexports.validateSipDomain = validateSipDomain;\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\nconst pg_1 = require(\"pg\");\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\n// Load environment variables\ndotenv_1.default.config();\n// PostgreSQL connection pool\nconst pool = new pg_1.Pool({\n    connectionString: process.env.DATABASE_URL\n});\nasync function tenantContextMiddleware(req, res, next) {\n    try {\n        // Extract token from Authorization header\n        const authHeader = req.headers.authorization;\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n            return res.status(401).json({ error: 'No valid authorization header' });\n        }\n        const token = authHeader.split(' ')[1];\n        const JWT_SECRET = process.env.JWT_SECRET || 'edg-voip-secret-key-2024';\n        // Verify and decode JWT\n        const payload = jsonwebtoken_1.default.verify(token, JWT_SECRET);\n        if (!payload.tenant_id) {\n            return res.status(401).json({ error: 'No tenant_id in JWT payload' });\n        }\n        // Fetch tenant from database\n        const result = await pool.query('SELECT id, name, sip_domain FROM tenants WHERE id = $1 AND status = $2', [payload.tenant_id, 'active']);\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Tenant not found' });\n        }\n        const tenant = result.rows[0];\n        // Extract store_id from request body or query params (optional)\n        const store_id = req.body?.store_id || req.query?.store_id;\n        // Add tenant context to request\n        req.tenantContext = {\n            tenant_id: payload.tenant_id,\n            sip_domain: tenant.sip_domain,\n            store_id: store_id\n        };\n        next();\n    }\n    catch (error) {\n        console.error('Tenant context middleware error:', error);\n        return res.status(401).json({ error: 'Invalid token' });\n    }\n}\n// Helper function to generate SIP domain from tenant name\nfunction generateSipDomain(tenantName) {\n    return `${tenantName\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, '-')\n        .replace(/[^a-z0-9-]/g, '')}.edgvoip.it`;\n}\n// Helper function to validate SIP domain format\nfunction validateSipDomain(sipDomain) {\n    const regex = /^[a-z0-9-]+\\.edgvoip\\.it$/;\n    return regex.test(sipDomain) && sipDomain.length <= 253;\n}\n//# sourceMappingURL=tenant-context.js.map","size_bytes":2728},"voip-system/packages/backend/dist/middleware/auth.middleware.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { JWTPayload } from '@w3-voip/shared';\nexport interface AuthenticatedRequest extends Request {\n    user?: JWTPayload & {\n        id?: string;\n        email?: string;\n        tenant_slug?: string;\n    };\n}\n/**\n * Middleware to authenticate JWT tokens\n */\nexport declare function authenticateJWT(req: AuthenticatedRequest, res: Response, next: NextFunction): Response<any, Record<string, any>>;\n/**\n * Middleware to require super admin role\n */\nexport declare function requireSuperAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction): Response<any, Record<string, any>>;\n/**\n * Middleware to require admin role (super admin or tenant admin)\n */\nexport declare function requireAdmin(req: AuthenticatedRequest, res: Response, next: NextFunction): Response<any, Record<string, any>>;\n/**\n * Middleware to require tenant access (user must belong to the tenant)\n */\nexport declare function requireTenantAccess(req: AuthenticatedRequest, res: Response, next: NextFunction): void | Response<any, Record<string, any>>;\n//# sourceMappingURL=auth.middleware.d.ts.map","size_bytes":1135},"voip-system/packages/backend/dist/middleware/index.js":{"content":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Export all middleware\n__exportStar(require(\"./auth\"), exports);\n__exportStar(require(\"./tenant\"), exports);\n__exportStar(require(\"./security\"), exports);\n__exportStar(require(\"./validation\"), exports);\n//# sourceMappingURL=index.js.map","size_bytes":995},"voip-system/packages/backend/dist/routes/sip-trunks.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst middleware_1 = require(\"../middleware\");\nconst response_1 = require(\"../utils/response\");\nconst router = (0, express_1.Router)();\n// Apply authentication and tenant context to all routes\nrouter.use(middleware_1.authenticateToken);\nrouter.use(middleware_1.requireTenant);\nrouter.use(middleware_1.setTenantContext);\n// Get SIP trunks for tenant\nrouter.get('/', (0, response_1.asyncHandler)(async (req, res) => {\n    try {\n        // For now, return the MessageNet trunk configuration\n        // In a real implementation, this would come from the database\n        const trunks = [\n            {\n                id: 'messagenet',\n                name: 'MessageNet',\n                provider: 'MessageNet',\n                host: 'sip.messagenet.it',\n                port: 5060,\n                username: '5406594427',\n                status: 'registered',\n                type: 'sip',\n                tenant_id: req.tenantId,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }\n        ];\n        (0, response_1.successResponse)(res, trunks, 'SIP trunks retrieved successfully');\n    }\n    catch (error) {\n        console.error('Error fetching SIP trunks:', error);\n        (0, response_1.errorResponse)(res, 'Failed to fetch SIP trunks', 500);\n    }\n}));\n// Get SIP trunk status\nrouter.get('/:id/status', (0, response_1.asyncHandler)(async (req, res) => {\n    const trunkId = req.params.id;\n    try {\n        // For MessageNet trunk, return the status from FreeSWITCH\n        if (trunkId === 'messagenet') {\n            // This would normally query FreeSWITCH ESL for real status\n            const status = {\n                id: trunkId,\n                name: 'MessageNet',\n                status: 'registered',\n                last_registration: new Date().toISOString(),\n                calls_in: 0,\n                calls_out: 0,\n                failed_calls: 0\n            };\n            (0, response_1.successResponse)(res, status, 'SIP trunk status retrieved successfully');\n        }\n        else {\n            (0, response_1.errorResponse)(res, 'SIP trunk not found', 404);\n        }\n    }\n    catch (error) {\n        console.error('Error fetching SIP trunk status:', error);\n        (0, response_1.errorResponse)(res, 'Failed to fetch SIP trunk status', 500);\n    }\n}));\nexports.default = router;\n//# sourceMappingURL=sip-trunks.js.map","size_bytes":2529},"voip-system/packages/backend/dist/routes/voip.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=voip.d.ts.map","size_bytes":123},"voip-system/packages/backend/dist/middleware/auth.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyToken = exports.generateToken = exports.optionalAuth = exports.requireStoreAccess = exports.requirePermission = exports.requireRole = exports.requireSuperAdmin = exports.requireTenant = exports.authenticateToken = void 0;\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\n// JWT Authentication Middleware\nconst authenticateToken = (req, res, next) => {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n    if (!token) {\n        return res.status(401).json({\n            success: false,\n            error: {\n                code: 'MISSING_TOKEN',\n                message: 'Access token required'\n            }\n        });\n    }\n    try {\n        const secret = process.env.JWT_SECRET;\n        if (!secret) {\n            throw new Error('JWT_SECRET not configured');\n        }\n        const decoded = jsonwebtoken_1.default.verify(token, secret);\n        // Set user context\n        req.user = decoded;\n        req.tenantId = decoded.tenant_id;\n        req.storeId = decoded.store_id;\n        next();\n    }\n    catch (error) {\n        return res.status(403).json({\n            success: false,\n            error: {\n                code: 'INVALID_TOKEN',\n                message: 'Invalid or expired token'\n            }\n        });\n    }\n};\nexports.authenticateToken = authenticateToken;\n// Tenant Isolation Middleware\nconst requireTenant = (req, res, next) => {\n    if (!req.tenantId) {\n        return res.status(400).json({\n            success: false,\n            error: {\n                code: 'TENANT_REQUIRED',\n                message: 'Tenant context required'\n            }\n        });\n    }\n    next();\n};\nexports.requireTenant = requireTenant;\n// Super Admin Access Middleware\nconst requireSuperAdmin = (req, res, next) => {\n    if (req.user?.role !== 'super_admin') {\n        return res.status(403).json({\n            success: false,\n            error: {\n                code: 'SUPER_ADMIN_REQUIRED',\n                message: 'Super admin access required'\n            }\n        });\n    }\n    next();\n};\nexports.requireSuperAdmin = requireSuperAdmin;\n// Role-based Authorization Middleware\nconst requireRole = (roles) => {\n    return (req, res, next) => {\n        if (!req.user) {\n            return res.status(401).json({\n                success: false,\n                error: {\n                    code: 'AUTHENTICATION_REQUIRED',\n                    message: 'Authentication required'\n                }\n            });\n        }\n        if (!roles.includes(req.user.role)) {\n            return res.status(403).json({\n                success: false,\n                error: {\n                    code: 'INSUFFICIENT_PERMISSIONS',\n                    message: `Required role: ${roles.join(' or ')}`\n                }\n            });\n        }\n        next();\n    };\n};\nexports.requireRole = requireRole;\n// Permission-based Authorization Middleware\nconst requirePermission = (permission) => {\n    return (req, res, next) => {\n        if (!req.user) {\n            return res.status(401).json({\n                success: false,\n                error: {\n                    code: 'AUTHENTICATION_REQUIRED',\n                    message: 'Authentication required'\n                }\n            });\n        }\n        if (!req.user.permissions.includes(permission)) {\n            return res.status(403).json({\n                success: false,\n                error: {\n                    code: 'INSUFFICIENT_PERMISSIONS',\n                    message: `Required permission: ${permission}`\n                }\n            });\n        }\n        next();\n    };\n};\nexports.requirePermission = requirePermission;\n// Store Access Middleware\nconst requireStoreAccess = (req, res, next) => {\n    const storeId = req.params.storeId || req.body.storeId || req.query.storeId;\n    if (!storeId) {\n        return res.status(400).json({\n            success: false,\n            error: {\n                code: 'STORE_ID_REQUIRED',\n                message: 'Store ID required'\n            }\n        });\n    }\n    // If user has store_id in token, verify it matches\n    if (req.user.store_id && req.user.store_id !== storeId) {\n        return res.status(403).json({\n            success: false,\n            error: {\n                code: 'STORE_ACCESS_DENIED',\n                message: 'Access denied to this store'\n            }\n        });\n    }\n    req.storeId = storeId;\n    next();\n};\nexports.requireStoreAccess = requireStoreAccess;\n// Optional Authentication Middleware (for public endpoints)\nconst optionalAuth = (req, res, next) => {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n    if (token) {\n        try {\n            const secret = process.env.JWT_SECRET;\n            if (secret) {\n                const decoded = jsonwebtoken_1.default.verify(token, secret);\n                req.user = decoded;\n                req.tenantId = decoded.tenant_id;\n                req.storeId = decoded.store_id;\n            }\n        }\n        catch (error) {\n            // Ignore token errors for optional auth\n        }\n    }\n    next();\n};\nexports.optionalAuth = optionalAuth;\n// Generate JWT Token\nconst generateToken = (payload) => {\n    const secret = process.env.JWT_SECRET;\n    if (!secret) {\n        throw new Error('JWT_SECRET not configured');\n    }\n    const expiresIn = process.env.JWT_EXPIRES_IN || '24h';\n    return jsonwebtoken_1.default.sign(payload, secret, { expiresIn });\n};\nexports.generateToken = generateToken;\n// Verify JWT Token\nconst verifyToken = (token) => {\n    const secret = process.env.JWT_SECRET;\n    if (!secret) {\n        throw new Error('JWT_SECRET not configured');\n    }\n    return jsonwebtoken_1.default.verify(token, secret);\n};\nexports.verifyToken = verifyToken;\n//# sourceMappingURL=auth.js.map","size_bytes":6097},"voip-system/packages/backend/dist/routes/w3-voip-routes.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst w3_voip_service_1 = require(\"../services/w3-voip-service\");\nconst tenant_context_1 = require(\"../middleware/tenant-context\");\nconst router = (0, express_1.Router)();\nconst w3VoipService = new w3_voip_service_1.W3VoipService();\n// Apply tenant context middleware to all routes\nrouter.use(tenant_context_1.tenantContextMiddleware);\n// ===== VOIP TRUNKS =====\nrouter.post('/trunks', async (req, res) => {\n    try {\n        const data = req.body;\n        const trunk = await w3VoipService.createTrunk(req.tenantContext, data);\n        res.status(201).json({\n            success: true,\n            data: trunk\n        });\n    }\n    catch (error) {\n        console.error('Error creating trunk:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create trunk',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/trunks', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const storeId = req.query.store_id;\n        const trunks = await w3VoipService.getTrunks(tenantId, storeId);\n        res.json({\n            success: true,\n            data: trunks\n        });\n    }\n    catch (error) {\n        console.error('Error fetching trunks:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch trunks',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const trunk = await w3VoipService.getTrunkById(trunkId, tenantId);\n        if (!trunk) {\n            return res.status(404).json({\n                success: false,\n                message: 'Trunk not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: trunk\n        });\n    }\n    catch (error) {\n        console.error('Error fetching trunk:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch trunk',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.put('/trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const data = req.body;\n        const trunk = await w3VoipService.updateTrunk(trunkId, tenantId, data);\n        if (!trunk) {\n            return res.status(404).json({\n                success: false,\n                message: 'Trunk not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: trunk\n        });\n    }\n    catch (error) {\n        console.error('Error updating trunk:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to update trunk',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.delete('/trunks/:id', async (req, res) => {\n    try {\n        const trunkId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const deleted = await w3VoipService.deleteTrunk(trunkId, tenantId);\n        if (!deleted) {\n            return res.status(404).json({\n                success: false,\n                message: 'Trunk not found'\n            });\n        }\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting trunk:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to delete trunk',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== VOIP DIDS =====\nrouter.post('/dids', async (req, res) => {\n    try {\n        const data = req.body;\n        const did = await w3VoipService.createDid(req.tenantContext, data);\n        res.status(201).json({\n            success: true,\n            data: did\n        });\n    }\n    catch (error) {\n        console.error('Error creating DID:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create DID',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/dids', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const storeId = req.query.store_id;\n        const dids = await w3VoipService.getDids(tenantId, storeId);\n        res.json({\n            success: true,\n            data: dids\n        });\n    }\n    catch (error) {\n        console.error('Error fetching DIDs:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch DIDs',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/dids/:id', async (req, res) => {\n    try {\n        const didId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const did = await w3VoipService.getDidById(didId, tenantId);\n        if (!did) {\n            return res.status(404).json({\n                success: false,\n                message: 'DID not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: did\n        });\n    }\n    catch (error) {\n        console.error('Error fetching DID:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch DID',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.put('/dids/:id', async (req, res) => {\n    try {\n        const didId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const data = req.body;\n        const did = await w3VoipService.updateDid(didId, tenantId, data);\n        if (!did) {\n            return res.status(404).json({\n                success: false,\n                message: 'DID not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: did\n        });\n    }\n    catch (error) {\n        console.error('Error updating DID:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to update DID',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.delete('/dids/:id', async (req, res) => {\n    try {\n        const didId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const deleted = await w3VoipService.deleteDid(didId, tenantId);\n        if (!deleted) {\n            return res.status(404).json({\n                success: false,\n                message: 'DID not found'\n            });\n        }\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting DID:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to delete DID',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== VOIP EXTENSIONS =====\nrouter.post('/extensions', async (req, res) => {\n    try {\n        const data = req.body;\n        const extension = await w3VoipService.createExtension(req.tenantContext, data);\n        res.status(201).json({\n            success: true,\n            data: extension\n        });\n    }\n    catch (error) {\n        console.error('Error creating extension:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create extension',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/extensions', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const storeId = req.query.store_id;\n        const extensions = await w3VoipService.getExtensions(tenantId, storeId);\n        res.json({\n            success: true,\n            data: extensions\n        });\n    }\n    catch (error) {\n        console.error('Error fetching extensions:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch extensions',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const extension = await w3VoipService.getExtensionById(extensionId, tenantId);\n        if (!extension) {\n            return res.status(404).json({\n                success: false,\n                message: 'Extension not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: extension\n        });\n    }\n    catch (error) {\n        console.error('Error fetching extension:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch extension',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.put('/extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const data = req.body;\n        const extension = await w3VoipService.updateExtension(extensionId, tenantId, data);\n        if (!extension) {\n            return res.status(404).json({\n                success: false,\n                message: 'Extension not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: extension\n        });\n    }\n    catch (error) {\n        console.error('Error updating extension:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to update extension',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.delete('/extensions/:id', async (req, res) => {\n    try {\n        const extensionId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const deleted = await w3VoipService.deleteExtension(extensionId, tenantId);\n        if (!deleted) {\n            return res.status(404).json({\n                success: false,\n                message: 'Extension not found'\n            });\n        }\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting extension:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to delete extension',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== VOIP ROUTES =====\nrouter.post('/routes', async (req, res) => {\n    try {\n        const data = req.body;\n        const route = await w3VoipService.createRoute(req.tenantContext, data);\n        res.status(201).json({\n            success: true,\n            data: route\n        });\n    }\n    catch (error) {\n        console.error('Error creating route:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create route',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/routes', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const routes = await w3VoipService.getRoutes(tenantId);\n        res.json({\n            success: true,\n            data: routes\n        });\n    }\n    catch (error) {\n        console.error('Error fetching routes:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch routes',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const route = await w3VoipService.getRouteById(routeId, tenantId);\n        if (!route) {\n            return res.status(404).json({\n                success: false,\n                message: 'Route not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: route\n        });\n    }\n    catch (error) {\n        console.error('Error fetching route:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch route',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.put('/routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const data = req.body;\n        const route = await w3VoipService.updateRoute(routeId, tenantId, data);\n        if (!route) {\n            return res.status(404).json({\n                success: false,\n                message: 'Route not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: route\n        });\n    }\n    catch (error) {\n        console.error('Error updating route:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to update route',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.delete('/routes/:id', async (req, res) => {\n    try {\n        const routeId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const deleted = await w3VoipService.deleteRoute(routeId, tenantId);\n        if (!deleted) {\n            return res.status(404).json({\n                success: false,\n                message: 'Route not found'\n            });\n        }\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting route:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to delete route',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// ===== CONTACT POLICIES =====\nrouter.post('/contact-policies', async (req, res) => {\n    try {\n        const data = req.body;\n        const policy = await w3VoipService.createContactPolicy(req.tenantContext, data);\n        res.status(201).json({\n            success: true,\n            data: policy\n        });\n    }\n    catch (error) {\n        console.error('Error creating contact policy:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create contact policy',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/contact-policies', async (req, res) => {\n    try {\n        const tenantId = req.tenantContext.tenant_id;\n        const policies = await w3VoipService.getContactPolicies(tenantId);\n        res.json({\n            success: true,\n            data: policies\n        });\n    }\n    catch (error) {\n        console.error('Error fetching contact policies:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch contact policies',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.get('/contact-policies/:id', async (req, res) => {\n    try {\n        const policyId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const policy = await w3VoipService.getContactPolicyById(policyId, tenantId);\n        if (!policy) {\n            return res.status(404).json({\n                success: false,\n                message: 'Contact policy not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: policy\n        });\n    }\n    catch (error) {\n        console.error('Error fetching contact policy:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch contact policy',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.put('/contact-policies/:id', async (req, res) => {\n    try {\n        const policyId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const data = req.body;\n        const policy = await w3VoipService.updateContactPolicy(policyId, tenantId, data);\n        if (!policy) {\n            return res.status(404).json({\n                success: false,\n                message: 'Contact policy not found'\n            });\n        }\n        res.json({\n            success: true,\n            data: policy\n        });\n    }\n    catch (error) {\n        console.error('Error updating contact policy:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to update contact policy',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nrouter.delete('/contact-policies/:id', async (req, res) => {\n    try {\n        const policyId = req.params.id;\n        const tenantId = req.tenantContext.tenant_id;\n        const deleted = await w3VoipService.deleteContactPolicy(policyId, tenantId);\n        if (!deleted) {\n            return res.status(404).json({\n                success: false,\n                message: 'Contact policy not found'\n            });\n        }\n        res.status(204).send();\n    }\n    catch (error) {\n        console.error('Error deleting contact policy:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to delete contact policy',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=w3-voip-routes.js.map","size_bytes":17881},"voip-system/packages/backend/dist/routes/extensions.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=extensions.d.ts.map","size_bytes":129},"voip-system/packages/backend/dist/middleware/security.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.securityEventLogger = exports.ipWhitelist = exports.requestSizeLimit = exports.validateContentType = exports.sanitizeInput = exports.cdrRateLimit = exports.authRateLimit = exports.apiRateLimit = exports.createRateLimit = exports.requestId = exports.securityHeaders = void 0;\nconst express_rate_limit_1 = __importDefault(require(\"express-rate-limit\"));\nconst helmet_1 = __importDefault(require(\"helmet\"));\nconst uuid_1 = require(\"uuid\");\n// Security Headers Middleware\nexports.securityHeaders = (0, helmet_1.default)({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\n            fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n            imgSrc: [\"'self'\", \"data:\", \"https:\"],\n            scriptSrc: [\"'self'\"],\n            connectSrc: [\"'self'\", \"ws:\", \"wss:\"],\n            frameSrc: [\"'none'\"],\n            objectSrc: [\"'none'\"],\n            upgradeInsecureRequests: [],\n        },\n    },\n    hsts: {\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true\n    },\n    noSniff: true,\n    xssFilter: true,\n    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n});\n// Request ID Middleware\nconst requestId = (req, res, next) => {\n    req.id = req.headers['x-request-id'] || (0, uuid_1.v4)();\n    res.set('X-Request-ID', req.id);\n    next();\n};\nexports.requestId = requestId;\n// Rate Limiting Middleware\nconst createRateLimit = (windowMs, max, message) => {\n    return (0, express_rate_limit_1.default)({\n        windowMs,\n        max,\n        message: {\n            success: false,\n            error: {\n                code: 'RATE_LIMIT_EXCEEDED',\n                message: message || `Too many requests, please try again later.`\n            }\n        },\n        standardHeaders: true,\n        legacyHeaders: false,\n        keyGenerator: (req) => {\n            // Use tenant ID if available, otherwise IP\n            const tenantId = req.tenantId;\n            return tenantId ? `tenant:${tenantId}` : req.ip;\n        }\n    });\n};\nexports.createRateLimit = createRateLimit;\n// General API Rate Limiting\nexports.apiRateLimit = (0, exports.createRateLimit)(15 * 60 * 1000, // 15 minutes\n100, // 100 requests per window\n'API rate limit exceeded. Max 100 requests per 15 minutes.');\n// Authentication Rate Limiting\nexports.authRateLimit = (0, exports.createRateLimit)(15 * 60 * 1000, // 15 minutes\n5, // 5 requests per window\n'Authentication rate limit exceeded. Max 5 attempts per 15 minutes.');\n// CDR Webhook Rate Limiting\nexports.cdrRateLimit = (0, exports.createRateLimit)(60 * 1000, // 1 minute\n1000, // 1000 requests per minute\n'CDR webhook rate limit exceeded.');\n// Input Sanitization Middleware\nconst sanitizeInput = (req, res, next) => {\n    // Remove potentially dangerous characters from string inputs\n    const sanitizeString = (str) => {\n        return str\n            .replace(/[<>]/g, '') // Remove < and >\n            .replace(/javascript:/gi, '') // Remove javascript: protocol\n            .replace(/on\\w+=/gi, '') // Remove event handlers\n            .trim();\n    };\n    // Recursively sanitize object properties\n    const sanitizeObject = (obj) => {\n        if (typeof obj === 'string') {\n            return sanitizeString(obj);\n        }\n        if (Array.isArray(obj)) {\n            return obj.map(sanitizeObject);\n        }\n        if (obj && typeof obj === 'object') {\n            const sanitized = {};\n            for (const [key, value] of Object.entries(obj)) {\n                sanitized[key] = sanitizeObject(value);\n            }\n            return sanitized;\n        }\n        return obj;\n    };\n    // Sanitize request body, query, and params\n    if (req.body) {\n        req.body = sanitizeObject(req.body);\n    }\n    if (req.query) {\n        req.query = sanitizeObject(req.query);\n    }\n    if (req.params) {\n        req.params = sanitizeObject(req.params);\n    }\n    next();\n};\nexports.sanitizeInput = sanitizeInput;\n// Content Type Validation Middleware\nconst validateContentType = (allowedTypes = ['application/json']) => {\n    return (req, res, next) => {\n        if (req.method === 'GET' || req.method === 'DELETE') {\n            return next();\n        }\n        const contentType = req.headers['content-type'];\n        if (!contentType) {\n            return res.status(400).json({\n                success: false,\n                error: {\n                    code: 'CONTENT_TYPE_REQUIRED',\n                    message: 'Content-Type header is required'\n                }\n            });\n        }\n        const isValidType = allowedTypes.some(type => contentType.toLowerCase().includes(type.toLowerCase()));\n        if (!isValidType) {\n            return res.status(415).json({\n                success: false,\n                error: {\n                    code: 'UNSUPPORTED_CONTENT_TYPE',\n                    message: `Content-Type must be one of: ${allowedTypes.join(', ')}`\n                }\n            });\n        }\n        next();\n    };\n};\nexports.validateContentType = validateContentType;\n// Request Size Limiting Middleware\nconst requestSizeLimit = (maxSize = '10mb') => {\n    return (req, res, next) => {\n        const contentLength = parseInt(req.headers['content-length'] || '0');\n        const maxBytes = parseSize(maxSize);\n        if (contentLength > maxBytes) {\n            return res.status(413).json({\n                success: false,\n                error: {\n                    code: 'REQUEST_TOO_LARGE',\n                    message: `Request size exceeds limit of ${maxSize}`\n                }\n            });\n        }\n        next();\n    };\n};\nexports.requestSizeLimit = requestSizeLimit;\n// Parse size string to bytes\nfunction parseSize(size) {\n    const units = {\n        b: 1,\n        kb: 1024,\n        mb: 1024 * 1024,\n        gb: 1024 * 1024 * 1024\n    };\n    const match = size.toLowerCase().match(/^(\\d+(?:\\.\\d+)?)\\s*(b|kb|mb|gb)?$/);\n    if (!match) {\n        throw new Error(`Invalid size format: ${size}`);\n    }\n    const value = parseFloat(match[1]);\n    const unit = match[2] || 'b';\n    return Math.floor(value * units[unit]);\n}\n// IP Whitelist Middleware\nconst ipWhitelist = (allowedIPs) => {\n    return (req, res, next) => {\n        const clientIP = req.ip || req.connection.remoteAddress;\n        if (!clientIP) {\n            return res.status(400).json({\n                success: false,\n                error: {\n                    code: 'IP_NOT_DETECTED',\n                    message: 'Unable to detect client IP address'\n                }\n            });\n        }\n        const isAllowed = allowedIPs.some(allowedIP => {\n            if (allowedIP.includes('/')) {\n                // CIDR notation\n                return isIPInCIDR(clientIP, allowedIP);\n            }\n            else {\n                // Exact match\n                return clientIP === allowedIP;\n            }\n        });\n        if (!isAllowed) {\n            return res.status(403).json({\n                success: false,\n                error: {\n                    code: 'IP_NOT_ALLOWED',\n                    message: 'IP address not in whitelist'\n                }\n            });\n        }\n        next();\n    };\n};\nexports.ipWhitelist = ipWhitelist;\n// Check if IP is in CIDR range\nfunction isIPInCIDR(ip, cidr) {\n    const [network, prefixLength] = cidr.split('/');\n    const ipNum = ipToNumber(ip);\n    const networkNum = ipToNumber(network);\n    const mask = (0xffffffff << (32 - parseInt(prefixLength))) >>> 0;\n    return (ipNum & mask) === (networkNum & mask);\n}\n// Convert IP to number\nfunction ipToNumber(ip) {\n    return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;\n}\n// Security Event Logging Middleware\nconst securityEventLogger = (req, res, next) => {\n    const originalSend = res.send;\n    res.send = function (data) {\n        // Log security events\n        if (res.statusCode >= 400) {\n            const securityEvent = {\n                timestamp: new Date().toISOString(),\n                requestId: req.id,\n                method: req.method,\n                url: req.url,\n                ip: req.ip,\n                userAgent: req.headers['user-agent'],\n                statusCode: res.statusCode,\n                tenantId: req.tenantId,\n                userId: req.user?.sub\n            };\n            console.warn('Security Event:', securityEvent);\n        }\n        return originalSend.call(this, data);\n    };\n    next();\n};\nexports.securityEventLogger = securityEventLogger;\n//# sourceMappingURL=security.js.map","size_bytes":8799},"voip-system/packages/backend/dist/index.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.io = exports.server = exports.app = void 0;\nconst express_1 = __importDefault(require(\"express\"));\nconst cors_1 = __importDefault(require(\"cors\"));\nconst compression_1 = __importDefault(require(\"compression\"));\nconst morgan_1 = __importDefault(require(\"morgan\"));\nconst dotenv_1 = __importDefault(require(\"dotenv\"));\nconst http_1 = require(\"http\");\nconst socket_io_1 = require(\"socket.io\");\n// Load environment variables\ndotenv_1.default.config();\n// Import middleware\nconst security_1 = require(\"./middleware/security\");\nconst logger_1 = require(\"./utils/logger\");\nconst response_1 = require(\"./utils/response\");\n// Import routes\nconst routes_1 = __importDefault(require(\"./routes\"));\n// Import database\nconst database_1 = require(\"@w3-voip/database\");\nconst app = (0, express_1.default)();\nexports.app = app;\nconst server = (0, http_1.createServer)(app);\nexports.server = server;\nconst io = new socket_io_1.Server(server, {\n    cors: {\n        origin: process.env.CORS_ORIGIN || 'http://192.168.172.234:3000',\n        methods: ['GET', 'POST']\n    }\n});\nexports.io = io;\nconst PORT = process.env.PORT || 3001;\n// SICUREZZA: JWT_SECRET deve essere configurato in produzione\nif (!process.env.JWT_SECRET && process.env.NODE_ENV === 'production') {\n    console.error('❌ ERRORE CRITICO: JWT_SECRET non configurato in produzione!');\n    process.exit(1);\n}\nconst JWT_SECRET = process.env.JWT_SECRET || 'edg-voip-secret-key-2024-DEVELOPMENT-ONLY';\n// Security middleware\napp.use(security_1.securityHeaders);\napp.use(security_1.requestId);\napp.use(security_1.securityEventLogger);\n// CORS configuration - SICUREZZA: lista whitelist di origini permesse\nconst allowedOrigins = process.env.CORS_ORIGIN\n    ? process.env.CORS_ORIGIN.split(',')\n    : ['http://localhost:3000', 'http://192.168.172.234:3000'];\napp.use((0, cors_1.default)({\n    origin: (origin, callback) => {\n        // Permetti richieste senza origin (es. Postman, curl)\n        if (!origin)\n            return callback(null, true);\n        if (allowedOrigins.includes(origin)) {\n            callback(null, true);\n        }\n        else {\n            console.warn(`⚠️ CORS blocked origin: ${origin}`);\n            callback(new Error('Not allowed by CORS'));\n        }\n    },\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'X-Tenant-Slug']\n}));\n// Compression\napp.use((0, compression_1.default)());\n// Request logging\napp.use((0, morgan_1.default)('combined'));\napp.use(logger_1.requestLogger);\n// Debug middleware removed\n// Body parsing middleware\napp.use(express_1.default.json({ limit: '10mb' }));\napp.use(express_1.default.urlencoded({ extended: true, limit: '10mb' }));\n// Input sanitization (temporarily disabled for testing)\n// app.use(sanitizeInput);\n// Content type validation (temporarily disabled for testing)\n// app.use(validateContentType(['application/json']));\n// Request size limiting (temporarily disabled for testing)\n// app.use(requestSizeLimit('10mb'));\n// Rate limiting\napp.use('/api', security_1.apiRateLimit);\n// API routes\napp.use('/api', routes_1.default);\n// Root endpoint\napp.get('/', (req, res) => {\n    res.json({\n        success: true,\n        data: {\n            message: 'W3 VoIP System API',\n            version: process.env.npm_package_version || '1.0.0',\n            timestamp: new Date().toISOString(),\n            endpoints: {\n                health: '/api/health',\n                tenants: '/api/tenants',\n                stores: '/api/stores',\n                extensions: '/api/extensions'\n            }\n        }\n    });\n});\n// 404 handler\napp.use('*', (req, res) => {\n    res.status(404).json({\n        success: false,\n        error: {\n            code: 'NOT_FOUND',\n            message: 'Endpoint not found'\n        }\n    });\n});\n// Error handling middleware\napp.use(response_1.errorHandler);\n// Socket.IO connection handling\nio.on('connection', (socket) => {\n    console.log('Client connected:', socket.id);\n    // Join tenant room for real-time updates\n    socket.on('join-tenant', (tenantId) => {\n        socket.join(`tenant:${tenantId}`);\n        console.log(`Client ${socket.id} joined tenant: ${tenantId}`);\n    });\n    // Leave tenant room\n    socket.on('leave-tenant', (tenantId) => {\n        socket.leave(`tenant:${tenantId}`);\n        console.log(`Client ${socket.id} left tenant: ${tenantId}`);\n    });\n    socket.on('disconnect', () => {\n        console.log('Client disconnected:', socket.id);\n    });\n});\n// Make io available to other modules\napp.set('io', io);\n// Database health check\nasync function checkDatabaseHealth() {\n    try {\n        const isHealthy = await (0, database_1.healthCheck)();\n        if (!isHealthy) {\n            console.error('❌ Database health check failed');\n            process.exit(1);\n        }\n        console.log('✅ Database health check passed');\n    }\n    catch (error) {\n        console.error('❌ Database connection failed:', error);\n        process.exit(1);\n    }\n}\n// Start server\nasync function startServer() {\n    try {\n        // Check database health\n        await checkDatabaseHealth();\n        // Start HTTP server\n        server.listen(Number(PORT), '0.0.0.0', () => {\n            console.log(`🚀 W3 VoIP System API running on port ${PORT}`);\n            console.log(`📊 Environment: ${process.env.NODE_ENV || 'development'}`);\n            console.log(`🔗 CORS Origin: ${process.env.CORS_ORIGIN || 'http://192.168.172.234:3000'}`);\n            console.log(`📡 Socket.IO enabled for real-time updates`);\n        });\n    }\n    catch (error) {\n        console.error('❌ Failed to start server:', error);\n        process.exit(1);\n    }\n}\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n    console.log('🛑 SIGTERM received, shutting down gracefully');\n    server.close(() => {\n        console.log('✅ Server closed');\n        process.exit(0);\n    });\n});\nprocess.on('SIGINT', () => {\n    console.log('🛑 SIGINT received, shutting down gracefully');\n    server.close(() => {\n        console.log('✅ Server closed');\n        process.exit(0);\n    });\n});\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n    console.error('❌ Uncaught Exception:', error);\n    process.exit(1);\n});\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(1);\n});\n// Start the server\nstartServer();\n//# sourceMappingURL=index.js.map","size_bytes":6739},"voip-system/packages/backend/dist/routes/sip-test-routes.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=sip-test-routes.d.ts.map","size_bytes":134},"voip-system/packages/backend/dist/middleware/validation.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { ZodSchema } from 'zod';\nexport declare const handleValidationErrors: (req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare function validateRequest(schema: ZodSchema<any>, source?: 'body' | 'query' | 'params'): (req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const validateUUID: (field: string) => import(\"express-validator\").ValidationChain;\nexport declare const validateTenant: import(\"express-validator\").ValidationChain[];\nexport declare const validateStore: import(\"express-validator\").ValidationChain[];\nexport declare const validateExtension: import(\"express-validator\").ValidationChain[];\nexport declare const validateSipTrunk: import(\"express-validator\").ValidationChain[];\nexport declare const validateTrunkRegistration: import(\"express-validator\").ValidationChain[];\nexport declare const validateCDRFilter: import(\"express-validator\").ValidationChain[];\nexport declare const validatePagination: import(\"express-validator\").ValidationChain[];\nexport declare const validateSearch: import(\"express-validator\").ValidationChain[];\n//# sourceMappingURL=validation.d.ts.map","size_bytes":1251},"voip-system/packages/backend/dist/routes/extensions.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst extension_service_1 = require(\"../services/extension.service\");\nconst middleware_1 = require(\"../middleware\");\nconst response_1 = require(\"../utils/response\");\nconst router = (0, express_1.Router)();\nconst extensionService = new extension_service_1.ExtensionService();\n// Apply authentication and tenant context to all routes\nrouter.use(middleware_1.authenticateToken);\nrouter.use(middleware_1.requireTenant);\nrouter.use(middleware_1.setTenantContext);\n// Create extension\nrouter.post('/', middleware_1.validateExtension, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionData = {\n        ...req.body,\n        tenant_id: req.tenantId,\n        store_id: req.body.store_id || null\n    };\n    const extension = await extensionService.createExtension(extensionData);\n    (0, response_1.createdResponse)(res, extension, 'Extension created successfully');\n}));\n// List extensions for tenant\nrouter.get('/', middleware_1.validatePagination, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 50;\n    const search = req.query.q;\n    const storeId = req.query.store_id;\n    const result = await extensionService.listExtensions(req.tenantId, storeId, page, limit, search);\n    (0, response_1.paginatedResponse)(res, result.extensions, {\n        page,\n        limit,\n        total: result.total,\n        totalPages: result.totalPages\n    }, 'Extensions retrieved successfully');\n}));\n// Get extension by ID\nrouter.get('/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.getExtensionById(extensionId, req.tenantId);\n    if (!extension) {\n        return (0, response_1.notFoundResponse)(res, 'Extension not found');\n    }\n    (0, response_1.successResponse)(res, extension, 'Extension retrieved successfully');\n}));\n// Get extension by number\nrouter.get('/number/:extension', (0, response_1.asyncHandler)(async (req, res) => {\n    const extension = req.params.extension;\n    const ext = await extensionService.getExtensionByNumber(extension, req.tenantId);\n    if (!ext) {\n        return (0, response_1.notFoundResponse)(res, 'Extension not found');\n    }\n    (0, response_1.successResponse)(res, ext, 'Extension retrieved successfully');\n}));\n// Update extension\nrouter.put('/:id', middleware_1.validateExtension, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.updateExtension(extensionId, req.body, req.tenantId);\n    (0, response_1.updatedResponse)(res, extension, 'Extension updated successfully');\n}));\n// Delete extension\nrouter.delete('/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    await extensionService.deleteExtension(extensionId, req.tenantId);\n    (0, response_1.deletedResponse)(res, 'Extension deleted successfully');\n}));\n// Verify extension password (for authentication)\nrouter.post('/verify-password', (0, response_1.asyncHandler)(async (req, res) => {\n    const { extension, password } = req.body;\n    if (!extension || !password) {\n        return (0, response_1.errorResponse)(res, 'Extension and password are required', 400, 'MISSING_FIELDS');\n    }\n    const ext = await extensionService.verifyExtensionPassword(extension, password, req.tenantId);\n    if (!ext) {\n        return (0, response_1.errorResponse)(res, 'Invalid extension or password', 401, 'INVALID_CREDENTIALS');\n    }\n    (0, response_1.successResponse)(res, ext, 'Extension authenticated successfully');\n}));\n// Get extension registration status from FreeSWITCH\nrouter.get('/:id/status', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const status = await extensionService.getExtensionStatus(extensionId, req.tenantId);\n    (0, response_1.successResponse)(res, status, 'Extension status retrieved successfully');\n}));\n// Get extension statistics\nrouter.get('/:id/stats', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const stats = await extensionService.getExtensionStats(extensionId, req.tenantId);\n    (0, response_1.successResponse)(res, stats, 'Extension statistics retrieved successfully');\n}));\n// Activate extension\nrouter.post('/:id/activate', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.activateExtension(extensionId, req.tenantId);\n    (0, response_1.updatedResponse)(res, extension, 'Extension activated successfully');\n}));\n// Deactivate extension\nrouter.post('/:id/deactivate', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.deactivateExtension(extensionId, req.tenantId);\n    (0, response_1.updatedResponse)(res, extension, 'Extension deactivated successfully');\n}));\n// Lock extension\nrouter.post('/:id/lock', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.lockExtension(extensionId, req.tenantId);\n    (0, response_1.updatedResponse)(res, extension, 'Extension locked successfully');\n}));\n// Validate extension number uniqueness within tenant\nrouter.post('/validate-extension', (0, response_1.asyncHandler)(async (req, res) => {\n    const { extension, exclude_extension_id } = req.body;\n    if (!extension) {\n        return (0, response_1.errorResponse)(res, 'Extension number is required', 400, 'MISSING_FIELDS');\n    }\n    const isUnique = await extensionService.validateExtensionUniqueness(extension, req.tenantId, exclude_extension_id);\n    (0, response_1.successResponse)(res, { is_unique: isUnique }, 'Extension validation completed');\n}));\n// Get extensions by store\nrouter.get('/store/:storeId', middleware_1.setStoreContext, middleware_1.validatePagination, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.storeId;\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 50;\n    const search = req.query.q;\n    const result = await extensionService.listExtensions(req.tenantId, storeId, page, limit, search);\n    (0, response_1.paginatedResponse)(res, result.extensions, {\n        page,\n        limit,\n        total: result.total,\n        totalPages: result.totalPages\n    }, 'Store extensions retrieved successfully');\n}));\nexports.default = router;\n//# sourceMappingURL=extensions.js.map","size_bytes":6840},"voip-system/packages/backend/dist/middleware/index.d.ts":{"content":"export * from './auth';\nexport * from './tenant';\nexport * from './security';\nexport * from './validation';\n//# sourceMappingURL=index.d.ts.map","size_bytes":143},"voip-system/packages/backend/dist/middleware/tenant.middleware.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTenantSlug = validateTenantSlug;\nexports.extractTenantFromToken = extractTenantFromToken;\nconst database_1 = require(\"@w3-voip/database\");\n/**\n * Middleware to validate tenant slug from URL parameters\n * Extracts tenant information and attaches it to the request object\n */\nasync function validateTenantSlug(req, res, next) {\n    console.log('=== validateTenantSlug called ===');\n    console.log('validateTenantSlug - req.body:', JSON.stringify(req.body));\n    console.log('validateTenantSlug - req.params:', req.params);\n    const tenantSlug = req.params.tenantSlug || req.query.tenantSlug;\n    if (!tenantSlug) {\n        return res.status(400).json({\n            success: false,\n            error: 'Tenant slug is required'\n        });\n    }\n    try {\n        console.log('Looking for tenant with slug:', tenantSlug);\n        const client = await (0, database_1.getClient)();\n        const result = await client.query('SELECT id, slug, name, domain, sip_domain FROM tenants WHERE slug = $1 AND status = $2', [tenantSlug, 'active']);\n        console.log('Query result:', result.rows);\n        if (result.rows.length === 0) {\n            console.log('Tenant not found for slug:', tenantSlug);\n            return res.status(404).json({\n                success: false,\n                error: 'Tenant not found',\n                tenantSlug\n            });\n        }\n        const tenant = result.rows[0];\n        req.tenant = tenant;\n        console.log('✅ Tenant validated successfully, calling next() - FORCED RESTART');\n        next();\n    }\n    catch (error) {\n        console.error('Error validating tenant slug:', error);\n        return res.status(500).json({\n            success: false,\n            error: 'Failed to validate tenant'\n        });\n    }\n}\n/**\n * Middleware to extract tenant slug from JWT token\n * Used for API calls that don't have tenant slug in URL\n */\nfunction extractTenantFromToken(req, res, next) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return res.status(401).json({\n            success: false,\n            error: 'Authorization token required'\n        });\n    }\n    try {\n        const token = authHeader.substring(7);\n        const decoded = require('jsonwebtoken').verify(token, process.env.JWT_SECRET || 'your-secret-key');\n        req.tenantSlug = decoded.tenantSlug;\n        req.tenantId = decoded.tenantId;\n        req.userId = decoded.userId;\n        req.userRole = decoded.role;\n        next();\n    }\n    catch (error) {\n        return res.status(401).json({\n            success: false,\n            error: 'Invalid or expired token'\n        });\n    }\n}\n//# sourceMappingURL=tenant.middleware.js.map","size_bytes":2808},"voip-system/packages/backend/dist/routes/index.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=index.d.ts.map","size_bytes":124},"voip-system/packages/backend/dist/routes/tenants.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = __importDefault(require(\"express\"));\nconst tenant_service_1 = require(\"../services/tenant.service\");\nconst auth_1 = require(\"../middleware/auth\");\nconst response_1 = require(\"../utils/response\");\nconst shared_1 = require(\"@w3-voip/shared\");\nconst router = express_1.default.Router();\nconst tenantService = new tenant_service_1.TenantService();\n// Apply authentication and super admin middleware to all routes\nrouter.use(auth_1.authenticateToken);\nrouter.use(auth_1.requireSuperAdmin);\n// GET /api/tenants - List all tenants with statistics\nrouter.get('/', (0, response_1.asyncHandler)(async (req, res) => {\n    const { page = 1, limit = 50, search } = req.query;\n    const result = await tenantService.listTenants(parseInt(page), parseInt(limit), search);\n    (0, response_1.successResponse)(res, {\n        tenants: result.tenants,\n        pagination: {\n            page: parseInt(page),\n            limit: parseInt(limit),\n            total: result.total,\n            total_pages: result.totalPages\n        }\n    }, 'Tenants retrieved successfully');\n}));\n// GET /api/tenants/stats - Get cross-tenant statistics\nrouter.get('/stats', (0, response_1.asyncHandler)(async (req, res) => {\n    const stats = await tenantService.getCrossTenantStats();\n    (0, response_1.successResponse)(res, stats, 'Cross-tenant statistics retrieved successfully');\n}));\n// GET /api/tenants/stats-list - Get detailed statistics for all tenants\nrouter.get('/stats-list', (0, response_1.asyncHandler)(async (req, res) => {\n    const statsList = await tenantService.getTenantStatsList();\n    (0, response_1.successResponse)(res, statsList, 'Tenant statistics list retrieved successfully');\n}));\n// POST /api/tenants - Create new tenant with companies and contacts\nrouter.post('/', (0, response_1.asyncHandler)(async (req, res) => {\n    // Validate request body\n    const validationResult = shared_1.CreateTenantRequestSchema.safeParse(req.body);\n    if (!validationResult.success) {\n        return (0, response_1.errorResponse)(res, 'Invalid request data', 400, 'VALIDATION_ERROR', validationResult.error.errors);\n    }\n    const tenantData = validationResult.data;\n    // Determine if this is a super admin tenant\n    const isSuperAdmin = tenantData.slug === 'edg-voip' ||\n        tenantData.admin_user?.role === 'super_admin';\n    // Auto-generate sip_domain if not provided\n    if (!tenantData.sip_domain) {\n        if (isSuperAdmin) {\n            // Super admin tenants don't need SIP domain (they only manage other tenants)\n            tenantData.sip_domain = null;\n            console.log('Super admin tenant - no SIP domain needed');\n        }\n        else {\n            // Regular tenants get auto-generated SIP domain\n            tenantData.sip_domain = tenantData.slug + '.edgvoip.it';\n            console.log('Auto-generated SIP domain: ' + tenantData.sip_domain);\n        }\n    }\n    const tenant = await tenantService.createTenantWithCompanies(tenantData);\n    (0, response_1.successResponse)(res, tenant, 'Tenant created successfully');\n}));\n// GET /api/tenants/:id - Get tenant details with companies and contacts\nrouter.get('/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const { id } = req.params;\n    const result = await tenantService.getTenantWithDetails(id);\n    (0, response_1.successResponse)(res, result, 'Tenant details retrieved successfully');\n}));\n// PUT /api/tenants/:id - Update tenant\nrouter.put('/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const { id } = req.params;\n    const updateData = req.body;\n    const tenant = await tenantService.updateTenant(id, updateData);\n    (0, response_1.successResponse)(res, tenant, 'Tenant updated successfully');\n}));\n// DELETE /api/tenants/:id - Delete tenant (soft delete)\nrouter.delete('/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const { id } = req.params;\n    await tenantService.deleteTenant(id);\n    (0, response_1.successResponse)(res, null, 'Tenant deleted successfully');\n}));\nexports.default = router;\n//# sourceMappingURL=tenants.js.map","size_bytes":4293},"voip-system/packages/backend/dist/middleware/tenant.d.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { AuthRequest } from './auth';\nexport declare const setTenantContext: (req: AuthRequest, res: Response, next: NextFunction) => Promise<Response<any, Record<string, any>>>;\nexport declare const setStoreContext: (req: AuthRequest, res: Response, next: NextFunction) => Promise<void | Response<any, Record<string, any>>>;\nexport declare const tenantRateLimit: (maxRequests?: number, windowMs?: number) => (req: AuthRequest, res: Response, next: NextFunction) => void | Response<any, Record<string, any>>;\nexport declare const validateTenantResource: (resourceType: string) => (req: AuthRequest, res: Response, next: NextFunction) => Promise<void | Response<any, Record<string, any>>>;\n//# sourceMappingURL=tenant.d.ts.map","size_bytes":775},"voip-system/DEPLOYMENT_PRODUCTION.md":{"content":"# EDG VoIP System - Production Deployment Guide\r\n\r\n## 🚀 Deployment su Server Debian\r\n\r\n### Prerequisiti\r\n- Server Debian pulito\r\n- Accesso root\r\n- Porte aperte: 22, 80, 443, 8021, 5060, 5061, 16384-32768\r\n\r\n### Step 1: Setup Server Base\r\n```bash\r\n# Copiare script sul server\r\nscp scripts/setup-debian-server.sh root@YOUR_SERVER_IP:/tmp/\r\n\r\n# Eseguire setup\r\nssh root@YOUR_SERVER_IP\r\nchmod +x /tmp/setup-debian-server.sh\r\n/tmp/setup-debian-server.sh\r\n```\r\n\r\n### Step 2: Deploy Applicazione\r\n```bash\r\n# Dal computer locale, modificare IP nel file\r\nvim scripts/deploy-to-debian.sh\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\n\r\n# Eseguire deploy\r\nchmod +x scripts/deploy-to-debian.sh\r\n./scripts/deploy-to-debian.sh\r\n```\r\n\r\n### Step 3: Test Sistema\r\n```bash\r\n# Modificare IP nel file di test\r\nvim scripts/test-production.sh\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\n\r\n# Eseguire test\r\nchmod +x scripts/test-production.sh\r\n./scripts/test-production.sh\r\n```\r\n\r\n## 🔧 Configurazione Post-Deploy\r\n\r\n### 1. Aggiornare IP nel file env.production\r\n```bash\r\nssh root@YOUR_SERVER_IP\r\nvim /etc/voip-system/.env\r\n# Cambiare YOUR_SERVER_IP con l'IP reale\r\nsystemctl restart voip-backend\r\n```\r\n\r\n### 2. Configurare SSL (Opzionale)\r\n```bash\r\n# Generare certificato self-signed per test\r\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\r\n  -keyout /etc/ssl/private/voip.key \\\r\n  -out /etc/ssl/certs/voip.crt\r\n\r\n# Aggiornare Nginx per HTTPS\r\nvim /etc/nginx/sites-available/voip-system\r\n# Aggiungere configurazione SSL\r\nsystemctl reload nginx\r\n```\r\n\r\n## 📊 Monitoraggio\r\n\r\n### Comandi Utili\r\n```bash\r\n# Stato servizi\r\nsystemctl status voip-backend postgresql redis-server nginx freeswitch\r\n\r\n# Log applicazione\r\njournalctl -u voip-backend -f\r\n\r\n# Log FreeSWITCH\r\njournalctl -u freeswitch -f\r\n\r\n# Log Nginx\r\ntail -f /var/log/nginx/access.log\r\ntail -f /var/log/nginx/error.log\r\n\r\n# Porte in ascolto\r\nnetstat -tlnp | grep -E ':(80|443|5000|5060|5061|8021)'\r\n```\r\n\r\n### Health Checks\r\n```bash\r\n# API Health\r\ncurl http://YOUR_SERVER_IP/api/health\r\n\r\n# Database\r\nsudo -u postgres psql -c \"SELECT 1;\" voip_production\r\n\r\n# Redis\r\nredis-cli -a RedisSecure2025! ping\r\n\r\n# FreeSWITCH ESL\r\nfs_cli -x \"status\"\r\n```\r\n\r\n## 🔐 Credenziali Default\r\n\r\n### Super Admin\r\n- Email: `admin@edgvoip.local`\r\n- Password: `SuperAdmin2025!`\r\n- URL: `http://YOUR_SERVER_IP/edgvoip/login`\r\n\r\n### Demo Tenant\r\n- Email: `admin@demo.local`\r\n- Password: `tenantadmin123`\r\n- URL: `http://YOUR_SERVER_IP/demo/login`\r\n\r\n### Database\r\n- Database: `voip_production`\r\n- User: `voip_user`\r\n- Password: `VoipSecure2025!`\r\n\r\n### Redis\r\n- Password: `RedisSecure2025!`\r\n\r\n### FreeSWITCH ESL\r\n- Password: `1QzGEWv0Q6ao20M+hS8qeLI+u9gw77WuJGB5Z1xDk30=`\r\n\r\n## 🛠️ Troubleshooting\r\n\r\n### Backend non si avvia\r\n```bash\r\n# Controllare log\r\njournalctl -u voip-backend -n 50\r\n\r\n# Verificare variabili ambiente\r\ncat /etc/voip-system/.env\r\n\r\n# Testare connessione database\r\ncd /var/www/voip-system/packages/backend\r\nnpm run migrate\r\n```\r\n\r\n### FreeSWITCH non risponde\r\n```bash\r\n# Controllare configurazione\r\nfreeswitch -t\r\n\r\n# Verificare porte\r\nnetstat -tlnp | grep 5060\r\n\r\n# Test ESL\r\nfs_cli -x \"status\"\r\n```\r\n\r\n### Nginx errori 502\r\n```bash\r\n# Verificare che backend sia in ascolto\r\nnetstat -tlnp | grep 5000\r\n\r\n# Controllare log Nginx\r\ntail -f /var/log/nginx/error.log\r\n```\r\n\r\n## 📈 Performance\r\n\r\n### Ottimizzazioni Applicate\r\n- Rate limiting su API\r\n- Gzip compression\r\n- Static file caching\r\n- Connection pooling database\r\n- Redis caching\r\n- Fail2ban protection\r\n\r\n### Monitoraggio Risorse\r\n```bash\r\n# CPU e memoria\r\nhtop\r\n\r\n# Disco\r\ndf -h\r\n\r\n# Rete\r\niftop\r\n```\r\n\r\n## 🔄 Backup e Restore\r\n\r\n### Backup Automatico\r\n```bash\r\n# Script backup giornaliero\r\ncrontab -e\r\n# Aggiungere: 0 2 * * * /var/www/voip-system/scripts/backup.sh\r\n```\r\n\r\n### Restore\r\n```bash\r\n# Ripristinare database\r\ngunzip -c /var/backups/voip/postgres_YYYYMMDD_HHMMSS.sql.gz | \\\r\nsudo -u postgres psql voip_production\r\n\r\n# Ripristinare configurazioni\r\ntar -xzf /var/backups/voip/configs_YYYYMMDD_HHMMSS.tar.gz\r\n```\r\n\r\n## 🚨 Sicurezza\r\n\r\n### Firewall Configurato\r\n- SSH: porta 22\r\n- HTTP: porta 80\r\n- HTTPS: porta 443\r\n- SIP: porta 5060\r\n- SIP TLS: porta 5061\r\n- ESL: porta 8021\r\n- RTP: porte 16384-32768\r\n\r\n### Fail2ban Attivo\r\n- Protezione SSH\r\n- Protezione Nginx\r\n- Rate limiting\r\n\r\n### Password Sicure\r\n- Tutte le password sono state generate casualmente\r\n- JWT secrets sicuri\r\n- Database e Redis protetti\r\n\r\n## 📞 Supporto\r\n\r\nPer problemi o domande:\r\n1. Controllare i log\r\n2. Verificare stato servizi\r\n3. Testare connettività\r\n4. Controllare configurazioni\r\n\r\nIl sistema è ora production-ready e completamente funzionale!\r\n","size_bytes":4651},"voip-system/packages/backend/dist/routes/stores.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst store_service_1 = require(\"../services/store.service\");\nconst middleware_1 = require(\"../middleware\");\nconst response_1 = require(\"../utils/response\");\nconst router = (0, express_1.Router)();\nconst storeService = new store_service_1.StoreService();\n// Apply authentication and tenant context to all routes\nrouter.use(middleware_1.authenticateToken);\nrouter.use(middleware_1.requireTenant);\nrouter.use(middleware_1.setTenantContext);\n// Create store\nrouter.post('/', middleware_1.validateStore, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeData = {\n        ...req.body,\n        tenant_id: req.tenantId\n    };\n    const store = await storeService.createStore(storeData);\n    (0, response_1.createdResponse)(res, store, 'Store created successfully');\n}));\n// List stores for tenant\nrouter.get('/', middleware_1.validatePagination, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 50;\n    const search = req.query.q;\n    const result = await storeService.listStores(req.tenantId, page, limit, search);\n    (0, response_1.paginatedResponse)(res, result.stores, {\n        page,\n        limit,\n        total: result.total,\n        totalPages: result.totalPages\n    }, 'Stores retrieved successfully');\n}));\n// Get store by ID\nrouter.get('/:id', middleware_1.setStoreContext, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    const store = await storeService.getStoreById(storeId, req.tenantId);\n    if (!store) {\n        return (0, response_1.notFoundResponse)(res, 'Store not found');\n    }\n    (0, response_1.successResponse)(res, store, 'Store retrieved successfully');\n}));\n// Update store\nrouter.put('/:id', middleware_1.setStoreContext, middleware_1.validateStore, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    const store = await storeService.updateStore(storeId, req.body, req.tenantId);\n    (0, response_1.updatedResponse)(res, store, 'Store updated successfully');\n}));\n// Delete store\nrouter.delete('/:id', middleware_1.setStoreContext, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    await storeService.deleteStore(storeId, req.tenantId);\n    (0, response_1.deletedResponse)(res, 'Store deleted successfully');\n}));\n// Get store statistics\nrouter.get('/:id/stats', middleware_1.setStoreContext, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    const stats = await storeService.getStoreStats(storeId, req.tenantId);\n    (0, response_1.successResponse)(res, stats, 'Store statistics retrieved successfully');\n}));\n// Activate store\nrouter.post('/:id/activate', middleware_1.setStoreContext, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    const store = await storeService.activateStore(storeId, req.tenantId);\n    (0, response_1.updatedResponse)(res, store, 'Store activated successfully');\n}));\n// Deactivate store\nrouter.post('/:id/deactivate', middleware_1.setStoreContext, (0, response_1.asyncHandler)(async (req, res) => {\n    const storeId = req.params.id;\n    const store = await storeService.deactivateStore(storeId, req.tenantId);\n    (0, response_1.updatedResponse)(res, store, 'Store deactivated successfully');\n}));\n// Validate store_id uniqueness within tenant\nrouter.post('/validate-store-id', (0, response_1.asyncHandler)(async (req, res) => {\n    const { store_id, exclude_store_id } = req.body;\n    if (!store_id) {\n        return (0, response_1.errorResponse)(res, 'Store ID is required', 400, 'MISSING_FIELDS');\n    }\n    const isUnique = await storeService.validateStoreIdUniqueness(store_id, req.tenantId, exclude_store_id);\n    (0, response_1.successResponse)(res, { is_unique: isUnique }, 'Store ID validation completed');\n}));\nexports.default = router;\n//# sourceMappingURL=stores.js.map","size_bytes":4173},"voip-system/packages/backend/dist/middleware/validation.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSearch = exports.validatePagination = exports.validateCDRFilter = exports.validateTrunkRegistration = exports.validateSipTrunk = exports.validateExtension = exports.validateStore = exports.validateTenant = exports.validateUUID = exports.handleValidationErrors = void 0;\nexports.validateRequest = validateRequest;\nconst express_validator_1 = require(\"express-validator\");\n// Validation Error Handler\nconst handleValidationErrors = (req, res, next) => {\n    const errors = (0, express_validator_1.validationResult)(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({\n            success: false,\n            error: {\n                code: 'VALIDATION_ERROR',\n                message: 'Validation failed',\n                details: errors.array().map(error => ({\n                    field: error.type === 'field' ? error.path : 'unknown',\n                    message: error.msg,\n                    value: error.type === 'field' ? error.value : undefined\n                }))\n            }\n        });\n    }\n    next();\n};\nexports.handleValidationErrors = handleValidationErrors;\n// Generic Zod validator for body/query/params\nfunction validateRequest(schema, source = 'body') {\n    return (req, res, next) => {\n        try {\n            const data = source === 'body' ? req.body : source === 'query' ? req.query : req.params;\n            const parsed = schema.safeParse(data);\n            if (!parsed.success) {\n                return res.status(400).json({\n                    success: false,\n                    error: {\n                        code: 'VALIDATION_ERROR',\n                        message: 'Validation failed',\n                        details: parsed.error.errors.map(e => ({\n                            field: e.path?.join('.') || 'unknown',\n                            message: e.message\n                        }))\n                    }\n                });\n            }\n            // assign parsed data back to request to ensure types/values\n            if (source === 'body')\n                req.body = parsed.data;\n            if (source === 'query')\n                req.query = parsed.data;\n            if (source === 'params')\n                req.params = parsed.data;\n            next();\n        }\n        catch (err) {\n            return res.status(500).json({ success: false, error: { code: 'VALIDATION_MIDDLEWARE_ERROR', message: 'Unexpected validation error' } });\n        }\n    };\n}\n// UUID Validation\nconst validateUUID = (field) => {\n    return (0, express_validator_1.param)(field).isUUID().withMessage(`${field} must be a valid UUID`);\n};\nexports.validateUUID = validateUUID;\n// Tenant Validation\nexports.validateTenant = [\n    (0, express_validator_1.body)('name')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Name must be between 1 and 100 characters')\n        .trim(),\n    (0, express_validator_1.body)('domain')\n        .matches(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/)\n        .withMessage('Domain must contain only alphanumeric characters and hyphens, cannot start or end with hyphen')\n        .isLength({ min: 3, max: 100 })\n        .withMessage('Domain must be between 3 and 100 characters'),\n    (0, express_validator_1.body)('sip_domain')\n        .matches(/^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$/)\n        .withMessage('SIP domain must be a valid domain name')\n        .isLength({ min: 3, max: 100 })\n        .withMessage('SIP domain must be between 3 and 100 characters'),\n    (0, express_validator_1.body)('status')\n        .optional()\n        .isIn(['active', 'suspended', 'pending'])\n        .withMessage('Status must be active, suspended, or pending'),\n    (0, express_validator_1.body)('settings.max_concurrent_calls')\n        .optional()\n        .isInt({ min: 1, max: 1000 })\n        .withMessage('Max concurrent calls must be between 1 and 1000'),\n    (0, express_validator_1.body)('settings.recording_enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('Recording enabled must be a boolean'),\n    (0, express_validator_1.body)('settings.gdpr_compliant')\n        .optional()\n        .isBoolean()\n        .withMessage('GDPR compliant must be a boolean'),\n    (0, express_validator_1.body)('settings.timezone')\n        .optional()\n        .isLength({ min: 1, max: 50 })\n        .withMessage('Timezone must be between 1 and 50 characters'),\n    (0, express_validator_1.body)('settings.language')\n        .optional()\n        .isLength({ min: 2, max: 5 })\n        .withMessage('Language must be between 2 and 5 characters')\n];\n// Store Validation\nexports.validateStore = [\n    (0, express_validator_1.body)('name')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Name must be between 1 and 100 characters')\n        .trim(),\n    (0, express_validator_1.body)('store_id')\n        .isLength({ min: 1, max: 50 })\n        .withMessage('Store ID must be between 1 and 50 characters')\n        .matches(/^[a-zA-Z0-9-_]+$/)\n        .withMessage('Store ID can only contain alphanumeric characters, hyphens, and underscores'),\n    (0, express_validator_1.body)('status')\n        .optional()\n        .isIn(['active', 'inactive'])\n        .withMessage('Status must be active or inactive'),\n    (0, express_validator_1.body)('settings.business_hours.enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('Business hours enabled must be a boolean'),\n    (0, express_validator_1.body)('settings.business_hours.timezone')\n        .optional()\n        .isLength({ min: 1, max: 50 })\n        .withMessage('Business hours timezone must be between 1 and 50 characters'),\n    (0, express_validator_1.body)('settings.outbound_caller_id')\n        .optional()\n        .matches(/^\\+?[1-9]\\d{1,14}$/)\n        .withMessage('Outbound caller ID must be a valid E.164 number'),\n    (0, express_validator_1.body)('settings.recording_consent_required')\n        .optional()\n        .isBoolean()\n        .withMessage('Recording consent required must be a boolean')\n];\n// Extension Validation\nexports.validateExtension = [\n    (0, express_validator_1.body)('extension')\n        .matches(/^[0-9]{3,6}$/)\n        .withMessage('Extension must be 3-6 digits'),\n    (0, express_validator_1.body)('password')\n        .isLength({ min: 8, max: 32 })\n        .withMessage('Password must be between 8 and 32 characters')\n        .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/)\n        .withMessage('Password must contain at least one lowercase letter, one uppercase letter, and one number'),\n    (0, express_validator_1.body)('display_name')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Display name must be between 1 and 100 characters')\n        .trim(),\n    (0, express_validator_1.body)('status')\n        .optional()\n        .isIn(['active', 'inactive', 'locked'])\n        .withMessage('Status must be active, inactive, or locked'),\n    (0, express_validator_1.body)('type')\n        .optional()\n        .isIn(['user', 'queue', 'conference', 'voicemail'])\n        .withMessage('Type must be user, queue, conference, or voicemail'),\n    (0, express_validator_1.body)('settings.voicemail_enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('Voicemail enabled must be a boolean'),\n    (0, express_validator_1.body)('settings.call_forwarding.enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('Call forwarding enabled must be a boolean'),\n    (0, express_validator_1.body)('settings.call_forwarding.destination')\n        .optional()\n        .matches(/^\\+?[1-9]\\d{1,14}$|^[0-9]{3,6}$/)\n        .withMessage('Call forwarding destination must be a valid E.164 number or extension'),\n    (0, express_validator_1.body)('settings.dnd_enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('DND enabled must be a boolean'),\n    (0, express_validator_1.body)('settings.recording_enabled')\n        .optional()\n        .isBoolean()\n        .withMessage('Recording enabled must be a boolean')\n];\n// SIP Trunk Validation\nexports.validateSipTrunk = [\n    (0, express_validator_1.body)('name')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Name must be between 1 and 100 characters')\n        .trim(),\n    (0, express_validator_1.body)('provider')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Provider must be between 1 and 100 characters')\n        .trim(),\n    (0, express_validator_1.body)('status')\n        .optional()\n        .isIn(['active', 'inactive', 'testing'])\n        .withMessage('Status must be active, inactive, or testing'),\n    (0, express_validator_1.body)('sip_config.host')\n        .isLength({ min: 1, max: 255 })\n        .withMessage('SIP host must be between 1 and 255 characters'),\n    (0, express_validator_1.body)('sip_config.port')\n        .isInt({ min: 1, max: 65535 })\n        .withMessage('SIP port must be between 1 and 65535'),\n    (0, express_validator_1.body)('sip_config.transport')\n        .isIn(['udp', 'tcp', 'tls'])\n        .withMessage('SIP transport must be udp, tcp, or tls'),\n    (0, express_validator_1.body)('sip_config.username')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('SIP username must be between 1 and 100 characters'),\n    (0, express_validator_1.body)('sip_config.password')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('SIP password must be between 1 and 100 characters'),\n    (0, express_validator_1.body)('did_config.number')\n        .matches(/^\\+?[1-9]\\d{1,14}$/)\n        .withMessage('DID number must be a valid E.164 number'),\n    (0, express_validator_1.body)('did_config.country_code')\n        .isLength({ min: 2, max: 2 })\n        .withMessage('Country code must be exactly 2 characters'),\n    (0, express_validator_1.body)('did_config.local_number')\n        .isLength({ min: 1, max: 20 })\n        .withMessage('Local number must be between 1 and 20 characters'),\n    (0, express_validator_1.body)('security.encryption')\n        .optional()\n        .isIn(['none', 'tls', 'srtp'])\n        .withMessage('Encryption must be none, tls, or srtp'),\n    (0, express_validator_1.body)('security.authentication')\n        .optional()\n        .isIn(['none', 'digest', 'tls'])\n        .withMessage('Authentication must be none, digest, or tls'),\n    (0, express_validator_1.body)('gdpr.data_retention_days')\n        .optional()\n        .isInt({ min: 30, max: 2555 })\n        .withMessage('Data retention days must be between 30 and 2555'),\n    (0, express_validator_1.body)('gdpr.recording_consent_required')\n        .optional()\n        .isBoolean()\n        .withMessage('Recording consent required must be a boolean'),\n    (0, express_validator_1.body)('gdpr.data_controller')\n        .optional()\n        .isLength({ min: 1, max: 200 })\n        .withMessage('Data controller must be between 1 and 200 characters'),\n    (0, express_validator_1.body)('gdpr.dpo_contact')\n        .optional()\n        .isEmail()\n        .withMessage('DPO contact must be a valid email address')\n];\n// Trunk Registration Validation (for UI form)\nexports.validateTrunkRegistration = [\n    (0, express_validator_1.body)('name')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Nome trunk richiesto (1-100 caratteri)')\n        .trim(),\n    (0, express_validator_1.body)('provider')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Provider richiesto (1-100 caratteri)')\n        .trim(),\n    (0, express_validator_1.body)('host')\n        .isLength({ min: 1, max: 255 })\n        .withMessage('Host SIP richiesto (1-255 caratteri)'),\n    (0, express_validator_1.body)('port')\n        .isInt({ min: 1, max: 65535 })\n        .withMessage('Porta SIP deve essere tra 1 e 65535'),\n    (0, express_validator_1.body)('transport')\n        .isIn(['udp', 'tcp', 'tls'])\n        .withMessage('Trasporto deve essere udp, tcp o tls'),\n    (0, express_validator_1.body)('username')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Username SIP richiesto (1-100 caratteri)'),\n    (0, express_validator_1.body)('password')\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Password SIP richiesta (1-100 caratteri)'),\n    (0, express_validator_1.body)('number')\n        .matches(/^\\+?[1-9]\\d{1,14}$/)\n        .withMessage('Formato numero non valido (E.164)'),\n    (0, express_validator_1.body)('country_code')\n        .isLength({ min: 2, max: 2 })\n        .withMessage('Codice paese richiesto (2 caratteri)'),\n    (0, express_validator_1.body)('local_number')\n        .isLength({ min: 1, max: 20 })\n        .withMessage('Numero locale richiesto (1-20 caratteri)'),\n    (0, express_validator_1.body)('encryption')\n        .isIn(['none', 'tls', 'srtp'])\n        .withMessage('Crittografia deve essere none, tls o srtp'),\n    (0, express_validator_1.body)('authentication')\n        .isIn(['none', 'digest', 'tls'])\n        .withMessage('Autenticazione deve essere none, digest o tls'),\n    (0, express_validator_1.body)('data_retention_days')\n        .isInt({ min: 30, max: 2555 })\n        .withMessage('Conservazione dati deve essere tra 30 e 2555 giorni'),\n    (0, express_validator_1.body)('recording_consent_required')\n        .isBoolean()\n        .withMessage('Consenso registrazione deve essere true o false'),\n    (0, express_validator_1.body)('data_controller')\n        .isLength({ min: 1, max: 200 })\n        .withMessage('Titolare del trattamento richiesto (1-200 caratteri)'),\n    (0, express_validator_1.body)('dpo_contact')\n        .optional()\n        .isEmail()\n        .withMessage('Email DPO non valida'),\n    (0, express_validator_1.body)('gdpr_consent')\n        .isBoolean()\n        .custom((value) => {\n        if (!value) {\n            throw new Error('Consenso GDPR richiesto');\n        }\n        return true;\n    }),\n    (0, express_validator_1.body)('terms_accepted')\n        .isBoolean()\n        .custom((value) => {\n        if (!value) {\n            throw new Error('Termini e condizioni richiesti');\n        }\n        return true;\n    })\n];\n// CDR Filter Validation\nexports.validateCDRFilter = [\n    (0, express_validator_1.query)('tenant_id')\n        .optional()\n        .isUUID()\n        .withMessage('Tenant ID must be a valid UUID'),\n    (0, express_validator_1.query)('store_id')\n        .optional()\n        .isUUID()\n        .withMessage('Store ID must be a valid UUID'),\n    (0, express_validator_1.query)('start_date')\n        .optional()\n        .isISO8601()\n        .withMessage('Start date must be a valid ISO 8601 date'),\n    (0, express_validator_1.query)('end_date')\n        .optional()\n        .isISO8601()\n        .withMessage('End date must be a valid ISO 8601 date'),\n    (0, express_validator_1.query)('call_direction')\n        .optional()\n        .isIn(['inbound', 'outbound', 'internal'])\n        .withMessage('Call direction must be inbound, outbound, or internal'),\n    (0, express_validator_1.query)('call_type')\n        .optional()\n        .isIn(['voice', 'video', 'fax'])\n        .withMessage('Call type must be voice, video, or fax'),\n    (0, express_validator_1.query)('hangup_disposition')\n        .optional()\n        .isIn(['answered', 'busy', 'no_answer', 'congestion', 'fail', 'timeout'])\n        .withMessage('Hangup disposition must be answered, busy, no_answer, congestion, fail, or timeout'),\n    (0, express_validator_1.query)('min_duration')\n        .optional()\n        .isInt({ min: 0 })\n        .withMessage('Min duration must be a non-negative integer'),\n    (0, express_validator_1.query)('max_duration')\n        .optional()\n        .isInt({ min: 0 })\n        .withMessage('Max duration must be a non-negative integer'),\n    (0, express_validator_1.query)('page')\n        .optional()\n        .isInt({ min: 1 })\n        .withMessage('Page must be a positive integer'),\n    (0, express_validator_1.query)('limit')\n        .optional()\n        .isInt({ min: 1, max: 1000 })\n        .withMessage('Limit must be between 1 and 1000'),\n    (0, express_validator_1.query)('sort_by')\n        .optional()\n        .isIn(['start_time', 'duration', 'caller_number', 'callee_number'])\n        .withMessage('Sort by must be start_time, duration, caller_number, or callee_number'),\n    (0, express_validator_1.query)('sort_order')\n        .optional()\n        .isIn(['asc', 'desc'])\n        .withMessage('Sort order must be asc or desc')\n];\n// Pagination Validation\nexports.validatePagination = [\n    (0, express_validator_1.query)('page')\n        .optional()\n        .isInt({ min: 1 })\n        .withMessage('Page must be a positive integer'),\n    (0, express_validator_1.query)('limit')\n        .optional()\n        .isInt({ min: 1, max: 1000 })\n        .withMessage('Limit must be between 1 and 1000')\n];\n// Search Validation\nexports.validateSearch = [\n    (0, express_validator_1.query)('q')\n        .optional()\n        .isLength({ min: 1, max: 100 })\n        .withMessage('Search query must be between 1 and 100 characters')\n        .trim()\n];\n//# sourceMappingURL=validation.js.map","size_bytes":16989},"voip-system/packages/backend/dist/routes/system.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=system.d.ts.map","size_bytes":125},"voip-system/packages/backend/dist/middleware/auth.d.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { JWTPayload } from '@w3-voip/shared';\ndeclare global {\n    namespace Express {\n        interface Request {\n            user?: JWTPayload;\n            tenantId?: string;\n            storeId?: string;\n        }\n    }\n}\nexport interface AuthRequest extends Request {\n    user: JWTPayload;\n    tenantId: string;\n    storeId?: string;\n}\nexport declare const authenticateToken: (req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const requireTenant: (req: AuthRequest, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const requireSuperAdmin: (req: AuthRequest, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const requireRole: (roles: string[]) => (req: AuthRequest, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const requirePermission: (permission: string) => (req: AuthRequest, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const requireStoreAccess: (req: AuthRequest, res: Response, next: NextFunction) => Response<any, Record<string, any>>;\nexport declare const optionalAuth: (req: Request, res: Response, next: NextFunction) => void;\nexport declare const generateToken: (payload: Omit<JWTPayload, \"iat\" | \"exp\">) => string;\nexport declare const verifyToken: (token: string) => JWTPayload;\n//# sourceMappingURL=auth.d.ts.map","size_bytes":1512},"voip-system/packages/backend/dist/routes/analytics.js":{"content":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = __importDefault(require(\"express\"));\nconst database_1 = require(\"@w3-voip/database\");\nconst auth_1 = require(\"../middleware/auth\");\nconst response_1 = require(\"../utils/response\");\nconst router = express_1.default.Router();\n// Apply authentication and super admin middleware to all routes\nrouter.use(auth_1.authenticateToken);\nrouter.use(auth_1.requireSuperAdmin);\n// GET /api/analytics/cross-tenant/calls - CDR aggregato tutti tenant\nrouter.get('/cross-tenant/calls', (0, response_1.asyncHandler)(async (req, res) => {\n    const { start_date, end_date, tenant_id, limit = 100 } = req.query;\n    const client = await (0, database_1.getClient)();\n    try {\n        let whereClause = '';\n        let queryParams = [];\n        let paramCount = 1;\n        if (start_date) {\n            whereClause += ` AND c.start_time >= $${paramCount++}`;\n            queryParams.push(start_date);\n        }\n        if (end_date) {\n            whereClause += ` AND c.start_time <= $${paramCount++}`;\n            queryParams.push(end_date);\n        }\n        if (tenant_id) {\n            whereClause += ` AND c.tenant_id = $${paramCount++}`;\n            queryParams.push(tenant_id);\n        }\n        const result = await client.query(`\r\n      SELECT \r\n        c.*,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        u.email as user_email\r\n      FROM cdr c\r\n      JOIN tenants t ON c.tenant_id = t.id\r\n      LEFT JOIN users u ON c.user_id = u.id\r\n      WHERE 1=1 ${whereClause}\r\n      ORDER BY c.start_time DESC\r\n      LIMIT $${paramCount}\r\n    `, [...queryParams, parseInt(limit)]);\n        (0, response_1.successResponse)(res, result.rows, 'Cross-tenant calls retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\n// GET /api/analytics/cross-tenant/extensions - Conteggi estensioni per tenant\nrouter.get('/cross-tenant/extensions', (0, response_1.asyncHandler)(async (req, res) => {\n    const client = await (0, database_1.getClient)();\n    try {\n        const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        t.status as tenant_status,\r\n        COUNT(e.id) as extensions_count,\r\n        COUNT(CASE WHEN e.status = 'active' THEN 1 END) as active_extensions,\r\n        COUNT(CASE WHEN e.status = 'inactive' THEN 1 END) as inactive_extensions\r\n      FROM tenants t\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      GROUP BY t.id, t.name, t.slug, t.status\r\n      ORDER BY extensions_count DESC\r\n    `);\n        (0, response_1.successResponse)(res, result.rows, 'Cross-tenant extensions statistics retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\n// GET /api/analytics/cross-tenant/live-calls - Live calls tutti tenant\nrouter.get('/cross-tenant/live-calls', (0, response_1.asyncHandler)(async (req, res) => {\n    const client = await (0, database_1.getClient)();\n    try {\n        const result = await client.query(`\r\n      SELECT \r\n        ac.*,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        u.email as user_email\r\n      FROM active_calls ac\r\n      JOIN tenants t ON ac.tenant_id = t.id\r\n      LEFT JOIN users u ON ac.user_id = u.id\r\n      ORDER BY ac.start_time DESC\r\n    `);\n        (0, response_1.successResponse)(res, result.rows, 'Cross-tenant live calls retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\n// GET /api/analytics/cross-tenant/users - Statistiche utenti per tenant\nrouter.get('/cross-tenant/users', (0, response_1.asyncHandler)(async (req, res) => {\n    const client = await (0, database_1.getClient)();\n    try {\n        const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        t.status as tenant_status,\r\n        COUNT(u.id) as users_count,\r\n        COUNT(CASE WHEN u.status = 'active' THEN 1 END) as active_users,\r\n        COUNT(CASE WHEN u.role = 'tenant_admin' THEN 1 END) as admin_users,\r\n        COUNT(CASE WHEN u.role = 'user' THEN 1 END) as regular_users,\r\n        MAX(u.last_login) as last_login\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      GROUP BY t.id, t.name, t.slug, t.status\r\n      ORDER BY users_count DESC\r\n    `);\n        (0, response_1.successResponse)(res, result.rows, 'Cross-tenant users statistics retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\n// GET /api/analytics/cross-tenant/companies - Statistiche companies per tenant\nrouter.get('/cross-tenant/companies', (0, response_1.asyncHandler)(async (req, res) => {\n    const client = await (0, database_1.getClient)();\n    try {\n        const result = await client.query(`\r\n      SELECT \r\n        t.id as tenant_id,\r\n        t.name as tenant_name,\r\n        t.slug as tenant_slug,\r\n        COUNT(c.id) as companies_count,\r\n        COUNT(CASE WHEN c.is_primary = true THEN 1 END) as primary_companies,\r\n        COUNT(cont.id) as contacts_count,\r\n        COUNT(CASE WHEN cont.is_primary = true THEN 1 END) as primary_contacts\r\n      FROM tenants t\r\n      LEFT JOIN companies c ON t.id = c.tenant_id\r\n      LEFT JOIN tenant_contacts cont ON t.id = cont.tenant_id\r\n      GROUP BY t.id, t.name, t.slug\r\n      ORDER BY companies_count DESC\r\n    `);\n        (0, response_1.successResponse)(res, result.rows, 'Cross-tenant companies statistics retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\n// GET /api/analytics/cross-tenant/summary - Summary completo cross-tenant\nrouter.get('/cross-tenant/summary', (0, response_1.asyncHandler)(async (req, res) => {\n    const { period = '24h' } = req.query;\n    const client = await (0, database_1.getClient)();\n    try {\n        let timeFilter = '';\n        switch (period) {\n            case '1h':\n                timeFilter = \"AND c.start_time > NOW() - INTERVAL '1 hour'\";\n                break;\n            case '24h':\n                timeFilter = \"AND c.start_time > NOW() - INTERVAL '24 hours'\";\n                break;\n            case '7d':\n                timeFilter = \"AND c.start_time > NOW() - INTERVAL '7 days'\";\n                break;\n            case '30d':\n                timeFilter = \"AND c.start_time > NOW() - INTERVAL '30 days'\";\n                break;\n        }\n        const result = await client.query(`\r\n      SELECT \r\n        COUNT(DISTINCT t.id) as total_tenants,\r\n        COUNT(DISTINCT CASE WHEN t.status = 'active' THEN t.id END) as active_tenants,\r\n        COUNT(DISTINCT u.id) as total_users,\r\n        COUNT(DISTINCT e.id) as total_extensions,\r\n        COUNT(DISTINCT c.id) as total_calls,\r\n        COUNT(DISTINCT ac.id) as active_calls,\r\n        COUNT(DISTINCT comp.id) as total_companies,\r\n        COUNT(DISTINCT cont.id) as total_contacts,\r\n        AVG(c.duration) as avg_call_duration,\r\n        SUM(c.duration) as total_call_duration\r\n      FROM tenants t\r\n      LEFT JOIN users u ON t.id = u.tenant_id\r\n      LEFT JOIN extensions e ON t.id = e.tenant_id\r\n      LEFT JOIN cdr c ON t.id = c.tenant_id ${timeFilter}\r\n      LEFT JOIN active_calls ac ON t.id = ac.tenant_id\r\n      LEFT JOIN companies comp ON t.id = comp.tenant_id\r\n      LEFT JOIN tenant_contacts cont ON t.id = cont.tenant_id\r\n    `);\n        (0, response_1.successResponse)(res, result.rows[0], 'Cross-tenant summary retrieved successfully');\n    }\n    finally {\n        await client.release();\n    }\n}));\nexports.default = router;\n//# sourceMappingURL=analytics.js.map","size_bytes":7781},"voip-system/packages/backend/dist/routes/calls.d.ts":{"content":"declare const router: import(\"express-serve-static-core\").Router;\nexport default router;\n//# sourceMappingURL=calls.d.ts.map","size_bytes":124},"voip-system/packages/backend/dist/routes/sip-test-routes.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst sip_test_service_1 = require(\"../services/sip-test-service\");\nconst router = (0, express_1.Router)();\nconst sipTestService = new sip_test_service_1.SipTestService();\n// Test SIP registration\nrouter.post('/test-registration', async (req, res) => {\n    try {\n        const config = req.body;\n        // Validate required fields\n        if (!config.provider || !config.proxy || !config.auth_username || !config.auth_password) {\n            return res.status(400).json({\n                success: false,\n                message: 'Missing required fields: provider, proxy, auth_username, auth_password'\n            });\n        }\n        const result = await sipTestService.testSipRegistration(config);\n        res.json({\n            success: true,\n            data: result\n        });\n    }\n    catch (error) {\n        console.error('Error testing SIP registration:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to test SIP registration',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Test SIP trunk connectivity\nrouter.post('/test-connectivity', async (req, res) => {\n    try {\n        const config = req.body;\n        // Validate required fields\n        if (!config.proxy || !config.port) {\n            return res.status(400).json({\n                success: false,\n                message: 'Missing required fields: proxy, port'\n            });\n        }\n        const result = await sipTestService.testSipTrunkConnectivity(config);\n        res.json({\n            success: true,\n            data: result\n        });\n    }\n    catch (error) {\n        console.error('Error testing SIP connectivity:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to test SIP connectivity',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Test Messagenet connection specifically\nrouter.post('/test-messagenet', async (req, res) => {\n    try {\n        const result = await sipTestService.testMessagenetConnection();\n        res.json({\n            success: true,\n            data: result\n        });\n    }\n    catch (error) {\n        console.error('Error testing Messagenet connection:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to test Messagenet connection',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\n// Test multiple configurations\nrouter.post('/test-multiple', async (req, res) => {\n    try {\n        const configs = req.body.configs;\n        if (!Array.isArray(configs) || configs.length === 0) {\n            return res.status(400).json({\n                success: false,\n                message: 'configs must be a non-empty array'\n            });\n        }\n        const results = await sipTestService.testMultipleConfigurations(configs);\n        res.json({\n            success: true,\n            data: results\n        });\n    }\n    catch (error) {\n        console.error('Error testing multiple SIP configurations:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to test SIP configurations',\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n});\nexports.default = router;\n//# sourceMappingURL=sip-test-routes.js.map","size_bytes":3532},"voip-system/packages/backend/dist/routes/cdr.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-nocheck\nconst express_1 = require(\"express\");\nconst zod_1 = require(\"zod\");\nconst cdr_service_1 = require(\"../services/cdr.service\");\nconst auth_1 = require(\"../middleware/auth\");\nconst tenant_1 = require(\"../middleware/tenant\");\nconst validation_1 = require(\"../middleware/validation\");\nconst response_1 = require(\"../utils/response\");\n// Removed unused import: logAPICall\nconst router = (0, express_1.Router)();\nconst cdrService = new cdr_service_1.CDRService();\n// Validation schemas\nconst cdrFilterSchema = zod_1.z.object({\n    tenant_id: zod_1.z.string().uuid().optional(),\n    store_id: zod_1.z.string().uuid().optional(),\n    extension_id: zod_1.z.string().uuid().optional(),\n    trunk_id: zod_1.z.string().uuid().optional(),\n    start_date: zod_1.z.string().datetime().optional(),\n    end_date: zod_1.z.string().datetime().optional(),\n    call_direction: zod_1.z.enum(['inbound', 'outbound', 'internal']).optional(),\n    call_type: zod_1.z.enum(['voice', 'video', 'fax']).optional(),\n    hangup_disposition: zod_1.z.enum(['answered', 'no_answer', 'busy', 'failed', 'unknown']).optional(),\n    caller_number: zod_1.z.string().optional(),\n    callee_number: zod_1.z.string().optional(),\n    min_duration: zod_1.z.number().min(0).optional(),\n    max_duration: zod_1.z.number().min(0).optional(),\n    recording_enabled: zod_1.z.boolean().optional(),\n    recording_consent: zod_1.z.boolean().optional(),\n    min_mos: zod_1.z.number().min(1).max(5).optional(),\n    page: zod_1.z.number().min(1).default(1),\n    limit: zod_1.z.number().min(1).max(100).default(20),\n    sort_by: zod_1.z.enum(['start_time', 'duration', 'caller_number', 'callee_number']).default('start_time'),\n    sort_order: zod_1.z.enum(['asc', 'desc']).default('desc')\n});\nconst cdrStatsSchema = zod_1.z.object({\n    tenant_id: zod_1.z.string().uuid().optional(),\n    store_id: zod_1.z.string().uuid().optional(),\n    extension_id: zod_1.z.string().uuid().optional(),\n    trunk_id: zod_1.z.string().uuid().optional(),\n    start_date: zod_1.z.string().datetime().optional(),\n    end_date: zod_1.z.string().datetime().optional(),\n    call_direction: zod_1.z.enum(['inbound', 'outbound', 'internal']).optional(),\n    call_type: zod_1.z.enum(['voice', 'video', 'fax']).optional(),\n    hangup_disposition: zod_1.z.enum(['answered', 'no_answer', 'busy', 'failed', 'unknown']).optional()\n});\nconst updateCDRSchema = zod_1.z.object({\n    answer_time: zod_1.z.string().datetime().optional(),\n    end_time: zod_1.z.string().datetime().optional(),\n    duration: zod_1.z.number().min(0).optional(),\n    bill_seconds: zod_1.z.number().min(0).optional(),\n    hangup_cause: zod_1.z.string().optional(),\n    hangup_disposition: zod_1.z.enum(['answered', 'no_answer', 'busy', 'failed', 'unknown']).optional(),\n    audio_codec: zod_1.z.string().optional(),\n    video_codec: zod_1.z.string().optional(),\n    rtp_audio_in_mos: zod_1.z.number().min(1).max(5).optional(),\n    rtp_audio_out_mos: zod_1.z.number().min(1).max(5).optional(),\n    recording_enabled: zod_1.z.boolean().optional(),\n    recording_path: zod_1.z.string().optional(),\n    recording_duration: zod_1.z.number().min(0).optional(),\n    recording_consent: zod_1.z.boolean().optional(),\n    metadata: zod_1.z.record(zod_1.z.any()).optional(),\n    tags: zod_1.z.array(zod_1.z.string()).optional()\n});\nconst anonymizeCDRSchema = zod_1.z.object({\n    cdr_id: zod_1.z.string().uuid('Invalid CDR ID')\n});\nconst deleteCDRSchema = zod_1.z.object({\n    cdr_id: zod_1.z.string().uuid('Invalid CDR ID')\n});\n// List CDR records\nrouter.get('/', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(cdrFilterSchema, 'query'), async (req, res) => {\n    try {\n        const filter = req.query;\n        const tenantId = req.tenantId;\n        logAPICall('list_cdr', {\n            tenant_id: tenantId,\n            filter: Object.keys(filter)\n        });\n        // Ensure tenant_id is set from context\n        const cdrFilter = {\n            ...filter,\n            tenant_id: tenantId\n        };\n        const result = await cdrService.listCDR(cdrFilter);\n        (0, response_1.successResponse)(res, {\n            cdr: result.cdr,\n            pagination: {\n                page: parseInt(filter.page) || 1,\n                limit: parseInt(filter.limit) || 20,\n                total: result.total,\n                total_pages: result.totalPages\n            }\n        });\n    }\n    catch (error) {\n        console.error('Error listing CDR:', error);\n        (0, response_1.errorResponse)(res, 'Failed to list CDR records', 500);\n    }\n});\n// Get CDR statistics\nrouter.get('/stats', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(cdrStatsSchema, 'query'), async (req, res) => {\n    try {\n        const filter = req.query;\n        const tenantId = req.tenantId;\n        logAPICall('get_cdr_stats', {\n            tenant_id: tenantId,\n            filter: Object.keys(filter)\n        });\n        // Ensure tenant_id is set from context\n        const statsFilter = {\n            ...filter,\n            tenant_id: tenantId\n        };\n        const stats = await cdrService.getCDRStats(statsFilter);\n        (0, response_1.successResponse)(res, stats);\n    }\n    catch (error) {\n        console.error('Error getting CDR stats:', error);\n        (0, response_1.errorResponse)(res, 'Failed to get CDR statistics', 500);\n    }\n});\n// Get CDR by ID\nrouter.get('/:cdr_id', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const { cdr_id } = req.params;\n        const tenantId = req.tenantId;\n        logAPICall('get_cdr', {\n            tenant_id: tenantId,\n            cdr_id\n        });\n        const cdr = await cdrService.getCDRById(cdr_id, tenantId);\n        if (!cdr) {\n            return (0, response_1.errorResponse)(res, 'CDR not found', 404);\n        }\n        (0, response_1.successResponse)(res, cdr);\n    }\n    catch (error) {\n        console.error('Error getting CDR:', error);\n        (0, response_1.errorResponse)(res, 'Failed to get CDR', 500);\n    }\n});\n// Update CDR record\nrouter.patch('/:cdr_id', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(updateCDRSchema), async (req, res) => {\n    try {\n        const { cdr_id } = req.params;\n        const updates = req.body;\n        const tenantId = req.tenantId;\n        logAPICall('update_cdr', {\n            tenant_id: tenantId,\n            cdr_id,\n            updates: Object.keys(updates)\n        });\n        const cdr = await cdrService.updateCDR(cdr_id, updates, tenantId);\n        (0, response_1.successResponse)(res, cdr);\n    }\n    catch (error) {\n        console.error('Error updating CDR:', error);\n        if (error.message === 'CDR not found') {\n            return (0, response_1.errorResponse)(res, 'CDR not found', 404);\n        }\n        (0, response_1.errorResponse)(res, 'Failed to update CDR', 500);\n    }\n});\n// Anonymize CDR record (GDPR compliance)\nrouter.post('/:cdr_id/anonymize', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const { cdr_id } = req.params;\n        const tenantId = req.tenantId;\n        logAPICall('anonymize_cdr', {\n            tenant_id: tenantId,\n            cdr_id\n        });\n        await cdrService.anonymizeCDR(cdr_id, tenantId);\n        (0, response_1.successResponse)(res, {\n            cdr_id,\n            status: 'anonymized',\n            message: 'CDR record has been anonymized for GDPR compliance'\n        });\n    }\n    catch (error) {\n        console.error('Error anonymizing CDR:', error);\n        if (error.message === 'CDR not found') {\n            return (0, response_1.errorResponse)(res, 'CDR not found', 404);\n        }\n        (0, response_1.errorResponse)(res, 'Failed to anonymize CDR', 500);\n    }\n});\n// Delete CDR record (GDPR compliance)\nrouter.delete('/:cdr_id', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const { cdr_id } = req.params;\n        const tenantId = req.tenantId;\n        logAPICall('delete_cdr', {\n            tenant_id: tenantId,\n            cdr_id\n        });\n        await cdrService.deleteCDR(cdr_id, tenantId);\n        (0, response_1.successResponse)(res, {\n            cdr_id,\n            status: 'deleted',\n            message: 'CDR record has been deleted for GDPR compliance'\n        });\n    }\n    catch (error) {\n        console.error('Error deleting CDR:', error);\n        if (error.message === 'CDR not found') {\n            return (0, response_1.errorResponse)(res, 'CDR not found', 404);\n        }\n        (0, response_1.errorResponse)(res, 'Failed to delete CDR', 500);\n    }\n});\n// Export CDR records (CSV format)\nrouter.get('/export/csv', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(cdrFilterSchema, 'query'), async (req, res) => {\n    try {\n        const filter = req.query;\n        const tenantId = req.tenantId;\n        logAPICall('export_cdr_csv', {\n            tenant_id: tenantId,\n            filter: Object.keys(filter)\n        });\n        // Ensure tenant_id is set from context\n        const cdrFilter = {\n            ...filter,\n            tenant_id: tenantId,\n            limit: 10000 // Large limit for export\n        };\n        const result = await cdrService.listCDR(cdrFilter);\n        // Generate CSV\n        const csvHeaders = [\n            'ID',\n            'Call UUID',\n            'Start Time',\n            'Answer Time',\n            'End Time',\n            'Duration (s)',\n            'Bill Seconds',\n            'Call Direction',\n            'Call Type',\n            'Caller Number',\n            'Caller Name',\n            'Caller Extension',\n            'Callee Number',\n            'Callee Name',\n            'Callee Extension',\n            'Hangup Cause',\n            'Hangup Disposition',\n            'Audio Codec',\n            'Video Codec',\n            'MOS Score',\n            'Recording Enabled',\n            'Recording Path',\n            'Recording Duration',\n            'Recording Consent',\n            'Local IP',\n            'Remote IP',\n            'Created At'\n        ];\n        const csvRows = result.cdr.map(cdr => [\n            cdr.id,\n            cdr.call_uuid,\n            cdr.start_time?.toISOString() || '',\n            cdr.answer_time?.toISOString() || '',\n            cdr.end_time?.toISOString() || '',\n            cdr.duration || 0,\n            cdr.bill_seconds || 0,\n            cdr.call_direction,\n            cdr.call_type,\n            cdr.caller_id_number || '',\n            cdr.caller_id_name || '',\n            cdr.caller_extension || '',\n            cdr.callee_id_number || '',\n            cdr.callee_id_name || '',\n            cdr.callee_extension || '',\n            cdr.hangup_cause || '',\n            cdr.hangup_disposition,\n            cdr.audio_codec || '',\n            cdr.video_codec || '',\n            cdr.rtp_audio_in_mos || cdr.rtp_audio_out_mos || '',\n            cdr.recording_enabled ? 'Yes' : 'No',\n            cdr.recording_path || '',\n            cdr.recording_duration || 0,\n            cdr.recording_consent ? 'Yes' : 'No',\n            cdr.local_ip || '',\n            cdr.remote_ip || '',\n            cdr.created_at?.toISOString() || ''\n        ]);\n        const csvContent = [\n            csvHeaders.join(','),\n            ...csvRows.map(row => row.map(field => `\"${field}\"`).join(','))\n        ].join('\\n');\n        // Set response headers for CSV download\n        const filename = `cdr_export_${tenantId}_${new Date().toISOString().split('T')[0]}.csv`;\n        res.setHeader('Content-Type', 'text/csv');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n        res.setHeader('Content-Length', Buffer.byteLength(csvContent));\n        res.send(csvContent);\n    }\n    catch (error) {\n        console.error('Error exporting CDR CSV:', error);\n        (0, response_1.errorResponse)(res, 'Failed to export CDR records', 500);\n    }\n});\n// Export CDR records (JSON format)\nrouter.get('/export/json', auth_1.authenticateToken, tenant_1.setTenantContext, (0, validation_1.validateRequest)(cdrFilterSchema, 'query'), async (req, res) => {\n    try {\n        const filter = req.query;\n        const tenantId = req.tenantId;\n        logAPICall('export_cdr_json', {\n            tenant_id: tenantId,\n            filter: Object.keys(filter)\n        });\n        // Ensure tenant_id is set from context\n        const cdrFilter = {\n            ...filter,\n            tenant_id: tenantId,\n            limit: 10000 // Large limit for export\n        };\n        const result = await cdrService.listCDR(cdrFilter);\n        // Set response headers for JSON download\n        const filename = `cdr_export_${tenantId}_${new Date().toISOString().split('T')[0]}.json`;\n        res.setHeader('Content-Type', 'application/json');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n        (0, response_1.successResponse)(res, {\n            export_info: {\n                tenant_id: tenantId,\n                export_date: new Date().toISOString(),\n                total_records: result.total,\n                filters_applied: filter\n            },\n            cdr_records: result.cdr\n        });\n    }\n    catch (error) {\n        console.error('Error exporting CDR JSON:', error);\n        (0, response_1.errorResponse)(res, 'Failed to export CDR records', 500);\n    }\n});\n// Bulk operations for GDPR compliance\nrouter.post('/bulk/anonymize', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const { cdr_ids } = req.body;\n        const tenantId = req.tenantId;\n        if (!Array.isArray(cdr_ids) || cdr_ids.length === 0) {\n            return (0, response_1.errorResponse)(res, 'CDR IDs array is required', 400);\n        }\n        logAPICall('bulk_anonymize_cdr', {\n            tenant_id: tenantId,\n            count: cdr_ids.length\n        });\n        const results = [];\n        const errors = [];\n        for (const cdrId of cdr_ids) {\n            try {\n                await cdrService.anonymizeCDR(cdrId, tenantId);\n                results.push({ cdr_id: cdrId, status: 'anonymized' });\n            }\n            catch (error) {\n                errors.push({ cdr_id: cdrId, error: error.message });\n            }\n        }\n        (0, response_1.successResponse)(res, {\n            total_processed: cdr_ids.length,\n            successful: results.length,\n            failed: errors.length,\n            results,\n            errors\n        });\n    }\n    catch (error) {\n        console.error('Error bulk anonymizing CDR:', error);\n        (0, response_1.errorResponse)(res, 'Failed to bulk anonymize CDR records', 500);\n    }\n});\nrouter.post('/bulk/delete', auth_1.authenticateToken, tenant_1.setTenantContext, async (req, res) => {\n    try {\n        const { cdr_ids } = req.body;\n        const tenantId = req.tenantId;\n        if (!Array.isArray(cdr_ids) || cdr_ids.length === 0) {\n            return (0, response_1.errorResponse)(res, 'CDR IDs array is required', 400);\n        }\n        logAPICall('bulk_delete_cdr', {\n            tenant_id: tenantId,\n            count: cdr_ids.length\n        });\n        const results = [];\n        const errors = [];\n        for (const cdrId of cdr_ids) {\n            try {\n                await cdrService.deleteCDR(cdrId, tenantId);\n                results.push({ cdr_id: cdrId, status: 'deleted' });\n            }\n            catch (error) {\n                errors.push({ cdr_id: cdrId, error: error.message });\n            }\n        }\n        (0, response_1.successResponse)(res, {\n            total_processed: cdr_ids.length,\n            successful: results.length,\n            failed: errors.length,\n            results,\n            errors\n        });\n    }\n    catch (error) {\n        console.error('Error bulk deleting CDR:', error);\n        (0, response_1.errorResponse)(res, 'Failed to bulk delete CDR records', 500);\n    }\n});\nexports.default = router;\n//# sourceMappingURL=cdr.js.map","size_bytes":16121},"voip-system/packages/backend/dist/routes/voip.js":{"content":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst extension_service_1 = require(\"../services/extension.service\");\nconst middleware_1 = require(\"../middleware\");\nconst response_1 = require(\"../utils/response\");\nconst router = (0, express_1.Router)();\nconst extensionService = new extension_service_1.ExtensionService();\n// Apply authentication and tenant context to all routes\nrouter.use(middleware_1.authenticateToken);\nrouter.use(middleware_1.requireTenant);\nrouter.use(middleware_1.setTenantContext);\n// List SIP Extensions for tenant\nrouter.get('/sip-extensions', middleware_1.validatePagination, middleware_1.handleValidationErrors, (0, response_1.asyncHandler)(async (req, res) => {\n    const page = parseInt(req.query.page) || 1;\n    const limit = parseInt(req.query.limit) || 50;\n    const search = req.query.q;\n    const storeId = req.query.store_id;\n    const result = await extensionService.listExtensions(req.tenantId, storeId, page, limit, search);\n    (0, response_1.paginatedResponse)(res, result.extensions, {\n        page,\n        limit,\n        total: result.total,\n        totalPages: result.totalPages\n    }, 'SIP Extensions retrieved successfully');\n}));\n// Get SIP Extension by ID\nrouter.get('/sip-extensions/:id', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionId = req.params.id;\n    const extension = await extensionService.getExtensionById(extensionId, req.tenantId);\n    if (!extension) {\n        return (0, response_1.notFoundResponse)(res, 'SIP Extension not found');\n    }\n    (0, response_1.successResponse)(res, extension, 'SIP Extension retrieved successfully');\n}));\n// Get SIP Extension by number\nrouter.get('/sip-extensions/number/:extension', (0, response_1.asyncHandler)(async (req, res) => {\n    const extensionNumber = req.params.extension;\n    const extension = await extensionService.getExtensionByNumber(extensionNumber, req.tenantId);\n    if (!extension) {\n        return (0, response_1.notFoundResponse)(res, 'SIP Extension not found');\n    }\n    (0, response_1.successResponse)(res, extension, 'SIP Extension retrieved successfully');\n}));\nexports.default = router;\n//# sourceMappingURL=voip.js.map","size_bytes":2237},"packages/backend/src/routes/users.routes.ts":{"content":"import { Router } from 'express';\nimport bcrypt from 'bcryptjs';\nimport { getClient } from '@w3-voip/database';\nimport {\n  authenticateToken,\n  requireTenant,\n  setTenantContext\n} from '../middleware';\nimport { requireTenantAdmin } from '../middleware/auth.middleware';\nimport {\n  successResponse,\n  errorResponse,\n  createdResponse,\n  updatedResponse,\n  deletedResponse,\n  notFoundResponse,\n  asyncHandler\n} from '../utils/response';\n\nconst router = Router();\n\nrouter.use(authenticateToken);\nrouter.use(requireTenant);\nrouter.use(setTenantContext);\nrouter.use(requireTenantAdmin);\n\nrouter.get('/',\n  asyncHandler(async (req, res) => {\n    const tenantId = req.tenantId!;\n    const client = await getClient();\n    \n    const result = await client.query(`\n      SELECT id, email, first_name, last_name, role, status, created_at, updated_at, last_login_at\n      FROM users \n      WHERE tenant_id = $1\n      ORDER BY created_at DESC\n    `, [tenantId]);\n\n    successResponse(res, {\n      users: result.rows,\n      total: result.rows.length\n    }, 'Users retrieved successfully');\n  })\n);\n\nrouter.post('/',\n  asyncHandler(async (req, res) => {\n    const { email, password, first_name, last_name, role } = req.body;\n    const tenantId = req.tenantId!;\n\n    if (!email || !password || !first_name || !last_name || !role) {\n      return errorResponse(res, 'Missing required fields', 400);\n    }\n\n    if (!['tenant_admin', 'agent', 'user'].includes(role)) {\n      return errorResponse(res, 'Invalid role. Must be: tenant_admin, agent, or user', 400);\n    }\n\n    const client = await getClient();\n    \n    const existingUser = await client.query(\n      'SELECT id FROM users WHERE email = $1 AND tenant_id = $2',\n      [email, tenantId]\n    );\n    \n    if (existingUser.rows.length > 0) {\n      return errorResponse(res, 'User with this email already exists', 409);\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    \n    const result = await client.query(`\n      INSERT INTO users (tenant_id, email, password_hash, first_name, last_name, role, status)\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\n      RETURNING id, email, first_name, last_name, role, status, created_at\n    `, [tenantId, email, hashedPassword, first_name, last_name, role, 'active']);\n\n    createdResponse(res, result.rows[0], 'User created successfully');\n  })\n);\n\nrouter.patch('/:id',\n  asyncHandler(async (req, res) => {\n    const userId = req.params.id;\n    const tenantId = req.tenantId!;\n    const { first_name, last_name, role, status } = req.body;\n\n    const client = await getClient();\n    \n    const userCheck = await client.query(\n      'SELECT id FROM users WHERE id = $1 AND tenant_id = $2',\n      [userId, tenantId]\n    );\n    \n    if (userCheck.rows.length === 0) {\n      return notFoundResponse(res, 'User not found');\n    }\n\n    const updates: string[] = [];\n    const values: any[] = [];\n    let paramIndex = 1;\n\n    if (first_name) {\n      updates.push(`first_name = $${paramIndex++}`);\n      values.push(first_name);\n    }\n    if (last_name) {\n      updates.push(`last_name = $${paramIndex++}`);\n      values.push(last_name);\n    }\n    if (role && ['tenant_admin', 'agent', 'user'].includes(role)) {\n      updates.push(`role = $${paramIndex++}`);\n      values.push(role);\n    }\n    if (status && ['active', 'inactive', 'suspended'].includes(status)) {\n      updates.push(`status = $${paramIndex++}`);\n      values.push(status);\n    }\n\n    if (updates.length === 0) {\n      return errorResponse(res, 'No valid fields to update', 400);\n    }\n\n    updates.push(`updated_at = NOW()`);\n    values.push(userId, tenantId);\n\n    const result = await client.query(`\n      UPDATE users \n      SET ${updates.join(', ')}\n      WHERE id = $${paramIndex++} AND tenant_id = $${paramIndex++}\n      RETURNING id, email, first_name, last_name, role, status, updated_at\n    `, values);\n\n    updatedResponse(res, result.rows[0], 'User updated successfully');\n  })\n);\n\nrouter.delete('/:id',\n  asyncHandler(async (req, res) => {\n    const userId = req.params.id;\n    const tenantId = req.tenantId!;\n\n    const client = await getClient();\n    \n    const userCheck = await client.query(\n      'SELECT id, email FROM users WHERE id = $1 AND tenant_id = $2',\n      [userId, tenantId]\n    );\n    \n    if (userCheck.rows.length === 0) {\n      return notFoundResponse(res, 'User not found');\n    }\n\n    await client.query(\n      'DELETE FROM users WHERE id = $1 AND tenant_id = $2',\n      [userId, tenantId]\n    );\n\n    deletedResponse(res, { id: userId }, 'User deleted successfully');\n  })\n);\n\nexport default router;\n","size_bytes":4587},"packages/frontend/src/hooks/useTenantValidation.ts":{"content":"import { useState, useEffect } from 'react';\n\ninterface TenantValidationResult {\n  isValid: boolean | null;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useTenantValidation(tenantSlug: string | undefined): TenantValidationResult {\n  const [state, setState] = useState<TenantValidationResult>({\n    isValid: null,\n    isLoading: true,\n    error: null,\n  });\n\n  useEffect(() => {\n    if (!tenantSlug || tenantSlug === 'edgvoip') {\n      setState({ isValid: true, isLoading: false, error: null });\n      return;\n    }\n\n    const validateTenant = async () => {\n      try {\n        const response = await fetch(`/api/${tenantSlug}/validate`, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n        });\n\n        if (response.status === 404) {\n          setState({ isValid: false, isLoading: false, error: 'Tenant not found' });\n          return;\n        }\n\n        if (response.ok) {\n          setState({ isValid: true, isLoading: false, error: null });\n        } else {\n          setState({ isValid: false, isLoading: false, error: 'Validation failed' });\n        }\n      } catch (error) {\n        setState({ isValid: false, isLoading: false, error: 'Network error' });\n      }\n    };\n\n    validateTenant();\n  }, [tenantSlug]);\n\n  return state;\n}\n","size_bytes":1300},"packages/database/dist/index.d.ts":{"content":"import { Pool } from 'pg';\ndeclare const pool: Pool;\nexport declare class DatabaseClient {\n    private client;\n    private tenantId;\n    private userRole;\n    private released;\n    constructor(client: any);\n    setTenantContext(tenantId: string, userRole?: string): Promise<void>;\n    clearTenantContext(): Promise<void>;\n    getCurrentTenantId(): string | null;\n    getCurrentUserRole(): string | null;\n    query(text: string, params?: any[]): Promise<any>;\n    release(): Promise<void>;\n}\nexport declare function getClient(tenantId?: string, userRole?: string): Promise<DatabaseClient>;\nexport declare function queryWithTenant(text: string, params?: any[], tenantId?: string, userRole?: string): Promise<any>;\nexport declare function withTransaction<T>(callback: (client: DatabaseClient) => Promise<T>, tenantId?: string, userRole?: string): Promise<T>;\nexport declare function healthCheck(): Promise<boolean>;\nexport declare function startPeriodicHealthCheck(intervalMs?: number): void;\nexport declare function stopPeriodicHealthCheck(): void;\nexport declare function closePool(): Promise<void>;\nexport declare function getPoolStats(): {\n    totalCount: number;\n    idleCount: number;\n    waitingCount: number;\n};\nexport { pool };\n//# sourceMappingURL=index.d.ts.map","size_bytes":1269},"deployment/STEP-BY-STEP.md":{"content":"# 🚀 EDG VoIP - Comandi Deployment VPS Step-by-Step\n\n**Server:** 93.93.113.13  \n**Password:** B66v6My6  \n**Database:** edgvoip  \n**User DB:** edgadmin  \n**Password DB:** VoipSecure2024!\n\n---\n\n## PASSO 1: Connessione al VPS\n\n```bash\nssh root@93.93.113.13\n# Password: B66v6My6\n```\n\n---\n\n## PASSO 2: Installazione Node.js 20\n\n```bash\ncurl -fsSL https://deb.nodesource.com/setup_20.x | bash -\napt install -y nodejs\nnode --version\nnpm --version\n```\n\n---\n\n## PASSO 3: Creazione Directory Progetto\n\n```bash\nmkdir -p /opt/edgvoip\ncd /opt/edgvoip\n```\n\n---\n\n## PASSO 4: Upload Codice (DAL TUO COMPUTER LOCALE)\n\n**Apri un NUOVO terminale sul tuo computer (NON sul VPS):**\n\n```bash\n# Vai nella directory del progetto\ncd /path/to/your/project\n\n# Comprimi il progetto\ntar --exclude='node_modules' \\\n    --exclude='.git' \\\n    --exclude='dist' \\\n    --exclude='build' \\\n    -czf edgvoip-deploy.tar.gz \\\n    packages/ package.json tsconfig.json\n\n# Carica sul VPS\nscp edgvoip-deploy.tar.gz root@93.93.113.13:/opt/edgvoip/\n```\n\n---\n\n## PASSO 5: Estrazione e Build (TORNA SUL VPS)\n\n```bash\ncd /opt/edgvoip\ntar -xzf edgvoip-deploy.tar.gz\nnpm install\ncd packages/database && npm run build && cd ../..\ncd packages/backend && npm install && cd ../..\ncd packages/frontend && npm install && npm run build && cd ../..\n```\n\n---\n\n## PASSO 6: Configurazione Environment Variables\n\n```bash\ncat > /opt/edgvoip/packages/backend/.env << 'ENVEOF'\nNODE_ENV=production\nPORT=3001\nDATABASE_URL=postgresql://edgadmin:VoipSecure2024!@localhost:5432/edgvoip\nJWT_SECRET=TEMP_SECRET_WILL_BE_REPLACED\nCORS_ORIGIN=http://93.93.113.13,http://demo.edgvoip.it,http://edgvoip.it\n\nFREESWITCH_HOST=localhost\nFREESWITCH_PORT=8021\nFREESWITCH_PASSWORD=ClueCon\nENVEOF\n\n# Genera JWT Secret sicuro\nJWT_SECRET=$(openssl rand -base64 32)\nsed -i \"s|JWT_SECRET=TEMP_SECRET_WILL_BE_REPLACED|JWT_SECRET=$JWT_SECRET|\" /opt/edgvoip/packages/backend/.env\n\n# Verifica\ncat /opt/edgvoip/packages/backend/.env\n```\n\n---\n\n## PASSO 7: Inizializzazione Database\n\n```bash\ncd /opt/edgvoip/packages/backend\nnpm run db:push\n```\n\n---\n\n## PASSO 8: Configurazione Nginx\n\n```bash\napt install -y nginx\n\ncat > /etc/nginx/sites-available/edgvoip << 'NGINXEOF'\nserver {\n    listen 80;\n    server_name 93.93.113.13 demo.edgvoip.it edgvoip.it;\n\n    root /opt/edgvoip/packages/frontend/dist;\n    index index.html;\n\n    # Disable caching for HTML\n    location ~* \\.html$ {\n        add_header Cache-Control \"no-cache, no-store, must-revalidate\";\n    }\n\n    # Frontend routes\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n\n    # Backend API proxy\n    location /api {\n        proxy_pass http://localhost:3001;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\nNGINXEOF\n\nln -sf /etc/nginx/sites-available/edgvoip /etc/nginx/sites-enabled/\nrm -f /etc/nginx/sites-enabled/default\nnginx -t\nsystemctl restart nginx\nsystemctl enable nginx\n```\n\n---\n\n## PASSO 9: Configurazione Servizio Backend\n\n```bash\ncat > /etc/systemd/system/edgvoip-backend.service << 'SYSTEMDEOF'\n[Unit]\nDescription=EDG VoIP Backend API\nAfter=network.target postgresql.service\n\n[Service]\nType=simple\nUser=root\nWorkingDirectory=/opt/edgvoip/packages/backend\nEnvironment=NODE_ENV=production\nExecStart=/usr/bin/npm start\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nSYSTEMDEOF\n\nsystemctl daemon-reload\nsystemctl start edgvoip-backend\nsystemctl enable edgvoip-backend\nsystemctl status edgvoip-backend\n```\n\n---\n\n## PASSO 10: Configurazione Firewall\n\n```bash\napt install -y ufw\nufw allow ssh\nufw allow 80/tcp\nufw allow 443/tcp\nufw allow 5060/udp\nufw allow 5061/tcp\nufw allow 16384:32768/udp\nufw --force enable\nufw status\n```\n\n---\n\n## PASSO 11: Test Finale\n\n```bash\n# Test backend locale\ncurl http://localhost:3001/api/demo/validate\n\n# Test da browser\necho \"Apri nel browser: http://93.93.113.13/demo/login\"\necho \"Credenziali: admin@demo.local / tenantadmin123\"\n```\n\n---\n\n## COMANDI UTILI POST-DEPLOYMENT\n\n```bash\n# Visualizza logs backend\njournalctl -u edgvoip-backend -f\n\n# Restart backend\nsystemctl restart edgvoip-backend\n\n# Stato servizi\nsystemctl status edgvoip-backend nginx postgresql\n\n# Logs Nginx\ntail -f /var/log/nginx/error.log\ntail -f /var/log/nginx/access.log\n\n# Accesso database\nsudo -u postgres psql -d edgvoip\n```\n\n---\n\n## TROUBLESHOOTING\n\n**Backend non si avvia:**\n```bash\njournalctl -u edgvoip-backend -n 50\n```\n\n**Nginx errori:**\n```bash\nnginx -t\ntail -f /var/log/nginx/error.log\n```\n\n**Database problemi:**\n```bash\nsudo -u postgres psql -d edgvoip -c \"\\dt\"\n```\n\n---\n\n✅ **DEPLOYMENT COMPLETATO!**\n","size_bytes":4854},"DEPLOYMENT_GUIDE.md":{"content":"# 🚀 Guida Deployment VPS Debian - W3 VoIP System\n\n## Informazioni Server\n- **IP:** 93.93.113.13\n- **OS:** Debian VPS\n- **User:** root\n- **Password:** B66v6My6\n\n## Architettura Porte Production\n- **Frontend (React + Vite):** Porta 5000\n- **Backend (Express API):** Porta 3001\n- **PostgreSQL:** Porta 5432\n- **FreeSWITCH:** Porta 5060 (SIP), 5080 (WSS)\n- **Nginx Proxy:** Porta 80/443\n\n## 📋 Prerequisiti Locali\nPrima di iniziare il deployment, assicurati di avere:\n```bash\n# Installa sshpass per automazione SSH\napt-get install sshpass  # Linux\nbrew install sshpass      # macOS\n```\n\n## 🎯 Deploy Automatico - UN COMANDO\n\n### Opzione 1: Deploy Completo (Raccomandato)\n```bash\nchmod +x scripts/complete-deploy.sh\n./scripts/complete-deploy.sh\n```\n\nQuesto script esegue automaticamente:\n1. ✅ Setup server Debian (Node.js, PostgreSQL, Redis, FreeSWITCH, Nginx)\n2. ✅ Deploy applicazione (Backend + Frontend)\n3. ✅ Configurazione database e migrazioni\n4. ✅ Setup systemd services\n5. ✅ Configurazione Nginx reverse proxy\n6. ✅ Test endpoint API\n\n**Tempo stimato:** 10-15 minuti\n\n### Opzione 2: Deploy Manuale Step-by-Step\n\n#### Passo 1: Setup Server Base\n```bash\n# Connetti al server\nssh root@93.93.113.13\n\n# Copia e esegui script setup\nscp scripts/setup-debian-server.sh root@93.93.113.13:/tmp/\nssh root@93.93.113.13 \"chmod +x /tmp/setup-debian-server.sh && /tmp/setup-debian-server.sh\"\n```\n\n#### Passo 2: Deploy Applicazione\n```bash\nchmod +x scripts/auto-deploy.sh\n./scripts/auto-deploy.sh\n```\n\n## 📦 Cosa Viene Installato\n\n### Software\n- Node.js 20 LTS\n- PostgreSQL 15\n- Redis 7\n- Nginx\n- FreeSWITCH (con moduli: ESL, XML Curl, Sofia SIP)\n- PM2 (process manager)\n- Fail2ban (sicurezza)\n- UFW (firewall)\n\n### Configurazione Firewall\n```\nPort 22   (SSH)\nPort 80   (HTTP)\nPort 443  (HTTPS)\nPort 5060 (SIP TCP)\nPort 5080 (WSS)\nPort 5432 (PostgreSQL - solo localhost)\n```\n\n### Directory Create\n```\n/var/www/voip-system           # Applicazione\n/var/www/voip-uploads          # File upload\n/var/www/voip-recordings       # Registrazioni chiamate\n/var/log/voip-system           # Log applicazione\n/etc/voip-system               # Configurazioni\n```\n\n## 🔐 Credenziali Default\n\n### Database PostgreSQL\n- **Database:** voip_production\n- **User:** voip_user\n- **Password:** VoipSecure2025!\n- **Host:** localhost:5432\n\n### Applicazione Web\n\n#### Super Admin (Master Tenant)\n- **Email:** admin@edgvoip.it\n- **Password:** admin123\n- **URL:** http://93.93.113.13/edgvoip/login\n\n#### Demo Tenant\n- **Email:** admin@demo.local\n- **Password:** tenantadmin123\n- **URL:** http://93.93.113.13/demo/login\n\n## 🛠️ Gestione Servizi Post-Deploy\n\n### Backend API\n```bash\n# Status\nsystemctl status voip-backend\n\n# Start/Stop/Restart\nsystemctl start voip-backend\nsystemctl stop voip-backend\nsystemctl restart voip-backend\n\n# Log in tempo reale\njournalctl -u voip-backend -f\n```\n\n### Nginx\n```bash\nsystemctl status nginx\nsystemctl restart nginx\nsystemctl reload nginx  # Ricarica config senza downtime\n\n# Test configurazione\nnginx -t\n```\n\n### FreeSWITCH\n```bash\nsystemctl status freeswitch\nsystemctl restart freeswitch\n\n# Console CLI\nfs_cli\n```\n\n### PostgreSQL\n```bash\nsystemctl status postgresql\n\n# Connetti al database\npsql -U voip_user -d voip_production\n```\n\n## 🧪 Verifica Deployment\n\n### 1. Test Connessione Server\n```bash\nping 93.93.113.13\nssh root@93.93.113.13\n```\n\n### 2. Test Servizi\n```bash\n# Tutti i servizi\nssh root@93.93.113.13 \"systemctl status voip-backend nginx postgresql freeswitch\"\n```\n\n### 3. Test API Endpoints\n```bash\n# Health check\ncurl http://93.93.113.13/api/health\n\n# Tenant validation\ncurl http://93.93.113.13/api/demo/validate\n\n# FreeSWITCH status\ncurl http://93.93.113.13/api/freeswitch/status\n```\n\n### 4. Test Frontend\nApri nel browser:\n- Frontend: http://93.93.113.13\n- Super Admin: http://93.93.113.13/edgvoip/login\n- Demo Tenant: http://93.93.113.13/demo/login\n\n## 🔄 Update/Redeploy\n\n### Quick Update (solo codice)\n```bash\nchmod +x scripts/deploy-to-debian.sh\n./scripts/deploy-to-debian.sh\n```\n\n### Full Redeploy\n```bash\n./scripts/complete-deploy.sh\n```\n\n## 📊 Monitoring e Log\n\n### Log Applicazione\n```bash\n# Backend\njournalctl -u voip-backend -f\n\n# Nginx access\ntail -f /var/log/nginx/access.log\n\n# Nginx error\ntail -f /var/log/nginx/error.log\n\n# FreeSWITCH\ntail -f /var/log/freeswitch/freeswitch.log\n```\n\n### Monitoring Risorse\n```bash\n# CPU e RAM\nhtop\n\n# Disk usage\ndf -h\n\n# Processi Node\nps aux | grep node\n```\n\n## 🔒 Sicurezza Post-Deploy\n\n### 1. Cambia Password Root\n```bash\nssh root@93.93.113.13\npasswd\n```\n\n### 2. Configura SSL/TLS (Certificato Let's Encrypt)\n```bash\nssh root@93.93.113.13\n\n# Installa certbot\napt install certbot python3-certbot-nginx\n\n# Genera certificato (sostituisci con il tuo dominio)\ncertbot --nginx -d your-domain.com -d www.your-domain.com\n\n# Auto-renewal\nsystemctl enable certbot.timer\n```\n\n### 3. Aggiorna Firewall\n```bash\n# Blocca accesso PostgreSQL dall'esterno\nufw deny 5432/tcp\n\n# Permetti solo IP specifici per SSH (opzionale)\nufw allow from YOUR_OFFICE_IP to any port 22\n```\n\n## 🆘 Troubleshooting\n\n### Backend non si avvia\n```bash\n# Controlla log\njournalctl -u voip-backend -n 100\n\n# Controlla permessi\nls -la /var/www/voip-system\nchown -R voip:voip /var/www/voip-system\n\n# Reinstalla dipendenze\ncd /var/www/voip-system/packages/backend\nnpm install\n```\n\n### Frontend mostra errore 502\n```bash\n# Verifica backend è running\nsystemctl status voip-backend\n\n# Test backend direttamente\ncurl http://localhost:3001/api/health\n\n# Riavvia nginx\nsystemctl restart nginx\n```\n\n### Database connection error\n```bash\n# Verifica PostgreSQL\nsystemctl status postgresql\n\n# Test connessione\npsql -U voip_user -d voip_production -h localhost\n\n# Reset password database\nsudo -u postgres psql\nALTER USER voip_user WITH PASSWORD 'VoipSecure2025!';\n```\n\n## 📞 Supporto\n\nPer problemi di deployment:\n1. Controlla i log: `journalctl -u voip-backend -f`\n2. Verifica tutti i servizi: `systemctl status voip-backend nginx postgresql`\n3. Test connettività: `curl http://localhost:3001/api/health`\n\n---\n\n**Ultimo aggiornamento:** 24 Ottobre 2025  \n**Versione:** 1.0.0\n","size_bytes":6121},"deployment/deploy-from-replit.sh":{"content":"#!/bin/bash\n# Script da eseguire sul VPS per deployare da questo archivio\n\nset -e\n\necho \"🚀 EDG VoIP Deployment Script\"\necho \"================================\"\n\n# Download archivio (sostituisci URL con link pubblico del file)\necho \"📦 Downloading code archive...\"\ncd /opt/edgvoip\n\n# Estrai\necho \"📂 Extracting files...\"\ntar -xzf edgvoip-deploy.tar.gz\n\n# Installa dipendenze root\necho \"📚 Installing root dependencies...\"\nnpm install\n\n# Build database package\necho \"🔨 Building database package...\"\ncd packages/database\nnpm install\nnpm run build\ncd ../..\n\n# Build backend\necho \"🔨 Building backend...\"\ncd packages/backend\nnpm install\ncd ../..\n\n# Build frontend\necho \"🔨 Building frontend...\"\ncd packages/frontend\nnpm install\nnpm run build\ncd ../..\n\necho \"✅ Build completato!\"\necho \"Prossimo step: Configurare .env e avviare i servizi\"\n","size_bytes":850}},"version":2}