export interface CallQueue {
    id: string;
    tenant_id: string;
    store_id?: string;
    name: string;
    description?: string;
    extension: string;
    strategy: 'ring-all' | 'longest-idle' | 'round-robin' | 'top-down' | 'agent-with-least-talk-time';
    max_wait_time: number;
    max_wait_time_with_no_agent: number;
    max_wait_time_with_no_agent_time_reached: number;
    tier_rules_apply: boolean;
    tier_rule_wait_second: number;
    tier_rule_wait_multiply_level: boolean;
    tier_rule_no_agent_no_wait: boolean;
    discard_abandoned_after: number;
    abandoned_resume_allowed: boolean;
    agents: Array<{
        id: string;
        extension_id: string;
        agent_name: string;
        agent_type: 'callback' | 'uuid-standby' | 'uuid-bridge';
        contact: string;
        status: 'Available' | 'On Break' | 'Logged Out';
        state: 'Waiting' | 'Receiving' | 'In a queue call';
        max_no_answer: number;
        wrap_up_time: number;
        reject_delay_time: number;
        busy_delay_time: number;
        no_answer_delay_time: number;
        calls_answered: number;
        talk_time: number;
        tier_level: number;
        tier_position: number;
        enabled: boolean;
    }>;
    moh_sound?: string;
    record_template?: string;
    time_base_score: 'system' | 'queue' | 'member';
    queue_timeout: number;
    queue_timeout_action: 'hangup' | 'voicemail' | 'forward';
    queue_timeout_destination?: string;
    failover_enabled: boolean;
    failover_destination_type?: string;
    failover_destination_id?: string;
    failover_destination_data?: any;
    caller_id_name?: string;
    caller_id_number?: string;
    recording_enabled: boolean;
    recording_path?: string;
    recording_consent_required: boolean;
    max_concurrent_calls: number;
    current_calls: number;
    settings: any;
    enabled: boolean;
    created_at: Date;
    updated_at: Date;
}
export interface QueueAgent {
    id: string;
    queue_id: string;
    extension_id: string;
    agent_name: string;
    agent_type: 'callback' | 'uuid-standby' | 'uuid-bridge';
    contact: string;
    status: 'Available' | 'On Break' | 'Logged Out';
    state: 'Waiting' | 'Receiving' | 'In a queue call';
    max_no_answer: number;
    wrap_up_time: number;
    reject_delay_time: number;
    busy_delay_time: number;
    no_answer_delay_time: number;
    last_bridge_start?: Date;
    last_bridge_end?: Date;
    last_offered_call?: Date;
    last_status_change?: Date;
    no_answer_count: number;
    calls_answered: number;
    talk_time: number;
    ready_time?: Date;
    external_calls_count: number;
    uuid?: string;
    tier_level: number;
    tier_position: number;
    enabled: boolean;
    settings: any;
    created_at: Date;
    updated_at: Date;
}
export interface QueueCallLog {
    id: string;
    queue_id: string;
    call_uuid: string;
    caller_id_name?: string;
    caller_id_number?: string;
    destination_number?: string;
    queue_position?: number;
    queue_wait_time: number;
    start_time: Date;
    end_time?: Date;
    duration: number;
    hangup_cause?: string;
    answered_by_agent?: string;
    answered_by_extension?: string;
    agent_wait_time: number;
    agent_talk_time: number;
    recording_path?: string;
    settings: any;
    created_at: Date;
}
export interface QueueStatistics {
    id: string;
    queue_id: string;
    date: Date;
    total_calls: number;
    answered_calls: number;
    abandoned_calls: number;
    total_wait_time: number;
    average_wait_time: number;
    longest_wait_time: number;
    total_talk_time: number;
    average_talk_time: number;
    longest_talk_time: number;
    service_level_percentage: number;
    service_level_threshold: number;
    created_at: Date;
    updated_at: Date;
}
export declare class QueueService {
    createCallQueue(queueData: Partial<CallQueue>): Promise<CallQueue>;
    getCallQueues(tenantId: string, storeId?: string): Promise<CallQueue[]>;
    getCallQueue(queueId: string): Promise<CallQueue | null>;
    addAgent(queueId: string, extensionId: string, agentData: Partial<QueueAgent>): Promise<QueueAgent>;
    removeAgent(queueId: string, extensionId: string): Promise<void>;
    updateAgentStatus(queueId: string, extensionId: string, status: string, state?: string): Promise<QueueAgent>;
    updateCallQueue(queueId: string, updateData: Partial<CallQueue>): Promise<CallQueue>;
    deleteCallQueue(queueId: string): Promise<void>;
    getCallLogs(queueId: string, limit?: number, offset?: number): Promise<QueueCallLog[]>;
    getStatistics(queueId: string, startDate: Date, endDate: Date): Promise<QueueStatistics[]>;
    logCall(callData: Partial<QueueCallLog>): Promise<string>;
    updateCallLog(callUuid: string, updateData: Partial<QueueCallLog>): Promise<void>;
    updateStatistics(queueId: string, date: Date, stats: {
        total_calls?: number;
        answered_calls?: number;
        abandoned_calls?: number;
        total_wait_time?: number;
        total_talk_time?: number;
    }): Promise<void>;
    generateCallcenterXML(queue: CallQueue): string;
    private generateQueueBridgeXML;
    private generateTimeoutActionXML;
    private mapRowToCallQueue;
    private mapRowToQueueAgent;
    private mapRowToQueueCallLog;
    private mapRowToQueueStatistics;
}
export declare const queueService: QueueService;
//# sourceMappingURL=queue.service.d.ts.map