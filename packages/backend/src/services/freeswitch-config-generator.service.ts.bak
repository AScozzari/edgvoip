import { FreeSWITCHService } from './freeswitch.service';
import { ExtensionService } from './extension.service';
import { SipTrunkService } from './sip-trunk.service';

export interface Extension {
  id: string;
  extension: string;
  display_name: string;
  password: string;
  tenant_id: string;
  type?: string;
  settings?: any;
}

export interface SipTrunk {
  id: string;
  tenant_id: string;
  store_id?: string;
  name: string;
  provider: string;
  status: 'active' | 'inactive' | 'testing';
  sip_config: {
    host: string;
    port: number;
    transport: 'udp' | 'tcp' | 'tls';
    username: string;
    password: string;
    realm?: string;
    from_user?: string;
    from_domain?: string;
    register: boolean;
    register_proxy?: string;
    register_transport?: 'udp' | 'tcp' | 'tls';
    retry_seconds: number;
    caller_id_in_from: boolean;
    contact_params?: string;
    ping: boolean;
    ping_time: number;
  };
  did_config: {
    number: string;
    country_code: string;
    area_code?: string;
    local_number: string;
    provider_did?: string;
    inbound_route?: string;
  };
  security: {
    encryption: 'none' | 'tls' | 'srtp';
    authentication: 'none' | 'digest' | 'tls';
    acl: string[];
    rate_limit: {
      enabled: boolean;
      calls_per_minute: number;
      calls_per_hour: number;
    };
  };
  gdpr: {
    data_retention_days: number;
    recording_consent_required: boolean;
    data_processing_purpose: string;
    lawful_basis: 'consent' | 'contract' | 'legitimate_interest';
    data_controller: string;
    dpo_contact?: string;
  };
  created_at: Date;
  updated_at: Date;
}

export interface DialplanRoute {
  id: string;
  name: string;
  pattern: string;
  destination: string;
  destination_type: 'extension' | 'ring_group' | 'queue' | 'ivr' | 'conference' | 'voicemail';
  tenant_id: string;
  settings?: any;
}

export class FreeSwitchConfigGenerator {
  private extensionService: ExtensionService;
  private sipTrunkService: SipTrunkService;
  private configPath: string;

  constructor() {
    this.extensionService = new ExtensionService();
    this.sipTrunkService = new SipTrunkService();
    this.configPath = process.env.FREESWITCH_CONFIG_PATH || './docker/freeswitch/conf';
    
    console.log(`üîß FreeSWITCH Config Generator initialized with path: ${this.configPath}`);
  }

  /**
   * Generate XML for a single extension
   */
  generateExtensionXML(extension: Extension): string {
    const xml = `<?xml version="1.0" encoding="utf-8"?>
<include>
  <user id="${extension.extension}">
    <params>
      <param name="password" value="${extension.password}"/>
      <param name="vm-password" value="${extension.password}"/>
      <param name="toll-allow" value="domestic,international,local"/>
      <param name="accountcode" value="${extension.tenant_id}"/>
      <param name="user-context" value="default"/>
      <param name="effective-caller-id-name" value="${extension.display_name}"/>
      <param name="effective-caller-id-number" value="${extension.extension}"/>
      <param name="outbound-caller-id-name" value="${extension.display_name}"/>
      <param name="outbound-caller-id-number" value="${extension.extension}"/>
      <param name="callgroup" value="default"/>
      <param name="user-type" value="subscriber"/>
    </params>
    <variables>
      <variable name="toll_allow" value="domestic,international,local"/>
      <variable name="accountcode" value="${extension.tenant_id}"/>
      <variable name="user_context" value="default"/>
      <variable name="effective_caller_id_name" value="${extension.display_name}"/>
      <variable name="effective_caller_id_number" value="${extension.extension}"/>
      <variable name="outbound_caller_id_name" value="${extension.display_name}"/>
      <variable name="outbound_caller_id_number" value="${extension.extension}"/>
      <variable name="callgroup" value="default"/>
      <variable name="user_type" value="subscriber"/>
    </variables>
  </user>
</include>`;

    return xml;
  }

  /**
   * Generate XML for a SIP trunk/gateway
   */
  generateGatewayXML(trunk: SipTrunk): string {
    const sipConfig = trunk.sip_config;
    const port = sipConfig.port || 5060;
    const register = sipConfig.register || false;
    const realm = sipConfig.realm || sipConfig.host;

    const xml = `<?xml version="1.0" encoding="utf-8"?>
<include>
  <gateway name="${trunk.name}">
    <param name="username" value="${sipConfig.username}"/>
    <param name="realm" value="${realm}"/>
    <param name="password" value="${sipConfig.password}"/>
    <param name="proxy" value="${sipConfig.host}:${port}"/>
    <param name="register" value="${register}"/>
    <param name="register-proxy" value="${sipConfig.host}:${port}"/>
    <param name="expire-seconds" value="600"/>
    <param name="retry-seconds" value="${sipConfig.retry_seconds || 30}"/>
    <param name="caller-id-in-from" value="${sipConfig.caller_id_in_from}"/>
    <param name="extension" value="${sipConfig.username}"/>
    <param name="ping" value="${sipConfig.ping ? sipConfig.ping_time : 0}"/>
    <param name="ping-timeout" value="10"/>
    <param name="ping-delay" value="0"/>
    <param name="codec-prefs" value="PCMU,PCMA,G729,GSM"/>
    <param name="absolute-codec-prefs" value="false"/>
    <param name="enable-t38" value="true"/>
    <param name="enable-t38-passthrough" value="false"/>
    <param name="enable-t38-gateway" value="false"/>
    <param name="rtp-ip" value="\${local_ip_v4}"/>
    <param name="rtp-timeout-sec" value="300"/>
    <param name="rtp-hold-timeout-sec" value="1800"/>
    <param name="rtp-timeout-hold-sec" value="1800"/>
    <param name="multi-tenant" value="false"/>
    <param name="tenant-id" value="${trunk.tenant_id}"/>
  </gateway>
</include>`;

    return xml;
  }

  /**
   * Generate dialplan XML for routing
   */
  generateDialplanXML(routes: DialplanRoute[]): string {
    let xml = `<?xml version="1.0" encoding="utf-8"?>
<include>
  <extension name="internal_calls">
    <condition field="destination_number" expression="^(1\\d{3})$">
      <action application="set" data="domain_name=\${domain_name}"/>
      <action application="set" data="domain_uuid=\${domain_uuid}"/>
      <action application="set" data="call_direction=inbound"/>
      <action application="set" data="sip_h_X-accountcode=\${accountcode}"/>
      <action application="bridge" data="user/\\\${destination_number}@\\\${domain_name}"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>`;

    // Add outbound routes
    routes.forEach(route => {
      xml += `
  <extension name="${route.name}">
    <condition field="destination_number" expression="^${route.pattern}$">
      <action application="set" data="domain_name=\${domain_name}"/>
      <action application="set" data="domain_uuid=\${domain_uuid}"/>
      <action application="set" data="call_direction=outbound"/>
      <action application="set" data="sip_h_X-accountcode=\${accountcode}"/>
      <action application="set" data="sip_h_X-tenant-id=${route.tenant_id}"/>
      <action application="bridge" data="sofia/gateway/${route.destination}/\\\${destination_number}"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>`;
    });

    // Add default route for external calls
    xml += `
  <extension name="external_calls">
    <condition field="destination_number" expression="^([0-9]+)$">
      <action application="set" data="domain_name=\${domain_name}"/>
      <action application="set" data="domain_uuid=\${domain_uuid}"/>
      <action application="set" data="call_direction=outbound"/>
      <action application="set" data="sip_h_X-accountcode=\${accountcode}"/>
      <action application="bridge" data="sofia/gateway/default/\\\${destination_number}"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>
</include>`;

    return xml;
  }

  /**
   * Generate IVR configuration XML
   */
  generateIVRXML(ivrMenus: any[]): string {
    let xml = `<?xml version="1.0" encoding="utf-8"?>
<include>
  <extension name="ivr_menus">
    <condition field="destination_number" expression="^(\\d{4})$">
      <action application="answer"/>
      <action application="sleep" data="1000"/>
      <action application="ivr" data="ivr_\\\${destination_number}"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>
</include>`;

    // Generate IVR menu configurations
    ivrMenus.forEach(menu => {
      xml += `
  <extension name="ivr_${menu.extension}">
    <condition field="destination_number" expression="^${menu.extension}$">
      <action application="answer"/>
      <action application="sleep" data="1000"/>
      <action application="ivr" data="ivr_${menu.extension}"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>`;
    });

    return xml;
  }

  /**
   * Generate conference configuration XML
   */
  generateConferenceXML(conferences: any[]): string {
    let xml = `<?xml version="1.0" encoding="utf-8"?>
<include>
  <extension name="conferences">
    <condition field="destination_number" expression="^(\\d{3})$">
      <action application="answer"/>
      <action application="conference" data="\\\${destination_number}@default"/>
      <action application="hangup" data="NORMAL_CLEARING"/>
    </condition>
  </extension>
</include>`;

    return xml;
  }

  /**
   * Sync all configurations to FreeSWITCH
   */
  async syncToFreeSWITCH(): Promise<void> {
    try {
      console.log('üîÑ Starting FreeSWITCH configuration sync...');

      // Sync extensions
      await this.syncExtensions();

      // Sync SIP trunks
      await this.syncSipTrunks();

      // Sync dialplan
      await this.syncDialplan();

      // Reload FreeSWITCH configurations
      await this.reloadFreeSWITCH();

      console.log('‚úÖ FreeSWITCH configuration sync completed');
    } catch (error) {
      console.error('‚ùå Error syncing FreeSWITCH configurations:', error);
      throw error;
    }
  }

  /**
   * Sync extensions from database to FreeSWITCH
   */
  async syncExtensions(): Promise<void> {
    try {
      console.log('üîÑ Syncing extensions...');

      // Get all extensions from database (using default tenant for now)
      const extensionsResult = await this.extensionService.listExtensions('bfb2e4dc-55f4-4240-8c7d-0fc8c7ecadd8');
      const extensions = extensionsResult.extensions;
      
      // Generate XML for each extension
      for (const extension of extensions) {
        const xml = this.generateExtensionXML(extension);
        const filePath = `${this.configPath}/directory/default/${extension.extension}.xml`;
        
        // Write XML file (in real implementation, use fs.writeFileSync)
        console.log(`üìù Generated extension XML for ${extension.extension}`);
        console.log(`üìÅ File path: ${filePath}`);
        console.log(`üìÑ XML content:\n${xml}`);
      }

      console.log(`‚úÖ Synced ${extensions.length} extensions`);
    } catch (error) {
      console.error('‚ùå Error syncing extensions:', error);
      throw error;
    }
  }

  /**
   * Sync SIP trunks from database to FreeSWITCH
   */
  async syncSipTrunks(): Promise<void> {
    try {
      console.log('üîÑ Syncing SIP trunks...');

      // Get all SIP trunks from database (using default tenant for now)
      const trunks = await this.sipTrunkService.listSipTrunks('bfb2e4dc-55f4-4240-8c7d-0fc8c7ecadd8');
      
      // Generate XML for each trunk
      for (const trunk of trunks) {
        const xml = this.generateGatewayXML(trunk);
        const filePath = `${this.configPath}/sip_profiles/external/${trunk.name}.xml`;
        
        // Write XML file (in real implementation, use fs.writeFileSync)
        console.log(`üìù Generated gateway XML for ${trunk.name}`);
        console.log(`üìÅ File path: ${filePath}`);
        console.log(`üìÑ XML content:\n${xml}`);
      }

      console.log(`‚úÖ Synced ${trunks.length} SIP trunks`);
    } catch (error) {
      console.error('‚ùå Error syncing SIP trunks:', error);
      throw error;
    }
  }

  /**
   * Sync dialplan from database to FreeSWITCH
   */
  async syncDialplan(): Promise<void> {
    try {
      console.log('üîÑ Syncing dialplan...');

      // For now, generate basic dialplan
      // In real implementation, get routes from database
      const routes: DialplanRoute[] = [
        {
          id: '1',
          name: 'default_outbound',
          pattern: '0([0-9]+)',
          destination: 'default',
          destination_type: 'extension',
          tenant_id: 'default'
        }
      ];

      const xml = this.generateDialplanXML(routes);
      const filePath = `${this.configPath}/dialplan/default.xml`;
      
      // Write XML file (in real implementation, use fs.writeFileSync)
      console.log(`üìù Generated dialplan XML`);
      console.log(`üìÅ File path: ${filePath}`);
      console.log(`üìÑ XML content:\n${xml}`);

      console.log(`‚úÖ Synced dialplan`);
    } catch (error) {
      console.error('‚ùå Error syncing dialplan:', error);
      throw error;
    }
  }

  /**
   * Reload FreeSWITCH configurations
   */
  async reloadFreeSWITCH(): Promise<void> {
    try {
      console.log('üîÑ Reloading FreeSWITCH configurations...');

      if (!FreeSWITCHService.isConnected()) {
        console.warn('‚ö†Ô∏è  FreeSWITCH ESL not connected, cannot reload configurations');
        return;
      }

      // Reload XML configurations
      await new Promise<void>((resolve, reject) => {
        FreeSWITCHService['client'].api('reloadxml', (response: any) => {
          try {
            const result = response.getBody();
            console.log('üìÑ FreeSWITCH reloadxml response:', result);
            resolve();
          } catch (error) {
            console.error('‚ùå Error reloading FreeSWITCH XML:', error);
            reject(error);
          }
        });
      });

      // Reload sofia profiles
      await new Promise<void>((resolve, reject) => {
        FreeSWITCHService['client'].api('sofia profile external restart', (response: any) => {
          try {
            const result = response.getBody();
            console.log('üìÑ FreeSWITCH sofia restart response:', result);
            resolve();
          } catch (error) {
            console.error('‚ùå Error restarting FreeSWITCH sofia:', error);
            reject(error);
          }
        });
      });

      console.log('‚úÖ FreeSWITCH configurations reloaded');
    } catch (error) {
      console.error('‚ùå Error reloading FreeSWITCH:', error);
      throw error;
    }
  }

  /**
   * Generate all configuration files
   */
  async generateAllConfigs(): Promise<void> {
    try {
      console.log('üîß Generating all FreeSWITCH configurations...');

      await this.syncExtensions();
      await this.syncSipTrunks();
      await this.syncDialplan();

      console.log('‚úÖ All FreeSWITCH configurations generated');
    } catch (error) {
      console.error('‚ùå Error generating configurations:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const freeSwitchConfigGenerator = new FreeSwitchConfigGenerator();
